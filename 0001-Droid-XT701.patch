From 6558a3b3c931728da3d5cdac29adecfe91609c71 Mon Sep 17 00:00:00 2001
From: stlifey <stlifey@gmail.com>
Date: Sun, 25 Dec 2011 20:39:02 +0800
Subject: [PATCH] XT701

---
 Makefile                                           |   11 +-
 NOTICE                                             |  355 +++
 arch/arm/Kconfig                                   |   31 +
 arch/arm/boot/compressed/Makefile                  |    1 +
 arch/arm/configs/ext_config/eng_bld.config         |   12 +
 .../arm/configs/ext_config/feature/coverage.config |   15 +
 .../configs/ext_config/feature/cup2touch.config    |    2 +
 .../configs/ext_config/feature/faultinject.config  |   17 +
 .../arm/configs/ext_config/feature/kmemleak.config |   26 +
 arch/arm/configs/mapphone_defconfig                | 2149 +++++++++++++++
 arch/arm/configs/sholes_defconfig                  |   14 +-
 arch/arm/configs/sholest_cu_defconfig              | 2172 ++++++++++++++++
 arch/arm/include/asm/bootinfo.h                    |  102 +
 arch/arm/include/asm/elf.h                         |    1 +
 arch/arm/include/asm/mach/serial_omap.h            |    9 +
 arch/arm/include/asm/prom.h                        |  142 +
 arch/arm/include/asm/setup.h                       |   71 +
 arch/arm/include/asm/unistd.h                      |    3 +
 arch/arm/kernel/Makefile                           |    2 +
 arch/arm/kernel/bootinfo.c                         |  271 ++
 arch/arm/kernel/calls.S                            |    6 +
 arch/arm/kernel/entry-armv.S                       |   76 +-
 arch/arm/kernel/entry-common.S                     |   24 +
 arch/arm/kernel/entry-header.S                     |    4 +
 arch/arm/kernel/head-common.S                      |    6 +
 arch/arm/kernel/irq.c                              |   10 +-
 arch/arm/kernel/module.c                           |    1 +
 arch/arm/kernel/process.c                          |  119 +
 arch/arm/kernel/prom.c                             |  407 +++
 arch/arm/kernel/setup.c                            |   94 +-
 arch/arm/kernel/signal.c                           |    6 +
 arch/arm/kernel/traps.c                            |   25 +
 arch/arm/kernel/vmlinux.lds.S                      |   12 +-
 arch/arm/mach-omap2/Kconfig                        |   36 +-
 arch/arm/mach-omap2/Makefile                       |   38 +-
 arch/arm/mach-omap2/Makefile.boot                  |   14 +-
 arch/arm/mach-omap2/board-mapphone-camera.c        |  277 ++
 arch/arm/mach-omap2/board-mapphone-emu_uart.c      |  574 ++++
 arch/arm/mach-omap2/board-mapphone-flash.c         |  118 +
 arch/arm/mach-omap2/board-mapphone-gpio.c          |  311 +++
 arch/arm/mach-omap2/board-mapphone-hsmmc.c         |  350 +++
 arch/arm/mach-omap2/board-mapphone-keypad.c        |  253 ++
 arch/arm/mach-omap2/board-mapphone-mmcprobe.c      |   78 +
 arch/arm/mach-omap2/board-mapphone-padconf.c       | 1837 +++++++++++++
 arch/arm/mach-omap2/board-mapphone-panel.c         |  137 +
 arch/arm/mach-omap2/board-mapphone-sensors.c       |  240 ++
 arch/arm/mach-omap2/board-mapphone-spi.c           |  680 +++++
 arch/arm/mach-omap2/board-mapphone-wifi.c          |  202 ++
 arch/arm/mach-omap2/board-mapphone.c               | 1521 +++++++++++
 arch/arm/mach-omap2/board-sholes.c                 |    4 +-
 arch/arm/mach-omap2/board-sholest-camera.c         |  598 +++++
 arch/arm/mach-omap2/board-sholest-flash.c          |  120 +
 arch/arm/mach-omap2/board-sholest-gpio.c           |  304 +++
 arch/arm/mach-omap2/board-sholest-hsmmc.c          |  350 +++
 arch/arm/mach-omap2/board-sholest-keypad.c         |  158 ++
 arch/arm/mach-omap2/board-sholest-mdtv.c           |  109 +
 arch/arm/mach-omap2/board-sholest-mmcprobe.c       |   78 +
 arch/arm/mach-omap2/board-sholest-padconf.c        | 1837 +++++++++++++
 arch/arm/mach-omap2/board-sholest-panel.c          |  202 ++
 arch/arm/mach-omap2/board-sholest-sensors.c        |  382 +++
 arch/arm/mach-omap2/board-sholest-spi.c            |  698 +++++
 arch/arm/mach-omap2/board-sholest-wifi.c           |  202 ++
 arch/arm/mach-omap2/board-sholest.c                | 1820 +++++++++++++
 arch/arm/mach-omap2/board-zoom2.c                  |    4 +-
 arch/arm/mach-omap2/clock34xx.c                    |   11 +
 arch/arm/mach-omap2/clock34xx.h                    |    4 +-
 arch/arm/mach-omap2/cpuidle34xx.c                  |   49 +-
 arch/arm/mach-omap2/gpmc.c                         |   31 +-
 arch/arm/mach-omap2/mux.c                          |   84 +-
 arch/arm/mach-omap2/phoneid.c                      |   66 +
 arch/arm/mach-omap2/pm.c                           |    1 +
 arch/arm/mach-omap2/pm.h                           |    1 +
 arch/arm/mach-omap2/pm34xx.c                       |  331 +++-
 arch/arm/mach-omap2/powerdomain.c                  |    4 +-
 arch/arm/mach-omap2/powerdomains34xx.h             |    6 +-
 arch/arm/mach-omap2/prcm.c                         |    2 +-
 arch/arm/mach-omap2/resource34xx.c                 |   30 +-
 arch/arm/mach-omap2/resource34xx.h                 |    3 +
 arch/arm/mach-omap2/sdram-toshiba-hynix-numonyx.h  |   10 +-
 arch/arm/mach-omap2/serial.c                       |   26 +-
 arch/arm/mach-omap2/sleep34xx.S                    |    4 +-
 arch/arm/mach-omap2/smartreflex.c                  |  157 +-
 arch/arm/mach-omap2/smartreflex.h                  |    4 -
 arch/arm/mach-omap2/sram34xx.S                     |    6 +
 arch/arm/mach-omap2/usb-musb.c                     |    2 +
 arch/arm/mach-omap2/wakeup-timer.c                 |  801 ++++++
 arch/arm/mm/fault.c                                |    7 +
 arch/arm/mm/mmu.c                                  |   20 +
 arch/arm/plat-omap/Kconfig                         |   15 +
 arch/arm/plat-omap/dma.c                           |    7 +
 arch/arm/plat-omap/dmtimer.c                       |    8 +
 arch/arm/plat-omap/include/dspbridge/dbdefs.h      |    1 +
 arch/arm/plat-omap/include/dspbridge/mem.h         |    2 +-
 arch/arm/plat-omap/include/dspbridge/util.h        |  122 +
 .../include/mach/board-mapphone-emu_uart.h         |   43 +
 .../include/mach/board-mapphone-padconf.h          |  135 +
 arch/arm/plat-omap/include/mach/board-mapphone.h   |   68 +
 .../plat-omap/include/mach/board-sholest-padconf.h |  135 +
 arch/arm/plat-omap/include/mach/board-sholest.h    |   73 +
 arch/arm/plat-omap/include/mach/clock.h            |    1 +
 arch/arm/plat-omap/include/mach/display.h          |    5 +-
 arch/arm/plat-omap/include/mach/dt_path.h          |  107 +
 arch/arm/plat-omap/include/mach/gpmc.h             |   64 +
 arch/arm/plat-omap/include/mach/hardware.h         |   11 +
 arch/arm/plat-omap/include/mach/memory.h           |    4 +-
 arch/arm/plat-omap/include/mach/mux.h              |   39 +-
 arch/arm/plat-omap/include/mach/oldisp_user.h      |   10 +
 arch/arm/plat-omap/include/mach/powerdomain.h      |    2 +
 arch/arm/plat-omap/include/mach/prcm.h             |    3 +-
 arch/arm/plat-omap/resource.c                      |   98 +-
 arch/arm/tools/mach-types                          |  119 +-
 arch/powerpc/kernel/vmlinux.lds.S                  |    4 +
 arch/s390/kernel/vdso32/Makefile                   |    2 +-
 arch/s390/kernel/vdso64/Makefile                   |    2 +-
 arch/x86/kernel/Makefile                           |    3 +
 drivers/Kconfig                                    |    4 +
 drivers/Makefile                                   |    1 +
 drivers/base/devres.c                              |    4 +
 drivers/char/Kconfig                               |   13 +
 drivers/char/Makefile                              |    2 +
 drivers/char/gpiodev.c                             |  682 +++++
 drivers/cpufreq/cpufreq_ondemand.c                 |  147 +-
 drivers/dsp/bridge/pmgr/wcd.c                      |    3 +-
 drivers/dsp/bridge/rmgr/proc.c                     |    6 +-
 drivers/dsp/bridge/services/mem.c                  |    6 +-
 drivers/dsp/bridge/wmd/tiomap3430_pwr.c            |    2 +-
 drivers/gpio/Kconfig                               |    6 +
 drivers/gpio/Makefile                              |    1 +
 drivers/gpio/gpio_mapping.c                        |   58 +
 drivers/gpu/pvr/Kconfig                            |    2 +-
 drivers/gpu/pvr/Makefile                           |    3 -
 drivers/gpu/pvr/buffer_manager.c                   |  104 +-
 drivers/gpu/pvr/mem_debug.c                        |  250 ++
 drivers/gpu/pvr/omap3430/sysutils_linux.c          |    6 +-
 drivers/gpu/pvr/services.h                         |    2 +
 drivers/i2c/chips/Kconfig                          |    8 +
 drivers/i2c/chips/Makefile                         |    3 +-
 drivers/i2c/chips/lp3907_i2c.c                     |  529 ++++
 drivers/input/misc/Kconfig                         |    8 +
 drivers/input/misc/gpio_matrix.c                   |    5 +
 drivers/input/touchscreen/qtouch_obp_ts.c          |  220 ++-
 drivers/leds/Kconfig                               |   32 +
 drivers/leds/Makefile                              |    3 +
 drivers/leds/led-lm3530.c                          |  304 +++-
 drivers/leds/leds-bd7885.c                         |  661 +++++
 drivers/leds/leds-bu9847.c                         |  297 +++
 drivers/leds/leds-ld-cpcap-afled.c                 |  174 ++
 drivers/leds/leds-ld-cpcap-disp.c                  |   41 +-
 drivers/leds/leds-ld-cpcap-rgb.c                   |   29 +-
 drivers/media/dvb/siano/Kconfig                    |   73 +-
 drivers/media/dvb/siano/Makefile                   |   42 +-
 drivers/media/dvb/siano/compat.h                   |  238 ++
 drivers/media/dvb/siano/sms-cards.c                |  329 ++-
 drivers/media/dvb/siano/sms-cards.h                |   72 +-
 drivers/media/dvb/siano/smschar.c                  |  683 +++++
 drivers/media/dvb/siano/smscharioctl.h             |   58 +
 drivers/media/dvb/siano/smscoreapi.c               | 1255 +++++++---
 drivers/media/dvb/siano/smscoreapi.h               |  721 ++++--
 drivers/media/dvb/siano/smsdbg_prn.h               |   57 +
 drivers/media/dvb/siano/smsdvb.c                   |  423 ++-
 drivers/media/dvb/siano/smsendian.c                |  100 +
 drivers/media/dvb/siano/smsendian.h                |   32 +
 drivers/media/dvb/siano/smsir.c                    |  301 +++
 drivers/media/dvb/siano/smsir.h                    |   93 +
 drivers/media/dvb/siano/smsspicommon.c             |  384 +++
 drivers/media/dvb/siano/smsspicommon.h             |   96 +
 drivers/media/dvb/siano/smsspilog.c                |  506 ++++
 drivers/media/dvb/siano/smsspiphy.h                |   39 +
 drivers/media/dvb/siano/smsspiphy_omap34xx.c       |  374 +++
 drivers/media/dvb/siano/smsusb.c                   |   45 -
 drivers/media/video/Kconfig                        |   30 +
 drivers/media/video/Makefile                       |    4 +
 drivers/media/video/hp3a/hp3a.h                    |    1 +
 drivers/media/video/hp3a/hp3a_af.c                 |   28 +-
 drivers/media/video/hp3a/hp3a_common.h             |   18 +-
 drivers/media/video/hp3a/hp3a_ext.c                |   19 +-
 drivers/media/video/hp3a/hp3a_hardpipe.c           |    4 +-
 drivers/media/video/hp3a/hp3a_histogram.c          |   67 +-
 drivers/media/video/hp3a/hp3a_ioctl.c              |   54 +-
 drivers/media/video/hp3a/hp3a_queue.c              |    5 +-
 drivers/media/video/hp3a/hp3a_raw.c                |   34 +-
 drivers/media/video/hp3a/hp3a_stats.c              |  214 ++-
 drivers/media/video/hplens.c                       |   56 +-
 drivers/media/video/mipi_dli.c                     |  185 ++
 drivers/media/video/mt9p012.c                      |   43 +-
 drivers/media/video/oldisp/isp.c                   |  759 +++---
 drivers/media/video/oldisp/isp.h                   |    7 +-
 drivers/media/video/oldisp/ispccdc.c               |  166 +-
 drivers/media/video/oldisp/ispccdc.h               |    3 +
 drivers/media/video/oldisp/ispcsi2.c               |   16 +
 drivers/media/video/oldisp/ispcsi2.h               |    6 +
 drivers/media/video/oldisp/ispmmu.c                |   12 +-
 drivers/media/video/oldisp/ispmmu.h                |    2 +-
 drivers/media/video/oldisp/isppreview.c            |   73 +-
 drivers/media/video/oldisp/ispreg.h                |    7 +-
 drivers/media/video/oldisp/ispresizer.c            |  214 +-
 drivers/media/video/oldomap34xxcam.c               |   48 +-
 drivers/media/video/oldomap34xxcam.h               |    2 +
 drivers/media/video/omap-vout/omapvout-dss.c       |   84 +-
 drivers/media/video/omap-vout/omapvout-dss.h       |    6 +
 drivers/media/video/omap-vout/omapvout.c           |  120 +-
 drivers/media/video/omap_mot/Kconfig               |    8 +
 drivers/media/video/omap_mot/Makefile              |    7 +
 drivers/media/video/omap_mot/omapvout-bp.c         |  183 ++
 drivers/media/video/omap_mot/omapvout-bp.h         |   38 +
 drivers/media/video/omap_mot/omapvout-dss.c        |  695 +++++
 drivers/media/video/omap_mot/omapvout-dss.h        |   76 +
 drivers/media/video/omap_mot/omapvout-mem.c        |  118 +
 drivers/media/video/omap_mot/omapvout-mem.h        |   23 +
 drivers/media/video/omap_mot/omapvout.c            | 1502 +++++++++++
 drivers/media/video/omap_mot/omapvout.h            |   91 +
 drivers/media/video/ov8810.c                       | 2606 +++++++++++++++++++
 drivers/media/video/ov8810.h                       |  985 +++++++
 drivers/media/video/tda19989.c                     |  489 ++++
 drivers/media/video/tda19989.h                     |   30 +
 drivers/media/video/videobuf-core.c                |    1 +
 drivers/mfd/cpcap-3mm5.c                           |   70 +-
 drivers/mfd/cpcap-adc.c                            |   36 +-
 drivers/mfd/cpcap-core.c                           |   71 +-
 drivers/mfd/cpcap-regacc.c                         |   32 +-
 drivers/mfd/cpcap-uc.c                             |   70 +-
 drivers/misc/Kconfig                               |   14 +-
 drivers/misc/Makefile                              |    7 +
 drivers/misc/akm8973.c                             |    1 +
 drivers/misc/akm8973_akmd.c                        |    4 +-
 drivers/misc/apanic.c                              |   42 +-
 drivers/misc/clk_32k_rw.c                          |  190 ++
 drivers/misc/lis331dlh.c                           |    3 +-
 drivers/misc/modem_pm_driver/Kconfig               |   27 +
 drivers/misc/modem_pm_driver/Makefile              |   26 +
 drivers/misc/modem_pm_driver/modem_pm_driver.h     |   57 +
 .../misc/modem_pm_driver/modem_pm_driver_main.c    |  231 ++
 drivers/misc/netmux/Kconfig                        |   11 +
 drivers/misc/netmux/LICENSE                        |   28 +
 drivers/misc/netmux/Makefile                       |   12 +
 drivers/misc/netmux/channelconfig.c                |   51 +
 drivers/misc/netmux/config.c                       | 1419 ++++++++++
 drivers/misc/netmux/config.h                       |  256 ++
 drivers/misc/netmux/debug.c                        |  144 +
 drivers/misc/netmux/debug.h                        |   47 +
 drivers/misc/netmux/debug_client.h                 |   41 +
 drivers/misc/netmux/debug_host.h                   |  167 ++
 drivers/misc/netmux/direct.c                       |  738 ++++++
 drivers/misc/netmux/direct.h                       |  176 ++
 drivers/misc/netmux/errorcodes.h                   |   81 +
 drivers/misc/netmux/interface.c                    |  335 +++
 drivers/misc/netmux/interface.h                    |  126 +
 drivers/misc/netmux/main.c                         |  128 +
 drivers/misc/netmux/mux.c                          | 2382 +++++++++++++++++
 drivers/misc/netmux/mux.h                          |  325 +++
 drivers/misc/netmux/network.c                      |  590 +++++
 drivers/misc/netmux/network.h                      |  148 ++
 drivers/misc/netmux/packet.h                       |  221 ++
 drivers/misc/netmux/protocol.c                     |  413 +++
 drivers/misc/netmux/protocol.h                     |   66 +
 drivers/misc/netmux/register.c                     |  341 +++
 drivers/misc/netmux/register.h                     |  129 +
 drivers/misc/netmux/shared/ldprotocol.h            |  139 +
 drivers/misc/netmux/tty.c                          |  842 ++++++
 drivers/misc/netmux/tty.h                          |  172 ++
 drivers/misc/netmux/types.h                        |   85 +
 drivers/misc/netmux/utility.c                      |  437 ++++
 drivers/misc/netmux/utility.h                      |   52 +
 drivers/misc/netmux/utility_client.h               |   41 +
 drivers/misc/netmux/utility_host.h                 |  248 ++
 drivers/misc/netmux_linkdriver/Kconfig             |   11 +
 drivers/misc/netmux_linkdriver/LICENSE             |   28 +
 drivers/misc/netmux_linkdriver/Makefile            |    5 +
 drivers/misc/netmux_linkdriver/usb/Kconfig         |   25 +
 drivers/misc/netmux_linkdriver/usb/Makefile        |   52 +
 drivers/misc/netmux_linkdriver/usb/Makefile.back   |   62 +
 drivers/misc/netmux_linkdriver/usb/ModKconfig      |   26 +
 .../misc/netmux_linkdriver/usb/arch/arm/defconfig  |   20 +
 .../netmux_linkdriver/usb/modkconfig/autoconf.h    |  483 ++++
 .../misc/netmux_linkdriver/usb/modkconfig/config.h |  483 ++++
 .../netmux_linkdriver/usb/netmux_linkdriver.sh     |    2 +
 .../netmux_linkdriver/usb/netmux_usb_linkdriver.c  |  899 +++++++
 drivers/misc/sec/Kconfig                           |   11 +
 drivers/misc/sec/Makefile                          |   24 +
 drivers/misc/sec/bridge_pub2sec.S                  |  192 ++
 drivers/misc/sec/sec_core.c                        |  481 ++++
 drivers/misc/sec/sec_core.h                        |  127 +
 drivers/misc/sec/sec_ks_external.h                 |   47 +
 drivers/misc/syspanic.c                            |  430 +++
 drivers/mmc/core/core.c                            |   13 +-
 drivers/mmc/core/debugfs.c                         |    1 +
 drivers/mmc/host/Kconfig                           |    8 +
 drivers/mmc/host/omap_hsmmc.c                      |   32 +-
 drivers/mtd/mtdoops.c                              |    4 +-
 drivers/mtd/nand/Kconfig                           |    7 +
 drivers/mtd/nand/nand_base.c                       |   23 +-
 drivers/mtd/nand/omap2.c                           |   95 +-
 drivers/net/pppolac.c                              |   96 +-
 drivers/net/pppopns.c                              |  151 +-
 drivers/power/cpcap-battery.c                      |   39 +-
 drivers/regulator/cpcap-regulator.c                |  274 ++-
 drivers/rtc/alarm.c                                |    9 +-
 drivers/rtc/rtc-cpcap.c                            |   32 +-
 drivers/serial/8250.c                              |  126 +
 drivers/serial/Kconfig                             |    7 +
 drivers/serial/omap-serial.c                       |   36 +-
 drivers/sim/Kconfig                                |    4 +
 drivers/sim/Makefile                               |   21 +
 drivers/sim/sim_core.c                             | 2649 +++++++++++++++++++
 drivers/sim/smart_card.h                           |  221 ++
 drivers/sim/smart_card_kernel.h                    |  261 ++
 drivers/spi/omap2_mcspi.c                          |   56 +-
 drivers/spi/spi.c                                  |   31 +
 drivers/staging/android/logger.c                   |  176 ++-
 drivers/staging/android/logger.h                   |    5 +
 drivers/usb/Kconfig                                |    2 +
 drivers/usb/Makefile                               |    2 +
 drivers/usb/class/Kconfig                          |    8 +
 drivers/usb/class/cdc-acm.c                        |   12 +-
 drivers/usb/core/Kconfig                           |    8 +
 drivers/usb/core/config.c                          |    2 +
 drivers/usb/core/driver.c                          |    4 +
 drivers/usb/core/hub.c                             |   17 +-
 drivers/usb/gadget/Kconfig                         |   14 +-
 drivers/usb/gadget/Makefile                        |    6 +-
 drivers/usb/gadget/android.c                       |   26 +-
 drivers/usb/gadget/composite.c                     |   36 +-
 drivers/usb/gadget/f_acm.c                         |  180 ++-
 drivers/usb/gadget/f_acm.h                         |    2 +
 drivers/usb/gadget/f_adb.c                         |   81 +-
 drivers/usb/gadget/f_adb.h                         |    4 +
 drivers/usb/gadget/f_mass_storage.c                |  272 ++-
 drivers/usb/gadget/f_mass_storage.h                |    4 +
 drivers/usb/gadget/f_mot_android.h                 |   32 +
 drivers/usb/gadget/f_mtp.c                         | 1205 +++++++++
 drivers/usb/gadget/f_mtp.h                         |   41 +
 drivers/usb/gadget/f_usbnet.c                      |  554 +++--
 drivers/usb/gadget/f_usbnet.h                      |    5 +-
 drivers/usb/gadget/mot_android.c                   |  855 ++++++
 drivers/usb/gadget/u_serial.c                      |   25 +
 drivers/usb/gadget/u_serial.h                      |    3 +
 drivers/usb/host/ehci-dbg.c                        |   64 +-
 drivers/usb/host/ehci-hcd.c                        |   38 +-
 drivers/usb/host/ehci-hub.c                        |   99 +-
 drivers/usb/host/ehci-ixp4xx.c                     |    2 +-
 drivers/usb/host/ehci-mem.c                        |    1 -
 drivers/usb/host/ehci-omap.c                       | 1059 +++++----
 drivers/usb/host/ehci-omap.h                       |   16 +-
 drivers/usb/host/ehci-orion.c                      |   17 +-
 drivers/usb/host/ehci-pci.c                        |   12 +-
 drivers/usb/host/ehci-ppc-of.c                     |   45 +-
 drivers/usb/host/ehci-ppc-soc.c                    |  201 ++
 drivers/usb/host/ehci-q.c                          |    3 +-
 drivers/usb/host/ehci-sched.c                      |   66 +-
 drivers/usb/host/ehci.h                            |  199 ++-
 drivers/usb/ipchost/Kconfig                        |   25 +
 drivers/usb/ipchost/Makefile                       |   10 +
 drivers/usb/ipchost/ipc_api.c                      | 1303 ++++++++++
 drivers/usb/ipchost/ipc_api_test.c                 |  377 +++
 drivers/usb/ipchost/ipc_data.c                     |  893 +++++++
 drivers/usb/ipchost/ipc_dma.c                      |  454 ++++
 drivers/usb/ipchost/ipc_log.c                      |  445 ++++
 drivers/usb/ipchost/ipc_shortmsg.c                 |  173 ++
 drivers/usb/musb/musb_gadget.c                     |   40 +-
 drivers/usb/musb/musb_regs.h                       |    2 +-
 drivers/usb/serial/qsc6085_modem.c                 |    2 +
 drivers/video/omap2/displays/Kconfig               |    6 +
 drivers/video/omap2/displays/Makefile              |    2 +
 drivers/video/omap2/displays/panel-hdtv.c          |  185 ++
 drivers/video/omap2/displays/panel-sholes.c        |  546 ++++-
 drivers/video/omap2/displays/panel-sholes.h        |   13 +
 drivers/video/omap2/dss/core.c                     |    2 +
 drivers/video/omap2/dss/dispc.c                    |    4 +-
 drivers/video/omap2/dss/display.c                  |   10 +
 drivers/video/omap2/dss/dsi.c                      |  255 ++-
 drivers/video/omap2/dss/manager.c                  |   13 +
 drivers/video/omap2/dss/overlay.c                  |   36 +
 drivers/video/omap2/omapfb/omapfb-sysfs.c          |    6 +
 drivers/w1/w1.c                                    |    8 +-
 drivers/watchdog/Kconfig                           |   16 +-
 drivers/watchdog/omap_wdt.c                        |  171 ++-
 drivers/watchdog/omap_wdt.h                        |    4 +
 firmware/Makefile                                  |    1 +
 firmware/cpcap/firmware_1_2x.H16                   |    3 +
 fs/Kconfig                                         |    5 +
 fs/exec.c                                          |   10 +
 fs/ioctl.c                                         |   12 +
 fs/yaffs2/yaffs_checkptrw.c                        |    3 +-
 fs/yaffs2/yaffs_fs.c                               |  167 ++-
 fs/yaffs2/yaffs_guts.c                             |   62 +-
 fs/yaffs2/yaffs_guts.h                             |   14 +-
 fs/yaffs2/yaffs_mtdif2.c                           |    1 -
 include/asm-generic/vmlinux.lds.h                  |   18 +
 include/linux/android_pmem.h                       |    4 +-
 include/linux/gcov.h                               |  243 ++
 include/linux/gpio_event.h                         |    1 +
 include/linux/gpio_mapping.h                       |   44 +
 include/linux/gpiodev.h                            |  149 ++
 include/linux/i2c/lp3907_i2c.h                     |   41 +
 include/linux/if_pppox.h                           |    3 +
 include/linux/interrupt.h                          |    6 +
 include/linux/ipc_api.h                            |  439 ++++
 include/linux/kernel.h                             |   14 +
 include/linux/led-lm3530.h                         |    5 +
 include/linux/leds-bd7885.h                        |  122 +
 include/linux/leds-bu9847.h                        |   67 +
 include/linux/leds-ld-cpcap.h                      |   37 +-
 include/linux/lttlite-events.h                     |  175 ++
 include/linux/memleak.h                            |  118 +
 include/linux/mipi_dli.h                           |   18 +
 include/linux/module.h                             |    5 +
 include/linux/panel-suppliers.h                    |   26 +
 include/linux/qtouch_obp_ts.h                      |  161 ++-
 include/linux/quickwakeup.h                        |   33 +
 include/linux/serial_8250.h                        |    9 +
 include/linux/slab.h                               |    6 +
 include/linux/slab_def.h                           |    9 +
 include/linux/soundcard.h                          |    3 +
 include/linux/spi/cpcap.h                          |   16 +
 include/linux/spi/spi.h                            |    4 +
 include/linux/syscalls.h                           |    4 +
 include/linux/usb/composite.h                      |    1 +
 include/linux/usb/omap.h                           |    1 +
 include/linux/usb_ipc.h                            |  305 +++
 include/linux/vmalloc.h                            |   12 +
 include/linux/wakeup_timer.h                       |   56 +
 include/linux/wakeup_timer_kernel.h                |   90 +
 include/linux/watchdog.h                           |    1 +
 init/main.c                                        |   31 +
 kernel/Kconfig.lttlite                             |   11 +
 kernel/Makefile                                    |    2 +
 kernel/exit.c                                      |   10 +
 kernel/fork.c                                      |    6 +
 kernel/gcov/Kconfig                                |   55 +
 kernel/gcov/Makefile                               |   13 +
 kernel/gcov/gcov-core.c                            |  295 +++
 kernel/gcov/gcov-proc.c                            | 2147 +++++++++++++++
 kernel/kthread.c                                   |    5 +
 kernel/ltt-lite.c                                  | 2737 ++++++++++++++++++++
 kernel/module.c                                    |   75 +
 kernel/power/Kconfig                               |    8 +
 kernel/power/Makefile                              |    4 +-
 kernel/power/main.c                                |   55 +-
 kernel/power/process.c                             |   21 +-
 kernel/power/quickwakeup.c                         |   62 +
 kernel/printk.c                                    |   10 +-
 kernel/sched.c                                     |   11 +
 kernel/sched_features.h                            |    2 +-
 kernel/signal.c                                    |   10 +
 kernel/softirq.c                                   |   28 +
 kernel/sysctl.c                                    |   14 +
 kernel/timer.c                                     |   17 +
 lib/Kconfig.debug                                  |  138 +
 mm/Makefile                                        |    3 +
 mm/memleak-test.c                                  |   94 +
 mm/memleak.c                                       | 1521 +++++++++++
 mm/slab.c                                          |   90 +
 mm/vmalloc.c                                       |   54 +
 net/bluetooth/hci_conn.c                           |    2 +-
 net/ipv4/tcp_output.c                              |   34 +
 net/sunrpc/sched.c                                 |    4 +
 scripts/Kbuild.include                             |    2 +
 scripts/Makefile.build                             |   16 +-
 scripts/Makefile.lib                               |   14 +-
 scripts/checkpatch.pl                              |    6 +-
 scripts/chk_gcc_warn.pl                            |  162 ++
 scripts/gcc_warn_filter.README                     |   39 +
 scripts/gcc_warn_filter.cfg                        |   56 +
 scripts/pre-commit                                 |   20 +
 sound/oss/Kconfig                                  |    2 +-
 sound/oss/Makefile                                 |    6 +-
 sound/oss/moto_audio/Makefile                      |    1 +
 sound/oss/moto_audio/cpcap_audio_driver.c          | 1204 +++++++++
 sound/oss/moto_audio/cpcap_audio_driver.h          |  219 ++
 sound/oss/moto_audio/omap34xx_audio_driver.c       | 2357 +++++++++++++++++
 sound/oss/moto_audio/omap34xx_audio_driver.h       |  175 ++
 sound/oss/omap34xx_audio_driver.c                  |   12 -
 472 files changed, 81190 insertions(+), 3621 deletions(-)
 create mode 100644 NOTICE
 create mode 100644 arch/arm/configs/ext_config/eng_bld.config
 create mode 100644 arch/arm/configs/ext_config/feature/coverage.config
 create mode 100644 arch/arm/configs/ext_config/feature/cup2touch.config
 create mode 100644 arch/arm/configs/ext_config/feature/faultinject.config
 create mode 100644 arch/arm/configs/ext_config/feature/kmemleak.config
 create mode 100755 arch/arm/configs/mapphone_defconfig
 create mode 100644 arch/arm/configs/sholest_cu_defconfig
 create mode 100644 arch/arm/include/asm/bootinfo.h
 create mode 100644 arch/arm/include/asm/prom.h
 create mode 100644 arch/arm/kernel/bootinfo.c
 create mode 100644 arch/arm/kernel/prom.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-camera.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-emu_uart.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-flash.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-gpio.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-hsmmc.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-keypad.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-mmcprobe.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-padconf.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-panel.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-sensors.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-spi.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone-wifi.c
 create mode 100644 arch/arm/mach-omap2/board-mapphone.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-camera.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-flash.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-gpio.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-hsmmc.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-keypad.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-mdtv.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-mmcprobe.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-padconf.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-panel.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-sensors.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-spi.c
 create mode 100644 arch/arm/mach-omap2/board-sholest-wifi.c
 create mode 100644 arch/arm/mach-omap2/board-sholest.c
 create mode 100644 arch/arm/mach-omap2/phoneid.c
 create mode 100644 arch/arm/mach-omap2/wakeup-timer.c
 create mode 100644 arch/arm/plat-omap/include/dspbridge/util.h
 create mode 100644 arch/arm/plat-omap/include/mach/board-mapphone-emu_uart.h
 create mode 100644 arch/arm/plat-omap/include/mach/board-mapphone-padconf.h
 create mode 100644 arch/arm/plat-omap/include/mach/board-mapphone.h
 create mode 100644 arch/arm/plat-omap/include/mach/board-sholest-padconf.h
 create mode 100644 arch/arm/plat-omap/include/mach/board-sholest.h
 create mode 100644 arch/arm/plat-omap/include/mach/dt_path.h
 create mode 100644 drivers/char/gpiodev.c
 create mode 100644 drivers/gpio/gpio_mapping.c
 create mode 100644 drivers/gpu/pvr/mem_debug.c
 mode change 100755 => 100644 drivers/gpu/pvr/pdump_osfunc.h
 mode change 100755 => 100644 drivers/gpu/pvr/sgx_mkif_km.h
 create mode 100644 drivers/i2c/chips/lp3907_i2c.c
 create mode 100644 drivers/leds/leds-bd7885.c
 create mode 100644 drivers/leds/leds-bu9847.c
 create mode 100644 drivers/leds/leds-ld-cpcap-afled.c
 create mode 100644 drivers/media/dvb/siano/compat.h
 create mode 100644 drivers/media/dvb/siano/smschar.c
 create mode 100644 drivers/media/dvb/siano/smscharioctl.h
 create mode 100644 drivers/media/dvb/siano/smsdbg_prn.h
 create mode 100644 drivers/media/dvb/siano/smsendian.c
 create mode 100644 drivers/media/dvb/siano/smsendian.h
 create mode 100644 drivers/media/dvb/siano/smsir.c
 create mode 100644 drivers/media/dvb/siano/smsir.h
 create mode 100644 drivers/media/dvb/siano/smsspicommon.c
 create mode 100644 drivers/media/dvb/siano/smsspicommon.h
 create mode 100644 drivers/media/dvb/siano/smsspilog.c
 create mode 100644 drivers/media/dvb/siano/smsspiphy.h
 create mode 100644 drivers/media/dvb/siano/smsspiphy_omap34xx.c
 create mode 100644 drivers/media/video/mipi_dli.c
 create mode 100644 drivers/media/video/omap_mot/Kconfig
 create mode 100644 drivers/media/video/omap_mot/Makefile
 create mode 100644 drivers/media/video/omap_mot/omapvout-bp.c
 create mode 100644 drivers/media/video/omap_mot/omapvout-bp.h
 create mode 100644 drivers/media/video/omap_mot/omapvout-dss.c
 create mode 100644 drivers/media/video/omap_mot/omapvout-dss.h
 create mode 100644 drivers/media/video/omap_mot/omapvout-mem.c
 create mode 100644 drivers/media/video/omap_mot/omapvout-mem.h
 create mode 100644 drivers/media/video/omap_mot/omapvout.c
 create mode 100644 drivers/media/video/omap_mot/omapvout.h
 create mode 100644 drivers/media/video/ov8810.c
 create mode 100644 drivers/media/video/ov8810.h
 create mode 100644 drivers/media/video/tda19989.c
 create mode 100644 drivers/media/video/tda19989.h
 create mode 100644 drivers/misc/clk_32k_rw.c
 create mode 100755 drivers/misc/modem_pm_driver/Kconfig
 create mode 100755 drivers/misc/modem_pm_driver/Makefile
 create mode 100755 drivers/misc/modem_pm_driver/modem_pm_driver.h
 create mode 100755 drivers/misc/modem_pm_driver/modem_pm_driver_main.c
 create mode 100644 drivers/misc/netmux/Kconfig
 create mode 100755 drivers/misc/netmux/LICENSE
 create mode 100644 drivers/misc/netmux/Makefile
 create mode 100755 drivers/misc/netmux/channelconfig.c
 create mode 100755 drivers/misc/netmux/config.c
 create mode 100755 drivers/misc/netmux/config.h
 create mode 100755 drivers/misc/netmux/debug.c
 create mode 100755 drivers/misc/netmux/debug.h
 create mode 100755 drivers/misc/netmux/debug_client.h
 create mode 100755 drivers/misc/netmux/debug_host.h
 create mode 100755 drivers/misc/netmux/direct.c
 create mode 100755 drivers/misc/netmux/direct.h
 create mode 100755 drivers/misc/netmux/errorcodes.h
 create mode 100755 drivers/misc/netmux/interface.c
 create mode 100755 drivers/misc/netmux/interface.h
 create mode 100755 drivers/misc/netmux/main.c
 create mode 100755 drivers/misc/netmux/mux.c
 create mode 100755 drivers/misc/netmux/mux.h
 create mode 100755 drivers/misc/netmux/network.c
 create mode 100755 drivers/misc/netmux/network.h
 create mode 100755 drivers/misc/netmux/packet.h
 create mode 100755 drivers/misc/netmux/protocol.c
 create mode 100755 drivers/misc/netmux/protocol.h
 create mode 100755 drivers/misc/netmux/register.c
 create mode 100755 drivers/misc/netmux/register.h
 create mode 100755 drivers/misc/netmux/shared/ldprotocol.h
 create mode 100755 drivers/misc/netmux/tty.c
 create mode 100755 drivers/misc/netmux/tty.h
 create mode 100755 drivers/misc/netmux/types.h
 create mode 100755 drivers/misc/netmux/utility.c
 create mode 100755 drivers/misc/netmux/utility.h
 create mode 100755 drivers/misc/netmux/utility_client.h
 create mode 100755 drivers/misc/netmux/utility_host.h
 create mode 100644 drivers/misc/netmux_linkdriver/Kconfig
 create mode 100755 drivers/misc/netmux_linkdriver/LICENSE
 create mode 100644 drivers/misc/netmux_linkdriver/Makefile
 create mode 100644 drivers/misc/netmux_linkdriver/usb/Kconfig
 create mode 100755 drivers/misc/netmux_linkdriver/usb/Makefile
 create mode 100644 drivers/misc/netmux_linkdriver/usb/Makefile.back
 create mode 100644 drivers/misc/netmux_linkdriver/usb/ModKconfig
 create mode 100644 drivers/misc/netmux_linkdriver/usb/arch/arm/defconfig
 create mode 100644 drivers/misc/netmux_linkdriver/usb/modkconfig/autoconf.h
 create mode 100644 drivers/misc/netmux_linkdriver/usb/modkconfig/config.h
 create mode 100755 drivers/misc/netmux_linkdriver/usb/netmux_linkdriver.sh
 create mode 100644 drivers/misc/netmux_linkdriver/usb/netmux_usb_linkdriver.c
 create mode 100644 drivers/misc/sec/Kconfig
 create mode 100644 drivers/misc/sec/Makefile
 create mode 100644 drivers/misc/sec/bridge_pub2sec.S
 create mode 100644 drivers/misc/sec/sec_core.c
 create mode 100644 drivers/misc/sec/sec_core.h
 create mode 100644 drivers/misc/sec/sec_ks_external.h
 create mode 100644 drivers/misc/syspanic.c
 create mode 100644 drivers/sim/Kconfig
 create mode 100644 drivers/sim/Makefile
 create mode 100644 drivers/sim/sim_core.c
 create mode 100644 drivers/sim/smart_card.h
 create mode 100644 drivers/sim/smart_card_kernel.h
 create mode 100644 drivers/usb/gadget/f_mot_android.h
 create mode 100644 drivers/usb/gadget/f_mtp.c
 create mode 100644 drivers/usb/gadget/f_mtp.h
 create mode 100644 drivers/usb/gadget/mot_android.c
 create mode 100644 drivers/usb/host/ehci-ppc-soc.c
 create mode 100644 drivers/usb/ipchost/Kconfig
 create mode 100644 drivers/usb/ipchost/Makefile
 create mode 100644 drivers/usb/ipchost/ipc_api.c
 create mode 100644 drivers/usb/ipchost/ipc_api_test.c
 create mode 100644 drivers/usb/ipchost/ipc_data.c
 create mode 100644 drivers/usb/ipchost/ipc_dma.c
 create mode 100644 drivers/usb/ipchost/ipc_log.c
 create mode 100644 drivers/usb/ipchost/ipc_shortmsg.c
 create mode 100644 drivers/video/omap2/displays/panel-hdtv.c
 create mode 100644 drivers/video/omap2/displays/panel-sholes.h
 create mode 100644 firmware/cpcap/firmware_1_2x.H16
 create mode 100644 include/linux/gcov.h
 create mode 100644 include/linux/gpio_mapping.h
 create mode 100644 include/linux/gpiodev.h
 create mode 100644 include/linux/i2c/lp3907_i2c.h
 create mode 100644 include/linux/ipc_api.h
 create mode 100644 include/linux/leds-bd7885.h
 create mode 100644 include/linux/leds-bu9847.h
 create mode 100644 include/linux/lttlite-events.h
 create mode 100644 include/linux/memleak.h
 create mode 100644 include/linux/mipi_dli.h
 create mode 100755 include/linux/panel-suppliers.h
 create mode 100644 include/linux/quickwakeup.h
 create mode 100644 include/linux/usb_ipc.h
 create mode 100644 include/linux/wakeup_timer.h
 create mode 100644 include/linux/wakeup_timer_kernel.h
 create mode 100644 kernel/Kconfig.lttlite
 create mode 100644 kernel/gcov/Kconfig
 create mode 100644 kernel/gcov/Makefile
 create mode 100644 kernel/gcov/gcov-core.c
 create mode 100644 kernel/gcov/gcov-proc.c
 create mode 100644 kernel/ltt-lite.c
 create mode 100644 kernel/power/quickwakeup.c
 create mode 100644 mm/memleak-test.c
 create mode 100644 mm/memleak.c
 create mode 100755 scripts/chk_gcc_warn.pl
 create mode 100644 scripts/gcc_warn_filter.README
 create mode 100644 scripts/gcc_warn_filter.cfg
 create mode 100755 scripts/pre-commit
 create mode 100644 sound/oss/moto_audio/Makefile
 create mode 100755 sound/oss/moto_audio/cpcap_audio_driver.c
 create mode 100644 sound/oss/moto_audio/cpcap_audio_driver.h
 create mode 100755 sound/oss/moto_audio/omap34xx_audio_driver.c
 create mode 100644 sound/oss/moto_audio/omap34xx_audio_driver.h

diff --git a/Makefile b/Makefile
index cf782ca..ac2a52e 100644
--- a/Makefile
+++ b/Makefile
@@ -78,6 +78,7 @@ ifdef M
   endif
 endif
 
+KBUILD_GCOV_FLAGS	= -fprofile-arcs -ftest-coverage
 
 # kbuild supports saving output files in a separate directory.
 # To locate output files in a separate directory two syntaxes are supported.
@@ -366,6 +367,7 @@ export HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
 export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
 export KBUILD_CFLAGS CFLAGS_KERNEL CFLAGS_MODULE
 export KBUILD_AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
+export KBUILD_CFLAGS_NOGCOV KBUILD_GCOV_FLAGS
 
 # When compiling out-of-tree modules, put MODVERDIR in the module
 # tree rather than in the kernel tree. The kernel tree might
@@ -595,6 +597,11 @@ ifneq ($(KCFLAGS),)
         KBUILD_CFLAGS += $(KCFLAGS)
 endif
 
+KBUILD_CFLAGS_NOGCOV := $(KBUILD_CFLAGS)
+ifeq ($(COV_FLAGS),1)
+KBUILD_CFLAGS += $(KBUILD_GCOV_FLAGS)
+endif
+
 # Use --build-id when available.
 LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,\
 			      $(call ld-option, -Wl$(comma)--build-id,))
@@ -1219,7 +1226,9 @@ clean: archclean $(clean-dirs)
 		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
 		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
 		-o -name '*.symtypes' -o -name 'modules.order' \
-		-o -name 'Module.markers' -o -name '.tmp_*.o.*' \) \
+		-o -name 'Module.markers' -o -name '.tmp_*.o.*' \
+		-o -name '*.bb' -o -name '*.bbg' -o -name '*.da' \
+		-o -name '*.gcno' -o -name '*.gcda' \) \
 		-type f -print | xargs rm -f
 
 # mrproper - Delete all generated files, including .config
diff --git a/NOTICE b/NOTICE
new file mode 100644
index 0000000..c87c902
--- /dev/null
+++ b/NOTICE
@@ -0,0 +1,355 @@
+   NOTE! This copyright does *not* cover user programs that use kernel
+ services by normal system calls - this is merely considered normal use
+ of the kernel, and does *not* fall under the heading of "derived work".
+ Also note that the GPL below is copyrighted by the Free Software
+ Foundation, but the instance of code that it refers to (the Linux
+ kernel) is copyrighted by me and others who actually wrote it.
+
+ Also note that the only valid version of the GPL as far as the kernel
+ is concerned is _this_ particular version of the license (ie v2, not
+ v2.2 or v3.x or whatever), unless explicitly otherwise stated.
+
+                        Linus Torvalds
+
+----------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 7453ae8..35f4c76 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -152,12 +152,41 @@ config GENERIC_ISA_DMA
 config FIQ
 	bool
 
+config NON_NESTED_FIQ
+    bool "Support non-nested FIQ on arm"
+	default n
+
 config ARCH_MTD_XIP
 	bool
 
 config GENERIC_HARDIRQS_NO__DO_IRQ
 	def_bool y
 
+config ARM_OF
+	bool "Support for open firmware device tree (ARM port)"
+	default n
+
+config OF
+	bool "Support for open firmware device tree"
+	depends on ARM_OF
+	default n
+
+config BOOTINFO
+    bool "Boot Information Feature"
+    default n
+    help
+      This feature provides access to certain boot information
+      from both kernel context (via function call) and user
+      context (via /proc/bootinfo).
+
+config PROC_DEVICETREE
+	bool "Support for device tree in /proc"
+	depends on PROC_FS && OF
+	help
+          This option adds a device-tree directory under /proc which contains
+          an image of the device tree that the kernel copies from Open
+          Firmware or other boot firmware. If unsure, say Y here.
+
 if OPROFILE
 
 config OPROFILE_ARMV6
@@ -1362,3 +1391,5 @@ source "security/Kconfig"
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
+
+source "kernel/Kconfig.lttlite"
diff --git a/arch/arm/boot/compressed/Makefile b/arch/arm/boot/compressed/Makefile
index b095303..ef044e8 100644
--- a/arch/arm/boot/compressed/Makefile
+++ b/arch/arm/boot/compressed/Makefile
@@ -8,6 +8,7 @@ HEAD	= head.o
 OBJS	= misc.o
 FONTC	= $(srctree)/drivers/video/console/font_acorn_8x8.c
 
+KBUILD_CFLAGS := $(KBUILD_CFLAGS_NOGCOV)
 #
 # Architecture dependencies
 #
diff --git a/arch/arm/configs/ext_config/eng_bld.config b/arch/arm/configs/ext_config/eng_bld.config
new file mode 100644
index 0000000..8d80cbb
--- /dev/null
+++ b/arch/arm/configs/ext_config/eng_bld.config
@@ -0,0 +1,12 @@
+#
+# Define options needed for engineering build
+# The options need to be turned off for production release
+#
+CONFIG_LTT_LITE=y
+CONFIG_DEBUG_SLAB=y
+CONFIG_MMC_TST=y
+CONFIG_EMU_UART_DEBUG=y
+CONFIG_CORE_DUMP_PERMISSION=y
+CONFIG_OMAP_WATCHDOG_CONTROL=y
+CONFIG_NON_NESTED_FIQ=y
+CONFIG_OMAP_WATCHDOG_FIQ=y
diff --git a/arch/arm/configs/ext_config/feature/coverage.config b/arch/arm/configs/ext_config/feature/coverage.config
new file mode 100644
index 0000000..f3517e7
--- /dev/null
+++ b/arch/arm/configs/ext_config/feature/coverage.config
@@ -0,0 +1,15 @@
+
+# arch/arm/configs/motorola_ljap/feature/coverage.config
+#
+# GCOV enable.
+#
+# Enabled by LJ Build Environment TEST_COVERAGE flag.
+#
+# Copyright 2007 Motorola, Inc.
+#
+
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_GCOV_PROFILE=y
+# CONFIG_GCOV_ALL is not set
+CONFIG_GCOV_PROC=y
diff --git a/arch/arm/configs/ext_config/feature/cup2touch.config b/arch/arm/configs/ext_config/feature/cup2touch.config
new file mode 100644
index 0000000..3775748
--- /dev/null
+++ b/arch/arm/configs/ext_config/feature/cup2touch.config
@@ -0,0 +1,2 @@
+# CU p2 touch need special treatment for its differenct IC
+CONFIG_CUP2TOUCH=y
diff --git a/arch/arm/configs/ext_config/feature/faultinject.config b/arch/arm/configs/ext_config/feature/faultinject.config
new file mode 100644
index 0000000..85b87c2
--- /dev/null
+++ b/arch/arm/configs/ext_config/feature/faultinject.config
@@ -0,0 +1,17 @@
+# arch/arm/configs/motorola_ljap/feature/faultinject.config
+#
+# Fault Injection enable.
+#
+# Enabled by LJ Build Environment TEST_FAULTINJECT flag.
+#
+# Copyright 2007 Motorola, Inc.
+#
+
+CONFIG_DEBUG_FS=y
+CONFIG_STACKTRACE=y
+CONFIG_FAULT_INJECTION=y
+CONFIG_FAILSLAB=y
+CONFIG_FAIL_PAGE_ALLOC=y
+CONFIG_FAIL_MAKE_REQUEST=y
+CONFIG_FAULT_INJECTION_DEBUG_FS=y
+CONFIG_FAULT_INJECTION_STACKTRACE_FILTER=y
diff --git a/arch/arm/configs/ext_config/feature/kmemleak.config b/arch/arm/configs/ext_config/feature/kmemleak.config
new file mode 100644
index 0000000..055447a
--- /dev/null
+++ b/arch/arm/configs/ext_config/feature/kmemleak.config
@@ -0,0 +1,26 @@
+# arch/arm/configs/motorola_ljap/feature/kmemleak.config
+#
+# KMEMLEAK enable.
+#
+# Enabled by LJ Build Environment TEST_KMEMLEAK flag.
+#
+# Copyright 2009 Motorola, Inc.
+#
+
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_SLAB=y
+CONFIG_DEBUG_SLAB_LEAK=y
+CONFIG_DEBUG_MEMLEAK=y
+CONFIG_DEBUG_MEMLEAK_DYNAMIC_NR=y
+CONFIG_DEBUG_MEMLEAK_HASH_BITS=16
+CONFIG_DEBUG_MEMLEAK_TRACE_LENGTH=4
+CONFIG_DEBUG_MEMLEAK_PREINIT_OBJECTS=512
+CONFIG_DEBUG_MEMLEAK_SECONDARY_ALIASES=y
+CONFIG_DEBUG_MEMLEAK_TASK_STACKS=y
+CONFIG_DEBUG_KEEP_INIT=y
+CONFIG_DEBUG_MEMLEAK_TEST=m
+# CONFIG_DEBUG_MEMLEAK_ORPHAN_FREEING is not set
+CONFIG_DEBUG_MEMLEAK_REPORT_THLD=1
+CONFIG_STACKTRACE=y
diff --git a/arch/arm/configs/mapphone_defconfig b/arch/arm/configs/mapphone_defconfig
new file mode 100755
index 0000000..00c5ec1
--- /dev/null
+++ b/arch/arm/configs/mapphone_defconfig
@@ -0,0 +1,2149 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.29-omap1
+# Tue Oct 20 13:15:45 2009
+# Fri Oct 23 20:03:54 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_ARM_OF=y
+CONFIG_OF=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_BOOTINFO=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ASHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_OMAP=y
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+
+#
+# TI OMAP Implementations
+#
+CONFIG_ARCH_OMAP_OTG=y
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_OMAP2 is not set
+CONFIG_ARCH_OMAP3=y
+
+#
+# OMAP Feature Selections
+#
+# CONFIG_ARCH_OMAP3_GP is not set
+CONFIG_ARCH_OMAP3_HS=y
+# CONFIG_OMAP_DEBUG_POWERDOMAIN is not set
+# CONFIG_OMAP_DEBUG_CLOCKDOMAIN is not set
+CONFIG_OMAP_SMARTREFLEX=y
+# CONFIG_OMAP_SMARTREFLEX_TESTING is not set
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_BOOT_TAG=y
+CONFIG_OMAP_BOOT_REASON=y
+# CONFIG_OMAP_COMPONENT_VERSION is not set
+# CONFIG_OMAP_GPIO_SWITCH is not set
+# CONFIG_OMAP_MUX is not set
+# CONFIG_OMAP_MUX_DEBUG is not set
+# CONFIG_OMAP_MUX_WARNINGS is not set
+CONFIG_OMAP_MCBSP=y
+CONFIG_MEM_DUMP=y
+# CONFIG_OMAP_MBOX_FWK is not set
+# CONFIG_OMAP_IOMMU is not set
+# CONFIG_OMAP_MPU_TIMER is not set
+CONFIG_OMAP_32K_TIMER=y
+# CONFIG_OMAP3_DEBOBS is not set
+CONFIG_OMAP_32K_TIMER_HZ=128
+CONFIG_OMAP_TICK_GPTIMER=1
+CONFIG_OMAP_DM_TIMER=y
+# CONFIG_OMAP_LL_DEBUG_UART1 is not set
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+CONFIG_OMAP_LL_DEBUG_UART3=y
+# CONFIG_OMAP_LL_DEBUG_UART_EXT is not set
+CONFIG_OMAP_SERIAL_WAKE=y
+# CONFIG_OMAP_PM_NONE is not set
+# CONFIG_OMAP_PM_NOOP is not set
+CONFIG_OMAP_PM_SRF=y
+CONFIG_ARCH_OMAP34XX=y
+CONFIG_ARCH_OMAP3430=y
+
+#
+# OMAP Board Type
+#
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP_ZOOM2 is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_TIWLAN_SDIO is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_SHOLES is not set
+CONFIG_MACH_MAPPHONE=y
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_HAS_TLS_REG is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# errata
+#
+CONFIG_ARM_ERRATA_430973=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=128
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_LEDS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=192.168.0.1:/home/user/buildroot ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.255.0:tgt:eth0:off rw console=ttyS2,115200n8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_MIN_TICKS=2
+CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_VERBOSE is not set
+# CONFIG_CAN_PM_TRACE is not set
+CONFIG_PM_DEBUG=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+# CONFIG_WAKELOCK_STAT is not set
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_QUICK_WAKEUP=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_COMPAT_NET_DEV_OPS=y
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+CONFIG_NETFILTER_XT_MATCH_RECENT_PROC_COMPAT=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_IDLETIMER=y
+CONFIG_NF_NAT_SNMP_BASIC=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+# CONFIG_DCB is not set
+
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIBRF6150 is not set
+# CONFIG_BT_HCIH4P is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_OF_DEVICE=y
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_OMAP_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_OMAP2=y
+CONFIG_MTD_NAND_OMAP_HWECC=y
+CONFIG_MTD_NAND_OMAP_PREFETCH=y
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ICS932S401 is not set
+CONFIG_OMAP_MODEM_CONTROL=y
+# CONFIG_OMAP_STI is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+# CONFIG_UID_STAT is not set
+CONFIG_VIB_PWM=y
+CONFIG_VIB_GPIO=y
+# CONFIG_SENSORS_AKM8973 is not set
+CONFIG_SENSORS_AKM8973_AKMD=y
+CONFIG_SENSORS_LIS331DLH=y
+CONFIG_WL127X_RFKILL=y
+CONFIG_WL127X_TEST=m
+CONFIG_APANIC=y
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Motorola TS 27.010 Mux driver
+#
+CONFIG_MOT_FEAT_TS27010MUX=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# Motorola netmux driver
+#
+CONFIG_NETMUX_DRIVER=m
+CONFIG_MOT_NETMUX_LINKDRIVER=m
+
+#
+# Motorola sec driver
+#
+CONFIG_SEC_DRIVER=m
+
+#
+# Motorola Modem PM Driver
+#
+CONFIG_MODEM_PM_DRIVER=m
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+CONFIG_SMC911X=y
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_OMAP is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC210X is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_TOUCHSCREEN_QUANTUM_OBP=y
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_PROXIMITY_SFH7743=y
+CONFIG_INPUT_HALLEFFECT_BU52014HV=y
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_GPIODEV=y
+CONFIG_GPIODEV_DEVICE_TREE=y
+
+CONFIG_GPIO_MAPPING=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_OMAP=y
+CONFIG_SERIAL_OMAP_CONSOLE=y
+# CONFIG_SERIAL_OMAP_DMA_UART1 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART2 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART3 is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_OMAP=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_OMAP24XX=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_TSC210X is not set
+# CONFIG_SPI_TSC2301 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+CONFIG_W1=y
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+# CONFIG_W1_MASTER_DS1WM is not set
+# CONFIG_W1_MASTER_GPIO is not set
+CONFIG_HDQ_MASTER_OMAP=y
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+CONFIG_W1_SLAVE_DS2502=y
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_CHARGER_CPCAP=y
+CONFIG_BATTERY_CPCAP=y
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG_AUTOPET=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+CONFIG_MFD_CPCAP=y
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_SG=y
+CONFIG_VIDEO_OMAP_VIDEOOUT=y
+CONFIG_VIDEO_OMAP_VIDEOOUT_BUFPOOL=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_OMAP3_HP3A=y
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_TCM825X is not set
+#CONFIG_VIDEO_MT9P012 is not set
+CONFIG_VIDEO_OMAP3_HPLENS=y
+CONFIG_VIDEO_OV8810=y
+CONFIG_VIDEO_MIPI_INTERFACE=y
+# CONFIG_VIDEO_IMX046 is not set
+# CONFIG_VIDEO_LV8093 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_VIDEO_OMAP3 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_VIDEO_OLDOMAP3=y
+CONFIG_VIDEO_OLDOMAP34XX_ISP_PREVIEWER=y
+CONFIG_VIDEO_OLDOMAP34XX_ISP_RESIZER=y
+CONFIG_VIDEO_OLDOMAP3_BUFFALLOC=y
+# CONFIG_V4L_USB_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+CONFIG_SGX=y
+CONFIG_SGX_BUILD_RELEASE=y
+# CONFIG_SGX_BUILD_DEBUG is not set
+CONFIG_SGX_RELEASE_LOGGING=y
+# CONFIG_SGX_EDM_TRACING is not set
+CONFIG_SGX_MK_TRACE=y
+CONFIG_PVR_OMAPLFB=y
+CONFIG_PVR_OMAP_DSS2=y
+# CONFIG_PVR_OMAP_USE_VSYNC is not set
+CONFIG_PVR_APM=y
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_FB_OMAP_BOOTLOADER_INIT=y
+CONFIG_OMAP2_DSS=y
+CONFIG_OMAP2_DSS_VRAM_SIZE=5
+CONFIG_OMAP2_DSS_DEBUG_SUPPORT=y
+# CONFIG_OMAP2_DSS_RFBI is not set
+# CONFIG_OMAP2_DSS_VENC is not set
+# CONFIG_OMAP2_DSS_SDI is not set
+CONFIG_OMAP2_DSS_DSI=y
+CONFIG_OMAP2_DSS_USE_DSI_PLL=y
+# CONFIG_OMAP2_DSS_FAKE_VSYNC is not set
+CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK=0
+
+#
+# OMAP2/3 Display Device Drivers
+#
+# CONFIG_PANEL_GENERIC is not set
+# CONFIG_PANEL_SAMSUNG_LTE430WQ_F0C is not set
+# CONFIG_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_PANEL_N800 is not set
+# CONFIG_PANEL_ZOOM2 is not set
+# CONFIG_CTRL_BLIZZARD is not set
+CONFIG_CTRL_EDISCO=y
+CONFIG_PANEL_SHOLES=y
+CONFIG_FB_OMAP2=y
+CONFIG_FB_OMAP2_DEBUG_SUPPORT=y
+# CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE is not set
+CONFIG_FB_OMAP2_NUM_FBS=1
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+# CONFIG_SND is not set
+CONFIG_SOUND_PRIME=y
+CONFIG_SOUND_CPCAP_OMAP=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_GREENASIA_FF is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+CONFIG_EHCI_SKIP_SYS_RESUME=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_OMAP_EHCI_PHY_MODE is not set
+CONFIG_OMAP_EHCI_TLL_MODE=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SOC=y
+
+#
+# OMAP 343x high speed USB support
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_PERIPHERAL is not set
+CONFIG_USB_MUSB_OTG=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_MUSB_HDRC_HCD=y
+# CONFIG_MUSB_PIO_ONLY is not set
+CONFIG_USB_INVENTRA_DMA=y
+# CONFIG_USB_TI_CPPI_DMA is not set
+# CONFIG_USB_MUSB_DEBUG is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+CONFIG_USB_SERIAL_MOTOROLA=y
+CONFIG_USB_QSC6085_CDMA_MODEM=y
+# CONFIG_EMU_UART_DEBUG is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+CONFIG_USB_SERIAL_MOTO_CDMA_FLASH=y
+
+#
+# USB Miscellaneous drivers
+#
+
+CONFIG_USB_IPC=y
+CONFIG_USB_IPC_TEST=y
+CONFIG_USB_PANIC_ENUMERATION=y
+
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MOT_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_ISP1301_OMAP is not set
+CONFIG_CPCAP_USB=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_TST=y
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_OMAP_HS_MMC2=y
+# CONFIG_OMAP_HS_MMC3 is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_OMAP_DEBUG is not set
+# CONFIG_LEDS_OMAP is not set
+# CONFIG_LEDS_OMAP_PWM is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_PCA955X is not set
+CONFIG_LEDS_SHOLES=y
+CONFIG_LEDS_LM3530=y
+#CONFIG_LEDS_LM3554 is not set
+CONFIG_LEDS_BD7885=y
+CONFIG_LEDS_BU9847=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_CPCAP=y
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+CONFIG_REGULATOR_CPCAP=y
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_MEILHAUS is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_INPUT_MIMIO is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+
+#
+# CBUS support
+#
+# CONFIG_CBUS is not set
+CONFIG_MPU_BRIDGE=y
+CONFIG_BRIDGE_DVFS=y
+CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
+# CONFIG_BRIDGE_DEBUG is not set
+
+#
+# File systems
+#
+# CONFIG_CORE_DUMP_PERMISSION is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_OMAP_PHONE_ID=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_DOES_TAGS_ECC=y
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_VM=y
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+
+#
+# Motorola Features
+#
+CONFIG_UMTS_SYSPANIC=y
+#
+# End of Motorola Features
+#
+
+# LTT-LITE
+# CONFIG_LTT_LITE is not set
diff --git a/arch/arm/configs/sholes_defconfig b/arch/arm/configs/sholes_defconfig
index c3849c1..ea1f155 100644
--- a/arch/arm/configs/sholes_defconfig
+++ b/arch/arm/configs/sholes_defconfig
@@ -1,7 +1,8 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.29-omap1
-# Mon Jan 11 12:29:41 2010
+# Tue Oct 20 13:15:45 2009
+# Fri Oct 23 20:03:54 2009
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -266,7 +267,6 @@ CONFIG_ARM_THUMB=y
 # CONFIG_CPU_BPREDICT_DISABLE is not set
 # CONFIG_HAS_TLS_REG is not set
 # CONFIG_OUTER_CACHE is not set
-CONFIG_ARM_L1_CACHE_SHIFT=6
 
 #
 # errata
@@ -371,12 +371,10 @@ CONFIG_BINFMT_MISC=y
 # Power management options
 #
 CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
 CONFIG_PM_DEBUG=y
-# CONFIG_PM_VERBOSE is not set
-CONFIG_CAN_PM_TRACE=y
 CONFIG_PM_SLEEP=y
 CONFIG_SUSPEND=y
-# CONFIG_PM_TEST_SUSPEND is not set
 CONFIG_SUSPEND_FREEZER=y
 CONFIG_HAS_WAKELOCK=y
 CONFIG_HAS_EARLYSUSPEND=y
@@ -534,7 +532,8 @@ CONFIG_RFKILL_PM=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
@@ -1139,7 +1138,7 @@ CONFIG_SGX_BUILD_RELEASE=y
 # CONFIG_SGX_BUILD_DEBUG is not set
 CONFIG_SGX_RELEASE_LOGGING=y
 CONFIG_SGX_EDM_TRACING=y
-CONFIG_SGX_MK_TRACE=y
+CONFIG_CONFIG_SGX_MK_TRACE=y
 CONFIG_PVR_OMAPLFB=y
 CONFIG_PVR_OMAP_DSS2=y
 # CONFIG_PVR_OMAP_USE_VSYNC is not set
@@ -1684,7 +1683,6 @@ CONFIG_YAFFS_AUTO_YAFFS2=y
 # CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
 # CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
 CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
-# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
 # CONFIG_JFFS2_FS is not set
 # CONFIG_CRAMFS is not set
 # CONFIG_SQUASHFS is not set
diff --git a/arch/arm/configs/sholest_cu_defconfig b/arch/arm/configs/sholest_cu_defconfig
new file mode 100644
index 0000000..0235c14
--- /dev/null
+++ b/arch/arm/configs/sholest_cu_defconfig
@@ -0,0 +1,2172 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.29-omap1
+# Tue Oct 20 13:15:45 2009
+# Fri Oct 23 20:03:54 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_ARM_OF=y
+CONFIG_OF=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_BOOTINFO=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_USER_SCHED is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+# CONFIG_CGROUP_NS is not set
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ASHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_OMAP=y
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_W90X900 is not set
+
+#
+# TI OMAP Implementations
+#
+CONFIG_ARCH_OMAP_OTG=y
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_OMAP2 is not set
+CONFIG_ARCH_OMAP3=y
+
+#
+# OMAP Feature Selections
+#
+# CONFIG_ARCH_OMAP3_GP is not set
+CONFIG_ARCH_OMAP3_HS=y
+# CONFIG_OMAP_DEBUG_POWERDOMAIN is not set
+# CONFIG_OMAP_DEBUG_CLOCKDOMAIN is not set
+CONFIG_OMAP_SMARTREFLEX=y
+# CONFIG_OMAP_SMARTREFLEX_TESTING is not set
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_BOOT_TAG=y
+CONFIG_OMAP_BOOT_REASON=y
+# CONFIG_OMAP_COMPONENT_VERSION is not set
+# CONFIG_OMAP_GPIO_SWITCH is not set
+# CONFIG_OMAP_MUX is not set
+# CONFIG_OMAP_MUX_DEBUG is not set
+# CONFIG_OMAP_MUX_WARNINGS is not set
+CONFIG_OMAP_MCBSP=y
+CONFIG_MEM_DUMP=y
+# CONFIG_OMAP_MBOX_FWK is not set
+# CONFIG_OMAP_IOMMU is not set
+# CONFIG_OMAP_MPU_TIMER is not set
+CONFIG_OMAP_32K_TIMER=y
+# CONFIG_OMAP3_DEBOBS is not set
+CONFIG_OMAP_32K_TIMER_HZ=128
+CONFIG_OMAP_TICK_GPTIMER=1
+CONFIG_OMAP_DM_TIMER=y
+# CONFIG_OMAP_LL_DEBUG_UART1 is not set
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+CONFIG_OMAP_LL_DEBUG_UART3=y
+# CONFIG_OMAP_LL_DEBUG_UART_EXT is not set
+CONFIG_OMAP_SERIAL_WAKE=y
+# CONFIG_OMAP_PM_NONE is not set
+# CONFIG_OMAP_PM_NOOP is not set
+CONFIG_OMAP_PM_SRF=y
+CONFIG_ARCH_OMAP34XX=y
+CONFIG_ARCH_OMAP3430=y
+
+#
+# OMAP Board Type
+#
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP_ZOOM2 is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_TIWLAN_SDIO is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_SHOLES is not set
+CONFIG_MACH_MAPPHONE=y
+CONFIG_MACH_SHOLEST=y
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_HAS_TLS_REG is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# errata
+#
+CONFIG_ARM_ERRATA_430973=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=128
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_LEDS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=192.168.0.1:/home/user/buildroot ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.255.0:tgt:eth0:off rw console=ttyS2,115200n8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_MIN_TICKS=2
+CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=500
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_VERBOSE is not set
+# CONFIG_CAN_PM_TRACE is not set
+CONFIG_PM_DEBUG=y
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+# CONFIG_WAKELOCK_STAT is not set
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_QUICK_WAKEUP=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_COMPAT_NET_DEV_OPS=y
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_SUB_POLICY is not set
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CT_ACCT=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+CONFIG_NETFILTER_XT_TARGET_RATEEST=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_DCCP=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_OWNER=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_RATEEST=y
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+CONFIG_NETFILTER_XT_MATCH_RECENT_PROC_COMPAT=y
+CONFIG_NETFILTER_XT_MATCH_SCTP=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_ADDRTYPE=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_IDLETIMER=y
+CONFIG_NF_NAT_SNMP_BASIC=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_ARP_MANGLE is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+CONFIG_NET_CLS_ROUTE=y
+# CONFIG_DCB is not set
+
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+CONFIG_BT_HCIUART_LL=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIBRF6150 is not set
+# CONFIG_BT_HCIH4P is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_OF_DEVICE=y
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_OMAP_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_OMAP2=y
+CONFIG_MTD_NAND_OMAP_HWECC=y
+CONFIG_MTD_NAND_OMAP_PREFETCH=y
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+# CONFIG_ICS932S401 is not set
+CONFIG_OMAP_MODEM_CONTROL=y
+# CONFIG_OMAP_STI is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+# CONFIG_UID_STAT is not set
+# CONFIG_VIB_OMAP_PWM is not set
+CONFIG_VIB_GPIO=y
+# CONFIG_SENSORS_AKM8973 is not set
+CONFIG_SENSORS_AKM8973_AKMD=y
+CONFIG_SENSORS_LIS331DLH=y
+CONFIG_WL127X_RFKILL=y
+CONFIG_WL127X_TEST=m
+CONFIG_APANIC=y
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Motorola TS 27.010 Mux driver
+#
+CONFIG_MOT_FEAT_TS27010MUX=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# Motorola netmux driver
+#
+CONFIG_NETMUX_DRIVER=m
+CONFIG_MOT_NETMUX_LINKDRIVER=m
+
+#
+# Motorola sec driver
+#
+CONFIG_SEC_DRIVER=m
+
+#
+# Motorola Modem PM Driver
+#
+CONFIG_MODEM_PM_DRIVER=m
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+CONFIG_SMC911X=y
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+CONFIG_INPUT_KEYRESET=y
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_OMAP is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC210X is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_TOUCHSCREEN_QUANTUM_OBP=y
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_INPUT_PROXIMITY_SFH7743=y
+# CONFIG_INPUT_HALLEFFECT_BU52014HV is not set
+CONFIG_DISABLE_IRQ_WAKE_KPD=y
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_GPIODEV=y
+CONFIG_GPIODEV_DEVICE_TREE=y
+
+CONFIG_GPIO_MAPPING=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_OMAP=y
+CONFIG_SERIAL_OMAP_CONSOLE=y
+# CONFIG_SERIAL_OMAP_DMA_UART1 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART2 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART3 is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_OMAP=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_OMAP24XX=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_TSC210X is not set
+# CONFIG_SPI_TSC2301 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+CONFIG_W1=y
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+# CONFIG_W1_MASTER_DS1WM is not set
+# CONFIG_W1_MASTER_GPIO is not set
+CONFIG_HDQ_MASTER_OMAP=y
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+CONFIG_W1_SLAVE_DS2502=y
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_CHARGER_CPCAP=y
+CONFIG_BATTERY_CPCAP=y
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG_AUTOPET=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+CONFIG_MFD_CPCAP=y
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_SG=y
+CONFIG_VIDEO_OMAP_VIDEOOUT=y
+CONFIG_VIDEO_OMAP_VIDEOOUT_BUFPOOL=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_OMAP3_HP3A=y
+# CONFIG_VIDEO_OMAP_MOT_VIDEOOUT is not set
+# CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL is not set
+# CONFIG_PANEL_HDTV is not set
+# CONFIG_HDMI_TDA19989 is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_TCM825X is not set
+#CONFIG_VIDEO_MT9P012 is not set
+CONFIG_VIDEO_OMAP3_HPLENS=y
+CONFIG_VIDEO_OV8810=y
+CONFIG_VIDEO_MIPI_INTERFACE=y
+# CONFIG_VIDEO_IMX046 is not set
+# CONFIG_VIDEO_LV8093 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_VIDEO_OMAP3 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_VIDEO_OLDOMAP3=y
+CONFIG_VIDEO_OLDOMAP34XX_ISP_PREVIEWER=y
+CONFIG_VIDEO_OLDOMAP34XX_ISP_RESIZER=y
+CONFIG_VIDEO_OLDOMAP3_BUFFALLOC=y
+# CONFIG_V4L_USB_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+CONFIG_SGX=y
+CONFIG_SGX_BUILD_RELEASE=y
+# CONFIG_SGX_BUILD_DEBUG is not set
+CONFIG_SGX_RELEASE_LOGGING=y
+# CONFIG_SGX_EDM_TRACING is not set
+CONFIG_SGX_MK_TRACE=y
+CONFIG_PVR_OMAPLFB=y
+CONFIG_PVR_OMAP_DSS2=y
+# CONFIG_PVR_OMAP_USE_VSYNC is not set
+CONFIG_PVR_APM=y
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=m
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_FB_OMAP_BOOTLOADER_INIT=y
+CONFIG_OMAP2_DSS=y
+CONFIG_OMAP2_DSS_VRAM_SIZE=5
+CONFIG_OMAP2_DSS_DEBUG_SUPPORT=y
+# CONFIG_OMAP2_DSS_RFBI is not set
+# CONFIG_OMAP2_DSS_VENC is not set
+# CONFIG_OMAP2_DSS_SDI is not set
+CONFIG_OMAP2_DSS_DSI=y
+CONFIG_OMAP2_DSS_USE_DSI_PLL=y
+# CONFIG_OMAP2_DSS_FAKE_VSYNC is not set
+CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK=0
+
+#
+# OMAP2/3 Display Device Drivers
+#
+# CONFIG_PANEL_GENERIC is not set
+# CONFIG_PANEL_SAMSUNG_LTE430WQ_F0C is not set
+# CONFIG_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_PANEL_N800 is not set
+# CONFIG_PANEL_ZOOM2 is not set
+# CONFIG_CTRL_BLIZZARD is not set
+CONFIG_CTRL_EDISCO=y
+CONFIG_PANEL_SHOLES=y
+CONFIG_FB_OMAP2=y
+CONFIG_FB_OMAP2_DEBUG_SUPPORT=y
+# CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE is not set
+CONFIG_FB_OMAP2_NUM_FBS=1
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+# CONFIG_SND is not set
+CONFIG_SOUND_PRIME=y
+CONFIG_SOUND_CPCAP_OMAP=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_GREENASIA_FF is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+CONFIG_EHCI_SKIP_SYS_RESUME=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_OMAP_EHCI_PHY_MODE is not set
+CONFIG_OMAP_EHCI_TLL_MODE=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SOC=y
+
+#
+# OMAP 343x high speed USB support
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_PERIPHERAL is not set
+CONFIG_USB_MUSB_OTG=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_MUSB_HDRC_HCD=y
+# CONFIG_MUSB_PIO_ONLY is not set
+CONFIG_USB_INVENTRA_DMA=y
+# CONFIG_USB_TI_CPPI_DMA is not set
+# CONFIG_USB_MUSB_DEBUG is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+CONFIG_USB_SERIAL_MOTOROLA=y
+CONFIG_USB_QSC6085_CDMA_MODEM=y
+# CONFIG_EMU_UART_DEBUG is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+CONFIG_USB_SERIAL_MOTO_CDMA_FLASH=y
+
+#
+# USB Miscellaneous drivers
+#
+
+CONFIG_USB_IPC=y
+CONFIG_USB_IPC_TEST=y
+CONFIG_USB_PANIC_ENUMERATION=y
+
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MOT_ANDROID=y
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_ISP1301_OMAP is not set
+CONFIG_CPCAP_USB=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+CONFIG_MMC_PARANOID_SD_INIT=y
+CONFIG_MMC_TST=y
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_OMAP_HS=y
+CONFIG_OMAP_HS_MMC2=y
+# CONFIG_OMAP_HS_MMC3 is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_OMAP_DEBUG is not set
+# CONFIG_LEDS_OMAP is not set
+# CONFIG_LEDS_OMAP_PWM is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_PCA955X is not set
+CONFIG_LEDS_SHOLES=y
+CONFIG_LEDS_SHOLEST=y
+CONFIG_LEDS_LM3530=y
+#CONFIG_LEDS_LM3554 is not set
+CONFIG_LEDS_BD7885=y
+CONFIG_LEDS_BU9847=y
+CONFIG_LEDS_AF_LED=y
+CONFIG_LEDS_FLASH_RESET=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+CONFIG_RTC_DRV_CPCAP=y
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+CONFIG_REGULATOR_CPCAP=y
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_MEILHAUS is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_ECHO is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_INPUT_MIMIO is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_RAM_CONSOLE=y
+CONFIG_ANDROID_RAM_CONSOLE_ENABLE_VERBOSE=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION=y
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
+CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+
+#
+# CBUS support
+#
+# CONFIG_CBUS is not set
+CONFIG_MPU_BRIDGE=y
+CONFIG_BRIDGE_DVFS=y
+CONFIG_BRIDGE_MEMPOOL_SIZE=0x600000
+# CONFIG_BRIDGE_DEBUG is not set
+
+#
+# File systems
+#
+# CONFIG_CORE_DUMP_PERMISSION is not set
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_OMAP_PHONE_ID=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_DOES_TAGS_ECC=y
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_VM=y
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_TRACE_BRANCH_PROFILING is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+
+#
+# Motorola Features
+#
+CONFIG_UMTS_SYSPANIC=y
+
+# support MDTV system
+# CONFIG_MOT_FEAT_MDTV is not set
+# support LP3907 regulator for TDMB block
+# CONFIG_MOT_FEAT_LP3907 is not set
+
+# SMS1130 SPI interface
+# CONFIG_MOT_FEAT_SPI_SMS1130 is not set
+#
+# Supported SMS1130(TDMB tuner)
+#
+# CONFIG_DVB_CORE is not set
+# CONFIG_SMS_SIANO_MDTV_TDMB is not set
+# CONFIG_SMS_HOSTLIB_SUBSYS is not set
+
+#
+# End of Motorola Features
+#
+
+# LTT-LITE
+# CONFIG_LTT_LITE is not set
diff --git a/arch/arm/include/asm/bootinfo.h b/arch/arm/include/asm/bootinfo.h
new file mode 100644
index 0000000..4565555
--- /dev/null
+++ b/arch/arm/include/asm/bootinfo.h
@@ -0,0 +1,102 @@
+/*
+ * linux/include/asm/bootinfo.h:  Include file for boot information
+ *                                provided on Motorola phones
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Date         Author          Comment
+ * 01/07/2009   Motorola        Initial version
+ */
+
+#ifndef __ASMARM_BOOTINFO_H
+#define __ASMARM_BOOTINFO_H
+
+
+#if !defined(__KERNEL__) || defined(CONFIG_BOOTINFO)
+
+/*
+ * These #defines are used for the bits in powerup_reason.
+ */
+#define PU_REASON_USB_CABLE             0x00000010 /* Bit 4  */
+#define PU_REASON_FACTORY_CABLE         0x00000020 /* Bit 5  */
+#define PU_REASON_PWR_KEY_PRESS         0x00000080 /* Bit 7  */
+#define PU_REASON_CHARGER               0x00000100 /* Bit 8  */
+#define PU_REASON_POWER_CUT             0x00000200 /* bit 9  */
+#define PU_REASON_SW_AP_RESET           0x00004000 /* Bit 14 */
+#define PU_REASON_WDOG_AP_RESET         0x00008000 /* Bit 15 */
+#define PU_REASON_AP_KERNEL_PANIC       0x00020000 /* Bit 17 */
+
+
+/*
+ * These #defines are used for the battery status at boot.
+ * When no battery is present, the status is BATTERY_LO_VOLTAGE.
+ */
+#define BATTERY_GOOD_VOLTAGE    1
+#define BATTERY_LO_VOLTAGE      2
+#define BATTERY_UNKNOWN         (-1)
+
+/*
+ * /proc/bootinfo has a strict format.  Each line contains a name/value
+ * pair which are separated with a colon and a single space on both
+ * sides of the colon.  The following defines help you size the
+ * buffers used to read the data from /proc/bootinfo.
+ *
+ * BOOTINFO_MAX_NAME_LEN:  maximum size in bytes of a name in the
+ *                         bootinfo line.  Don't forget to add space
+ *                         for the NUL if you need it.
+ * BOOTINFO_MAX_VAL_LEN:   maximum size in bytes of a value in the
+ *                         bootinfo line.  Don't forget to add space
+ *                         for the NUL if you need it.
+ * BOOTINFO_BUF_SIZE:      size in bytes of buffer that is large enough
+ *                         to read a /proc/bootinfo line.  The extra
+ *                         3 is for the " : ".  Don't forget to add
+ *                         space for the NUL and newline if you
+ *                         need them.
+ */
+#define BOOTINFO_MAX_NAME_LEN    32
+#define BOOTINFO_MAX_VAL_LEN    128
+#define BOOTINFO_BUF_SIZE       (BOOTINFO_MAX_NAME_LEN + \
+					3 + BOOTINFO_MAX_VAL_LEN)
+
+#endif
+
+
+#if defined(__KERNEL__) && defined(CONFIG_BOOTINFO)
+
+extern struct proc_dir_entry proc_root;
+
+u32  bi_powerup_reason(void);
+void bi_set_powerup_reason(u32 powerup_reason);
+
+u32  bi_mbm_version(void);
+void bi_set_mbm_version(u32 mbm_version);
+
+u32  bi_mbm_loader_version(void);
+void bi_set_mbm_loader_version(u32 mbm_loader_version);
+
+u32  bi_flat_dev_tree_address(void);
+void bi_set_flat_dev_tree_address(u32 flat_dev_tree_address);
+
+u16  bi_battery_status_at_boot(void);
+void bi_set_battery_status_at_boot(u16 battery_status_at_boot);
+
+u8  bi_cid_recover_boot(void);
+void bi_set_cid_recover_boot(u8 cid_recover_boot);
+
+#endif /* defined(__KERNEL__) && defined(CONFIG_BOOTINFO) */
+
+#endif
diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h
index 8196abf..d2cd874 100644
--- a/arch/arm/include/asm/elf.h
+++ b/arch/arm/include/asm/elf.h
@@ -50,6 +50,7 @@ typedef struct user_fp elf_fpregset_t;
 #define R_ARM_ABS32		2
 #define R_ARM_CALL		28
 #define R_ARM_JUMP24		29
+#define R_ARM_TARGET1		38
 #define R_ARM_V4BX		40
 #define R_ARM_PREL31		42
 #define R_ARM_MOVW_ABS_NC	43
diff --git a/arch/arm/include/asm/mach/serial_omap.h b/arch/arm/include/asm/mach/serial_omap.h
index fac969f..e512d9e 100644
--- a/arch/arm/include/asm/mach/serial_omap.h
+++ b/arch/arm/include/asm/mach/serial_omap.h
@@ -2,6 +2,7 @@
  *  arch/arm/include/mach/serial_omap.h
  *
  *  Copyright (C) 2009 San Mehat
+ *  Copyright (C) 2009 Motorola, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,6 +15,11 @@
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
 
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+#define SERIALOMAP_AUTO_RTS 0x01
+#define SERIALOMAP_AUTO_CTS 0x02
+#endif
+
 /*
  * This is the platform device platform_data structure
  */
@@ -25,6 +31,9 @@ struct plat_serialomap_port {
 	void __iomem	*membase;
 	unsigned char	regshift;
 	int		irq;
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+	unsigned char   rtscts;     /* bit0: rts, bit1: cts */
+#endif
 	int		wake_gpio_strobe;
 };
 
diff --git a/arch/arm/include/asm/prom.h b/arch/arm/include/asm/prom.h
new file mode 100644
index 0000000..5949d7d
--- /dev/null
+++ b/arch/arm/include/asm/prom.h
@@ -0,0 +1,142 @@
+#ifndef _ARM_PROM_H
+#define _ARM_PROM_H
+#ifdef __KERNEL__
+
+/*
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ * Updates for PPC64 by Peter Bergner & David Engebretsen, IBM Corp.
+ *
+ * Updates for ARM by Motorola Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+
+#define OF_ROOT_NODE_ADDR_CELLS_DEFAULT	1
+#define OF_ROOT_NODE_SIZE_CELLS_DEFAULT	1
+
+#define of_compat_cmp(s1, s2, l)	strcasecmp((s1), (s2))
+#define of_prop_cmp(s1, s2)		strcmp((s1), (s2))
+#define of_node_cmp(s1, s2)		strcasecmp((s1), (s2))
+
+/* Definitions used by the flattened device tree */
+#define OF_DT_HEADER		0xd00dfeed	/* marker */
+#define OF_DT_BEGIN_NODE	0x1		/* Start of node, full name */
+#define OF_DT_END_NODE		0x2		/* End node */
+#define OF_DT_PROP		0x3		/* Property: name off, size,
+						 * content */
+#define OF_DT_NOP		0x4		/* nop */
+#define OF_DT_END		0x9
+
+#define OF_DT_VERSION		0x10
+
+/*
+ * This is what gets passed to the kernel by prom_init or kexec
+ *
+ * The dt struct contains the device tree structure, full pathes and
+ * property contents. The dt strings contain a separate block with just
+ * the strings for the property names, and is fully page aligned and
+ * self contained in a page, so that it can be kept around by the kernel,
+ * each property name appears only once in this page (cheap compression)
+ *
+ * the mem_rsvmap contains a map of reserved ranges of physical memory,
+ * passing it here instead of in the device-tree itself greatly simplifies
+ * the job of everybody. It's just a list of u64 pairs (base/size) that
+ * ends when size is 0
+ */
+struct boot_param_header {
+	u32	magic;			/* magic word OF_DT_HEADER */
+	u32	totalsize;		/* total size of DT block */
+	u32	off_dt_struct;		/* offset to structure */
+	u32	off_dt_strings;		/* offset to strings */
+	u32	off_mem_rsvmap;		/* offset to memory reserve map */
+	u32	version;		/* format version */
+	u32	last_comp_version;	/* last compatible version */
+	/* version 2 fields below */
+	u32	boot_cpuid_phys;	/* Physical CPU id we're booting on */
+	/* version 3 fields below */
+	u32	dt_strings_size;	/* size of the DT strings block */
+	/* version 17 fields below */
+	u32	dt_struct_size;		/* size of the DT structure block */
+};
+
+
+
+typedef u32 phandle;
+typedef u32 ihandle;
+
+struct property {
+	char	*name;
+	int	length;
+	void	*value;
+	struct property *next;
+};
+
+struct device_node {
+	const char *name;
+	const char *type;
+	phandle	node;
+	phandle linux_phandle;
+	char	*full_name;
+
+	struct	property *properties;
+	struct  property *deadprops; /* removed properties */
+	struct	device_node *parent;
+	struct	device_node *child;
+	struct	device_node *sibling;
+	struct	device_node *next;	/* next device of same type */
+	struct	device_node *allnext;	/* next in list of all nodes */
+	struct  proc_dir_entry *pde;	/* this node's proc directory */
+	struct  kref kref;
+	unsigned long _flags;
+	void	*data;
+};
+
+extern struct device_node *of_chosen;
+
+static inline int of_node_check_flag(struct device_node *n, unsigned long flag)
+{
+	return test_bit(flag, &n->_flags);
+}
+
+static inline void of_node_set_flag(struct device_node *n, unsigned long flag)
+{
+	set_bit(flag, &n->_flags);
+}
+
+
+#define HAVE_ARCH_DEVTREE_FIXUPS
+
+static inline void set_node_proc_entry(struct device_node *dn,
+					struct proc_dir_entry *de)
+{
+	dn->pde = de;
+}
+
+extern struct device_node *of_node_get(struct device_node *node);
+extern void of_node_put(struct device_node *node);
+
+/* Other Prototypes */
+extern void unflatten_device_tree(void);
+
+/*
+ * NB:  This is here while we transition from using asm/prom.h
+ * to linux/of.h
+ */
+#include <linux/of.h>
+
+/* align addr on a size boundary - adjust address up/down if needed */
+#define _ALIGN_UP(addr, size)	(((addr) + ((size) - 1)) & (~((size) - 1)))
+#define _ALIGN_DOWN(addr, size)	((addr) & (~((size) - 1)))
+
+/* align addr on a size boundary - adjust address up if needed */
+#define _ALIGN(addr, size)     _ALIGN_UP(addr, size)
+
+#endif /* __KERNEL__ */
+#endif /* _ARM_PROM_H */
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index 7ffbb29..10c1a44 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -2,6 +2,10 @@
  *  linux/include/asm/setup.h
  *
  *  Copyright (C) 1997-1999 Russell King
+ *  Copyright (C) 2006-2009 Motorola, Inc.
+ *    
+ * Date         Author          Comment
+ * 06/2009      Motorola        Added Motorola specific ATAGs support.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +22,12 @@
 
 #define COMMAND_LINE_SIZE 1024
 
+#if defined(CONFIG_MACH_MAPPHONE) || defined(CONFIG_MOT_FEAT_DEVICE_TREE)
+/* Magic number at the beginning of the serialized device tree. */
+#define FLATTREE_BEGIN_SERIALIZED           0xD00DFEED
+#define FLATTREE_BEGIN_SERIALIZED_OTHEREND  0xEDFE0DD0
+#endif
+
 /* The list ends with an ATAG_NONE node. */
 #define ATAG_NONE	0x00000000
 
@@ -150,6 +160,54 @@ struct tag_memclk {
 	__u32 fmemclk;
 };
 
+#if defined(CONFIG_MACH_MAPPHONE) || defined(CONFIG_BOOTINFO)
+/* Powerup Reason */
+#define ATAG_POWERUP_REASON 0xf1000401
+
+struct tag_powerup_reason {
+	u32 powerup_reason;
+};
+
+/* MBM version */
+#define ATAG_MBM_VERSION 0xf1000407
+struct tag_mbm_version {
+	u32 mbm_version;
+};
+
+/* MBM loader version */
+#define ATAG_MBM_LOADER_VERSION 0xf1000408
+struct tag_mbm_loader_version {
+	u32 mbm_loader_version;
+};
+
+/* Flat dev tree address */
+#define ATAG_FLAT_DEV_TREE_ADDRESS 0xf100040A
+struct tag_flat_dev_tree_address {
+	u32 address;
+	u32 size;
+};
+
+/* Battery status at boot */
+#define ATAG_BATTERY_STATUS_AT_BOOT 0xf100040E
+struct tag_battery_status_at_boot {
+	u16 battery_status_at_boot;
+	u16 padding; /* each atag must be at least 4 bytes */
+};
+
+/* CID recover boot */
+#define ATAG_CID_RECOVER_BOOT 0xf1000414
+struct tag_cid_recover_boot {
+	u8 cid_recover_boot;
+};
+#else
+/* Flat dev tree address */
+#define ATAG_FLAT_DEV_TREE_ADDRESS 0xf100040A
+struct tag_flat_dev_tree_address {
+	u32 address;
+	u32 size;
+};
+#endif /* CONFIG_BOOTINFO */
+
 struct tag {
 	struct tag_header hdr;
 	union {
@@ -177,6 +235,19 @@ struct tag {
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
+#if defined(CONFIG_MACH_MAPPHONE) || defined(CONFIG_BOOTINFO)
+		/*
+		 * Motorola specific ATAGs
+		 */
+		struct tag_powerup_reason powerup_reason;
+		struct tag_mbm_version mbm_version;
+                struct tag_mbm_loader_version mbm_loader_version;
+		struct tag_flat_dev_tree_address flat_dev_tree;
+                struct tag_battery_status_at_boot battery_status_at_boot;
+				struct tag_cid_recover_boot cid_recover_boot;
+#else
+		struct tag_flat_dev_tree_address flat_dev_tree_address;
+#endif /* CONFIG_BOOTINFO */
 	} u;
 };
 
diff --git a/arch/arm/include/asm/unistd.h b/arch/arm/include/asm/unistd.h
index 0106184..e3925ac 100644
--- a/arch/arm/include/asm/unistd.h
+++ b/arch/arm/include/asm/unistd.h
@@ -387,6 +387,9 @@
 #define __NR_dup3			(__NR_SYSCALL_BASE+358)
 #define __NR_pipe2			(__NR_SYSCALL_BASE+359)
 #define __NR_inotify_init1		(__NR_SYSCALL_BASE+360)
+#ifdef CONFIG_LTT_LITE
+#define __NR_lttlite		(__NR_SYSCALL_BASE+361)
+#endif
 
 /*
  * The following SWIs are ARM private.
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 4305345..c4d079b 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -29,6 +29,8 @@ obj-$(CONFIG_ATAGS_PROC)	+= atags.o
 obj-$(CONFIG_OABI_COMPAT)	+= sys_oabi-compat.o
 obj-$(CONFIG_ARM_THUMBEE)	+= thumbee.o
 obj-$(CONFIG_KGDB)		+= kgdb.o
+obj-$(CONFIG_ARM_OF)		+= prom.o
+obj-$(CONFIG_BOOTINFO)		+= bootinfo.o
 
 obj-$(CONFIG_CRUNCH)		+= crunch.o crunch-bits.o
 AFLAGS_crunch-bits.o		:= -Wa,-mcpu=ep9312
diff --git a/arch/arm/kernel/bootinfo.c b/arch/arm/kernel/bootinfo.c
new file mode 100644
index 0000000..7c261c9
--- /dev/null
+++ b/arch/arm/kernel/bootinfo.c
@@ -0,0 +1,271 @@
+/*
+ * bootinfo.c: This file contains the bootinfo code.  This code
+ *	  provides boot information via /proc/bootinfo.  The
+ *	  information currently includes:
+ *            the powerup reason
+ *        This file also provides EZX compatible interfaces for
+ *	  retrieving the powerup reason.  All new user-space consumers
+ *	  of the powerup reason should use the /proc/bootinfo
+ *	  interface and all kernel-space consumers of the powerup
+ *	  reason should use the bi_powerup_reason interface.  The EZX
+ *	  compatibility code is deprecated.
+ *
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Revision History:
+ *
+ * Date         Author    Comment
+ * ----------   --------  -----------
+ * 30/06/2009   Motorola  Initialize version
+ */
+
+
+#ifdef CONFIG_BOOTINFO
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+#include <asm/setup.h>
+#include <asm/bootinfo.h>
+
+/*
+ * EMIT_BOOTINFO and EMIT_BOOTINFO_STR are used to emit the bootinfo
+ * information for data provided via ATAGs.
+ *
+ * The format for all bootinfo lines is "name : val" and these macros
+ * enforce that format.
+ *
+ * strname is the name printed in the name/val pair.
+ * name is the name of the function to call
+ *
+ * EMIT_BOOTINFO and EMIT_BOOTINFO_STR depend on buf and len to already
+ * be defined.
+ */
+#define EMIT_BOOTINFO(strname, fmt, name) \
+		do { \
+			len += sprintf(buf+len, strname " : " fmt "\n", \
+					bi_##name()); \
+		} while (0)
+
+#define EMIT_BOOTINFO_STR(strname, name) \
+		do { \
+			unsigned char *ptr; \
+			ptr = (unsigned char *)bi_##name(); \
+			if (strlen(ptr) == 0) { \
+				len += sprintf(buf+len, strname \
+							" : UNKNOWN\n"); \
+			} else { \
+				len += sprintf(buf+len, strname \
+							" : %s\n", ptr); \
+			} \
+		} while (0)
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * powerup_reason contains the powerup reason provided by the ATAGs when
+ * the machine boots.
+ *
+ * Exported symbols:
+ * bi_powerup_reason()             -- returns the powerup reason
+ * bi_set_powerup_reason()         -- sets the powerup reason
+ */
+static u32 powerup_reason;
+u32 bi_powerup_reason(void)
+{
+	return powerup_reason;
+}
+EXPORT_SYMBOL(bi_powerup_reason);
+
+void bi_set_powerup_reason(u32 __powerup_reason)
+{
+	powerup_reason = __powerup_reason;
+}
+EXPORT_SYMBOL(bi_set_powerup_reason);
+
+#define EMIT_POWERUPREASON() \
+	    EMIT_BOOTINFO("POWERUPREASON", "0x%08x", powerup_reason)
+
+
+/*
+ * mbm_version contains the MBM version.
+ * mbm_loader_version contains the MBM loader version.
+ * mbm_version and mbm_loader_version default to 0 if they are
+ * not set.
+ *
+ * Exported symbols:
+ * bi_mbm_version()                -- returns the MBM version
+ * bi_set_mbm_version()            -- sets the MBM version
+ * bi_mbm_loader_version()         -- returns the MBM loader version
+ * bi_set_mbm_loader_version()     -- sets the MBM loader version
+ */
+static u32 mbm_version;
+u32 bi_mbm_version(void)
+{
+	return mbm_version;
+}
+EXPORT_SYMBOL(bi_mbm_version);
+
+void bi_set_mbm_version(u32 __mbm_version)
+{
+	mbm_version = __mbm_version;
+}
+EXPORT_SYMBOL(bi_set_mbm_version);
+
+static u32 mbm_loader_version;
+u32 bi_mbm_loader_version(void)
+{
+	return mbm_loader_version;
+}
+EXPORT_SYMBOL(bi_mbm_loader_version);
+
+void bi_set_mbm_loader_version(u32 __mbm_loader_version)
+{
+	mbm_loader_version = __mbm_loader_version;
+}
+EXPORT_SYMBOL(bi_set_mbm_loader_version);
+
+#define EMIT_MBM_VERSION() \
+	    EMIT_BOOTINFO("MBM_VERSION", "0x%08x", mbm_version)
+#define EMIT_MBM_LOADER_VERSION() \
+	    EMIT_BOOTINFO("MBM_LOADER_VERSION", "0x%08x", mbm_loader_version)
+
+
+/*
+ * flat_dev_tree_address contains the Motorola flat dev tree address.
+ * flat_dev_tree_address defaults to -1 (0xffffffff) if it is not set.
+ *
+ * Exported symbols:
+ * bi_flat_dev_tree_address()      -- returns the flat dev tree address
+ * bi_set_flat_dev_tree_address()  -- sets the flat dev tree address
+ */
+static u32 flat_dev_tree_address = -1;
+u32 bi_flat_dev_tree_address(void)
+{
+	return flat_dev_tree_address;
+}
+EXPORT_SYMBOL(bi_flat_dev_tree_address);
+
+void bi_set_flat_dev_tree_address(u32 __flat_dev_tree_address)
+{
+	flat_dev_tree_address = __flat_dev_tree_address;
+}
+EXPORT_SYMBOL(bi_set_flat_dev_tree_address);
+
+#define EMIT_FLAT_DEV_TREE_ADDRESS() \
+		EMIT_BOOTINFO("FLAT_DEV_TREE_ADDRESS", "0x%08x", \
+					flat_dev_tree_address)
+
+
+/*
+ * battery_status_at_boot indicates the battery status
+ * when the machine started to boot.
+ * battery_status_at_boot defaults to -1 (0xffff) if the battery
+ * status can't be determined.
+ *
+ * Exported symbols:
+ * bi_battery_status_at_boot()         -- returns the battery boot status
+ * bi_set_battery_status_at_boot()     -- sets the battery boot status
+ */
+static u16 battery_status_at_boot = -1;
+u16 bi_battery_status_at_boot(void)
+{
+	return battery_status_at_boot;
+}
+EXPORT_SYMBOL(bi_battery_status_at_boot);
+
+void bi_set_battery_status_at_boot(u16 __battery_status_at_boot)
+{
+	battery_status_at_boot = __battery_status_at_boot;
+}
+EXPORT_SYMBOL(bi_set_battery_status_at_boot);
+
+#define EMIT_BATTERY_STATUS_AT_BOOT() \
+		EMIT_BOOTINFO("BATTERY_STATUS_AT_BOOT", "0x%04x", \
+					battery_status_at_boot)
+
+/*
+ * cid_recover_boot contains the flag to indicate whether phone should
+ * boot into recover mode or not.
+ * cid_recover_boot defaults to 0 if it is not set.
+ *
+ * Exported symbols:
+ * bi_cid_recover_boot()        -- returns the value of recover boot
+ * bi_set_cid_recover_boot()    -- sets the value of recover boot
+ */
+static u8 cid_recover_boot;
+u8 bi_cid_recover_boot(void)
+{
+	return cid_recover_boot;
+}
+EXPORT_SYMBOL(bi_cid_recover_boot);
+
+void bi_set_cid_recover_boot(u8 __cid_recover_boot)
+{
+	cid_recover_boot = __cid_recover_boot;
+}
+EXPORT_SYMBOL(bi_set_cid_recover_boot);
+
+
+#define EMIT_CID_RECOVER_BOOT() \
+		EMIT_BOOTINFO("CID_RECOVER_BOOT", "0x%02x", cid_recover_boot)
+/*
+ * get_bootinfo fills in the /proc/bootinfo information.
+ * We currently only have the powerup reason.
+ */
+static int get_bootinfo(char *buf, char **start,
+						off_t offset, int count,
+						int *eof, void *data)
+{
+	int len = 0;
+
+	EMIT_POWERUPREASON();
+	EMIT_MBM_VERSION();
+	EMIT_MBM_LOADER_VERSION();
+	EMIT_FLAT_DEV_TREE_ADDRESS();
+	EMIT_BATTERY_STATUS_AT_BOOT();
+	EMIT_CID_RECOVER_BOOT();
+
+	return len;
+}
+
+static struct proc_dir_entry *proc_bootinfo;
+
+int __init bootinfo_init_module(void)
+{
+	proc_bootinfo = &proc_root;
+	proc_bootinfo->owner = THIS_MODULE;
+	create_proc_read_entry("bootinfo", 0, NULL, get_bootinfo, NULL);
+	return 0;
+}
+
+void __exit bootinfo_cleanup_module(void)
+{
+    if (proc_bootinfo) {
+		remove_proc_entry("bootinfo", proc_bootinfo);
+		proc_bootinfo = NULL;
+	}
+}
+
+module_init(bootinfo_init_module);
+module_exit(bootinfo_cleanup_module);
+
+MODULE_AUTHOR("MOTOROLA");
+#endif /* CONFIG_BOOTINFO */
diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index 9ca8d13..e31c34e 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -370,6 +370,12 @@
 		CALL(sys_dup3)
 		CALL(sys_pipe2)
 /* 360 */	CALL(sys_inotify_init1)
+/* 361 */
+#ifdef CONFIG_LTT_LITE
+		CALL(sys_lttlite)
+#else
+		CALL(sys_ni_syscall)
+#endif
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 85040cf..d372cbb 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -83,6 +83,13 @@ __dabt_invalid:
 	b	common_invalid
 ENDPROC(__dabt_invalid)
 
+#ifdef CONFIG_NON_NESTED_FIQ
+__fiq_invalid:
+	inv_entry BAD_FIQ
+	b	common_invalid
+ENDPROC(__fiq_invalid)
+#endif
+
 __irq_invalid:
 	inv_entry BAD_IRQ
 	b	common_invalid
@@ -182,8 +189,22 @@ __dabt_svc:
 	@ set desired IRQ state, then call main handler
 	@
 	msr	cpsr_c, r9
+#ifdef CONFIG_NON_NESTED_FIQ
+	ldr	r2, .LCdisabledabt
+	ldr	r2, [r2]
+	tst	r2, #1
+	beq	doabort
+	ldr     r2, [sp, #S_PC]
+	add	r2, r2, #4
+	str	r2, [sp, #S_PC]
+	b	abortfinish
+doabort:
+#endif
 	mov	r2, sp
 	bl	do_DataAbort
+#ifdef CONFIG_NON_NESTED_FIQ
+abortfinish:
+#endif
 
 	@
 	@ IRQs off again before pulling preserved data off the stack
@@ -198,6 +219,22 @@ __dabt_svc:
 	ldmia	sp, {r0 - pc}^			@ load r0 - pc, cpsr
 ENDPROC(__dabt_svc)
 
+#ifdef CONFIG_NON_NESTED_FIQ
+.LCdisabledabt:
+	.word disable_abort
+
+	.align	5
+__fiq_svc:
+	disable_irq
+	svc_entry
+	mov 	r0, sp
+	bl 	asm_do_FIQ
+	ldr     r0, [sp, #S_PSR]                @ irqs are already disabled
+	msr     spsr_cxsf, r0
+	ldmia   sp, {r0 - pc}^                  @ load r0 - pc, cpsr
+ENDPROC(__fiq_svc)
+#endif
+
 	.align	5
 __irq_svc:
 	svc_entry
@@ -423,6 +460,19 @@ __dabt_usr:
 ENDPROC(__dabt_usr)
 
 	.align	5
+#ifdef CONFIG_NON_NESTED_FIQ
+__fiq_usr:
+	usr_entry
+	kuser_cmpxchg_check
+	mov 	r0, sp
+	bl 	asm_do_FIQ
+	get_thread_info tsk
+	mov 	why, #0
+	b   	ret_to_user
+ENDPROC(__fiq_svc)
+
+	.align	5
+#endif
 __irq_usr:
 	usr_entry
 	kuser_cmpxchg_check
@@ -1072,6 +1122,26 @@ __stubs_start:
 	.long	__irq_invalid			@  e
 	.long	__irq_invalid			@  f
 
+#ifdef CONFIG_NON_NESTED_FIQ
+	vector_stub	fiq, FIQ_MODE, 4
+
+	.long	__fiq_usr			@  0  (USR_26 / USR_32)
+	.long	__fiq_invalid			@  1  (FIQ_26 / FIQ_32)
+	.long	__fiq_invalid			@  2  (IRQ_26 / IRQ_32)
+	.long	__fiq_svc			@  3  (SVC_26 / SVC_32)
+	.long	__fiq_invalid			@  4
+	.long	__fiq_invalid			@  5
+	.long	__fiq_invalid			@  6
+	.long	__fiq_invalid			@  7
+	.long	__fiq_invalid			@  8
+	.long	__fiq_invalid			@  9
+	.long	__fiq_invalid			@  a
+	.long	__fiq_invalid			@  b
+	.long	__fiq_invalid			@  c
+	.long	__fiq_invalid			@  d
+	.long	__fiq_invalid			@  e
+	.long	__fiq_invalid			@  f
+#endif
 /*
  * Data abort dispatcher
  * Enter in ABT mode, spsr = USR CPSR, lr = USR PC
@@ -1153,9 +1223,11 @@ __stubs_start:
  * other mode than FIQ...  Ok you can switch to another mode, but you can't
  * get out of that mode without clobbering one register.
  */
+#ifndef CONFIG_NON_NESTED_FIQ
 vector_fiq:
-	disable_fiq
-	subs	pc, lr, #4
+    disable_fiq
+    subs	pc, lr, #4
+#endif
 
 /*=============================================================================
  * Address exception handler
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index 159d041..da35750 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -22,6 +22,18 @@
  * stack.
  */
 ret_fast_syscall:
+#ifdef CONFIG_LTT_LITE
+/*
+ * The syscall number is stored in r7.
+ * We add it as an additional parameter for LTT-LITE.
+ * The LTT function will ignore it.
+ */
+	mov     r1, r0                          @ save returned r0
+	mov     r0, r7
+	mov     r7, r1
+	bl      trace_real_syscall_exit
+	mov     r0, r7
+#endif
 	disable_irq				@ disable interrupts
 	ldr	r1, [tsk, #TI_FLAGS]
 	tst	r1, #_TIF_WORK_MASK
@@ -241,6 +253,18 @@ ENTRY(vector_swi)
 #endif
 	enable_irq
 
+#ifdef CONFIG_LTT_LITE
+	/*
+	 * note that validity of scno is not yet checked.
+	 * The visualizer checks it.
+	 */
+	add     r1, sp, #S_R0                   @ pointer to regs
+	mov     r0, scno
+	bl      trace_real_syscall_entry
+	add     r1, sp, #S_R0                   @ pointer to regs
+	ldmia   r1, {r0 - r3}                   @ have to reload r0 - r3
+#endif
+
 	get_thread_info tsk
 	adr	tbl, sys_call_table		@ load syscall table pointer
 	ldr	ip, [tsk, #TI_FLAGS]		@ check for syscall tracing
diff --git a/arch/arm/kernel/entry-header.S b/arch/arm/kernel/entry-header.S
index 87ab4e1..e8462ae 100644
--- a/arch/arm/kernel/entry-header.S
+++ b/arch/arm/kernel/entry-header.S
@@ -15,6 +15,10 @@
 #define BAD_IRQ		3
 #define BAD_UNDEFINSTR	4
 
+#ifdef CONFIG_NON_NESTED_FIQ
+#define BAD_FIQ		5
+#endif
+
 @
 @ Most of the stack format comes from struct pt_regs, but with
 @ the addition of 8 bytes for storing syscall args 5 and 6.
diff --git a/arch/arm/kernel/head-common.S b/arch/arm/kernel/head-common.S
index 991952c..6a37dc9 100644
--- a/arch/arm/kernel/head-common.S
+++ b/arch/arm/kernel/head-common.S
@@ -208,6 +208,12 @@ __lookup_machine_type:
 	sub	r3, r3, r4			@ get offset between virt&phys
 	add	r5, r5, r3			@ convert virt addresses to
 	add	r6, r6, r3			@ physical address space
+#if defined(CONFIG_MACH_MAPPHONE)
+	rsb	r3, r5, r6			@ number of machine types
+	teq	r3, #SIZEOF_MACHINE_DESC	@ only one?
+	ldreq	r1, [r5]			@ if so do not bother with r1
+	beq	2f				@ ...and be happy.
+#endif
 1:	ldr	r3, [r5, #MACHINFO_TYPE]	@ get machine type
 	teq	r3, r1				@ matches loader number?
 	beq	2f				@ found
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index 363db18..42fa18f 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -36,6 +36,7 @@
 #include <linux/list.h>
 #include <linux/kallsyms.h>
 #include <linux/proc_fs.h>
+#include <linux/lttlite-events.h>
 
 #include <asm/system.h>
 #include <asm/mach/irq.h>
@@ -121,14 +122,21 @@ asmlinkage void __exception asm_do_IRQ(unsigned int irq, struct pt_regs *regs)
 	 */
 	if (irq >= NR_IRQS)
 		handle_bad_irq(irq, &bad_irq_desc);
-	else
+	else {
+#ifdef CONFIG_LTT_LITE
+		ltt_ev_irq_entry(irq, !(user_mode(regs)));
+#endif
 		generic_handle_irq(irq);
+	}
 
 	/* AT91 specific workaround */
 	irq_finish(irq);
 
 	irq_exit();
 	set_irq_regs(old_regs);
+#ifdef CONFIG_LTT_LITE
+	ltt_ev_irq_exit();
+#endif
 }
 
 void set_irq_flags(unsigned int irq, unsigned int iflags)
diff --git a/arch/arm/kernel/module.c b/arch/arm/kernel/module.c
index 2ecffb8..fad8c38 100644
--- a/arch/arm/kernel/module.c
+++ b/arch/arm/kernel/module.c
@@ -105,6 +105,7 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 
 		switch (ELF32_R_TYPE(rel->r_info)) {
 		case R_ARM_ABS32:
+		case R_ARM_TARGET1:
 			*(u32 *)loc += sym->st_value;
 			break;
 
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index 7193845..3a7f7dd 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -51,6 +51,10 @@ extern void setup_mm_for_reboot(char mode);
 
 static volatile int hlt_counter;
 
+#ifdef CONFIG_NON_NESTED_FIQ
+static fiq_handler_t fiq_handler;
+#endif
+
 #include <mach/system.h>
 
 void disable_hlt(void)
@@ -199,6 +203,119 @@ void machine_restart(char * __unused)
 	arm_pm_restart(reboot_mode);
 }
 
+#ifdef CONFIG_NON_NESTED_FIQ
+void set_fiq_handler(fiq_handler_t ufiq_handler)
+{
+	fiq_handler = ufiq_handler;
+}
+EXPORT_SYMBOL(set_fiq_handler);
+
+static int __emergency_fiq_action(struct pt_regs *regs)
+{
+	if (NULL == (void *)fiq_handler)
+		return -EINVAL;
+
+	fiq_handler(regs);
+
+	return 0;
+}
+asmlinkage void __exception asm_do_FIQ(struct pt_regs* regs)
+{
+	__emergency_fiq_action(regs);
+}
+
+int disable_abort;
+#define safe_probe_kernel_address(addr, retval) \
+	({			\
+		long val;	\
+		disable_abort = 1;	\
+		asm volatile("mrc p15, 0, %0, c5, c0, 0" : "=r" (val));	\
+		val &= ~0xF;						\
+		asm volatile("mcr p15, 0, %0, c5, c0, 0" : : "r" (val));\
+		barrier();						\
+		retval = *addr;						\
+		asm volatile("mrc p15, 0, %0, c5, c0, 0" : "=r" (val));	\
+		disable_abort = 0;					\
+		barrier();						\
+		(val & 0x8);						\
+	})
+#endif
+
+/*
+ * dump a block of kernel memory from around the given address
+ */
+static void show_data(unsigned long addr, int nbytes, const char *name)
+{
+	int	i, j;
+	int	nlines;
+	u32	*p;
+
+	/*
+	 * don't attempt to dump non-kernel addresses or
+	 * values that are probably just small negative numbers
+	 */
+	if (addr < PAGE_OFFSET || addr > -256UL)
+		return;
+
+	printk("\n%s: %#lx:\n", name, addr);
+
+	/*
+	 * round address down to a 32 bit boundary
+	 * and always dump a multiple of 32 bytes
+	 */
+	p = (u32 *)(addr & ~(sizeof(u32) - 1));
+	nbytes += (addr & (sizeof(u32) - 1));
+	nlines = (nbytes + 31) / 32;
+
+
+	for (i = 0; i < nlines; i++) {
+		/*
+		 * just display low 16 bits of address to keep
+		 * each line of the dump < 80 characters
+		 */
+		printk("%04lx ", (unsigned long)p & 0xffff);
+		for (j = 0; j < 8; j++) {
+			u32	data;
+#ifndef CONFIG_NON_NESTED_FIQ
+			if (probe_kernel_address(p, data)) {
+#else
+			if (safe_probe_kernel_address(p, data)) {
+#endif
+				printk(" ********");
+			} else {
+				printk(" %08x", data);
+			}
+			++p;
+		}
+		printk("\n");
+	}
+}
+
+static void show_extra_register_data(struct pt_regs *regs, int nbytes)
+{
+	mm_segment_t fs;
+
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	show_data(regs->ARM_pc - nbytes, nbytes * 2, "PC");
+	show_data(regs->ARM_lr - nbytes, nbytes * 2, "LR");
+	show_data(regs->ARM_sp - nbytes, nbytes * 2, "SP");
+	show_data(regs->ARM_ip - nbytes, nbytes * 2, "IP");
+	show_data(regs->ARM_fp - nbytes, nbytes * 2, "FP");
+	show_data(regs->ARM_r0 - nbytes, nbytes * 2, "R0");
+	show_data(regs->ARM_r1 - nbytes, nbytes * 2, "R1");
+	show_data(regs->ARM_r2 - nbytes, nbytes * 2, "R2");
+	show_data(regs->ARM_r3 - nbytes, nbytes * 2, "R3");
+	show_data(regs->ARM_r4 - nbytes, nbytes * 2, "R4");
+	show_data(regs->ARM_r5 - nbytes, nbytes * 2, "R5");
+	show_data(regs->ARM_r6 - nbytes, nbytes * 2, "R6");
+	show_data(regs->ARM_r7 - nbytes, nbytes * 2, "R7");
+	show_data(regs->ARM_r8 - nbytes, nbytes * 2, "R8");
+	show_data(regs->ARM_r9 - nbytes, nbytes * 2, "R9");
+	show_data(regs->ARM_r10 - nbytes, nbytes * 2, "R10");
+	set_fs(fs);
+}
+
 void __show_regs(struct pt_regs *regs)
 {
 	unsigned long flags;
@@ -257,6 +374,8 @@ void __show_regs(struct pt_regs *regs)
 		printk("Control: %08x%s\n", ctrl, buf);
 	}
 #endif
+
+	show_extra_register_data(regs, 128);
 }
 
 void show_regs(struct pt_regs * regs)
diff --git a/arch/arm/kernel/prom.c b/arch/arm/kernel/prom.c
new file mode 100644
index 0000000..112f7b6
--- /dev/null
+++ b/arch/arm/kernel/prom.c
@@ -0,0 +1,407 @@
+/*
+ * Procedures for creating, accessing and interpreting the device tree.
+ *
+ * Paul Mackerras       August 1996.
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
+ *    {engebret|bergner}@us.ibm.com
+ *
+ *  Adapted for ARM by Motorola Inc.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#include <stdarg.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/threads.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/stringify.h>
+#include <linux/delay.h>
+#include <linux/initrd.h>
+#include <linux/bitops.h>
+#include <linux/module.h>
+#include <linux/bootmem.h>
+#include <linux/kexec.h>
+#include <linux/debugfs.h>
+#include <linux/irq.h>
+#include <asm/prom.h>
+#include <asm/setup.h>
+#include <asm/memory.h>
+#ifdef DEBUG
+#define DBG(fmt...) printk(KERN_ERR fmt)
+#else
+#define DBG(fmt...)
+#endif
+static unsigned long dev_tree_size;
+static struct boot_param_header *initial_boot_params;
+
+extern struct device_node *allnodes;	/* temporary while merging */
+
+extern rwlock_t devtree_lock;	/* temporary while merging */
+
+/* export that to outside world */
+struct device_node *of_chosen;
+
+static inline char *find_flat_dt_string(u32 offset)
+{
+	return ((char *)initial_boot_params) +
+		initial_boot_params->off_dt_strings + offset;
+}
+
+static void *__init unflatten_dt_alloc(unsigned long *mem, unsigned long size,
+				       unsigned long align)
+{
+	void *res;
+
+	*mem = _ALIGN(*mem, align);
+	res = (void *)*mem;
+	*mem += size;
+
+	return res;
+}
+
+static unsigned long __init unflatten_dt_node(unsigned long mem,
+					      unsigned long *p,
+					      struct device_node *dad,
+					      struct device_node ***allnextpp,
+					      unsigned long fpsize)
+{
+	struct device_node *np;
+	struct property *pp, **prev_pp = NULL;
+	char *pathp;
+	u32 tag;
+	unsigned int l, allocl;
+	int has_name = 0;
+	int new_format = 0;
+
+	tag = *((u32 *)(*p));
+	if (tag != OF_DT_BEGIN_NODE) {
+		printk("Weird tag at start of node: %x\n", tag);
+		return mem;
+	}
+	*p += 4;
+	pathp = (char *)*p;
+	l = allocl = strlen(pathp) + 1;
+	*p = _ALIGN(*p + l, 4);
+
+	/* version 0x10 has a more compact unit name here instead of the full
+	 * path. we accumulate the full path size using "fpsize", we'll rebuild
+	 * it later. We detect this because the first character of the name is
+	 * not '/'.
+	 */
+	if ((*pathp) != '/') {
+		new_format = 1;
+		if (fpsize == 0) {
+			/* root node: special case. fpsize accounts for path
+			 * plus terminating zero. root node only has '/', so
+			 * fpsize should be 2, but we want to avoid the first
+			 * level nodes to have two '/' so we use fpsize 1 here
+			 */
+			fpsize = 1;
+			allocl = 2;
+		} else {
+			/* account for '/' and path size minus terminal 0
+			 * already in 'l'
+			 */
+			fpsize += l;
+			allocl = fpsize;
+		}
+	}
+
+
+	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
+				__alignof__(struct device_node));
+	if (allnextpp) {
+		memset(np, 0, sizeof(*np));
+		np->full_name = ((char *)np) + sizeof(struct device_node);
+		if (new_format) {
+			int n = scnprintf(np->full_name, allocl, "%s/%s",
+				dad && dad->parent ? dad->full_name : "",
+				pathp);
+#ifdef DEBUG
+			if (n != allocl) {
+				DBG("%s: p: %d, l: %d, a: %d\n",
+				    pathp, (int)strlen(p), l, allocl);
+			}
+#endif
+		} else
+			memcpy(np->full_name, pathp, l);
+		prev_pp = &np->properties;
+		**allnextpp = np;
+		*allnextpp = &np->allnext;
+		if (dad != NULL) {
+			np->parent = dad;
+			/* we temporarily use the next field as `last_child'*/
+			if (dad->next == 0)
+				dad->child = np;
+			else
+				dad->next->sibling = np;
+			dad->next = np;
+		}
+		kref_init(&np->kref);
+	}
+	while (1) {
+		u32 sz, noff;
+		char *pname;
+
+		tag = *((u32 *)(*p));
+		if (tag == OF_DT_NOP) {
+			*p += 4;
+			continue;
+		}
+		if (tag != OF_DT_PROP)
+			break;
+		*p += 4;
+		sz = *((u32 *)(*p));
+		noff = *((u32 *)((*p) + 4));
+		*p += 8;
+		if (initial_boot_params->version < 0x10)
+			*p = _ALIGN(*p, sz >= 8 ? 8 : 4);
+
+		pname = find_flat_dt_string(noff);
+		if (pname == NULL) {
+			printk(KERN_INFO "Can't find property name in list!\n");
+			break;
+		}
+		if (strcmp(pname, "name") == 0)
+			has_name = 1;
+		l = strlen(pname) + 1;
+		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
+					__alignof__(struct property));
+		if (allnextpp) {
+			if (strcmp(pname, "linux,phandle") == 0) {
+				np->node = *((u32 *)*p);
+				if (np->linux_phandle == 0)
+					np->linux_phandle = np->node;
+			}
+			pp->name = pname;
+			pp->length = sz;
+			pp->value = (void *)*p;
+			*prev_pp = pp;
+			prev_pp = &pp->next;
+		}
+		*p = _ALIGN((*p) + sz, 4);
+	}
+	/* with version 0x10 we may not have the name property, recreate
+	 * it here from the unit name if absent
+	 */
+	if (!has_name) {
+		char *p = pathp, *ps = pathp, *pa = NULL;
+		int sz;
+
+		while (*p) {
+			if ((*p) == '@')
+				pa = p;
+			if ((*p) == '/')
+				ps = p + 1;
+			p++;
+		}
+		if (pa < ps)
+			pa = p;
+		sz = (pa - ps) + 1;
+		pp = unflatten_dt_alloc(&mem, sizeof(struct property) + sz,
+					__alignof__(struct property));
+		if (allnextpp) {
+			pp->name = "name";
+			pp->length = sz;
+			pp->value = pp + 1;
+			*prev_pp = pp;
+			prev_pp = &pp->next;
+			strlcpy(pp->value, ps, sz);
+			DBG("fixed up name for %s -> %s\n", pathp,
+				(char *)pp->value);
+		}
+	}
+	if (allnextpp) {
+		*prev_pp = NULL;
+		np->name = of_get_property(np, "name", NULL);
+		np->type = of_get_property(np, "device_type", NULL);
+
+		if (!np->name)
+			np->name = "<NULL>";
+		if (!np->type)
+			np->type = "<NULL>";
+	}
+	while (tag == OF_DT_BEGIN_NODE) {
+		mem = unflatten_dt_node(mem, p, np, allnextpp, fpsize);
+		tag = *((u32 *)(*p));
+	}
+	if (tag != OF_DT_END_NODE) {
+		printk(KERN_INFO "Weird tag at end of node: %x\n", tag);
+		return mem;
+	}
+	*p += 4;
+	return mem;
+}
+
+/**
+ * unflattens the device-tree passed by the firmware, creating the
+ * tree of struct device_node. It also fills the "name" and "type"
+ * pointers of the nodes so the normal device-tree walking functions
+ * can be used (this used to be done by finish_device_tree)
+ */
+void __init unflatten_device_tree(void)
+{
+	unsigned long start, size;
+	void *mem;
+	u32 *mem_endmarker;
+	struct device_node **allnextp = &allnodes;
+
+	DBG(" -> unflatten_device_tree()\n");
+	if (!initial_boot_params)
+		return;
+	mem = __alloc_bootmem(dev_tree_size, __alignof__(int), 0);
+	memcpy(mem, initial_boot_params, dev_tree_size);
+	initial_boot_params = mem;
+	/* First pass, scan for size */
+	start = ((unsigned long)initial_boot_params) +
+		initial_boot_params->off_dt_struct;
+	size = unflatten_dt_node(0, &start, NULL, NULL, 0);
+	size = ALIGN(size, __alignof__(u32));
+
+	DBG("  size is %lx, allocating...\n", size);
+
+	/* Allocate memory for the expanded device tree */
+	mem = __alloc_bootmem(size + sizeof(u32),
+			__alignof__(struct device_node), 0);
+	mem_endmarker = mem + size;
+	*mem_endmarker = 0xdeadbeef;
+
+	DBG("  unflattening %lx...\n", mem);
+
+	/* Second pass, do actual unflattening */
+	start = ((unsigned long)initial_boot_params) +
+		initial_boot_params->off_dt_struct;
+	unflatten_dt_node((unsigned long)mem, &start, NULL, &allnextp, 0);
+	if (*((u32 *)start) != OF_DT_END)
+		printk(KERN_WARNING "Weird tag at end of tree: %08x\n",
+			*((u32 *)start));
+	if (*mem_endmarker != 0xdeadbeef)
+		printk(KERN_WARNING "End of tree marker overwritten: %08x\n",
+		       *mem_endmarker);
+	*allnextp = NULL;
+
+	/* Get pointer to OF "/chosen" node for use everywhere */
+	of_chosen = of_find_node_by_path("/chosen");
+	if (of_chosen == NULL)
+		of_chosen = of_find_node_by_path("/chosen@0");
+
+	DBG(" <- unflatten_device_tree()\n");
+}
+
+/**
+ *	of_find_node_by_phandle - Find a node given a phandle
+ *	@handle:	phandle of the node to find
+ *
+ *	Returns a node pointer with refcount incremented, use
+ *	of_node_put() on it when done.
+ */
+struct device_node *of_find_node_by_phandle(phandle handle)
+{
+	struct device_node *np;
+
+	read_lock(&devtree_lock);
+	for (np = allnodes; np != 0; np = np->allnext)
+		if (np->linux_phandle == handle)
+			break;
+	of_node_get(np);
+	read_unlock(&devtree_lock);
+	return np;
+}
+EXPORT_SYMBOL(of_find_node_by_phandle);
+
+struct device_node *of_node_get(struct device_node *node)
+{
+	if (node)
+		kref_get(&node->kref);
+	return node;
+}
+EXPORT_SYMBOL(of_node_get);
+
+static inline struct device_node *kref_to_device_node(struct kref *kref)
+{
+	return container_of(kref, struct device_node, kref);
+}
+
+/**
+ *	of_node_release - release a dynamically allocated node
+ *	@kref:  kref element of the node to be released
+ *
+ *	In of_node_put() this function is passed to kref_put()
+ *	as the destructor.
+ */
+static void of_node_release(struct kref *kref)
+{
+	struct device_node *node = kref_to_device_node(kref);
+	struct property *prop = node->properties;
+
+	/* We should never be releasing nodes that haven't been detached. */
+	if (!of_node_check_flag(node, OF_DETACHED)) {
+		printk(KERN_WARNING "WARNING: Bad of_node_put() on %s\n",
+			node->full_name);
+		dump_stack();
+		kref_init(&node->kref);
+		return;
+	}
+
+	if (!of_node_check_flag(node, OF_DYNAMIC))
+		return;
+
+	while (prop) {
+		struct property *next = prop->next;
+		kfree(prop->name);
+		kfree(prop->value);
+		kfree(prop);
+		prop = next;
+
+		if (!prop) {
+			prop = node->deadprops;
+			node->deadprops = NULL;
+		}
+	}
+	kfree(node->full_name);
+	kfree(node->data);
+	kfree(node);
+}
+
+/**
+ *	of_node_put - Decrement refcount of a node
+ *	@node:	Node to dec refcount, NULL is supported to
+ *		simplify writing of callers
+ *
+ */
+void of_node_put(struct device_node *node)
+{
+	if (node)
+		kref_put(&node->kref, of_node_release);
+}
+EXPORT_SYMBOL(of_node_put);
+
+int have_of;
+
+/* process flat device tree for hardware configuration */
+static int __init parse_tag_flat_dev_tree_address(const struct tag *tag)
+{
+    if (tag->u.flat_dev_tree.size) {
+	initial_boot_params = phys_to_virt(tag->u.flat_dev_tree.address);
+	dev_tree_size = tag->u.flat_dev_tree.size;
+    }
+
+    have_of = 1;
+    printk(KERN_INFO
+	"flat_dev_tree_address=0x%08x, flat_dev_tree_size == 0x%08X\n",
+	tag->u.flat_dev_tree.address,
+	tag->u.flat_dev_tree.size);
+
+    return 0;
+}
+
+__tagtable(ATAG_FLAT_DEV_TREE_ADDRESS, parse_tag_flat_dev_tree_address);
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index d301a53..d896df9 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -41,6 +41,14 @@
 #include <asm/mach/time.h>
 #include <asm/traps.h>
 
+#ifdef CONFIG_ARM_OF
+#include <asm/prom.h>
+#include <mach/hardware.h>
+#endif
+#ifdef CONFIG_BOOTINFO
+#include <asm/bootinfo.h>
+#endif
+
 #include "compat.h"
 #include "atags.h"
 
@@ -105,6 +113,9 @@ struct stack {
 	u32 irq[3];
 	u32 abt[3];
 	u32 und[3];
+#ifdef CONFIG_NON_NESTED_FIQ
+	u32 fiq[3];
+#endif
 } ____cacheline_aligned;
 
 static struct stack stacks[NR_CPUS];
@@ -335,7 +346,13 @@ void cpu_init(void)
 	"add	sp, %0, %4\n\t"
 	"msr	cpsr_c, %5\n\t"
 	"add	sp, %0, %6\n\t"
-	"msr	cpsr_c, %7"
+#ifndef CONFIG_NON_NESTED_FIQ
+	"msr    cpsr_c, %7"
+#else
+	"msr	cpsr_c, %7\n\t"
+	"add	sp, %0, %8\n\t"
+	"msr	cpsr_c, %9"
+#endif
 	    :
 	    : "r" (stk),
 	      "I" (PSR_F_BIT | PSR_I_BIT | IRQ_MODE),
@@ -344,6 +361,10 @@ void cpu_init(void)
 	      "I" (offsetof(struct stack, abt[0])),
 	      "I" (PSR_F_BIT | PSR_I_BIT | UND_MODE),
 	      "I" (offsetof(struct stack, und[0])),
+#ifdef CONFIG_NON_NESTED_FIQ
+	      "I" (PSR_F_BIT | PSR_I_BIT | FIQ_MODE),
+	      "I" (offsetof(struct stack, fiq[0])),
+#endif
 	      "I" (PSR_F_BIT | PSR_I_BIT | SVC_MODE)
 	    : "r14");
 }
@@ -619,6 +640,60 @@ static int __init parse_tag_cmdline(const struct tag *tag)
 
 __tagtable(ATAG_CMDLINE, parse_tag_cmdline);
 
+#ifdef CONFIG_BOOTINFO
+static int __init parse_tag_powerup_reason(const struct tag *tag)
+{
+	bi_set_powerup_reason(tag->u.powerup_reason.powerup_reason);
+	printk(KERN_WARNING "%s: powerup reason=0x%08x\n",
+				__func__, bi_powerup_reason());
+	return 0;
+}
+
+__tagtable(ATAG_POWERUP_REASON, parse_tag_powerup_reason);
+
+static int __init parse_tag_mbm_version(const struct tag *tag)
+{
+	bi_set_mbm_version(tag->u.mbm_version.mbm_version);
+	printk(KERN_INFO "%s: mbm_version=0x%08x\n",
+				__func__, bi_mbm_version());
+	return 0;
+}
+
+__tagtable(ATAG_MBM_VERSION, parse_tag_mbm_version);
+
+static int __init parse_tag_mbm_loader_version(const struct tag *tag)
+{
+	bi_set_mbm_loader_version(tag->
+			u.mbm_loader_version.mbm_loader_version);
+	printk(KERN_INFO "%s: mbm_loader_version=0x%08x\n",
+				__func__, bi_mbm_loader_version());
+	return 0;
+}
+
+__tagtable(ATAG_MBM_LOADER_VERSION, parse_tag_mbm_loader_version);
+
+static int __init parse_tag_battery_status_at_boot(const struct tag *tag)
+{
+	bi_set_battery_status_at_boot(tag->
+			u.battery_status_at_boot.battery_status_at_boot);
+	printk(KERN_INFO "%s: battery_status_at_boot=0x%08x\n",
+				__func__, bi_battery_status_at_boot());
+	return 0;
+}
+
+__tagtable(ATAG_BATTERY_STATUS_AT_BOOT, parse_tag_battery_status_at_boot);
+
+static int __init parse_tag_cid_recover_boot(const struct tag *tag)
+{
+	bi_set_cid_recover_boot(tag->u.cid_recover_boot.cid_recover_boot);
+	printk(KERN_INFO "%s: cid_recover_boot=\"%d\"\n",
+				__func__, bi_cid_recover_boot());
+	return 0;
+}
+
+__tagtable(ATAG_CID_RECOVER_BOOT, parse_tag_cid_recover_boot);
+
+#endif /* CONFIG_BOOTINFO */
 /*
  * Scan the tag table for this tag, and call its parse function.
  * The tag table is built by the linker from all the __tagtable
@@ -725,6 +800,9 @@ void __init setup_arch(char **cmdline_p)
 	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
 	parse_cmdline(cmdline_p, from);
 	paging_init(mdesc);
+#if defined(CONFIG_ARM_OF)
+	unflatten_device_tree();
+#endif
 	request_standard_resources(&meminfo, mdesc);
 
 #ifdef CONFIG_SMP
@@ -789,6 +867,20 @@ static int c_show(struct seq_file *m, void *v)
 {
 	int i;
 
+#if defined(CONFIG_ARM_OF)
+	static char *p = NULL;
+	int len = strlen(bp_model);
+
+	if (!p && len) {
+		p = kmalloc(strlen(machine_name) + len + 1, GFP_KERNEL);
+		if (p) {
+			*p = '\0';
+			strcat(p, machine_name);
+			machine_name = strcat(p, bp_model);
+		}
+	}
+#endif
+
 	seq_printf(m, "Processor\t: %s rev %d (%s)\n",
 		   cpu_name, read_cpuid_id() & 15, elf_platform);
 
diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c
index 8f96922..e3c2e60 100644
--- a/arch/arm/kernel/signal.c
+++ b/arch/arm/kernel/signal.c
@@ -12,6 +12,7 @@
 #include <linux/personality.h>
 #include <linux/freezer.h>
 #include <linux/uaccess.h>
+#include <linux/lttlite-events.h>
 
 #include <asm/elf.h>
 #include <asm/cacheflush.h>
@@ -647,6 +648,11 @@ static int do_signal(sigset_t *oldset, struct pt_regs *regs, int syscall)
 
 	signr = get_signal_to_deliver(&info, &ka, regs, NULL);
 	if (signr > 0) {
+#ifdef CONFIG_LTT_LITE
+		ltt_lite_ev_handle_sig((unsigned short)current->pid,
+			(unsigned short)signr,
+			(unsigned long)ka.sa.sa_handler);
+#endif
 		handle_signal(signr, &ka, &info, oldset, regs, syscall);
 		single_step_set(current);
 		return 1;
diff --git a/arch/arm/kernel/traps.c b/arch/arm/kernel/traps.c
index 79abc4d..0879296 100644
--- a/arch/arm/kernel/traps.c
+++ b/arch/arm/kernel/traps.c
@@ -21,6 +21,7 @@
 #include <linux/hardirq.h>
 #include <linux/init.h>
 #include <linux/uaccess.h>
+#include <linux/lttlite-events.h>
 
 #include <asm/atomic.h>
 #include <asm/cacheflush.h>
@@ -194,6 +195,30 @@ void show_stack(struct task_struct *tsk, unsigned long *sp)
 	barrier();
 }
 
+#ifdef CONFIG_LTT_LITE
+asmlinkage void trace_real_syscall_entry(int scno)
+{
+	/*
+	 * The caller didn't bother checking for a
+	 * valid syscall number...
+	 */
+	if ((scno & 0x00f00000) != __NR_SYSCALL_BASE)
+		return;
+
+	/* mark the ARM private syscalls */
+	if ((scno & 0x00ff0000) == __ARM_NR_BASE)
+		scno |= 0x00008000;
+	ltt_lite_log_syscall(LTT_LITE_EVENT_ENTER, scno);
+}
+
+asmlinkage void trace_real_syscall_exit(int scno)
+{
+	/* mark the ARM private syscalls */
+	if ((scno & 0x00ff0000) == __ARM_NR_BASE)
+		scno |= 0x00008000;
+	ltt_lite_log_syscall(LTT_LITE_EVENT_RETURN, scno);
+}
+#endif /* CONFIG_LTT_LITE */
 #ifdef CONFIG_PREEMPT
 #define S_PREEMPT " PREEMPT"
 #else
diff --git a/arch/arm/kernel/vmlinux.lds.S b/arch/arm/kernel/vmlinux.lds.S
index 0021607..9aab166 100644
--- a/arch/arm/kernel/vmlinux.lds.S
+++ b/arch/arm/kernel/vmlinux.lds.S
@@ -68,6 +68,11 @@ SECTIONS
 			*(.data.percpu)
 			*(.data.percpu.shared_aligned)
 		__per_cpu_end = .;
+#ifdef CONFIG_DEBUG_MEMLEAK
+		__memleak_offsets_start = .;
+			*(.init.memleak_offsets)
+		__memleak_offsets_end = .;
+#endif
 #ifndef CONFIG_XIP_KERNEL
 		__init_begin = _stext;
 		INIT_DATA
@@ -120,7 +125,9 @@ SECTIONS
 
 	.data : AT(__data_loc) {
 		_data = .;		/* address in memory */
-
+#ifdef CONFIG_DEBUG_MEMLEAK
+		_sdata = .;
+#endif
 		/*
 		 * first, the init task union, aligned
 		 * to an 8192 byte boundary.
@@ -171,6 +178,9 @@ SECTIONS
 		__bss_start = .;	/* BSS				*/
 		*(.bss)
 		*(COMMON)
+#ifdef CONFIG_DEBUG_MEMLEAK
+		__bss_stop = .;
+#endif
 		_end = .;
 	}
 					/* Stabs debugging sections.	*/
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index 4e9125a..d2e8149 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -119,7 +119,7 @@ config MACH_OMAP_ZOOM2
 
 config WIFI_CONTROL_FUNC
         bool "Enable WiFi control function abstraction"
-	depends on MACH_OMAP_ZOOM2 || MACH_SHOLES
+	depends on MACH_OMAP_ZOOM2 || MACH_SHOLES || MACH_MAPPHONE || MACH_SHOLEST
         help
           Enables Power/Reset/Carddetect function abstraction
 
@@ -164,6 +164,14 @@ config MACH_SHOLES_UMTS
         bool "Motorola sholes umts"
         depends on MACH_SHOLES
 
+config MACH_SHOLEST
+        bool "Motorola sholes tablet"
+        depends on ARCH_OMAP3 && ARCH_OMAP34XX
+
+config MACH_MAPPHONE
+        bool "Motorola Android Platform phone"
+        depends on ARCH_OMAP3 && ARCH_OMAP34XX
+
 config MACH_OVERO
 	bool "Gumstix Overo board"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
@@ -171,3 +179,29 @@ config MACH_OVERO
 config MACH_OMAP3_PANDORA
 	bool "OMAP3 Pandora"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
+
+config MOT_FEAT_MDTV
+	bool "support MDTV system for motorola"
+	default n
+
+config EMU_UART_DEBUG
+	bool "Provide the option of setting MiniUSB port as UART3 to debug kernel"
+	default n
+	help
+	  If enabling this feature, USB functionality is NOT available
+	  any more. Only including "emu_uart_debug" parameters in command line
+	  could activate UART3 console over miniUSB port. This feature is
+	  specific for Motorola phone with CPCAP power IC.
+
+config PROC_OMAP_PHONE_ID
+        bool "/proc/phoneid support"
+        depends on PROC_FS && ARCH_OMAP34XX
+	default n
+	help
+	  Exports the DIE_ID reg value.
+
+config CUP2TOUCH
+	bool "Support touch for CU p2"
+	default n
+	help
+	  CU p2 touch needs special treatment for its differenct IC
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 01dd753..2981dc2 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_ARCH_OMAP2)		+= pm24xx.o
 obj-$(CONFIG_ARCH_OMAP24XX)		+= sleep24xx.o
 obj-$(CONFIG_ARCH_OMAP3)		+= pm34xx.o sleep34xx.o cpuidle34xx.o
 obj-$(CONFIG_PM_DEBUG)			+= pm-debug.o
+obj-y					+= wakeup-timer.o
 endif
 
 # SmartReflex driver
@@ -83,8 +84,35 @@ obj-$(CONFIG_MACH_SHOLES)		+= board-sholes.o \
 					   board-sholes-hsmmc.o \
 					   board-sholes-keypad.o \
 					   board-sholes-wifi.o \
-					   board-sholes-mmcprobe.o 
-
+					   board-sholes-mmcprobe.o
+obj-$(CONFIG_MACH_SHOLEST)             	+= board-sholest.o \
+					   board-sholest-camera.o \
+					   board-sholest-flash.o \
+					   board-sholest-padconf.o \
+					   board-sholest-panel.o \
+					   board-sholest-spi.o \
+					   board-sholest-sensors.o \
+					   board-sholest-hsmmc.o \
+					   board-sholest-keypad.o \
+					   board-sholest-wifi.o \
+					   board-sholest-gpio.o \
+					   board-sholest-mmcprobe.o \
+					   board-sholest-mdtv.o
+ifeq ($(CONFIG_MACH_SHOLEST),)
+obj-$(CONFIG_MACH_MAPPHONE)		+= board-mapphone.o \
+					   board-mapphone-camera.o \
+					   board-mapphone-flash.o \
+					   board-mapphone-padconf.o \
+					   board-mapphone-panel.o \
+					   board-mapphone-spi.o \
+					   board-mapphone-sensors.o \
+					   board-mapphone-hsmmc.o \
+					   board-mapphone-keypad.o \
+					   board-mapphone-wifi.o \
+					   board-mapphone-gpio.o \
+					   board-mapphone-mmcprobe.o \
+obj-$(CONFIG_MOT_FEAT_MDTV)             += board-mapphone-mdtv.o
+endif
 obj-$(CONFIG_MACH_OMAP_APOLLON)		+= board-apollon.o \
 					   board-apollon-mmc.o	\
 					   board-apollon-keys.o
@@ -107,12 +135,10 @@ obj-$(CONFIG_MACH_OVERO)		+= board-overo.o \
 					   twl4030-generic-scripts.o
 obj-$(CONFIG_MACH_OMAP3_PANDORA)	+= board-omap3pandora.o \
 					   mmc-twl4030.o
+obj-$(CONFIG_EMU_UART_DEBUG)		+= board-mapphone-emu_uart.o
 
 # Platform specific device init code
 obj-y								+= usb-musb.o
 obj-$(CONFIG_MACH_OMAP2_TUSB6010)	+= usb-tusb6010.o
-
-ifneq ($(CONFIG_USB_EHCI_HCD),)
-	obj-y				+= usb-ehci.o
-endif
+obj-$(CONFIG_PROC_OMAP_PHONE_ID)       	+= phoneid.o
 
diff --git a/arch/arm/mach-omap2/Makefile.boot b/arch/arm/mach-omap2/Makefile.boot
index c768643..dd30d9e 100644
--- a/arch/arm/mach-omap2/Makefile.boot
+++ b/arch/arm/mach-omap2/Makefile.boot
@@ -2,6 +2,14 @@
 params_phys-y		:= 0x80000100
 initrd_phys-y		:= 0x80800000
 
-  zreladdr-$(CONFIG_MACH_SHOLES_UMTS)  := 0x80c08000
-params_phys-$(CONFIG_MACH_SHOLES_UMTS) := 0x80c00100
-initrd_phys-$(CONFIG_MACH_SHOLES_UMTS) := 0x81400000
+  zreladdr-$(CONFIG_MACH_SHOLES_UMTS)   := 0x80c08000
+params_phys-$(CONFIG_MACH_SHOLES_UMTS)  := 0x80c00100
+initrd_phys-$(CONFIG_MACH_SHOLES_UMTS)  := 0x81400000
+
+  zreladdr-$(CONFIG_MACH_SHOLEST)       := 0x80c08000
+params_phys-$(CONFIG_MACH_SHOLEST)      := 0x80c00100
+initrd_phys-$(CONFIG_MACH_SHOLEST)      := 0x81400000
+
+  zreladdr-$(CONFIG_MACH_MAPPHONE)	:= 0x80c08000
+params_phys-$(CONFIG_MACH_MAPPHONE)	:= 0x80c00100
+initrd_phys-$(CONFIG_MACH_MAPPHONE)	:= 0x81400000
diff --git a/arch/arm/mach-omap2/board-mapphone-camera.c b/arch/arm/mach-omap2/board-mapphone-camera.c
new file mode 100644
index 0000000..7a016b3
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-camera.c
@@ -0,0 +1,277 @@
+/*
+ * linux/arch/arm/mach-omap2/board-mapphone-camera.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from mach-omap3/board-3430sdp.c
+ *
+ * Copyright (C) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-generic.c
+ *
+ * Initial code: Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/mux.h>
+#include <mach/board-mapphone.h>
+#include <mach/omap-pm.h>
+#include <mach/control.h>
+
+#ifdef CONFIG_VIDEO_OLDOMAP3
+#include <media/v4l2-int-device.h>
+#include <../drivers/media/video/oldomap34xxcam.h>
+#include <../drivers/media/video/oldisp/ispreg.h>
+#include <../drivers/media/video/oldisp/isp.h>
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+#include <media/mt9p012.h>
+#endif
+#endif
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+#include <../drivers/media/video/hplens.h>
+#endif
+
+#define CAM_IOMUX_SAFE_MODE (OMAP343X_PADCONF_PULL_UP | \
+				OMAP343X_PADCONF_PUD_ENABLED | \
+				OMAP343X_PADCONF_MUXMODE7)
+#define CAM_IOMUX_FUNC_MODE (OMAP343X_PADCONF_INPUT_ENABLED | \
+				OMAP343X_PADCONF_MUXMODE0)
+
+static void mapphone_camera_lines_safe_mode(void);
+static void mapphone_camera_lines_func_mode(void);
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+static int hplens_power_set(enum v4l2_power power)
+{
+	(void)power;
+
+	return 0;
+}
+
+static int hplens_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_LENS;
+
+	return 0;
+}
+
+struct hplens_platform_data mapphone_hplens_platform_data = {
+	.power_set = hplens_power_set,
+	.priv_data_set = hplens_set_prv_data,
+};
+#endif
+
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+static struct omap34xxcam_sensor_config mt9p012_cam_hwc = {
+	.sensor_isp = 0,
+	.xclk = OMAP34XXCAM_XCLK_A,
+	.capture_mem = PAGE_ALIGN(2592 * 1944 * 2) * 4,
+};
+
+static int mt9p012_sensor_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->u.sensor.xclk = mt9p012_cam_hwc.xclk;
+	hwc->u.sensor.sensor_isp = mt9p012_cam_hwc.sensor_isp;
+	hwc->u.sensor.capture_mem = mt9p012_cam_hwc.capture_mem;
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_SENSOR;
+	hwc->interface_type = ISP_PARLL;
+	return 0;
+}
+
+static struct isp_interface_config mt9p012_if_config = {
+	.ccdc_par_ser = ISP_PARLL,
+	.dataline_shift = 0x1,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.vdint0_timing = 0x0,
+	.vdint1_timing = 0x0,
+	.strobe = 0x0,
+	.prestrobe = 0x0,
+	.shutter = 0x0,
+	.wenlog = ISPCCDC_CFG_WENLOG_OR,
+	.dcsub = 42,
+	.raw_fmt_in = ISPCCDC_INPUT_FMT_GR_BG,
+	.wbal.coef0 = 0x23,
+	.wbal.coef1 = 0x20,
+	.wbal.coef2 = 0x20,
+	.wbal.coef3 = 0x30,
+	.u.par.par_bridge = 0x0,
+	.u.par.par_clk_pol = 0x0,
+};
+
+static int mt9p012_sensor_power_set(struct device* dev, enum v4l2_power power)
+{
+	static enum v4l2_power previous_power = V4L2_POWER_OFF;
+	static struct regulator *regulator;
+
+	switch (power) {
+	case V4L2_POWER_OFF:
+		/* Power Down Sequence */
+		gpio_free(GPIO_MT9P012_RESET);
+
+		/* Turn off power */
+		if (regulator != NULL) {
+			regulator_disable(regulator);
+			regulator_put(regulator);
+			regulator = NULL;
+		} else {
+			mapphone_camera_lines_safe_mode();
+			pr_err("%s: Regulator for vcam is not "\
+					"initialized\n", __func__);
+			return -EIO;
+		}
+
+		/* Release pm constraints */
+		omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 0);
+		mapphone_camera_lines_safe_mode();
+	break;
+	case V4L2_POWER_ON:
+		if (previous_power == V4L2_POWER_OFF) {
+			/* Power Up Sequence */
+			mapphone_camera_lines_func_mode();
+
+			/* Set min throughput to:
+			 *  2592 x 1944 x 2bpp x 30fps x 3 L3 accesses */
+			omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 885735);
+
+			/* Configure pixel clock divider (here?) */
+			omap_writel(0x2, 0x48004f40);
+			isp_configure_interface(&mt9p012_if_config);
+
+			/* Request and configure gpio pins */
+			if (gpio_request(GPIO_MT9P012_RESET,
+						"mt9p012 camera reset") != 0)
+				return -EIO;
+
+			/* set to output mode */
+			gpio_direction_output(GPIO_MT9P012_RESET, 0);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_MT9P012_RESET, 1);
+
+			/* turn on digital power */
+			if (regulator != NULL) {
+				pr_warning("%s: Already have "\
+						"regulator\n", __func__);
+			} else {
+				regulator = regulator_get(NULL, "vcam");
+				if (IS_ERR(regulator)) {
+					pr_err("%s: Cannot get vcam "\
+						"regulator, err=%ld\n",
+						__func__, PTR_ERR(regulator));
+					return PTR_ERR(regulator);
+				}
+			}
+
+			if (regulator_enable(regulator) != 0) {
+				pr_err("%s: Cannot enable vcam regulator\n",
+						__func__);
+				return -EIO;
+			}
+		}
+
+		udelay(1000);
+
+		if (previous_power == V4L2_POWER_OFF) {
+			/* trigger reset */
+			gpio_direction_output(GPIO_MT9P012_RESET, 0);
+
+			udelay(1500);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_MT9P012_RESET, 1);
+
+			/* give sensor sometime to get out of the reset.
+			 * Datasheet says 2400 xclks. At 6 MHz, 400 usec is
+			 * enough
+			 */
+			udelay(300);
+		}
+		break;
+	case V4L2_POWER_STANDBY:
+		/* Stand By Sequence */
+		break;
+	}
+	/* Save powerstate to know what was before calling POWER_ON. */
+	previous_power = power;
+	return 0;
+}
+
+u32 mt9p012_set_xclk(u32 xclkfreq)
+{
+	return isp_set_xclk(xclkfreq, OMAP34XXCAM_XCLK_A);
+}
+
+
+struct mt9p012_platform_data mapphone_mt9p012_platform_data = {
+	.power_set      = mt9p012_sensor_power_set,
+	.set_xclk	= mt9p012_set_xclk,
+	.priv_data_set  = mt9p012_sensor_set_prv_data,
+};
+
+#endif /* #ifdef CONFIG_VIDEO_MT9P012 || CONFIG_VIDEO_MT9P012_MODULE */
+
+/* We can't change the IOMUX config after bootup
+ * with the current pad configuration architecture,
+ * the next two functions are hack to configure the
+ * camera pads at runtime to save power in standby */
+
+void mapphone_camera_lines_safe_mode(void)
+{
+	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0122);
+	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0124);
+	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0126);
+	omap_ctrl_writew(CAM_IOMUX_SAFE_MODE, 0x0128);
+}
+
+void mapphone_camera_lines_func_mode(void)
+{
+	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0122);
+	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0124);
+	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0126);
+	omap_ctrl_writew(CAM_IOMUX_FUNC_MODE, 0x0128);
+}
+
+void __init mapphone_camera_init(void)
+{
+	omap_cfg_reg(A24_34XX_CAM_HS);
+	omap_cfg_reg(A23_34XX_CAM_VS);
+	omap_cfg_reg(C25_34XX_CAM_XCLKA);
+	omap_cfg_reg(C27_34XX_CAM_PCLK);
+	omap_cfg_reg(C23_34XX_CAM_FLD);
+	omap_cfg_reg(AG17_34XX_CAM_D0);
+	omap_cfg_reg(AH17_34XX_CAM_D1);
+	omap_cfg_reg(B24_34XX_CAM_D2);
+	omap_cfg_reg(C24_34XX_CAM_D3);
+	omap_cfg_reg(D24_34XX_CAM_D4);
+	omap_cfg_reg(A25_34XX_CAM_D5);
+	omap_cfg_reg(K28_34XX_CAM_D6);
+	omap_cfg_reg(L28_34XX_CAM_D7);
+	omap_cfg_reg(K27_34XX_CAM_D8);
+	omap_cfg_reg(L27_34XX_CAM_D9);
+	omap_cfg_reg(B25_34XX_CAM_D10);
+	omap_cfg_reg(C26_34XX_CAM_D11);
+	omap_cfg_reg(B23_34XX_CAM_WEN);
+	omap_cfg_reg(D25_34XX_CAM_STROBE);
+	omap_cfg_reg(K8_34XX_GPMC_WAIT2);
+
+	mapphone_camera_lines_safe_mode();
+}
+
diff --git a/arch/arm/mach-omap2/board-mapphone-emu_uart.c b/arch/arm/mach-omap2/board-mapphone-emu_uart.c
new file mode 100644
index 0000000..2d80d17
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-emu_uart.c
@@ -0,0 +1,574 @@
+/*
+ * board-mapphone-emu_uart.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Date         Author          Comment
+ * ===========  ==============  ==============================================
+ * Jun-26-2009  Motorola	Initial revision.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <linux/spi/spi.h>
+#include <mach/system.h>
+#include <linux/irq.h>
+
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include <mach/board-mapphone-emu_uart.h>
+#include <mach/hardware.h>
+#include <mach/omap34xx.h>
+
+/*
+ * Register definitions for CPCAP related SPI register
+ */
+#define OMAP2_MCSPI_MAX_FREQ		48000000
+
+#define OMAP2_MCSPI_REVISION		0x00
+#define OMAP2_MCSPI_SYSCONFIG		0x10
+#define OMAP2_MCSPI_SYSSTATUS		0x14
+#define OMAP2_MCSPI_IRQSTATUS		0x18
+#define OMAP2_MCSPI_IRQENABLE		0x1c
+#define OMAP2_MCSPI_WAKEUPENABLE	0x20
+#define OMAP2_MCSPI_SYST		0x24
+#define OMAP2_MCSPI_MODULCTRL		0x28
+
+/* per-channel banks, 0x14 bytes each, first is: */
+#define OMAP2_MCSPI_CHCONF0		0x2c
+#define OMAP2_MCSPI_CHSTAT0		0x30
+#define OMAP2_MCSPI_CHCTRL0		0x34
+#define OMAP2_MCSPI_TX0			0x38
+#define OMAP2_MCSPI_RX0			0x3c
+
+/* per-register bitmasks: */
+
+#define OMAP2_MCSPI_SYSCONFIG_AUTOIDLE	(1 << 0)
+#define OMAP2_MCSPI_SYSCONFIG_SOFTRESET	(1 << 1)
+#define OMAP2_AFTR_RST_SET_MASTER	(0 << 2)
+
+#define OMAP2_MCSPI_SYSSTATUS_RESETDONE	(1 << 0)
+#define OMAP2_MCSPI_SYS_CON_LVL_1 1
+#define OMAP2_MCSPI_SYS_CON_LVL_2 2
+
+#define OMAP2_MCSPI_MODULCTRL_SINGLE	(1 << 0)
+#define OMAP2_MCSPI_MODULCTRL_MS	(1 << 2)
+#define OMAP2_MCSPI_MODULCTRL_STEST	(1 << 3)
+
+#define OMAP2_MCSPI_CHCONF_PHA		(1 << 0)
+#define OMAP2_MCSPI_CHCONF_POL		(1 << 1)
+#define OMAP2_MCSPI_CHCONF_CLKD_MASK	(0x0f << 2)
+#define OMAP2_MCSPI_CHCONF_EPOL		(1 << 6)
+#define OMAP2_MCSPI_CHCONF_WL_MASK	(0x1f << 7)
+#define OMAP2_MCSPI_CHCONF_TRM_RX_ONLY	(0x01 << 12)
+#define OMAP2_MCSPI_CHCONF_TRM_TX_ONLY	(0x02 << 12)
+#define OMAP2_MCSPI_CHCONF_TRM_MASK	(0x03 << 12)
+#define OMAP2_MCSPI_CHCONF_TRM_TXRX	(~OMAP2_MCSPI_CHCONF_TRM_MASK)
+#define OMAP2_MCSPI_CHCONF_DMAW		(1 << 14)
+#define OMAP2_MCSPI_CHCONF_DMAR		(1 << 15)
+#define OMAP2_MCSPI_CHCONF_DPE0		(1 << 16)
+#define OMAP2_MCSPI_CHCONF_DPE1		(1 << 17)
+#define OMAP2_MCSPI_CHCONF_IS		(1 << 18)
+#define OMAP2_MCSPI_CHCONF_TURBO	(1 << 19)
+#define OMAP2_MCSPI_CHCONF_FORCE	(1 << 20)
+
+#define OMAP2_MCSPI_SYSCFG_WKUP		(1 << 2)
+#define OMAP2_MCSPI_SYSCFG_IDL		(2 << 3)
+#define OMAP2_MCSPI_SYSCFG_CLK		(2 << 8)
+#define OMAP2_MCSPI_WAKEUP_EN		(1 << 1)
+#define OMAP2_MCSPI_IRQ_WKS		(1 << 16)
+#define OMAP2_MCSPI_CHSTAT_RXS		(1 << 0)
+#define OMAP2_MCSPI_CHSTAT_TXS		(1 << 1)
+#define OMAP2_MCSPI_CHSTAT_EOT		(1 << 2)
+
+#define OMAP2_MCSPI_CHCTRL_EN		(1 << 0)
+#define OMAP2_MCSPI_MODE_IS_MASTER	0
+#define OMAP2_MCSPI_MODE_IS_SLAVE	1
+#define OMAP_MCSPI_WAKEUP_ENABLE	1
+
+#define OMAP_MCSPI_BASE                 0xd8098000
+
+#define WORD_LEN            32
+#define CLOCK_DIV           12	/* 2^(12)=4096  48000000/4096<19200 */
+
+#define LEVEL1              1
+#define LEVEL2              2
+#define WRITE_CPCAP         1
+#define READ_CPCAP          0
+
+#define CM_ICLKEN1_CORE  0xd8004A10
+#define CM_FCLKEN1_CORE  0xd8004A00
+#define OMAP2_MCSPI_EN_MCSPI1   (1 << 18)
+
+#define  RESET_FAIL      1
+#define RAW_MOD_REG_BIT(val, mask, set) do { \
+    if (set) \
+		val |= mask; \
+    else \
+		 val &= ~mask; \
+} while (0)
+
+struct cpcap_dev {
+	u16 address;
+	u16 value;
+	u32 result;
+	int access_flag;
+};
+
+static char tx[4];
+static bool emu_uart_is_active = FALSE;
+
+/*   Although SPI driver is provided through linux system as implemented above,
+ *   it can not cover some special situation.
+ *
+ *   During Debug phase, OMAP may need to acess CPCAP by SPI
+ *   to configure or check related register when boot up is not finished.
+ *   However, at this time, spi driver integrated in linux system may not
+ *   be initialized properly.
+ *
+ *   So we provode the following SPI driver with common API for access capcap
+ *   by SPI directly, i.e. we will skip the linux system driver,
+ *   but access SPI hardware directly to configure read/write specially for
+ *   cpcap access.
+ *
+ *   So developer should be very careful to use these APIs:
+ *
+ *        read_cpcap_register_raw()
+ *        write_cpcap_register_raw()
+ *
+ *   Pay attention: Only use them when boot up phase.
+ *   Rasons are as follows:
+ *   1. Although we provide protection on these two APIs for concurrency and
+ *      race conditions, it may impact the performance of system
+ *      because it will mask all interrupts during access.
+ *   2. Calling these APIs will reset all SPI registers, and may make previous
+ *      data lost during run time.
+ *
+ *      So, if developer wants to access CPCAP after boot up is finished,
+ *      we suggest they should use poweric interface.
+ *
+ */
+
+static inline void raw_writel_reg(u32 value, u32 reg)
+{
+#if defined(LOCAL_DEVELOPER_DEBUG)
+	unsigned int absolute_reg;
+
+	absolute_reg = OMAP_MCSPI_BASE + reg;
+	printk(KERN_ERR " raw write reg =0x%x value=0x%x \n", absolute_reg,
+	       value);
+#endif
+
+	__raw_writel(value, OMAP_MCSPI_BASE + reg);
+}
+
+static inline u32 raw_readl_reg(u32 reg)
+{
+	u32 result;
+	unsigned int absolute_reg;
+
+	absolute_reg = OMAP_MCSPI_BASE + reg;
+#if defined(LOCAL_DEVELOPER_DEBUG)
+	printk(KERN_ERR " raw read reg =0x%x  \n", absolute_reg);
+#endif
+	result = __raw_readl(absolute_reg);
+#if defined(LOCAL_DEVELOPER_DEBUG)
+	printk(KERN_ERR " raw read reg =0x%x result =0x%x  \n",
+	       absolute_reg, result);
+#endif
+	return result;
+}
+
+static void raw_omap_mcspi_wakeup_enable(int level)
+{
+	u32 result;
+
+	/* configure SYSCONFIG register...  */
+	if (level == LEVEL1) {
+		result = raw_readl_reg(OMAP2_MCSPI_SYSCONFIG);
+		result =
+		    result | OMAP2_MCSPI_SYSCFG_WKUP |
+		    OMAP2_MCSPI_SYSCFG_IDL | OMAP2_MCSPI_SYSCFG_CLK |
+		    OMAP2_MCSPI_SYSCONFIG_AUTOIDLE;
+		raw_writel_reg(result, OMAP2_MCSPI_SYSCONFIG);
+	}
+
+	if (level == LEVEL2) {
+		result = raw_readl_reg(OMAP2_MCSPI_SYSCONFIG);
+		result =
+		    result | OMAP2_MCSPI_SYSCFG_WKUP |
+		    OMAP2_MCSPI_SYSCFG_IDL |
+		    OMAP2_MCSPI_SYSCONFIG_AUTOIDLE;
+		RAW_MOD_REG_BIT(result, OMAP2_MCSPI_SYSCFG_CLK, 0);
+		raw_writel_reg(result, OMAP2_MCSPI_SYSCONFIG);
+	}
+
+	/* configure wakeupenable register...  */
+	raw_writel_reg(OMAP2_MCSPI_WAKEUP_EN, OMAP2_MCSPI_WAKEUPENABLE);
+
+	/* configure enable interrupt register... */
+	result = raw_readl_reg(OMAP2_MCSPI_IRQENABLE);
+	result = result | OMAP2_MCSPI_IRQ_WKS;
+	raw_writel_reg(result, OMAP2_MCSPI_IRQENABLE);
+}
+
+static void raw_omap2_mcspi_set_master_mode(void)
+{
+	u32 result;
+
+	/* configure MCSPI_MODULCTRL register... */
+	result = raw_readl_reg(OMAP2_MCSPI_MODULCTRL);
+
+	RAW_MOD_REG_BIT(result, OMAP2_MCSPI_MODULCTRL_STEST, 0);
+	RAW_MOD_REG_BIT(result, OMAP2_MCSPI_MODULCTRL_MS,
+			OMAP2_MCSPI_MODE_IS_MASTER);
+	RAW_MOD_REG_BIT(result, OMAP2_MCSPI_MODULCTRL_SINGLE, 1);
+
+	raw_writel_reg(result, OMAP2_MCSPI_MODULCTRL);
+}
+
+static void raw_omap2_mcspi_channel_config(void)
+{
+	u32 result;
+
+	/* select channel 0... otherwise 0x14*channel_num */
+	result = raw_readl_reg(OMAP2_MCSPI_CHCONF0);
+
+	/* configure master mode... */
+	result &= ~OMAP2_MCSPI_CHCONF_IS;
+	result &= ~OMAP2_MCSPI_CHCONF_DPE1;
+	result |= OMAP2_MCSPI_CHCONF_DPE0;
+
+	/* configure wordlength  */
+	result &= ~OMAP2_MCSPI_CHCONF_WL_MASK;
+	result |= (WORD_LEN - 1) << 7;
+
+	/*  configure active high  */
+	result &= ~OMAP2_MCSPI_CHCONF_EPOL;
+
+	/* set clock divisor  */
+	result &= ~OMAP2_MCSPI_CHCONF_CLKD_MASK;
+	result |= CLOCK_DIV << 2;
+
+	/* configure mode  polarity=0 phase=0  */
+	result &= ~OMAP2_MCSPI_CHCONF_POL;
+	result &= ~OMAP2_MCSPI_CHCONF_PHA;
+
+	raw_writel_reg(result, OMAP2_MCSPI_CHCONF0);
+
+}
+
+static void raw_mcspi_setup(void)
+{
+	raw_omap_mcspi_wakeup_enable(LEVEL1);
+	raw_omap2_mcspi_set_master_mode();
+	raw_omap2_mcspi_channel_config();
+	raw_omap_mcspi_wakeup_enable(LEVEL2);
+}
+
+static int raw_mcspi_reset(void)
+{
+	unsigned long timeout;
+	u32 tmp;
+
+	raw_omap_mcspi_wakeup_enable(LEVEL1);
+
+	raw_writel_reg(OMAP2_MCSPI_SYSCONFIG_SOFTRESET,
+		      OMAP2_MCSPI_SYSCONFIG);
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+
+	do {
+		tmp = raw_readl_reg(OMAP2_MCSPI_SYSSTATUS);
+		if (time_after(jiffies, timeout)) {
+			printk(KERN_ERR "SPI Error: Reset is time out!\n");
+			return -RESET_FAIL;
+		}
+	} while (!(tmp & OMAP2_MCSPI_SYSSTATUS_RESETDONE));
+
+	/*configure all modules in  reset master mode */
+	raw_writel_reg(OMAP2_AFTR_RST_SET_MASTER, OMAP2_MCSPI_MODULCTRL);
+
+	/* call wakeup function to set sysconfig as per pm activity */
+	raw_omap_mcspi_wakeup_enable(LEVEL1);
+	raw_omap_mcspi_wakeup_enable(LEVEL2);
+
+	return 0;
+}
+
+static void raw_omap2_mcspi_force_cs(int enable_tag)
+{
+	u32 result;
+	result = raw_readl_reg(OMAP2_MCSPI_CHCONF0);
+	/*
+	 * Manual spim_csx assertion to keep spim_csx for channel x active
+	 * RW 0x0 between SPI words (single channel master mode only).
+	 */
+	RAW_MOD_REG_BIT(result, OMAP2_MCSPI_CHCONF_FORCE, enable_tag);
+	raw_writel_reg(result, OMAP2_MCSPI_CHCONF0);
+}
+
+static void raw_omap2_mcspi_set_enable(int enable)
+{
+	u32 result;
+
+	result = enable ? OMAP2_MCSPI_CHCTRL_EN : 0;
+	raw_writel_reg(result, OMAP2_MCSPI_CHCTRL0);
+}
+
+
+static int raw_mcspi_wait_for_reg_bit(unsigned long reg, unsigned long bit)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+
+	while (!(raw_readl_reg(reg) & bit)) {
+		if (time_after(jiffies, timeout))
+			return -1;
+	}
+
+	return 0;
+}
+
+static void parser_cpcap(struct cpcap_dev *dev)
+{
+	if (dev->access_flag == WRITE_CPCAP) {
+		tx[3] = ((dev->address >> 6) & 0x000000FF) | 0x80;
+		tx[2] = (dev->address << 2) & 0x000000FF;
+		tx[1] = (dev->value >> 8) & 0x000000FF;
+		tx[0] = dev->value & 0x000000FF;
+	} else {
+		tx[3] = ((dev->address >> 6) & 0x000000FF);
+		tx[2] = (dev->address << 2) & 0x000000FF;
+		tx[1] = 1;
+		tx[0] = 1;
+	}
+}
+
+static void raw_omap2_mcspi_txrx_pio(struct cpcap_dev *dev)
+{
+	u32 result;
+	u32 tx_32bit;
+
+	/* config tranmission mode --- tx rx together */
+	result = raw_readl_reg(OMAP2_MCSPI_CHCONF0);
+	result &= ~OMAP2_MCSPI_CHCONF_TRM_MASK;
+	raw_writel_reg(result, OMAP2_MCSPI_CHCONF0);
+
+	/* enable the mcspi port! */
+	raw_omap2_mcspi_set_enable(1);
+
+	parser_cpcap(dev);
+
+	memcpy((void *)&tx_32bit, (void *)tx, 4);
+
+	if (raw_mcspi_wait_for_reg_bit(OMAP2_MCSPI_CHSTAT0,
+				       OMAP2_MCSPI_CHSTAT_TXS) < 0) {
+		printk(KERN_ERR "SPI Error: TXS timed out\n");
+		goto out;
+	}
+	raw_writel_reg(tx_32bit, OMAP2_MCSPI_TX0);
+
+	if (raw_mcspi_wait_for_reg_bit(OMAP2_MCSPI_CHSTAT0,
+				       OMAP2_MCSPI_CHSTAT_RXS) < 0) {
+		printk(KERN_ERR "SPI Error: RXS timed out\n");
+		goto out;
+	}
+
+	result = raw_readl_reg(OMAP2_MCSPI_RX0);
+
+	dev->result = result;
+
+out:
+	/* disable the mcspi port! */
+	raw_omap2_mcspi_set_enable(0);
+}
+
+static void raw_mcspi_run(struct cpcap_dev *dev)
+{
+	raw_omap_mcspi_wakeup_enable(LEVEL1);
+	raw_omap2_mcspi_set_master_mode();
+	raw_omap2_mcspi_channel_config();
+	raw_omap2_mcspi_force_cs(1);
+	raw_omap2_mcspi_txrx_pio(dev);
+	raw_omap2_mcspi_force_cs(0);
+	raw_omap_mcspi_wakeup_enable(LEVEL2);
+}
+
+static void raw_omap_mcspi_enable_IFclock(void)
+{
+	u32 result;
+
+	result = __raw_readl(CM_FCLKEN1_CORE);
+	RAW_MOD_REG_BIT(result, OMAP2_MCSPI_EN_MCSPI1, 1);
+	__raw_writel(result, CM_FCLKEN1_CORE);
+
+	result = __raw_readl(CM_ICLKEN1_CORE);
+	RAW_MOD_REG_BIT(result, OMAP2_MCSPI_EN_MCSPI1, 1);
+	__raw_writel(result, CM_ICLKEN1_CORE);
+
+}
+
+/*
+ * write_cpcap_register_raw is for cpcap spi write directly
+ * @return 0 on success; less than zero on failure.
+ */
+static int write_cpcap_register_raw(u16 addr, u16 val)
+{
+	int result;
+	unsigned long intr_flags;
+	struct cpcap_dev cpcap_write;
+
+#ifdef CONFIG_EMU_UART_DEBUG
+	if (is_emu_uart_active() && (addr == 897 || addr == 411))
+		return 0;
+#endif
+
+	local_irq_save(intr_flags);
+	raw_omap_mcspi_enable_IFclock();
+
+	result = raw_mcspi_reset();
+	if (result < 0) {
+		local_irq_restore(intr_flags);
+		printk(KERN_ERR "reset failed !\n");
+		return result;
+	}
+
+	raw_mcspi_setup();
+
+	cpcap_write.address = addr;
+	cpcap_write.value = val;
+	cpcap_write.access_flag = WRITE_CPCAP;
+	raw_mcspi_run(&cpcap_write);
+
+	local_irq_restore(intr_flags);
+
+	return result;
+}
+
+/*
+ *  read_cpcap_register_raw is for cpcap spi read directly,
+ *  read result is in val
+ *  @return 0 on success; less than zero on failure.
+ */
+static int read_cpcap_register_raw(u16 addr, u16 *val)
+{
+	int result;
+	unsigned long intr_flag;
+	struct cpcap_dev cpcap_read;
+
+	local_irq_save(intr_flag);
+	raw_omap_mcspi_enable_IFclock();
+
+	result = raw_mcspi_reset();
+	if (result < 0) {
+		local_irq_restore(intr_flag);
+		printk(KERN_ERR "reset failed !\n");
+		return result;
+	}
+
+	raw_mcspi_setup();
+
+	cpcap_read.address = addr;
+	cpcap_read.access_flag = READ_CPCAP;
+	raw_mcspi_run(&cpcap_read);
+	*val = cpcap_read.result;
+
+	local_irq_restore(intr_flag);
+
+	return result;
+}
+
+/*
+ * Check if the writting is allowed. If MiniUSB port has already been
+ * configured as UART3, we should ignore some SCM register writting.
+ */
+int is_emu_uart_iomux_reg(unsigned short offset)
+{
+	if ((emu_uart_is_active) && \
+	    ((offset >= 0x1A2 && offset < 0x1BA) || (offset == 0x19E)))
+		return 1;
+	else
+		return 0;
+}
+
+bool is_emu_uart_active(void)
+{
+	return emu_uart_is_active;
+}
+
+static void write_omap_mux_register(u16 offset, u8 mode, u8 input_en)
+{
+	u16 tmp_val, reg_val;
+	u32 reg = OMAP343X_CTRL_BASE + offset;
+
+	reg_val = mode | (input_en << 8);
+	tmp_val = omap_readw(reg) & ~(0x0007 | (1 << 8));
+	reg_val = reg_val | tmp_val;
+	omap_writew(reg_val, reg);
+}
+
+void activate_emu_uart(void)
+{
+	int i;
+
+	/*
+	 * Step 1:
+	 * Configure OMAP SCM to set all ULPI pin of USB OTG to SAFE MODE
+	 */
+	for (i = 0; i < 0x18; i += 2)
+		write_omap_mux_register(0x1A2 + i, 7, 0);
+
+	/*
+	 * Step 2:
+	 * Configure CPCAP to route UART3 to USB port; Switch VBUSIN to supply
+	 * UART/USB transeiver and set VBUS standby mode 3
+	 */
+	write_cpcap_register_raw(897, 0x0101);
+	write_cpcap_register_raw(411, 0x014C);
+
+	/* Step 3:
+	 * Configure OMAP SCM to set ULPI port as UART3 function
+	 */
+	/*
+	 * Set UART3 RX pin in safe mode
+	 */
+	write_omap_mux_register(0x19E, 7, 0);
+	/*
+	 * Route UART3 TX to ULPIDATA0, RX to ULPIDATA1
+	 */
+	write_omap_mux_register(0x1AA, 2, 0);
+	write_omap_mux_register(0x1AC, 2, 1);
+
+	emu_uart_is_active = TRUE;
+	printk
+	    (KERN_ALERT "WARNING: MiniUSB port works in UART3 mode,"
+	     "the USB functionality UNAVAILABLE!\n");
+
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-flash.c b/arch/arm/mach-omap2/board-mapphone-flash.c
new file mode 100644
index 0000000..0d7a189
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-flash.c
@@ -0,0 +1,118 @@
+/*
+ * linux/arch/arm/mach-omap2/board-mapphone-flash.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Modified from mach-omap2/board-3430sdp-flash.c
+ *
+ * Copyright (c) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-2430sdp-flash.c
+ * Author: Rohit Choraria <rohitkc@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/onenand_regs.h>
+#include <linux/types.h>
+#include <linux/io.h>
+
+#include <asm/mach/flash.h>
+#include <mach/onenand.h>
+#include <mach/board.h>
+#include <mach/gpmc.h>
+#include <mach/nand.h>
+
+#define NAND_GPMC_CS		0
+
+static struct mtd_partition sdp_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name		= "X-Loader-NAND",
+		.offset		= 0,
+		.size		= 4 * (64 * 2048),
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "U-Boot-NAND",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x80000 */
+		.size		= 4 * (64 * 2048),
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "Boot Env-NAND",
+
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x100000 */
+		.size		= 2 * (64 * 2048),
+	},
+	{
+		.name		= "Kernel-NAND",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x140000 */
+		.size		= 32 * (64 * 2048),
+
+
+	},
+	{
+		.name		= "File System - NAND",
+		.size		= MTDPART_SIZ_FULL,
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x540000 */
+	},
+};
+
+
+static struct omap_nand_platform_data sdp_nand_data = {
+	.parts		= sdp_nand_partitions,
+	.nr_parts	= ARRAY_SIZE(sdp_nand_partitions),
+	.nand_setup	= NULL,
+	.dma_channel	= -1,		/* disable DMA in OMAP NAND driver */
+	.dev_ready	= NULL,
+	.cs		= NAND_GPMC_CS,
+	.gpmc_cs_baseaddr = (void *)(OMAP34XX_GPMC_VIRT + GPMC_CS0_BASE +
+		NAND_GPMC_CS*GPMC_CS_SIZE),
+	.gpmc_baseaddr  = (void *)(OMAP34XX_GPMC_VIRT),
+};
+
+
+static struct resource sdp_nand_resource = {
+	.flags		= IORESOURCE_MEM,
+};
+
+
+static struct platform_device sdp_nand_device = {
+	.name		= "omap2-nand",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &sdp_nand_data,
+	},
+	.num_resources	= 1,
+	.resource	= &sdp_nand_resource,
+};
+
+static int omap_nand_dev_ready(struct omap_nand_platform_data *data)
+{
+	printk(KERN_INFO "RDY/BSY line is connected!\n");
+	return 0;
+}
+
+/**
+ * mapphone_flash_init - Identify devices connected to GPMC and register.
+ *
+ * @return - void.
+ */
+void __init mapphone_flash_init(void)
+{
+	/* We know the RDY/BSY line is connected now */
+	sdp_nand_data.dev_ready = omap_nand_dev_ready;
+
+	if (platform_device_register(&sdp_nand_device) < 0)
+		printk(KERN_ERR "Unable to register NAND device\n");
+
+	return;
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-gpio.c b/arch/arm/mach-omap2/board-mapphone-gpio.c
new file mode 100644
index 0000000..8eaa09b
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-gpio.c
@@ -0,0 +1,311 @@
+/*
+ * board-mapphone-gpio.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Date	 Author	  Comment
+ * ===========  ==============  ==============================================
+ * Jun-23-2009  Motorola	Initial revision.
+ */
+
+#include <linux/module.h>
+
+#ifdef CONFIG_GPIODEV
+#include <linux/gpiodev.h>
+#endif
+
+#ifdef CONFIG_GPIO_MAPPING
+#include <linux/gpio_mapping.h>
+#endif
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#ifdef CONFIG_GPIODEV
+#define GPIO_DEVICE_SIZE 20
+#define GPIO_DEVICE_UNUSED 0xFFFF
+
+static struct gpio_device gpio_devs[GPIO_DEVICE_SIZE] = {
+	{
+		111,
+		"slide_interrupt",
+		GPIODEV_CONFIG_INPUT | GPIODEV_CONFIG_INT_LLEV,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		149,
+		"gps_rts",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		59,
+		"gps_reset",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		136,
+		"gps_standby",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		160,
+		"gps_interrupt",
+		GPIODEV_CONFIG_INPUT | GPIODEV_CONFIG_INT_REDG,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		GPIO_DEVICE_UNUSED,
+	},
+};
+
+static struct gpio_device_platform_data gpio_device_data = {
+	.name = "mapphone-gpiodev",
+	.info = gpio_devs,
+};
+
+static struct platform_device mapphone_gpiodev_device = {
+	.name = GPIO_DEVICE_DEV_NAME,
+	.id = 0,
+	.dev = {
+		.platform_data = &gpio_device_data,
+	},
+};
+
+#ifdef CONFIG_ARM_OF
+/**
+ * Below structure definition should strictly comform to corresponding
+ * HW device tree format
+ */
+struct omap_gpiodev_entry {
+	u32 pin_num;				/* GPIO pin number  */
+	char name[GPIO_DEVICE_NAME_LEN];	/* GPIODev name */
+	u32 setting;				/* GPIO pin setting */
+} __attribute__ ((__packed__));
+
+static void gpiodev_devs_init(void *p_data)
+{
+	struct omap_gpiodev_entry *p = p_data;
+	struct gpio_device *p_devs = gpio_devs;
+	int i = 0;
+
+	while ((i < GPIO_DEVICE_NAME_LEN) && (' ' != p->name[i]))
+		i++;
+	p->name[i] = '\0';
+
+	for (i = 0; i < GPIO_DEVICE_SIZE; i++) {
+		if (p_devs[i].pin_nr == GPIO_DEVICE_UNUSED) {
+			p_devs[i].pin_nr = p->pin_num;
+			strcpy(p_devs[i].device_name, p->name);
+			p_devs[i].init_config = p->setting;
+			p_devs[i].current_config = GPIODEV_CONFIG_INVALID;
+			p_devs[i].flags = GPIODEV_FLAG_CONFIGURABLE |
+						GPIODEV_FLAG_LOWLEVELACCESS;
+
+			if (i != (GPIO_DEVICE_SIZE - 1))
+				p_devs[i + 1].pin_nr = GPIO_DEVICE_UNUSED;
+
+			printk(KERN_INFO "GPIODev: Add new device [%s] setting!\n",
+					p->name);
+			return;
+		}
+
+		if (strncmp(p_devs[i].device_name, p->name,
+			GPIO_DEVICE_NAME_LEN) == 0) {
+			p_devs[i].pin_nr = p->pin_num;
+			p_devs[i].init_config = p->setting;
+			p_devs[i].current_config = GPIODEV_CONFIG_INVALID;
+			p_devs[i].flags = GPIODEV_FLAG_CONFIGURABLE |
+						GPIODEV_FLAG_LOWLEVELACCESS;
+
+			printk(KERN_INFO "GPIODev: Overwrite device [%s] setting!\n",
+					p->name);
+			return;
+		}
+
+		if (i == (GPIO_DEVICE_SIZE - 1))
+			printk(KERN_ERR "GPIODev: Too big gpiodev count!\n");
+	}
+}
+
+static void gpio_devs_of_init(void)
+{
+	int size, unit_size, i, count;
+	struct device_node *node;
+	const void *prop;
+
+	node = of_find_node_by_path(DT_PATH_GPIOGEV);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_GPIOGEV);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_gpiodev_entry);
+	prop = of_get_property(node, DT_PROP_GPIODEV_INIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_GPIODEV_INIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "gpio_dev_size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		gpiodev_devs_init((struct omap_gpiodev_entry *)prop + i);
+
+	of_node_put(node);
+	return;
+}
+#endif
+
+static int __init mapphone_init_gpiodev(void)
+{
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	gpio_devs_of_init();
+#endif
+
+	for (i = 0; i < GPIO_DEVICE_SIZE; i++) {
+		if (gpio_devs[i].pin_nr == GPIO_DEVICE_UNUSED)
+			break;
+	}
+	gpio_device_data.info_count = i;
+
+	return platform_device_register(&mapphone_gpiodev_device);
+}
+device_initcall(mapphone_init_gpiodev);
+#endif
+
+#ifdef CONFIG_GPIO_MAPPING
+#define GPIO_MAP_SIZE 50
+
+static struct gpio_mapping gpio_map_table[GPIO_MAP_SIZE] = {
+	{1, 92, "lcd_panel_reset"},
+	{1, 93, "lcd_panel_sd"},
+	{1, 149, "usb_ipc_phy_reset"},
+	{1, 164, "touch_panel_reset"},
+	{1, 163, "mmc_detect"},
+	{1, 177, "slider_data"},
+	{1, 65, "wlan_host_wake"},
+};
+
+#ifdef CONFIG_ARM_OF
+struct omap_gpio_map_entry {
+	u32 pin_num;
+	char name[GPIO_MAP_NAME_SIZE];
+} __attribute__ ((__packed__));
+
+void trim_gpio_map_string(char *s)
+{
+	int i;
+
+	/* ignore all characters behind space key */
+	for (i = 0; i < GPIO_MAP_NAME_SIZE; i++) {
+		if (' ' == s[i]) {
+			s[i] = '\0';
+			return;
+		}
+	}
+
+	printk(KERN_ERR "Too long gpio map string name!\n");
+}
+#endif
+#endif
+
+void __init mapphone_gpio_mapping_init(void)
+{
+#ifdef CONFIG_GPIO_MAPPING
+#ifdef CONFIG_ARM_OF
+	struct device_node *node;
+	const void *prop;
+	int i, j, size, unit_size;
+	char name[GPIO_MAP_NAME_SIZE];
+
+	node = of_find_node_by_path(DT_PATH_GPIO);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_GPIO);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_gpio_map_entry);
+	prop = of_get_property(node, DT_PROP_GPIO_MAP, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_GPIO_MAP);
+		of_node_put(node);
+		return;
+	}
+
+	for (i = 0; i < size / unit_size; i++) {
+		struct omap_gpio_map_entry *p =
+				(struct omap_gpio_map_entry *) prop;
+
+		memcpy((void *) name, p->name, GPIO_MAP_NAME_SIZE);
+		trim_gpio_map_string(name);
+
+		for (j = 0; j < GPIO_MAP_SIZE; j++) {
+			if (gpio_map_table[j].used == 0) {
+				gpio_map_table[j].used = 1;
+				gpio_map_table[j].pin_num = p->pin_num;
+				strncpy(gpio_map_table[j].name, name,
+						GPIO_MAP_NAME_SIZE);
+				break;
+			} else if (strncmp(gpio_map_table[j].name, name,
+					GPIO_MAP_NAME_SIZE) == 0) {
+				gpio_map_table[j].pin_num = p->pin_num;
+				break;
+			}
+		}
+
+		if (j == GPIO_MAP_SIZE)
+			printk(KERN_ERR "Unable to write gpio_map_table\n");
+		else
+			printk(KERN_INFO "GPIO mapping write: pin = %d, name = %s\n",
+						gpio_map_table[j].pin_num,
+						gpio_map_table[j].name);
+
+		prop += unit_size;
+	}
+
+	of_node_put(node);
+	printk(KERN_INFO "DT overwrite GPIO Mapping done!\n");
+#else
+	printk(KERN_INFO "GPIO Mapping: Using no-dt configuration!\n");
+#endif
+	gpio_mapping_init(gpio_map_table, GPIO_MAP_SIZE);
+	printk(KERN_INFO "GPIO Mapping init done!\n");
+#else
+	printk(KERN_INFO "GPIO Mapping unused!\n");
+#endif
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-hsmmc.c b/arch/arm/mach-omap2/board-mapphone-hsmmc.c
new file mode 100644
index 0000000..89740d7
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-hsmmc.c
@@ -0,0 +1,350 @@
+/*
+ * linux/arch/arm/mach-omap2/board-mapphone-hsmm.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from linux/arch/arm/mach-omap2/board-sdp-hsmmc.c
+ *
+ * Copyright (C) 2007-2008 Texas Instruments
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/hardware.h>
+#include <mach/control.h>
+#include <mach/mmc.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+
+#define GPIO_SIGNAL_MMC_DET 163
+
+static const int mmc2_cd_gpio = OMAP_MAX_GPIO_LINES + 1;
+
+static int hsmmc_card_detect(int irq)
+{
+	return !gpio_get_value_cansleep(GPIO_SIGNAL_MMC_DET);
+}
+
+#ifdef CONFIG_OMAP_HS_MMC2
+extern int mapphone_wifi_status(int irq);
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern int mapphone_wifi_status_register(void (*callback)(int card_present,
+						void *dev_id), void *dev_id);
+#endif
+
+static int hsmmc2_card_detect(int irq)
+{
+	return mapphone_wifi_status(irq);
+}
+#endif
+
+/*
+ * MMC Slot Initialization.
+ */
+static struct regulator *hsmmc_regulator;
+static unsigned char hsmmc_regulator_is_on;
+DEFINE_MUTEX(regulator_lock);
+
+static int hsmmc_late_init(struct device *dev)
+{
+	int ret = 0;
+
+	/*
+	 * Configure GPIO parameters for MMC hotplug irq
+	 */
+	ret = gpio_request(GPIO_SIGNAL_MMC_DET, "mmc_detect");
+	if (ret < 0)
+		goto err;
+	ret = gpio_direction_input(GPIO_SIGNAL_MMC_DET);
+	if (ret < 0)
+		goto err2;
+
+	hsmmc_regulator = regulator_get(NULL, "vwlan2");
+	if (IS_ERR(hsmmc_regulator)) {
+		dev_dbg(dev, "vwlan2 regulator missing\n");
+		ret = PTR_ERR(hsmmc_regulator);
+		goto err2;
+	}
+
+	return ret;
+err2:
+	gpio_free(GPIO_SIGNAL_MMC_DET);
+err:
+	dev_err(dev, "Failed to configure GPIO MMC_DET\n");
+	return ret;
+}
+
+static void hsmmc_cleanup(struct device *dev)
+{
+	gpio_free(GPIO_SIGNAL_MMC_DET);
+	if (hsmmc_regulator)
+		regulator_put(hsmmc_regulator);
+}
+
+#ifdef CONFIG_PM
+/*
+ * To mask and unmask MMC Card Detect Interrupt
+ * mask : 1
+ * unmask : 0
+ */
+static int mask_cd_interrupt(int mask)
+{
+	return 0;
+}
+
+static int hsmmc_suspend(struct device *dev, int slot)
+{
+	int ret = 0;
+
+	disable_irq(gpio_to_irq(GPIO_SIGNAL_MMC_DET));
+	ret = mask_cd_interrupt(1);
+
+	return ret;
+}
+
+static int hsmmc_resume(struct device *dev, int slot)
+{
+	int ret = 0;
+
+	enable_irq(gpio_to_irq(GPIO_SIGNAL_MMC_DET));
+	ret = mask_cd_interrupt(0);
+
+	return ret;
+}
+#endif
+
+static int hsmmc_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	u32 reg;
+	int ret = 0;
+
+	if (power_on) {
+		reg = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0);
+		reg |= OMAP2_MMCSDIO1ADPCLKISEL;
+		omap_ctrl_writel(reg, OMAP2_CONTROL_DEVCONF0);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg &= ~OMAP2_PBIASSPEEDCTRL0;
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		mutex_lock(&regulator_lock);
+		if (!hsmmc_regulator_is_on) {
+			hsmmc_regulator_is_on = 1;
+			regulator_enable(hsmmc_regulator);
+			msleep(4);
+		}
+		mutex_unlock(&regulator_lock);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg |= OMAP2_PBIASLITEPWRDNZ0;
+		if ((1 << vdd) <= MMC_VDD_165_195)
+			reg &= ~OMAP2_PBIASLITEVMODE0;
+		else
+			reg |= OMAP2_PBIASLITEVMODE0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		return ret;
+	} else {
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		mutex_lock(&regulator_lock);
+		if (hsmmc_regulator_is_on) {
+			hsmmc_regulator_is_on = 0;
+			regulator_disable(hsmmc_regulator);
+			msleep(20);
+		}
+		mutex_unlock(&regulator_lock);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg |= (OMAP2_PBIASLITEPWRDNZ0 | OMAP2_PBIASLITEVMODE0);
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_MMC_TST
+int ex_hsmmc_set_power(struct device *dev, int slot, int power_on,
+						int vdd)
+{
+    hsmmc_set_power(dev, slot, power_on, vdd);
+    return 0;
+}
+EXPORT_SYMBOL(ex_hsmmc_set_power);
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+static int hsmmc2_late_init(struct device *dev)
+{
+	return 0;
+}
+
+static void hsmmc2_cleanup(struct device *dev)
+{
+}
+
+static int hsmmc2_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hsmmc2_suspend(struct device *dev, int slot)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int hsmmc2_resume(struct device *dev, int slot)
+{
+	int ret = 0;
+	return ret;
+}
+#endif
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC3)
+static int hsmmc3_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	/* Power to the slot is hard wired */
+	return 0;
+}
+#endif
+
+static struct omap_mmc_platform_data mmc1_data = {
+	.nr_slots			= 1,
+	.init				= hsmmc_late_init,
+	.cleanup			= hsmmc_cleanup,
+#ifdef CONFIG_PM
+	.suspend			= hsmmc_suspend,
+	.resume				= hsmmc_resume,
+#endif
+	.dma_mask			= 0xffffffff,
+	.slots[0] = {
+		.wires			= 8,
+		.set_power		= hsmmc_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34 |
+						MMC_VDD_165_195,
+		.name			= "first slot",
+		/* we get car_detect_irq later */
+		.card_detect_irq	= 0,
+		.card_detect            = hsmmc_card_detect,
+	},
+};
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+static struct sdio_embedded_func wifi_func_array[] = {
+	{
+		.f_class        = SDIO_CLASS_NONE,
+		.f_maxblksize   = 0,
+	},
+	{
+		.f_class        = SDIO_CLASS_WLAN,
+		.f_maxblksize   = 512,
+	},
+};
+
+static struct embedded_sdio_data mapphone_wifi_emb_data = {
+	.cis    = {
+		.vendor         = 0x104c,
+		.device         = 0x9066,
+		.blksize        = 512,
+		.max_dtr        = 24000000,
+	},
+	.cccr   = {
+		.multi_block    = 1,
+		.low_speed      = 0,
+		.wide_bus       = 1,
+		.high_power     = 0,
+		.high_speed     = 0,
+	},
+	.funcs  = wifi_func_array,
+	.num_funcs = 2,
+};
+#endif
+
+static struct omap_mmc_platform_data mmc2_data = {
+	.nr_slots			= 1,
+	.init				= hsmmc2_late_init,
+	.cleanup			= hsmmc2_cleanup,
+#ifdef CONFIG_PM
+	.suspend			= hsmmc2_suspend,
+	.resume				= hsmmc2_resume,
+#endif
+	.dma_mask			= 0xffffffff,
+#ifndef CONFIG_MMC_EMBEDDED_SDIO
+	.name				= "TIWLAN_SDIO",
+#endif
+	.slots[0] = {
+		.wires			= 4,
+		.set_power		= hsmmc2_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34 |
+						MMC_VDD_165_195,
+		.name			= "first slot",
+		.internal_clock		= 1,
+		.card_detect_irq        = 0,
+		.card_detect            = hsmmc2_card_detect,
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		.embedded_sdio		= &mapphone_wifi_emb_data,
+		.register_status_notify	= &mapphone_wifi_status_register,
+#endif
+	},
+};
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC3)
+static struct omap_mmc_platform_data mmc3_data = {
+	.nr_slots			= 1,
+	.init				= NULL,
+	.cleanup			= NULL,
+	.dma_mask			= 0xffffffff,
+	.slots[0] = {
+		.wires			= 4,
+		.set_power		= hsmmc3_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34,
+		.name			= "first slot",
+
+		.card_detect_irq        = 0,
+		.card_detect            = NULL,
+	},
+};
+#endif
+
+static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC];
+
+void __init mapphone_hsmmc_init(void)
+{
+	hsmmc_data[0] = &mmc1_data;
+
+	mmc1_data.slots[0].card_detect_irq = gpio_to_irq(GPIO_SIGNAL_MMC_DET);
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+	hsmmc_data[1] = &mmc2_data;
+#endif
+#if defined(CONFIG_OMAP_HS_MMC3)
+	hsmmc_data[2] = &mmc3_data;
+#endif
+	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-keypad.c b/arch/arm/mach-omap2/board-mapphone-keypad.c
new file mode 100644
index 0000000..af16e68
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-keypad.c
@@ -0,0 +1,253 @@
+/*
+ * arch/arm/mach-omap2/board-mapphone-keypad.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/gpio_event.h>
+#include <linux/keyreset.h>
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+#include <mach/board-mapphone.h>
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+static unsigned int mapphone_col_gpios[] = { 43, 53, 54, 55, 56, 57, 58, 63 };
+static unsigned int mapphone_row_gpios[] = { 34, 35, 36, 37, 38, 39, 40, 41 };
+
+#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(mapphone_row_gpios) + (row))
+
+static const unsigned short mapphone_p3_keymap[ARRAY_SIZE(mapphone_col_gpios) *
+					     ARRAY_SIZE(mapphone_row_gpios)] = {
+	[KEYMAP_INDEX(0, 0)] = KEY_9,
+	[KEYMAP_INDEX(0, 1)] = KEY_R,
+	[KEYMAP_INDEX(0, 2)] = KEY_SEND, /* n/c dummy for CALLSEND testing*/
+	[KEYMAP_INDEX(0, 3)] = KEY_VOLUMEDOWN,
+	[KEYMAP_INDEX(0, 4)] = KEY_F4,   /* n/c dummy for CALLEND testing */
+	[KEYMAP_INDEX(0, 5)] = KEY_VOLUMEUP,
+	[KEYMAP_INDEX(0, 6)] = KEY_SEARCH,
+	[KEYMAP_INDEX(0, 7)] = KEY_D,
+
+	[KEYMAP_INDEX(1, 0)] = KEY_7,
+	[KEYMAP_INDEX(1, 1)] = KEY_M,
+	[KEYMAP_INDEX(1, 2)] = KEY_L,
+	[KEYMAP_INDEX(1, 3)] = KEY_K,
+	[KEYMAP_INDEX(1, 4)] = KEY_N,
+	[KEYMAP_INDEX(1, 5)] = KEY_C,
+	[KEYMAP_INDEX(1, 6)] = KEY_Z,
+	[KEYMAP_INDEX(1, 7)] = KEY_RIGHTSHIFT,
+
+	[KEYMAP_INDEX(2, 0)] = KEY_1,
+	[KEYMAP_INDEX(2, 1)] = KEY_Y,
+	[KEYMAP_INDEX(2, 2)] = KEY_I,
+	[KEYMAP_INDEX(2, 3)] = KEY_COMMA,
+	[KEYMAP_INDEX(2, 4)] = KEY_LEFTALT,
+	[KEYMAP_INDEX(2, 5)] = KEY_DOT,
+	[KEYMAP_INDEX(2, 6)] = KEY_G,
+	[KEYMAP_INDEX(2, 7)] = KEY_E,
+
+/*	[KEYMAP_INDEX(3, 0)] = KEY_, */
+	[KEYMAP_INDEX(3, 1)] = KEY_6,
+	[KEYMAP_INDEX(3, 2)] = KEY_3,
+	[KEYMAP_INDEX(3, 3)] = KEY_DOWN,
+	[KEYMAP_INDEX(3, 4)] = KEY_UP,
+	[KEYMAP_INDEX(3, 5)] = KEY_LEFT,
+	[KEYMAP_INDEX(3, 6)] = KEY_RIGHT,
+	[KEYMAP_INDEX(3, 7)] = KEY_REPLY,	/* d-pad center key */
+
+	[KEYMAP_INDEX(4, 0)] = KEY_5,
+	[KEYMAP_INDEX(4, 1)] = KEY_J,
+	[KEYMAP_INDEX(4, 2)] = KEY_B,
+	[KEYMAP_INDEX(4, 3)] = KEY_CAMERA-1,	/* camera 1 key, steal KEY_HP*/
+	[KEYMAP_INDEX(4, 4)] = KEY_T,
+	[KEYMAP_INDEX(4, 5)] = KEY_CAMERA,	/* "camera 2" key */
+	[KEYMAP_INDEX(4, 6)] = KEY_MENU,
+	[KEYMAP_INDEX(4, 7)] = KEY_X,
+
+	[KEYMAP_INDEX(5, 0)] = KEY_8,
+	[KEYMAP_INDEX(5, 1)] = KEY_SPACE,
+	[KEYMAP_INDEX(5, 2)] = KEY_RIGHTALT,
+/*	[KEYMAP_INDEX(5, 3)] = KEY_, */
+	[KEYMAP_INDEX(5, 4)] = KEY_SLASH,
+	[KEYMAP_INDEX(5, 5)] = KEY_EMAIL,	/* @ */
+	[KEYMAP_INDEX(5, 6)] = KEY_BACKSPACE,
+	[KEYMAP_INDEX(5, 7)] = KEY_A,
+
+	[KEYMAP_INDEX(6, 0)] = KEY_2,
+	[KEYMAP_INDEX(6, 1)] = KEY_0,
+	[KEYMAP_INDEX(6, 2)] = KEY_F,
+	[KEYMAP_INDEX(6, 3)] = KEY_LEFTSHIFT,
+	[KEYMAP_INDEX(6, 4)] = KEY_ENTER,
+	[KEYMAP_INDEX(6, 5)] = KEY_O,
+	[KEYMAP_INDEX(6, 6)] = KEY_H,
+	[KEYMAP_INDEX(6, 7)] = KEY_Q,
+
+	[KEYMAP_INDEX(7, 0)] = KEY_4,
+	[KEYMAP_INDEX(7, 1)] = KEY_V,
+	[KEYMAP_INDEX(7, 2)] = KEY_S,
+	[KEYMAP_INDEX(7, 3)] = KEY_P,
+	[KEYMAP_INDEX(7, 4)] = KEY_QUESTION,
+	[KEYMAP_INDEX(7, 5)] = KEY_MUTE,
+	[KEYMAP_INDEX(7, 6)] = KEY_U,
+	[KEYMAP_INDEX(7, 7)] = KEY_W,
+};
+
+static struct gpio_event_matrix_info mapphone_keypad_matrix_info = {
+	.info.func = gpio_event_matrix_func,
+	.keymap = mapphone_p3_keymap,
+	.output_gpios = mapphone_col_gpios,
+	.input_gpios = mapphone_row_gpios,
+	.noutputs = ARRAY_SIZE(mapphone_col_gpios),
+	.ninputs = ARRAY_SIZE(mapphone_row_gpios),
+	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
+	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
+	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_REMOVE_PHANTOM_KEYS |
+		 GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
+};
+
+static struct gpio_event_direct_entry mapphone_keypad_switch_map[] = {
+	{ GPIO_SILENCE_KEY,	SW_HEADPHONE_INSERT },
+	{ GPIO_SLIDER,		SW_LID}
+};
+
+static struct gpio_event_input_info mapphone_keypad_switch_info = {
+	.info.func = gpio_event_input_func,
+	.flags = 0,
+	.type = EV_SW,
+	.keymap = mapphone_keypad_switch_map,
+	.keymap_size = ARRAY_SIZE(mapphone_keypad_switch_map)
+};
+
+static struct gpio_event_info *mapphone_keypad_info[] = {
+	&mapphone_keypad_matrix_info.info,
+	&mapphone_keypad_switch_info.info,
+};
+
+static struct gpio_event_platform_data mapphone_keypad_data = {
+	.name = "sholes-keypad",
+	.info = mapphone_keypad_info,
+	.info_count = ARRAY_SIZE(mapphone_keypad_info)
+};
+
+static struct platform_device mapphone_keypad_device = {
+	.name = GPIO_EVENT_DEV_NAME,
+	.id = 0,
+	.dev		= {
+		.platform_data	= &mapphone_keypad_data,
+	},
+};
+
+static int mapphone_reset_keys_up[] = {
+	BTN_MOUSE,		/* XXX */
+	0
+};
+
+static struct keyreset_platform_data mapphone_reset_keys_pdata = {
+	.crash_key = KEY_SPACE,
+	.keys_up = mapphone_reset_keys_up,
+	.keys_down = {
+		KEY_LEFTSHIFT,
+		KEY_RIGHTALT,
+		KEY_BACKSPACE,
+		0
+	},
+};
+
+struct platform_device mapphone_reset_keys_device = {
+	.name = KEYRESET_NAME,
+	.dev.platform_data = &mapphone_reset_keys_pdata,
+};
+
+#ifdef CONFIG_ARM_OF
+static int __init mapphone_dt_kp_init(void)
+{
+	struct device_node *kp_node;
+	const void *kp_prop;
+
+	if ((kp_node = of_find_node_by_path(DT_PATH_KEYPAD))) {
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_ROWS, NULL)))
+			mapphone_keypad_matrix_info.ninputs = \
+				*(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_COLS, NULL)))
+			mapphone_keypad_matrix_info.noutputs = \
+				*(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_ROWREG, NULL)))
+			mapphone_keypad_matrix_info.input_gpios = \
+				(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_COLREG, NULL)))
+			mapphone_keypad_matrix_info.output_gpios = \
+				(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_MAPS, NULL)))
+			mapphone_keypad_matrix_info.keymap = \
+				(unsigned short *)kp_prop;
+
+		of_node_put(kp_node);
+	}
+
+	return kp_node ? 0 : -ENODEV;
+}
+#endif
+
+static int __init mapphone_init_keypad(void)
+{
+#ifdef CONFIG_ARM_OF
+	if (mapphone_dt_kp_init())
+		printk(KERN_INFO "Keypad: using non-dt configuration\n");
+#endif
+
+	/* keypad rows */
+	omap_cfg_reg(N4_34XX_GPIO34);
+	omap_cfg_reg(M4_34XX_GPIO35);
+	omap_cfg_reg(L4_34XX_GPIO36);
+	omap_cfg_reg(K4_34XX_GPIO37);
+	omap_cfg_reg(T3_34XX_GPIO38);
+	omap_cfg_reg(R3_34XX_GPIO39);
+	omap_cfg_reg(N3_34XX_GPIO40);
+	omap_cfg_reg(M3_34XX_GPIO41);
+
+	/* keypad columns */
+	omap_cfg_reg(K3_34XX_GPIO43_OUT);
+	omap_cfg_reg(V8_34XX_GPIO53_OUT);
+	omap_cfg_reg(U8_34XX_GPIO54_OUT);
+	omap_cfg_reg(T8_34XX_GPIO55_OUT);
+	omap_cfg_reg(R8_34XX_GPIO56_OUT);
+	omap_cfg_reg(P8_34XX_GPIO57_OUT);
+	omap_cfg_reg(N8_34XX_GPIO58_OUT);
+	omap_cfg_reg(L8_34XX_GPIO63_OUT);
+
+	/* switches */
+	omap_cfg_reg(AB2_34XX_GPIO177);
+	omap_cfg_reg(AH17_34XX_GPIO100);
+
+	platform_device_register(&mapphone_reset_keys_device);
+	return platform_device_register(&mapphone_keypad_device);
+}
+
+device_initcall(mapphone_init_keypad);
diff --git a/arch/arm/mach-omap2/board-mapphone-mmcprobe.c b/arch/arm/mach-omap2/board-mapphone-mmcprobe.c
new file mode 100644
index 0000000..2d58ed0
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-mmcprobe.c
@@ -0,0 +1,78 @@
+/*
+ * arch/arm/mach-omap2/board-mapphone-mmcprobe.c
+ *
+ * Copyright (C) 2007-2009 Google Inc.
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * San Mehat (san@android.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/reboot.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/setup.h>
+
+#include <mach/board-mapphone.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/common.h>
+#include <mach/control.h>
+#include <linux/delay.h>
+
+#define CH_BASE_GPIO 120
+
+void mapphone_mmcprobe_strobe(int ch, int rpt)
+{
+	int i;
+
+	for (i = 0; i < rpt; i++) {
+		gpio_direction_output(CH_BASE_GPIO + ch, 1);
+		udelay(10);
+		gpio_direction_output(CH_BASE_GPIO + ch, 0);
+		udelay(10);
+	}
+}
+
+void mapphone_mmcprobe_set(int ch, int lvl)
+{
+	gpio_direction_output(CH_BASE_GPIO + ch, lvl);
+}
+
+void __init mapphone_mmcprobe_init(void)
+{
+	int i;
+
+	printk(KERN_INFO "mapphone_mmcprobe: MMC subsystem ganked for debug\n");
+
+	omap_ctrl_writew(0x04, 0x144); /* MMC1_CLK/GPIO120 */
+	omap_ctrl_writew(0x04, 0x146); /* MMC1_CMD/GPIO121 */
+	omap_ctrl_writew(0x04, 0x148); /* MMC1_DAT0/GPIO122 */
+	omap_ctrl_writew(0x04, 0x14a); /* MMC1_DAT1/GPIO123 */
+	omap_ctrl_writew(0x04, 0x14c); /* MMC1_DAT2/GPIO124 */
+	omap_ctrl_writew(0x04, 0x14e); /* MMC1_DAT3/GPIO125 */
+
+	gpio_request(120, "mmcprobe-ch1");
+	gpio_request(121, "mmcprobe-ch2");
+	gpio_request(122, "mmcprobe-ch3");
+	gpio_request(123, "mmcprobe-ch4");
+	gpio_request(124, "mmcprobe-ch5");
+	gpio_request(125, "mmcprobe-ch6");
+
+	for (i = 0; i < 5; i++)
+		mapphone_mmcprobe_strobe(i, 1 + i);
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-padconf.c b/arch/arm/mach-omap2/board-mapphone-padconf.c
new file mode 100644
index 0000000..5f0e8e5
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-padconf.c
@@ -0,0 +1,1837 @@
+/*
+ * board-mapphone-padconf.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+
+#include <mach/hardware.h>
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+#ifdef CONFIG_EMU_UART_DEBUG
+#include <mach/board-mapphone-emu_uart.h>
+#endif
+
+struct iomux_range {
+	unsigned int start;
+	unsigned int end;
+};
+
+static struct iomux_range iomux_range_base[] = {
+	{OMAP343X_PADCONF_CORE_CTRL_BASE, OMAP343X_PADCONF_CORE_CTRL_TOP},
+	{OMAP343X_PADCONF_CORE_ETK_BASE, OMAP343X_PADCONF_CORE_ETK_TOP},
+	{OMAP343X_PADCONF_CORE_D2D_BASE, OMAP343X_PADCONF_CORE_D2D_TOP},
+	{OMAP343X_PADCONF_WKUP_BASE, OMAP343X_PADCONF_WKUP_TOP},
+	{OMAP343X_PADCONF_WKUP_D2D_BASE, OMAP343X_PADCONF_WKUP_D2D_TOP}
+};
+
+inline bool is_omap343x_padconf_register(uint16_t offset)
+{
+	unsigned long addr = offset + OMAP343X_CTRL_BASE;
+	unsigned int i;
+
+	if  ((offset & 0x1) != 0x0)
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(iomux_range_base); i++)
+		if (addr >= iomux_range_base[i].start &&
+			 addr <= iomux_range_base[i].end)
+			return 1;
+
+	return 0;
+}
+
+static __initdata struct {
+	uint16_t offset;
+	uint16_t setting;
+} padconf_settings[] = {
+	/* SDRC_D0 */
+	{
+	0x0030,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D1 */
+	{
+	0x0032,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D2 */
+	{
+	0x0034,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D3 */
+	{
+	0x0036,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D4 */
+	{
+	0x0038,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D5 */
+	{
+	0x003A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D6 */
+	{
+	0x003C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D7 */
+	{
+	0x003E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D8 */
+	{
+	0x0040,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D9 */
+	{
+	0x0042,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D10 */
+	{
+	0x0044,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D11 */
+	{
+	0x0046,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D12 */
+	{
+	0x0048,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D13 */
+	{
+	0x004A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D14 */
+	{
+	0x004C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D15 */
+	{
+	0x004E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D16 */
+	{
+	0x0050,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D17 */
+	{
+	0x0052,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D18 */
+	{
+	0x0054,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D19 */
+	{
+	0x0056,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D20 */
+	{
+	0x0058,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D21 */
+	{
+	0x005A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D22 */
+	{
+	0x005C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D23 */
+	{
+	0x005E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D24 */
+	{
+	0x0060,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D25 */
+	{
+	0x0062,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D26 */
+	{
+	0x0064,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D27 */
+	{
+	0x0066,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D28 */
+	{
+	0x0068,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D29 */
+	{
+	0x006A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D30 */
+	{
+	0x006C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D31 */
+	{
+	0x006E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CLK */
+	{
+	0x0070,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS0 */
+	{
+	0x0072,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS1 */
+	{
+	0x0074,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS2 */
+	{
+	0x0076,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS3 */
+	{
+	0x0078,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_A1 */
+	{
+	0x007A,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A2 */
+	{
+	0x007C,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A3 */
+	{
+	0x007E,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A4 */
+	{
+	0x0080,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A5 */
+	{
+	0x0082,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A6 */
+	{
+	0x0084,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A7 */
+	{
+	0x0086,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A8 */
+	{
+	0x0088,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A9 */
+	{
+	0x008A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* GPMC_A10 */
+	{
+	0x008C, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_D0 */
+	{
+	0x008E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D1 */
+	{
+	0x0090,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D2 */
+	{
+	0x0092,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D3 */
+	{
+	0x0094,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D4 */
+	{
+	0x0096,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D5 */
+	{
+	0x0098,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D6 */
+	{
+	0x009A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D7 */
+	{
+	0x009C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D8 */
+	{
+	0x009E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D9 */
+	{
+	0x00A0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D10 */
+	{
+	0x00A2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D11 */
+	{
+	0x00A4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D12 */
+	{
+	0x00A6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D13 */
+	{
+	0x00A8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D14 */
+	{
+	0x00AA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D15 */
+	{
+	0x00AC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS0 */
+	{
+	0x00AE,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS1 */
+	{
+	0x00B0,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS2 */
+	{
+	0x00B2, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS3 */
+	{
+	0x00B4, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS4 */
+	{
+	0x00B6, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS5 */
+	{
+	0x00B8, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS6 */
+	{
+	0x00BA, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS7 */
+	{
+	0x00BC, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_CLK */
+	{
+	0x00BE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NADV_ALE */
+	{
+	0x00C0,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NOE */
+	{
+	0x00C2,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NWE */
+	{
+	0x00C4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NBE0_CLE */
+	{
+	0x00C6,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NBE1 */
+	{
+	0x00C8,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NWP */
+	{
+	0x00CA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_WAIT0 */
+	{
+	0x00CC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_WAIT1 */
+	{
+	0x00CE, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_WAIT2 */
+	{
+	0x00D0,
+		    OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_WAIT3 */
+	{
+	0x00D2,
+		    OMAP343X_PADCONF_OFFMODE_DISABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_PCLK */
+	{
+	0x00D4, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_HSYNC */
+	{
+	0x00D6, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_VSYNC */
+	{
+	0x00D8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_ACBIAS */
+	{
+	0x00DA, OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA0 */
+	{
+	0x00DC,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA1 */
+	{
+	0x00DE,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA2 */
+	{
+	0x00E0,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA3 */
+	{
+	0x00E2,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA4 */
+	{
+	0x00E4,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA5 */
+	{
+	0x00E6,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA6 */
+	{
+	0x00E8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA7 */
+	{
+	0x00EA, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA8 */
+	{
+	0x00EC, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA9 */
+	{
+	0x00EE, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA10 */
+	{
+	0x00F0, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA11 */
+	{
+	0x00F2, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA12 */
+	{
+	0x00F4, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA13 */
+	{
+	0x00F6, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA14 */
+	{
+	0x00F8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA15 */
+	{
+	0x00FA, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA16 */
+	{
+	0x00FC, OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA17 */
+	{
+	0x00FE,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA18 */
+	{
+	0x0100,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA19 */
+	{
+	0x0102, OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA20 */
+	{
+	0x0104,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA21 */
+	{
+	0x0106, OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA22 */
+	{
+	0x0108,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA23 */
+	{
+	0x010A, OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_HS */
+	{
+	0x010C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_VS */
+	{
+	0x010E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_XCLKA */
+	{
+	0x0110, OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_PCLK */
+	{
+	0x0112,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_FLD */
+	{
+	0x0114, OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D0 */
+	{
+	0x0116,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D1 */
+	{
+	0x0118,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D2 */
+	{
+	0x011A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D3 */
+	{
+	0x011C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D4 */
+	{
+	0x011E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D5 */
+	{
+	0x0120,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D6 */
+	{
+	0x0122,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D7 */
+	{
+	0x0124,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D8 */
+	{
+	0x0126,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D9 */
+	{
+	0x0128,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D10 */
+	{
+	0x012A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D11 */
+	{
+	0x012C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_XCLKB */
+	{
+	0x012E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_WEN */
+	{
+	0x0130, OMAP343X_PADCONF_MUXMODE2},
+	    /* CAM_STROBE */
+	{
+	0x0132, OMAP343X_PADCONF_MUXMODE0},
+	    /* CSI2_DX0 */
+	{
+	0x0134,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DY0 */
+	{
+	0x0136,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DX1 */
+	{
+	0x0138,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DY1 */
+	{
+	0x013A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* MCBSP2_FSX */
+	{
+	0x013C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_CLKX */
+	{
+	0x013E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_DR */
+	{
+	0x0140,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_DX */
+	{
+	0x0142,
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_CLK */
+	{
+	0x0144, OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_CMD */
+	{
+	0x0146,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT0 */
+	{
+	0x0148,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT1 */
+	{
+	0x014A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT2 */
+	{
+	0x014C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT3 */
+	{
+	0x014E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT4 */
+	{
+	0x0150,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT5 */
+	{
+	0x0152,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT6 */
+	{
+	0x0154,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT7 */
+	{
+	0x0156,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC2_CLK */
+	{
+	0x0158,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_CMD */
+	{
+	0x015A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT0 */
+	{
+	0x015C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT1 */
+	{
+	0x015E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT2 */
+	{
+	0x0160,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT3 */
+	{
+	0x0162,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT4 */
+	{
+	0x0164, OMAP343X_PADCONF_MUXMODE4},
+	    /* MMC2_DAT5 */
+	{
+	0x0166,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MMC2_DAT6 */
+	{
+	0x0168,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MMC2_DAT7 */
+	{
+	0x016A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_DX */
+	{
+	0x016C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_DR */
+	{
+	0x016E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_CLKX */
+	{
+	0x0170,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_FSX */
+	{
+	0x0172,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* UART2_CTS */
+	{
+	0x0174,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_RTS */
+	{
+	0x0176, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_TX */
+	{
+	0x0178, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_RX */
+	{
+	0x017A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_TX */
+	{
+	0x017C, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_RTS */
+	{
+	0x017E, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_CTS */
+	{
+	0x0180,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* UART1_RX */
+	{
+	0x0182,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP4_CLKX */
+	{
+	0x0184,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_DR */
+	{
+	0x0186,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_DX */
+	{
+	0x0188,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_FSX */
+	{
+	0x018A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP1_CLKR */
+	{
+	0x018C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_FSR */
+	{
+	0x018E, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCBSP1_DX */
+	{
+	0x0190,
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_DR */
+	{
+	0x0192,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP_CLKS */
+	{
+	0x0194,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCBSP1_FSX */
+	{
+	0x0196,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_CLKX */
+	{
+	0x0198,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* UART3_CTS_RCTX */
+	{
+	0x019A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* UART3_RTS_SD */
+	{
+	0x019C,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* UART3_RX_IRRX */
+	{
+	0x019E,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART3_TX_IRTX */
+	{
+	0x01A0, OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_CLK */
+	{
+	0x01A2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_STP */
+	{
+	0x01A4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DIR */
+	{
+	0x01A6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_NXT */
+	{
+	0x01A8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA0 */
+	{
+	0x01AA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA1 */
+	{
+	0x01AC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA2 */
+	{
+	0x01AE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA3 */
+	{
+	0x01B0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA4 */
+	{
+	0x01B2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA5 */
+	{
+	0x01B4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA6 */
+	{
+	0x01B6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA7 */
+	{
+	0x01B8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C1_SCL */
+	{
+	0x01BA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C1_SDA */
+	{
+	0x01BC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C2_SCL */
+	{
+	0x01BE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C2_SDA */
+	{
+	0x01C0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C3_SCL */
+	{
+	0x01C2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C3_SDA */
+	{
+	0x01C4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HDQ_SIO */
+	{
+	0x01C6,
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CLK */
+	{
+	0x01C8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_SIMO */
+	{
+	0x01CA, OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_SOMI */
+	{
+	0x01CC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CS0 */
+	{
+	0x01CE, OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CS1 */
+	{
+	0x01D0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI1_CS2 */
+	{
+	0x01D2,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI1_CS3 */
+	{
+	0x01D4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CLK */
+	{
+	0x01D6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_SIMO */
+	{
+	0x01D8, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_SOMI */
+	{
+	0x01DA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CS0 */
+	{
+	0x01DC, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CS1 */
+	{
+	0x01DE,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* SYS_NIRQ */
+	{
+	0x01E0,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_CLKOUT2 */
+	{
+	0x01E2, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_CLK */
+	{
+	0x05D8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_CTL */
+	{
+	0x05DA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D0 */
+	{
+	0x05DC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D1 */
+	{
+	0x05DE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D2 */
+	{
+	0x05E0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D3 */
+	{
+	0x05E2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D4 */
+	{
+	0x05E4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D5 */
+	{
+	0x05E6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D6 */
+	{
+	0x05E8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D7 */
+	{
+	0x05EA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D8 */
+	{
+	0x05EC, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D9 */
+	{
+	0x05EE, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D10 */
+	{
+	0x05F0, OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D11 */
+	{
+	0x05F2,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D12 */
+	{
+	0x05F4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D13 */
+	{
+	0x05F6,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D14 */
+	{
+	0x05F8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D15 */
+	{
+	0x05FA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* SAD2D_MCAD0 */
+	{
+	0x01E4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD1 */
+	{
+	0x01E6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD2 */
+	{
+	0x01E8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD3 */
+	{
+	0x01EA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD4 */
+	{
+	0x01EC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD5 */
+	{
+	0x01EE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD6 */
+	{
+	0x01F0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD7 */
+	{
+	0x01F2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD8 */
+	{
+	0x01F4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD9 */
+	{
+	0x01F6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD10 */
+	{
+	0x01F8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD11 */
+	{
+	0x01FA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD12 */
+	{
+	0x01FC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD13 */
+	{
+	0x01FE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD14 */
+	{
+	0x0200,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD15 */
+	{
+	0x0202,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD16 */
+	{
+	0x0204,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD17 */
+	{
+	0x0206,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD18 */
+	{
+	0x0208,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD19 */
+	{
+	0x020A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD20 */
+	{
+	0x020C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD21 */
+	{
+	0x020E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD22 */
+	{
+	0x0210,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD23 */
+	{
+	0x0212,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD24 */
+	{
+	0x0214,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD25 */
+	{
+	0x0216,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD26 */
+	{
+	0x0218,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD27 */
+	{
+	0x021A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD28 */
+	{
+	0x021C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD29 */
+	{
+	0x021E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD30 */
+	{
+	0x0220,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD31 */
+	{
+	0x0222,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD32 */
+	{
+	0x0224,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD33 */
+	{
+	0x0226,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD34 */
+	{
+	0x0228,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD35 */
+	{
+	0x022A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD36 */
+	{
+	0x022C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_CLK26MI */
+	{
+	0x022E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NRESPWRON */
+	{
+	0x0230,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NRESWARM */
+	{
+	0x0232,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_ARMNIRQ */
+	{
+	0x0234,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_UMAFIQ */
+	{
+	0x0236,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SPINT */
+	{
+	0x0238,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_FRINT */
+	{
+	0x023A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ0 */
+	{
+	0x023C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ1 */
+	{
+	0x023E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ2 */
+	{
+	0x0240,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ3 */
+	{
+	0x0242,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NTRST */
+	{
+	0x0244,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TDI */
+	{
+	0x0246,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TDO */
+	{
+	0x0248,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TMS */
+	{
+	0x024A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TCK */
+	{
+	0x024C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_RTCK */
+	{
+	0x024E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MSTDBY */
+	{
+	0x0250,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_IDLEREQ */
+	{
+	0x0252,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_IDLEACK */
+	{
+	0x0254,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MWRITE */
+	{
+	0x0256,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SWRITE */
+	{
+	0x0258,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MREAD */
+	{
+	0x025A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SREAD */
+	{
+	0x025C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MBUSFLAG */
+	{
+	0x025E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SBUSFLAG */
+	{
+	0x0260,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CKE0 */
+	{
+	0x0262,
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CKE1 */
+	{
+	0x0264,
+			OMAP343X_PADCONF_INPUT_ENABLED |
+			OMAP343X_PADCONF_PULL_UP |
+			OMAP343X_PADCONF_PUD_ENABLED |
+			OMAP343X_PADCONF_MUXMODE7},
+	    /* I2C4_SCL */
+	{
+	0x0A00,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C4_SDA */
+	{
+	0x0A02,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_32K */
+	{
+	0x0A04,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_CLKREQ */
+	{
+	0x0A06,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_NRESWARM */
+	{
+	0x0A08,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT0 */
+	{
+	0x0A0A,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED |
+			OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT1 */
+	{
+	0x0A0C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT2 */
+	{
+	0x0A0E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT3 */
+	{
+	0x0A10,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT4 */
+	{
+	0x0A12,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT5 */
+	{
+	0x0A14,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT6 */
+	{
+	0x0A16, OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_OFF_MODE */
+	{
+	0x0A18,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_CLKOUT1 */
+	{
+	0x0A1A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* JTAG_NTRST */
+	{
+	0x0A1C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TCK */
+	{
+	0x0A1E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TMS_TMSC */
+	{
+	0x0A20,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TDI */
+	{
+	0x0A22,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_EMU0 */
+	{
+	0x0A24,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_EMU1 */
+	{
+	0x0A26,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SWAKEUP */
+	{
+	0x0A4C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_RTCK */
+	{
+	0x0A4E, OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TDO */
+	{
+	0x0A50, OMAP343X_PADCONF_MUXMODE0},};
+
+#ifdef CONFIG_ARM_OF
+static void __init mux_pad_callback(const void *p_data)
+{
+	struct mux_conf_entry *p = (struct mux_conf_entry *)p_data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (padconf_settings[i].offset == p->offset) {
+			padconf_settings[i].setting &= (~(OMAP343X_PAD_MASK));
+
+			padconf_settings[i].setting |=
+			    (MAKE_OMAP343X_PAD_VALUE
+			     (p->mode, p->input_en, p->pull_type));
+
+			return;
+		}
+	}
+
+	printk(KERN_ERR "padconf override failed, offset = 0x%04x\n",
+			p->offset);
+}
+
+static void __init mux_offmode_callback(const void *p_data)
+{
+	struct mux_offmode_conf_entry *p =
+	    (struct mux_offmode_conf_entry *)p_data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (padconf_settings[i].offset == p->offset) {
+			padconf_settings[i].setting &=
+			    (~(OMAP343X_OFFMODE_MASK));
+
+			padconf_settings[i].setting |=
+			    (MAKE_OMAP343X_OFFMODE_VALUE
+			     (p->offmode_en, p->offout_type, p->offpull_type,
+			      p->offwkup_en));
+
+			return;
+		}
+	}
+
+	printk(KERN_ERR "padconf offmode override failed, offset = 0x%04x\n",
+	       p->offset);
+}
+
+void dt_prop_or_init(struct dt_operation *op)
+{
+	struct device_node *node;
+	const void *prop;
+	int i, size;
+
+	node = of_find_node_by_path(op->path);
+	if (node == NULL) {
+		printk(KERN_ERR "Unable to read node %s from device tree!\n",
+		       op->path);
+		return;
+	}
+
+	prop = of_get_property(node, op->prop, &size);
+	if ((!prop) || (size % op->prop_unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n", op->prop);
+	} else {
+		for (i = 0; i < size / op->prop_unit_size; i++) {
+			(*op->callback) (prop);
+			prop += op->prop_unit_size;
+		}
+	}
+
+	of_node_put(node);
+	printk(KERN_INFO "Device tree prop %s override done\n", op->prop);
+}
+
+void __init mux_setting_init(void)
+{
+	struct dt_operation op;
+
+	/* Read and implement MUX pad setting for pad registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_PAD;
+	op.prop_unit_size = sizeof(struct mux_conf_entry);
+	op.callback = mux_pad_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX pad setting for pad wakeups registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_PADWKUPS;
+	op.prop_unit_size = sizeof(struct mux_conf_entry);
+	op.callback = mux_pad_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX off mode setting for pad registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_OFFMODE;
+	op.prop_unit_size = sizeof(struct mux_offmode_conf_entry);
+	op.callback = mux_offmode_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX off mode setting for pad wakeups registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_OFFMODEWKUPS;
+	op.prop_unit_size = sizeof(struct mux_offmode_conf_entry);
+	op.callback = mux_offmode_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+}
+#endif
+
+void __init mapphone_padconf_init(void)
+{
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	mux_setting_init();
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (is_omap343x_padconf_register(padconf_settings[i].offset)) {
+			unsigned long addr = padconf_settings[i].offset
+			    + OMAP343X_CTRL_BASE;
+			/*
+			   despite the w, omap_readw actual reads a short which
+			   is a half word on this architecture
+			 */
+			unsigned short val = omap_readw(addr);
+#ifdef CONFIG_EMU_UART_DEBUG
+			if (is_emu_uart_iomux_reg(padconf_settings[i].offset)) {
+				printk(KERN_ERR "padconf ignored, offset = 0x%04x\n",
+						padconf_settings[i].offset);
+				continue;
+			}
+#endif
+			val &= ~(OMAP343X_PADCONF_SETTING_MASK);
+			val |= padconf_settings[i].setting;
+
+			omap_writew(val, addr);
+		} else {
+			printk(KERN_ERR "padconf check failed, offset = 0x%04x\n",
+						padconf_settings[i].offset);
+		}
+	}
+
+	return;
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-panel.c b/arch/arm/mach-omap2/board-mapphone-panel.c
new file mode 100644
index 0000000..b423494
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-panel.c
@@ -0,0 +1,137 @@
+/*
+ * linux/arch/arm/mach-omap2/board-mapphone-panel.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/omapfb.h>
+
+#include <mach/display.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/resource.h>
+
+#define MAPPHONE_DISPLAY_RESET_GPIO	136
+
+struct regulator *display_regulator;
+
+static int mapphone_panel_enable(struct omap_dss_device *dssdev)
+{
+	if (!display_regulator) {
+		display_regulator = regulator_get(NULL, "vhvio");
+		if (IS_ERR(display_regulator)) {
+			printk(KERN_ERR "failed to get regulator for display");
+			return PTR_ERR(display_regulator);
+		}
+#ifndef CONFIG_FB_OMAP2_MTD_LOGO
+		regulator_enable(display_regulator);
+		return 0;
+#endif
+	}
+
+	regulator_enable(display_regulator);
+	msleep(1);
+	gpio_request(MAPPHONE_DISPLAY_RESET_GPIO, "display reset");
+	gpio_direction_output(MAPPHONE_DISPLAY_RESET_GPIO, 1);
+	msleep(5);
+	gpio_set_value(MAPPHONE_DISPLAY_RESET_GPIO, 0);
+	msleep(5);
+	gpio_set_value(MAPPHONE_DISPLAY_RESET_GPIO, 1);
+	msleep(10);
+
+	return 0;
+}
+
+static void mapphone_panel_disable(struct omap_dss_device *dssdev)
+{
+	gpio_direction_output(MAPPHONE_DISPLAY_RESET_GPIO, 1);
+	gpio_set_value(MAPPHONE_DISPLAY_RESET_GPIO, 0);
+	msleep(1);
+	regulator_disable(display_regulator);
+}
+
+static struct omapfb_platform_data mapphone_fb_data = {
+	.mem_desc = {
+		.region_cnt = 1,
+		.region = {
+			{
+				.format = OMAPFB_COLOR_ARGB32,
+				.format_used = 1,
+			},
+		},
+	},
+};
+
+static struct omap_dss_device mapphone_lcd_device = {
+	.type = OMAP_DISPLAY_TYPE_DSI,
+	.name = "lcd",
+	.driver_name = "sholes-panel",
+	.phy.dsi.clk_lane = 1,
+	.phy.dsi.clk_pol = 0,
+	.phy.dsi.data1_lane = 2,
+	.phy.dsi.data1_pol = 0,
+	.phy.dsi.data2_lane = 3,
+	.phy.dsi.data2_pol = 0,
+	.phy.dsi.ddr_clk_hz = 160000000,
+	.phy.dsi.lp_clk_hz = 10000000,
+	.reset_gpio = MAPPHONE_DISPLAY_RESET_GPIO,
+	.platform_enable = mapphone_panel_enable,
+	.platform_disable = mapphone_panel_disable,
+};
+
+static struct omap_dss_device *mapphone_dss_devices[] = {
+	&mapphone_lcd_device,
+};
+
+static struct omap_dss_board_info mapphone_dss_data = {
+	.num_devices = ARRAY_SIZE(mapphone_dss_devices),
+	.devices = mapphone_dss_devices,
+	.default_device = &mapphone_lcd_device,
+};
+
+struct platform_device mapphone_dss_device = {
+	.name = "omapdss",
+	.id = -1,
+	.dev = {
+		.platform_data = &mapphone_dss_data,
+	},
+};
+
+void __init mapphone_panel_init(void)
+{
+	int ret;
+
+	omap_cfg_reg(AG22_34XX_DSI_DX0);
+	omap_cfg_reg(AH22_34XX_DSI_DY0);
+	omap_cfg_reg(AG23_34XX_DSI_DX1);
+	omap_cfg_reg(AH23_34XX_DSI_DY1);
+	omap_cfg_reg(AG24_34XX_DSI_DX2);
+	omap_cfg_reg(AH24_34XX_DSI_DY2);
+	/* disp reset b */
+	omap_cfg_reg(AE4_34XX_GPIO136_OUT);
+
+	omapfb_set_platform_data(&mapphone_fb_data);
+
+	ret = gpio_request(MAPPHONE_DISPLAY_RESET_GPIO, "display reset");
+	if (ret) {
+		printk(KERN_ERR "failed to get display reset gpio\n");
+		goto error;
+	}
+
+	platform_device_register(&mapphone_dss_device);
+	return;
+
+error:
+	gpio_free(MAPPHONE_DISPLAY_RESET_GPIO);
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-sensors.c b/arch/arm/mach-omap2/board-mapphone-sensors.c
new file mode 100644
index 0000000..86305b1
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-sensors.c
@@ -0,0 +1,240 @@
+/*
+ * linux/arch/arm/mach-omap2/board-mapphone-sensors.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/sfh7743.h>
+#include <linux/bu52014hfv.h>
+#include <linux/lis331dlh.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/vib-gpio.h>
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+
+#define MAPPHONE_PROX_INT_GPIO		180
+#define MAPPHONE_HF_NORTH_GPIO		10
+#define MAPPHONE_HF_SOUTH_GPIO		111
+#define MAPPHONE_AKM8973_INT_GPIO	175
+#define MAPPHONE_AKM8973_RESET_GPIO	28
+#define MAPPHONE_VIBRATOR_GPIO		181
+
+static struct regulator *mapphone_vibrator_regulator;
+static int mapphone_vibrator_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vvib");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	mapphone_vibrator_regulator = reg;
+	return 0;
+}
+
+static void mapphone_vibrator_exit(void)
+{
+	regulator_put(mapphone_vibrator_regulator);
+}
+
+static int mapphone_vibrator_power_on(void)
+{
+	regulator_set_voltage(mapphone_vibrator_regulator, 3000000, 3000000);
+	return regulator_enable(mapphone_vibrator_regulator);
+}
+
+static int mapphone_vibrator_power_off(void)
+{
+	if (mapphone_vibrator_regulator)
+		return regulator_disable(mapphone_vibrator_regulator);
+	return 0;
+}
+
+static struct vib_gpio_platform_data mapphone_vib_gpio_data = {
+	.gpio = MAPPHONE_VIBRATOR_GPIO,
+	.max_timeout = 15000,
+	.active_low = 0,
+	.initial_vibrate = 0,
+
+	.init = mapphone_vibrator_initialization,
+	.exit = mapphone_vibrator_exit,
+	.power_on = mapphone_vibrator_power_on,
+	.power_off = mapphone_vibrator_power_off,
+};
+
+static struct platform_device mapphone_vib_gpio = {
+	.name           = "vib-gpio",
+	.id             = -1,
+	.dev            = {
+		.platform_data  = &mapphone_vib_gpio_data,
+	},
+};
+
+static struct regulator *mapphone_sfh7743_regulator;
+static int mapphone_sfh7743_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vsdio");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	mapphone_sfh7743_regulator = reg;
+	return 0;
+}
+
+static void mapphone_sfh7743_exit(void)
+{
+	regulator_put(mapphone_sfh7743_regulator);
+}
+
+static int mapphone_sfh7743_power_on(void)
+{
+	return regulator_enable(mapphone_sfh7743_regulator);
+}
+
+static int mapphone_sfh7743_power_off(void)
+{
+	if (mapphone_sfh7743_regulator)
+		return regulator_disable(mapphone_sfh7743_regulator);
+	return 0;
+}
+
+static struct sfh7743_platform_data mapphone_sfh7743_data = {
+	.init = mapphone_sfh7743_initialization,
+	.exit = mapphone_sfh7743_exit,
+	.power_on = mapphone_sfh7743_power_on,
+	.power_off = mapphone_sfh7743_power_off,
+
+	.gpio = MAPPHONE_PROX_INT_GPIO,
+};
+
+static void __init mapphone_sfh7743_init(void)
+{
+	gpio_request(MAPPHONE_PROX_INT_GPIO, "sfh7743 proximity int");
+	gpio_direction_input(MAPPHONE_PROX_INT_GPIO);
+	omap_cfg_reg(Y3_34XX_GPIO180);
+}
+
+
+static struct bu52014hfv_platform_data bu52014hfv_platform_data = {
+	.docked_north_gpio = MAPPHONE_HF_NORTH_GPIO,
+	.docked_south_gpio = MAPPHONE_HF_SOUTH_GPIO,
+	.north_is_desk = 1,
+};
+
+static struct regulator *mapphone_lis331dlh_regulator;
+static int mapphone_lis331dlh_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vhvio");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	mapphone_lis331dlh_regulator = reg;
+	return 0;
+}
+
+static void mapphone_lis331dlh_exit(void)
+{
+	regulator_put(mapphone_lis331dlh_regulator);
+}
+
+static int mapphone_lis331dlh_power_on(void)
+{
+	return regulator_enable(mapphone_lis331dlh_regulator);
+}
+
+static int mapphone_lis331dlh_power_off(void)
+{
+	if (mapphone_lis331dlh_regulator)
+		return regulator_disable(mapphone_lis331dlh_regulator);
+	return 0;
+}
+
+struct lis331dlh_platform_data mapphone_lis331dlh_data = {
+	.init = mapphone_lis331dlh_initialization,
+	.exit = mapphone_lis331dlh_exit,
+	.power_on = mapphone_lis331dlh_power_on,
+	.power_off = mapphone_lis331dlh_power_off,
+
+	.min_interval	= 1,
+	.poll_interval	= 200,
+
+	.g_range	= LIS331DLH_G_8G,
+
+	.axis_map_x	= 0,
+	.axis_map_y	= 1,
+	.axis_map_z	= 2,
+
+	.negate_x	= 0,
+	.negate_y	= 0,
+	.negate_z	= 0,
+};
+
+static void __init mapphone_akm8973_init(void)
+{
+	gpio_request(MAPPHONE_AKM8973_RESET_GPIO, "akm8973 reset");
+	gpio_direction_output(MAPPHONE_AKM8973_RESET_GPIO, 1);
+	omap_cfg_reg(AB10_34XX_GPIO28_OUT);
+
+	gpio_request(MAPPHONE_AKM8973_INT_GPIO, "akm8973 irq");
+	gpio_direction_input(MAPPHONE_AKM8973_INT_GPIO);
+	omap_cfg_reg(AC3_34XX_GPIO175);
+}
+
+struct platform_device sfh7743_platform_device = {
+	.name = "sfh7743",
+	.id = -1,
+	.dev = {
+		.platform_data = &mapphone_sfh7743_data,
+	},
+};
+
+static struct platform_device omap3430_hall_effect_dock = {
+	.name	= BU52014HFV_MODULE_NAME,
+	.id	= -1,
+	.dev	= {
+		.platform_data  = &bu52014hfv_platform_data,
+	},
+};
+
+static void mapphone_vibrator_init(void)
+{
+	gpio_request(MAPPHONE_VIBRATOR_GPIO, "vibrator");
+	gpio_direction_output(MAPPHONE_VIBRATOR_GPIO, 0);
+	omap_cfg_reg(Y4_34XX_GPIO181);
+}
+
+static struct platform_device *mapphone_sensors[] __initdata = {
+	&sfh7743_platform_device,
+	&omap3430_hall_effect_dock,
+	&mapphone_vib_gpio,
+};
+
+static void mapphone_hall_effect_init(void)
+{
+	gpio_request(MAPPHONE_HF_NORTH_GPIO, "mapphone dock north");
+	gpio_direction_input(MAPPHONE_HF_NORTH_GPIO);
+	omap_cfg_reg(AG25_34XX_GPIO10);
+
+	gpio_request(MAPPHONE_HF_SOUTH_GPIO, "mapphone dock south");
+	gpio_direction_input(MAPPHONE_HF_SOUTH_GPIO);
+	omap_cfg_reg(B26_34XX_GPIO111);
+}
+
+void __init mapphone_sensors_init(void)
+{
+	mapphone_sfh7743_init();
+	mapphone_hall_effect_init();
+	mapphone_vibrator_init();
+	mapphone_akm8973_init();
+	platform_add_devices(mapphone_sensors, ARRAY_SIZE(mapphone_sensors));
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-spi.c b/arch/arm/mach-omap2/board-mapphone-spi.c
new file mode 100644
index 0000000..72a8fd4
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-spi.c
@@ -0,0 +1,680 @@
+/*
+ * arch/arm/mach-omap2/board-mapphone-spi.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/spi/cpcap.h>
+#include <linux/spi/spi.h>
+#include <mach/mcspi.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/resource.h>
+#include <mach/omap34xx.h>
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+extern struct platform_device cpcap_disp_button_led;
+extern struct platform_device cpcap_rgb_led;
+
+struct cpcap_spi_init_data mapphone_cpcap_spi_init[CPCAP_REG_SIZE + 1] = {
+	{CPCAP_REG_ASSIGN1,   0x0101},
+	{CPCAP_REG_ASSIGN2,   0x0000},
+	{CPCAP_REG_ASSIGN3,   0x0000},
+	{CPCAP_REG_ASSIGN4,   0x0000},
+	{CPCAP_REG_ASSIGN5,   0x0000},
+	{CPCAP_REG_ASSIGN6,   0x0000},
+	{CPCAP_REG_UCC1,      0x0000},
+	{CPCAP_REG_PC1,       0x010A},
+	{CPCAP_REG_PC2,       0x0150},
+	{CPCAP_REG_PGC,       0x0000},
+	{CPCAP_REG_SDVSPLL,   0xDB14},
+	{CPCAP_REG_SI2CC1,    0x0281},
+	{CPCAP_REG_Si2CC2,    0x00C4},
+	{CPCAP_REG_S1C1,      0x6438},
+	{CPCAP_REG_S1C2,      0x3838},
+	{CPCAP_REG_S2C1,      0x6434},
+	{CPCAP_REG_S2C2,      0x3C14},
+	{CPCAP_REG_S3C,       0x0539},
+	{CPCAP_REG_S4C1,      0x0000},
+	{CPCAP_REG_S4C2,      0x0000},
+	{CPCAP_REG_S6C,       0x0000},
+	{CPCAP_REG_VWLAN2C,   0x0001},
+	{CPCAP_REG_VUSBINT1C, 0x0029},
+	{CPCAP_REG_VUSBINT2C, 0x0029},
+	{CPCAP_REG_VAUDIOC,   0x0060},
+	{CPCAP_REG_ADCC1,     0x9000},
+	{CPCAP_REG_ADCC2,     0x4136},
+	{CPCAP_REG_USBC1,     0x1201},
+	{CPCAP_REG_USBC3,     0x7DFB},
+	{CPCAP_REG_UIER2,     0x001F},
+	{CPCAP_REG_UIEF2,     0x001F},
+	{CPCAP_REG_OWDC,      0x0003},
+	{CPCAP_REG_GPIO0,     0x3004},
+	{CPCAP_REG_GPIO1,     0x3000},
+	{CPCAP_REG_GPIO2,     0x3204},
+	{CPCAP_REG_GPIO3,     0x3008},
+	{CPCAP_REG_GPIO4,     0x3204},
+	{CPCAP_REG_GPIO5,     0x3008},
+	{CPCAP_REG_GPIO6,     0x3004},
+	{CPCAP_REG_MDLC,      0x0000},
+	{CPCAP_REG_KLC,       0x0000},
+	{CPCAP_REG_UNUSED,    0x0000},
+};
+
+unsigned short cpcap_regulator_mode_values[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5]      = 0x0022,
+	[CPCAP_VCAM]     = 0x0003,
+	[CPCAP_VCSI]     = 0x0043,
+	[CPCAP_VDAC]     = 0x0003,
+	[CPCAP_VDIG]     = 0x0082,
+	[CPCAP_VFUSE]    = 0x0080,
+	[CPCAP_VHVIO]    = 0x0003,
+	[CPCAP_VSDIO]    = 0x0003,
+	[CPCAP_VPLL]     = 0x0042,
+	[CPCAP_VRF1]     = 0x0024,
+	[CPCAP_VRF2]     = 0x0001,
+	[CPCAP_VRFREF]   = 0x0023,
+	[CPCAP_VWLAN1]   = 0x0003,
+	[CPCAP_VWLAN2]   = 0x000C,
+	[CPCAP_VSIM]     = 0x0003,
+	[CPCAP_VSIMCARD] = 0x1E00,
+	[CPCAP_VVIB]     = 0x0001,
+	[CPCAP_VUSB]     = 0x000C,
+	[CPCAP_VAUDIO]   = 0x0014,
+};
+
+unsigned short cpcap_regulator_off_mode_values[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5]      = 0x0000,
+	[CPCAP_VCAM]     = 0x0000,
+	[CPCAP_VCSI]     = 0x0041,
+	[CPCAP_VDAC]     = 0x0000,
+	[CPCAP_VDIG]     = 0x0000,
+	[CPCAP_VFUSE]    = 0x0000,
+	[CPCAP_VHVIO]    = 0x0000,
+	[CPCAP_VSDIO]    = 0x0000,
+	[CPCAP_VPLL]     = 0x0000,
+	[CPCAP_VRF1]     = 0x0000,
+	[CPCAP_VRF2]     = 0x0000,
+	[CPCAP_VRFREF]   = 0x0000,
+	[CPCAP_VWLAN1]   = 0x0000,
+	[CPCAP_VWLAN2]   = 0x0000,
+	[CPCAP_VSIM]     = 0x0000,
+	[CPCAP_VSIMCARD] = 0x0000,
+	[CPCAP_VVIB]     = 0x0000,
+	[CPCAP_VUSB]     = 0x0000,
+	[CPCAP_VAUDIO]   = 0x0000,
+};
+
+#define CPCAP_GPIO 0
+
+#define REGULATOR_CONSUMER(name, device) { .supply = name, .dev = device, }
+
+struct regulator_consumer_supply cpcap_sw5_consumers[] = {
+	REGULATOR_CONSUMER("sw5", &cpcap_disp_button_led.dev),
+	REGULATOR_CONSUMER("sw5", &cpcap_rgb_led.dev),
+};
+
+struct regulator_consumer_supply cpcap_vcam_consumers[] = {
+	REGULATOR_CONSUMER("vcam", NULL /* cpcap_cam_device */),
+};
+
+extern struct platform_device mapphone_dss_device;
+
+struct regulator_consumer_supply cpcap_vhvio_consumers[] = {
+	REGULATOR_CONSUMER("vhvio", NULL /* lighting_driver */),
+#if 0
+	REGULATOR_CONSUMER("vhvio", NULL /* lighting_driver */),
+	REGULATOR_CONSUMER("vhvio", NULL /* magnetometer */),
+	REGULATOR_CONSUMER("vhvio", NULL /* light sensor */),
+	REGULATOR_CONSUMER("vhvio", NULL /* accelerometer */),
+	REGULATOR_CONSUMER("vhvio", NULL /* display */),
+#endif
+};
+
+struct regulator_consumer_supply cpcap_vsdio_consumers[] = {
+	REGULATOR_CONSUMER("vsdio", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vcsi_consumers[] = {
+	REGULATOR_CONSUMER("vdds_dsi", &mapphone_dss_device.dev),
+};
+
+struct regulator_consumer_supply cpcap_vwlan1_consumers[] = {
+	REGULATOR_CONSUMER("vwlan1", NULL /* cpcap_cam_device */),
+};
+
+struct regulator_consumer_supply cpcap_vwlan2_consumers[] = {
+	REGULATOR_CONSUMER("vwlan2", NULL /* sd slot */),
+};
+
+struct regulator_consumer_supply cpcap_vsim_consumers[] = {
+	REGULATOR_CONSUMER("vsim", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vsimcard_consumers[] = {
+	REGULATOR_CONSUMER("vsimcard", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vvib_consumers[] = {
+	REGULATOR_CONSUMER("vvib", NULL /* vibrator */),
+};
+
+struct regulator_consumer_supply cpcap_vaudio_consumers[] = {
+	REGULATOR_CONSUMER("vaudio", NULL /* mic opamp */),
+};
+
+struct regulator_consumer_supply cpcap_vfuse_consumers[] = {
+    REGULATOR_CONSUMER("vfuse", NULL),
+};
+
+
+
+static struct regulator_init_data cpcap_regulator[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5] = {
+		.constraints = {
+			.min_uV			= 5050000,
+			.max_uV			= 5050000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_sw5_consumers),
+		.consumer_supplies	= cpcap_sw5_consumers,
+	},
+	[CPCAP_VCAM] = {
+		.constraints = {
+			.min_uV			= 2900000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vcam_consumers),
+		.consumer_supplies	= cpcap_vcam_consumers,
+	},
+	[CPCAP_VCSI] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.boot_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vcsi_consumers),
+		.consumer_supplies	= cpcap_vcsi_consumers,
+	},
+	[CPCAP_VDAC] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VDIG] = {
+		.constraints = {
+			.min_uV			= 1875000,
+			.max_uV			= 1875000,
+			.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VFUSE] = {
+		.constraints = {
+			.min_uV			= 1500000,
+			.max_uV			= 3150000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_VOLTAGE |
+						   REGULATOR_CHANGE_STATUS),
+		},
+		.num_consumer_supplies  = ARRAY_SIZE(cpcap_vfuse_consumers),
+		.consumer_supplies      = cpcap_vfuse_consumers,
+	},
+	[CPCAP_VHVIO] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vhvio_consumers),
+		.consumer_supplies	= cpcap_vhvio_consumers,
+	},
+	[CPCAP_VSDIO] = {
+		.constraints = {
+			.min_uV			= 2900000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsdio_consumers),
+		.consumer_supplies	= cpcap_vsdio_consumers,
+	},
+	[CPCAP_VPLL] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= 0,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRF1] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRF2] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRFREF] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VWLAN1] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1900000,
+			.valid_ops_mask		= 0,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan1_consumers),
+		.consumer_supplies	= cpcap_vwlan1_consumers,
+	},
+	[CPCAP_VWLAN2] = {
+		.constraints = {
+			.min_uV			= 3000000,
+			.max_uV			= 3000000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan2_consumers),
+		.consumer_supplies	= cpcap_vwlan2_consumers,
+	},
+	[CPCAP_VSIM] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsim_consumers),
+		.consumer_supplies	= cpcap_vsim_consumers,
+	},
+	[CPCAP_VSIMCARD] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsimcard_consumers),
+		.consumer_supplies	= cpcap_vsimcard_consumers,
+	},
+	[CPCAP_VVIB] = {
+		.constraints = {
+			.min_uV			= 1300000,
+			.max_uV			= 3000000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_VOLTAGE |
+						   REGULATOR_CHANGE_STATUS),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vvib_consumers),
+		.consumer_supplies	= cpcap_vvib_consumers,
+	},
+	[CPCAP_VUSB] = {
+		.constraints = {
+			.min_uV			= 3300000,
+			.max_uV			= 3300000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VAUDIO] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_modes_mask	= (REGULATOR_MODE_NORMAL |
+						   REGULATOR_MODE_STANDBY),
+			.valid_ops_mask		= REGULATOR_CHANGE_MODE,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vaudio_consumers),
+		.consumer_supplies	= cpcap_vaudio_consumers,
+	},
+};
+
+static struct cpcap_adc_ato mapphone_cpcap_adc_ato = {
+	.ato_in = 0x0480,
+	.atox_in = 0,
+	.adc_ps_factor_in = 0x0200,
+	.atox_ps_factor_in = 0,
+	.ato_out = 0,
+	.atox_out = 0,
+	.adc_ps_factor_out = 0,
+	.atox_ps_factor_out = 0,
+};
+
+static void ac_changed(struct power_supply *ac,
+		       struct cpcap_batt_ac_data *ac_state)
+{
+	static char requested;
+	int ret = 0;
+
+	if (!ac || !ac_state)
+		return;
+
+	if (ac_state->online) {
+		/* To reduce OMAP Vdd1 DC/DC converter output voltage dips as
+		 * much as possible, limit Vdd1 to OPP3-OPP5 when the phone is
+		 * connected to a charger. */
+		if (!requested)
+			ret = resource_request("vdd1_opp", ac->dev, VDD1_OPP3);
+
+		if (!ret)
+			requested = 1;
+	} else if (requested) {
+		ret = resource_release("vdd1_opp", ac->dev);
+
+		if (!ret)
+			requested = 0;
+	}
+}
+
+static void batt_changed(struct power_supply *batt,
+			 struct cpcap_batt_data *batt_state)
+{
+	static char requested;
+	int ret = 0;
+
+	if (!batt || !batt_state)
+		return;
+
+	if (batt_state->batt_temp < 0) {
+		/* To reduce OMAP Vdd1 DC/DC converter output voltage dips as
+		 * much as possible, limit Vdd1 to OPP3-OPP5 when the
+		 * temperature is below 0 degrees C. */
+		if (!requested)
+			ret = resource_request("vdd1_opp", batt->dev, VDD1_OPP3);
+
+		if (!ret)
+			requested = 1;
+	} else if (requested) {
+		ret = resource_release("vdd1_opp", batt->dev);
+
+		if (!ret)
+			requested = 0;
+	}
+}
+
+static struct cpcap_platform_data mapphone_cpcap_data = {
+	.init = mapphone_cpcap_spi_init,
+	.regulator_mode_values = cpcap_regulator_mode_values,
+	.regulator_off_mode_values = cpcap_regulator_off_mode_values,
+	.regulator_init = cpcap_regulator,
+	.adc_ato = &mapphone_cpcap_adc_ato,
+	.ac_changed = ac_changed,
+	.batt_changed = batt_changed,
+	.usb_changed = NULL,
+};
+
+static struct spi_board_info mapphone_spi_board_info[] __initdata = {
+	{
+		.modalias = "cpcap",
+		.bus_num = 1,
+		.chip_select = 0,
+		.max_speed_hz = 20000000,
+		.controller_data = &mapphone_cpcap_data,
+		.mode = SPI_CS_HIGH,
+	},
+};
+
+#ifdef CONFIG_ARM_OF
+struct omap_spi_init_entry {
+	u32 reg;
+	u32 data;
+} __attribute__ ((__packed__));
+
+struct omap_rgt_mode_entry {
+	u32 id;
+	u16 data;
+} __attribute__ ((__packed__));
+
+struct omap_rgt_init_entry {
+	u32 id;
+	u32 min_uV;
+	u32 max_uV;
+	u32 valid_ops_mask;
+	u8 always_on;
+	u8 boot_on;
+	u8 apply_uV;
+} __attribute__ ((__packed__));
+
+static void regulator_init(void *p_data)
+{
+	struct omap_rgt_init_entry *p = p_data;
+	struct regulator_init_data *p_devs = cpcap_regulator;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id].constraints.min_uV = p->min_uV;
+		p_devs[p->id].constraints.max_uV = p->max_uV;
+		p_devs[p->id].constraints.valid_ops_mask = p->valid_ops_mask;
+		p_devs[p->id].constraints.always_on = p->always_on;
+		p_devs[p->id].constraints.boot_on = p->boot_on;
+		p_devs[p->id].constraints.apply_uV = p->apply_uV;
+		printk(KERN_INFO "CPCAP: Overwrite regulator init [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void regulator_mode_init(void *p_data)
+{
+	struct omap_rgt_mode_entry *p = p_data;
+	unsigned short *p_devs = cpcap_regulator_mode_values;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id] = p->data;
+		printk(KERN_INFO "CPCAP: Overwrite regulator mode [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void regulator_off_mode_init(void *p_data)
+{
+	struct omap_rgt_mode_entry *p = p_data;
+	unsigned short *p_devs = cpcap_regulator_off_mode_values;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id] = p->data;
+		printk(KERN_INFO "CPCAP: Overwrite regulator off mode [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void cpcap_spi_init(void *p_data)
+{
+	struct omap_spi_init_entry *p = p_data;
+	struct cpcap_spi_init_data *p_devs = mapphone_cpcap_spi_init;
+	int i = 0;
+
+	for (i = 0; i < CPCAP_REG_SIZE + 1; i++) {
+		if (p_devs[i].reg == CPCAP_REG_UNUSED) {
+			p_devs[i].reg = p->reg;
+			p_devs[i].data = p->data;
+
+			if (i != CPCAP_REG_SIZE)
+				p_devs[i + 1].reg = CPCAP_REG_UNUSED;
+
+			printk(KERN_INFO "CPCAP: Add new reg [%d] setting!\n",
+					p->reg);
+			return;
+		}
+
+		if (p_devs[i].reg == p->reg) {
+			p_devs[i].data = p->data;
+
+			printk(KERN_INFO "CPCAP: Overwrite reg [%d] setting!\n",
+					p->reg);
+			return;
+		}
+
+		if (i == CPCAP_REG_SIZE)
+			printk(KERN_ERR "CPCAP: Too big cpcap reg count!\n");
+	}
+}
+
+static void __init cpcap_of_init(void)
+{
+	int size, unit_size, i, count;
+	struct device_node *node;
+	const void *prop;
+
+	node = of_find_node_by_path(DT_PATH_CPCAP);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_CPCAP);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_spi_init_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_SPIINIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_SPIINIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		cpcap_spi_init((struct omap_spi_init_entry *)prop + i);
+
+#if 0 /* Temporary FOTA workaround:Do not allow the device tree to
+	 overwrite the board file regulator mode settings. */
+	unit_size = sizeof(struct omap_rgt_init_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTINIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTINIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_init((struct omap_rgt_init_entry *)prop + i);
+
+	unit_size = sizeof(struct omap_rgt_mode_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTMODE, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTMODE);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_mode_init((struct omap_rgt_mode_entry *)prop + i);
+
+	unit_size = sizeof(struct omap_rgt_mode_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTOFFMODE, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTOFFMODE);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_off_mode_init((struct omap_rgt_mode_entry *)prop + i);
+#endif
+	of_node_put(node);
+	return;
+}
+#endif
+
+void __init mapphone_spi_init(void)
+{
+	int irq;
+	int ret;
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	cpcap_of_init();
+#endif
+
+	for (i = 0; i < CPCAP_REG_SIZE; i++) {
+		if (mapphone_cpcap_spi_init[i].reg == CPCAP_REG_UNUSED)
+			break;
+	}
+	mapphone_cpcap_data.init_len = i;
+
+	ret = gpio_request(CPCAP_GPIO, "cpcap-irq");
+	if (ret)
+		return;
+	ret = gpio_direction_input(CPCAP_GPIO);
+	if (ret) {
+		gpio_free(CPCAP_GPIO);
+		return;
+	}
+
+	irq = gpio_to_irq(CPCAP_GPIO);
+	set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+	omap_cfg_reg(AF26_34XX_GPIO0);
+
+	mapphone_spi_board_info[0].irq = irq;
+	spi_register_board_info(mapphone_spi_board_info,
+				ARRAY_SIZE(mapphone_spi_board_info));
+
+	/* regulator_has_full_constraints(); */
+}
diff --git a/arch/arm/mach-omap2/board-mapphone-wifi.c b/arch/arm/mach-omap2/board-mapphone-wifi.c
new file mode 100644
index 0000000..d5fd9cb
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone-wifi.c
@@ -0,0 +1,202 @@
+/* linux/arch/arm/mach-omap2/board-mapphone-wifi.c
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/err.h>
+
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/wifi_tiwlan.h>
+
+#include <linux/debugfs.h>
+
+#define MAPPHONE_WIFI_PMENA_GPIO	186
+#define MAPPHONE_WIFI_IRQ_GPIO	65
+
+static int mapphone_wifi_cd = 0;		/* WIFI virtual 'card detect' status */
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
+
+int mapphone_wifi_status_register(void (*callback)(int card_present,
+						void *dev_id), void *dev_id)
+{
+	if (wifi_status_cb)
+		return -EAGAIN;
+	wifi_status_cb = callback;
+	wifi_status_cb_devid = dev_id;
+	return 0;
+}
+
+int mapphone_wifi_status(int irq)
+{
+	return mapphone_wifi_cd;
+}
+
+int mapphone_wifi_set_carddetect(int val)
+{
+	printk("%s: %d\n", __func__, val);
+	mapphone_wifi_cd = val;
+	if (wifi_status_cb) {
+		wifi_status_cb(val, wifi_status_cb_devid);
+	} else
+		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(mapphone_wifi_set_carddetect);
+#endif
+
+static int mapphone_wifi_power_state;
+
+int mapphone_wifi_power(int on)
+{
+	printk("%s: %d\n", __func__, on);
+	gpio_set_value(MAPPHONE_WIFI_PMENA_GPIO, on);
+	mapphone_wifi_power_state = on;
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(mapphone_wifi_power);
+#endif
+
+static int mapphone_wifi_reset_state;
+int mapphone_wifi_reset(int on)
+{
+	printk("%s: %d\n", __func__, on);
+	mapphone_wifi_reset_state = on;
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(mapphone_wifi_reset);
+#endif
+
+struct wifi_platform_data mapphone_wifi_control = {
+        .set_power	= mapphone_wifi_power,
+	.set_reset	= mapphone_wifi_reset,
+	.set_carddetect	= mapphone_wifi_set_carddetect,
+};
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+static struct resource mapphone_wifi_resources[] = {
+	[0] = {
+		.name		= "device_wifi_irq",
+		.start		= OMAP_GPIO_IRQ(MAPPHONE_WIFI_IRQ_GPIO),
+		.end		= OMAP_GPIO_IRQ(MAPPHONE_WIFI_IRQ_GPIO),
+		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,
+	},
+};
+
+static struct platform_device mapphone_wifi_device = {
+        .name           = "device_wifi",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(mapphone_wifi_resources),
+        .resource       = mapphone_wifi_resources,
+        .dev            = {
+                .platform_data = &mapphone_wifi_control,
+        },
+};
+#endif
+
+static int __init mapphone_wifi_init(void)
+{
+	int ret;
+
+	printk("%s: start\n", __func__);
+	ret = gpio_request(MAPPHONE_WIFI_IRQ_GPIO, "wifi_irq");
+	if (ret < 0) {
+		printk(KERN_ERR "%s: can't reserve GPIO: %d\n", __func__,
+			MAPPHONE_WIFI_IRQ_GPIO);
+		goto out;
+	}
+	ret = gpio_request(MAPPHONE_WIFI_PMENA_GPIO, "wifi_pmena");
+	if (ret < 0) {
+		printk(KERN_ERR "%s: can't reserve GPIO: %d\n", __func__,
+			MAPPHONE_WIFI_PMENA_GPIO);
+		gpio_free(MAPPHONE_WIFI_IRQ_GPIO);
+		goto out;
+	}
+	gpio_direction_input(MAPPHONE_WIFI_IRQ_GPIO);
+	gpio_direction_output(MAPPHONE_WIFI_PMENA_GPIO, 0);
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	ret = platform_device_register(&mapphone_wifi_device);
+#endif
+out:
+        return ret;
+}
+
+device_initcall(mapphone_wifi_init);
+
+#if defined(CONFIG_DEBUG_FS)
+
+static int mapphonemmc_dbg_wifi_reset_set(void *data, u64 val)
+{
+	mapphone_wifi_reset((int) val);
+	return 0;
+}
+
+static int mapphonemmc_dbg_wifi_reset_get(void *data, u64 *val)
+{
+	*val = mapphone_wifi_reset_state;
+	return 0;
+}
+
+static int mapphonemmc_dbg_wifi_cd_set(void *data, u64 val)
+{
+	mapphone_wifi_set_carddetect((int) val);
+	return 0;
+}
+
+static int mapphonemmc_dbg_wifi_cd_get(void *data, u64 *val)
+{
+	*val = mapphone_wifi_cd;
+	return 0;
+}
+
+static int mapphonemmc_dbg_wifi_pwr_set(void *data, u64 val)
+{
+	mapphone_wifi_power((int) val);
+	return 0;
+}
+
+static int mapphonemmc_dbg_wifi_pwr_get(void *data, u64 *val)
+{
+	*val = mapphone_wifi_power_state;
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(mapphonemmc_dbg_wifi_reset_fops,
+			mapphonemmc_dbg_wifi_reset_get,
+			mapphonemmc_dbg_wifi_reset_set, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(mapphonemmc_dbg_wifi_cd_fops,
+			mapphonemmc_dbg_wifi_cd_get,
+			mapphonemmc_dbg_wifi_cd_set, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(mapphonemmc_dbg_wifi_pwr_fops,
+			mapphonemmc_dbg_wifi_pwr_get,
+			mapphonemmc_dbg_wifi_pwr_set, "%llu\n");
+
+static int __init mapphonemmc_dbg_init(void)
+{
+	struct dentry *dent;
+
+	dent = debugfs_create_dir("mapphone_mmc_dbg", 0);
+	if (IS_ERR(dent))
+		return PTR_ERR(dent);
+
+	debugfs_create_file("wifi_reset", 0644, dent, NULL,
+			    &mapphonemmc_dbg_wifi_reset_fops);
+	debugfs_create_file("wifi_cd", 0644, dent, NULL,
+			    &mapphonemmc_dbg_wifi_cd_fops);
+	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
+			    &mapphonemmc_dbg_wifi_pwr_fops);
+	return 0;
+}
+
+device_initcall(mapphonemmc_dbg_init);
+#endif
diff --git a/arch/arm/mach-omap2/board-mapphone.c b/arch/arm/mach-omap2/board-mapphone.c
new file mode 100644
index 0000000..5102742
--- /dev/null
+++ b/arch/arm/mach-omap2/board-mapphone.c
@@ -0,0 +1,1521 @@
+/*
+ * linux/arch/arm/mach-omap2/board-mapphone.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Modified from mach-omap3/board-3430sdp.c
+ *
+ * Copyright (C) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-generic.c
+ *
+ * Initial code: Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/reboot.h>
+#include <linux/qtouch_obp_ts.h>
+#include <linux/led-cpcap-lm3554.h>
+#include <linux/led-lm3530.h>
+#include <linux/usb/omap.h>
+#include <linux/wl127x-rfkill.h>
+#include <linux/wl127x-test.h>
+#include <linux/omap_mdm_ctrl.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/setup.h>
+
+#include <mach/board-mapphone.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/common.h>
+#include <mach/gpmc.h>
+#include <mach/usb.h>
+#include <linux/delay.h>
+#include <mach/control.h>
+#include <mach/hdq.h>
+#include <mach/system.h>
+#include <linux/usb/android.h>
+#include <linux/wakelock.h>
+
+#include "cm-regbits-34xx.h"
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#include "pm.h"
+#include "prm-regbits-34xx.h"
+#include "smartreflex.h"
+#include "omap3-opp.h"
+#include "sdram-toshiba-hynix-numonyx.h"
+#include "prcm-common.h"
+#include "cm.h"
+#include "clock.h"
+
+#ifdef CONFIG_VIDEO_OLDOMAP3
+#include <media/v4l2-int-device.h>
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+#include <media/mt9p012.h>
+
+#endif
+#if defined(CONFIG_VIDEO_OV8810) || defined(CONFIG_VIDEO_OV8810_MODULE)
+#include <../drivers/media/video/ov8810.h>
+#include <../drivers/media/video/oldisp/ispcsi2.h>
+#define OV8810_CSI2_CLOCK_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA0_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA1_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_CLOCK_LANE		1	 /* Clock lane position: 1 */
+#define OV8810_CSI2_DATA0_LANE		2	 /* Data0 lane position: 2 */
+#define OV8810_CSI2_DATA1_LANE		3	 /* Data1 lane position: 3 */
+#define OV8810_CSI2_PHY_THS_TERM	1  /* GVH */
+#define OV8810_CSI2_PHY_THS_SETTLE	21  /* GVH */
+#define OV8810_CSI2_PHY_TCLK_TERM	0
+#define OV8810_CSI2_PHY_TCLK_MISS	1
+#define OV8810_CSI2_PHY_TCLK_SETTLE	14
+#endif
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+#include <../drivers/media/video/hplens.h>
+#endif
+#endif
+
+#define MAPPHONE_IPC_USB_SUSP_GPIO	142
+#define MAPPHONE_AP_TO_BP_FLASH_EN_GPIO	157
+#define MAPPHONE_TOUCH_RESET_N_GPIO	164
+#define MAPPHONE_TOUCH_INT_GPIO		99
+#define MAPPHONE_LM_3530_INT_GPIO	92
+#define MAPPHONE_AKM8973_INT_GPIO	175
+#define MAPPHONE_WL1271_NSHUTDOWN_GPIO	179
+#define MAPPHONE_WL1271_WAKE_GPIO	8
+#define MAPPHONE_WL1271_HOSTWAKE_GPIO	178
+#define MAPPHONE_AUDIO_PATH_GPIO	143
+#define MAPPHONE_BP_READY_AP_GPIO	141
+#define MAPPHONE_BP_READY2_AP_GPIO	59
+#define MAPPHONE_BP_RESOUT_GPIO		139
+#define MAPPHONE_BP_PWRON_GPIO		137
+#define MAPPHONE_AP_TO_BP_PSHOLD_GPIO	138
+#define MAPPHONE_AP_TO_BP_FLASH_EN_GPIO	157
+#define MAPPHONE_POWER_OFF_GPIO		176
+#define MAPPHONE_BPWAKE_STROBE_GPIO	157
+#define MAPPHONE_APWAKE_TRIGGER_GPIO	141
+#define DIE_ID_REG_BASE			(L4_WK_34XX_PHYS + 0xA000)
+#define DIE_ID_REG_OFFSET		0x218
+#define MAX_USB_SERIAL_NUM		17
+#define MAPPHONE_VENDOR_ID		0x22B8
+#define MAPPHONE_PRODUCT_ID		0x41D9
+#define MAPPHONE_ADB_PRODUCT_ID		0x41DB
+#define FACTORY_PRODUCT_ID		0x41E3
+#define FACTORY_ADB_PRODUCT_ID		0x41E2
+
+#define MAPPHONE_MMCPROBE_ENABLED 0
+
+static char device_serial[MAX_USB_SERIAL_NUM];
+char *bp_model = "CDMA";
+
+static struct omap_opp mapphone_mpu_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{S125M, VDD1_OPP1, 0x20},
+	/*OPP2*/
+	{S250M, VDD1_OPP2, 0x27},
+	/*OPP3*/
+	{S500M, VDD1_OPP3, 0x32},
+	/*OPP4*/
+	{S550M, VDD1_OPP4, 0x38},
+	/*OPP5*/
+	{S600M, VDD1_OPP5, 0x3E},
+};
+
+#define S80M 80000000
+#define S160M 160000000
+
+static struct omap_opp mapphone_l3_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{0, VDD2_OPP1, 0x20},
+	/*OPP2*/
+	{S80M, VDD2_OPP2, 0x27},
+	/*OPP3*/
+	{S160M, VDD2_OPP3, 0x2E},
+};
+
+static struct omap_opp mapphone_dsp_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{S90M, VDD1_OPP1, 0x20},
+	/*OPP2*/
+	{S180M, VDD1_OPP2, 0x27},
+	/*OPP3*/
+	{S360M, VDD1_OPP3, 0x32},
+	/*OPP4*/
+	{S400M, VDD1_OPP4, 0x38},
+	/*OPP5*/
+	{S430M, VDD1_OPP5, 0x3E},
+};
+
+static void __init mapphone_init_irq(void)
+{
+	omap2_init_common_hw(JEDEC_JESD209A_sdrc_params,
+			mapphone_mpu_rate_table, mapphone_dsp_rate_table,
+			mapphone_l3_rate_table);
+	omap_init_irq();
+#ifdef CONFIG_OMAP3_PM
+	scm_clk_init();
+#endif
+	omap_gpio_init();
+}
+
+#define BOOT_MODE_MAX_LEN 30
+static char boot_mode[BOOT_MODE_MAX_LEN+1];
+int __init board_boot_mode_init(char *s)
+
+{
+	strncpy(boot_mode, s, BOOT_MODE_MAX_LEN);
+
+	printk(KERN_INFO "boot_mode=%s\n", boot_mode);
+
+	return 1;
+}
+__setup("androidboot.mode=", board_boot_mode_init);
+
+
+
+static struct android_usb_platform_data andusb_plat = {
+	.vendor_id      = 0x22b8,
+	.product_id     = 0x41DA,
+	.adb_product_id = 0x41DA,
+	.product_name   = "A853",
+	.manufacturer_name	= "Motorola",
+	.serial_number		= device_serial,
+};
+
+static struct platform_device androidusb_device = {
+	.name	= "android_usb",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &andusb_plat,
+	},
+};
+
+static struct usb_mass_storage_platform_data usbms_plat = {
+	.vendor			= "Motorola",
+	.product		= "A853",
+	.release		= 1,
+};
+
+static struct platform_device usb_mass_storage_device = {
+	.name	= "usb_mass_storage",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &usbms_plat,
+	},
+};
+
+static int cpcap_usb_connected_probe(struct platform_device *pdev)
+{
+	android_usb_set_connected(1);
+	return 0;
+}
+
+static int cpcap_usb_connected_remove(struct platform_device *pdev)
+{
+	android_usb_set_connected(0);
+	return 0;
+}
+
+static struct platform_driver cpcap_usb_connected_driver = {
+	.probe		= cpcap_usb_connected_probe,
+	.remove		= cpcap_usb_connected_remove,
+	.driver		= {
+		.name	= "cpcap_usb_connected",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void mapphone_gadget_init(void)
+{
+	unsigned int val[2];
+	unsigned int reg;
+
+	reg = DIE_ID_REG_BASE + DIE_ID_REG_OFFSET;
+	val[0] = omap_readl(reg);
+	val[1] = omap_readl(reg + 4);
+
+	snprintf(device_serial, MAX_USB_SERIAL_NUM, "%08X%08X", val[1], val[0]);
+
+	if (!strcmp(boot_mode, "factorycable"))
+		andusb_plat.factory_enabled = 1;
+	else
+		andusb_plat.factory_enabled = 0;
+
+	andusb_plat.vendor_id = MAPPHONE_VENDOR_ID;
+
+	/* check powerup reason - To be added once kernel support is available*/
+	if (andusb_plat.factory_enabled) {
+		andusb_plat.product_id = FACTORY_PRODUCT_ID;
+		andusb_plat.adb_product_id = FACTORY_ADB_PRODUCT_ID;
+	} else {
+		andusb_plat.product_id = MAPPHONE_PRODUCT_ID;
+		andusb_plat.adb_product_id = MAPPHONE_ADB_PRODUCT_ID;
+	}
+	platform_device_register(&androidusb_device);
+	platform_device_register(&usb_mass_storage_device);
+	platform_driver_register(&cpcap_usb_connected_driver);
+}
+
+static void mapphone_audio_init(void)
+{
+	gpio_request(MAPPHONE_AUDIO_PATH_GPIO, "mapphone audio path");
+
+	omap_cfg_reg(P21_OMAP34XX_MCBSP2_FSX);
+	omap_cfg_reg(N21_OMAP34XX_MCBSP2_CLKX);
+	omap_cfg_reg(R21_OMAP34XX_MCBSP2_DR);
+	omap_cfg_reg(M21_OMAP34XX_MCBSP2_DX);
+	omap_cfg_reg(K26_OMAP34XX_MCBSP3_FSX);
+	omap_cfg_reg(W21_OMAP34XX_MCBSP3_CLKX);
+	omap_cfg_reg(U21_OMAP34XX_MCBSP3_DR);
+	omap_cfg_reg(V21_OMAP34XX_MCBSP3_DX);
+
+	gpio_direction_output(MAPPHONE_AUDIO_PATH_GPIO, 1);
+	omap_cfg_reg(AE5_34XX_GPIO143);
+}
+
+static struct omap_uart_config mapphone_uart_config __initdata = {
+	.enabled_uarts = ((1 << 0) | (1 << 1) | (1 << 2)),
+};
+
+static struct omap_board_config_kernel mapphone_config[] __initdata = {
+	{OMAP_TAG_UART,		&mapphone_uart_config },
+};
+
+static int mapphone_touch_reset(void)
+{
+	gpio_direction_output(MAPPHONE_TOUCH_RESET_N_GPIO, 1);
+	msleep(1);
+	gpio_set_value(MAPPHONE_TOUCH_RESET_N_GPIO, 0);
+	msleep(20);
+	gpio_set_value(MAPPHONE_TOUCH_RESET_N_GPIO, 1);
+	msleep(20);
+
+	return 0;
+}
+
+/* These are for test event-injection purposes only */
+static struct vkey mapphone_touch_vkeys[] = {
+	{
+		.code		= KEY_BACK,
+	},
+	{
+		.code		= KEY_MENU,
+	},
+	{
+		.code		= KEY_HOME,
+	},
+	{
+		.code		= KEY_SEARCH,
+	},
+};
+
+static ssize_t mapphone_virtual_keys_show(struct kobject *kobj,
+					struct kobj_attribute *attr, char *buf)
+{
+	/* center: x: home: 55, menu: 185, back: 305, search 425, y: 835 */
+	/* keys are specified by setting the x,y of the center, the width,
+	 * and the height, as such keycode:center_x:center_y:width:height */
+	return sprintf(buf, __stringify(EV_KEY) ":"
+		       __stringify(KEY_BACK) ":32:906:63:57"
+		       ":" __stringify(EV_KEY) ":"
+		       __stringify(KEY_MENU) ":162:906:89:57"
+		       ":" __stringify(EV_KEY) ":"
+		       __stringify(KEY_HOME) ":292:906:89:57"
+		       ":" __stringify(EV_KEY) ":"
+		       __stringify(KEY_SEARCH) ":439:906:63:57"
+		       "\n");
+}
+static struct kobj_attribute mapphone_virtual_keys_attr = {
+	.attr = {
+		.name = "virtualkeys.qtouch-touchscreen",
+		.mode = S_IRUGO,
+	},
+	.show = &mapphone_virtual_keys_show,
+};
+
+static struct attribute *mapphone_properties_attrs[] = {
+	&mapphone_virtual_keys_attr.attr,
+	NULL,
+};
+
+static struct attribute_group mapphone_properties_attr_group = {
+	.attrs = mapphone_properties_attrs,
+};
+
+static struct qtouch_ts_platform_data mapphone_ts_platform_data;
+
+static void mapphone_touch_init(void)
+{
+#ifdef CONFIG_ARM_OF
+	struct device_node *touch_node;
+	const void *touch_prop;
+	int len = 0;
+
+	if ((touch_node = of_find_node_by_path(DT_PATH_TOUCH))) {
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_KEYMAP, &len)) \
+			&& len && (0 == len % sizeof(struct vkey))) {
+			mapphone_ts_platform_data.vkeys.count = len / sizeof(struct vkey);
+			mapphone_ts_platform_data.vkeys.keys = (struct vkey *)touch_prop;
+		}
+		of_node_put(touch_node);
+	}
+#endif
+
+	gpio_request(MAPPHONE_TOUCH_RESET_N_GPIO, "mapphone touch reset");
+	gpio_direction_output(MAPPHONE_TOUCH_RESET_N_GPIO, 1);
+	omap_cfg_reg(H19_34XX_GPIO164_OUT);
+
+	gpio_request(MAPPHONE_TOUCH_INT_GPIO, "mapphone touch irq");
+	gpio_direction_input(MAPPHONE_TOUCH_INT_GPIO);
+	omap_cfg_reg(AG17_34XX_GPIO99);
+}
+
+static void mapphone_als_init(void)
+{
+	printk(KERN_INFO "%s:Initializing\n", __func__);
+	gpio_request(MAPPHONE_LM_3530_INT_GPIO, "mapphone als int");
+	gpio_direction_input(MAPPHONE_LM_3530_INT_GPIO);
+	omap_cfg_reg(AC27_34XX_GPIO92);
+}
+static struct qtm_touch_keyarray_cfg mapphone_key_array_data[] = {
+	{
+		.ctrl = 0,
+		.x_origin = 0,
+		.y_origin = 0,
+		.x_size = 0,
+		.y_size = 0,
+		.aks_cfg = 0,
+		.burst_len = 0,
+		.tch_det_thr = 0,
+		.tch_det_int = 0,
+		.rsvd1 = 0,
+		.rsvd2 = 0,
+	},
+	{
+		.ctrl = 0,
+		.x_origin = 0,
+		.y_origin = 0,
+		.x_size = 0,
+		.y_size = 0,
+		.aks_cfg = 0,
+		.burst_len = 0,
+		.tch_det_thr = 0,
+		.tch_det_int = 0,
+		.rsvd1 = 0,
+		.rsvd2 = 0,
+	},
+};
+
+static struct qtouch_ts_platform_data mapphone_ts_platform_data = {
+	.irqflags	= (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW),
+	.flags		= (QTOUCH_SWAP_XY |
+			   QTOUCH_USE_MULTITOUCH |
+			   QTOUCH_CFG_BACKUPNV |
+			   QTOUCH_EEPROM_CHECKSUM),
+	.abs_min_x	= 20,
+	.abs_max_x	= 1004,
+	.abs_min_y	= 0,
+	.abs_max_y	= 960,
+	.abs_min_p	= 0,
+	.abs_max_p	= 255,
+	.abs_min_w	= 0,
+	.abs_max_w	= 15,
+	.x_delta	= 400,
+	.y_delta	= 250,
+	.nv_checksum	= 0xfaf5,
+	.fuzz_x		= 0,
+	.fuzz_y		= 0,
+	.fuzz_p		= 2,
+	.fuzz_w		= 2,
+	.hw_reset	= mapphone_touch_reset,
+	.power_cfg	= {
+		.idle_acq_int	= 0xff,
+		.active_acq_int	= 0xff,
+		.active_idle_to	= 0x01,
+	},
+	.acquire_cfg	= {
+		.charge_time	= 12,
+		.atouch_drift	= 5,
+		.touch_drift	= 20,
+		.drift_susp	= 20,
+		.touch_autocal	= 0x96,
+		.sync		= 0,
+	},
+	.multi_touch_cfg	= {
+		.ctrl		= 0x0b,
+		.x_origin	= 0,
+		.y_origin	= 0,
+		.x_size		= 12,
+		.y_size		= 7,
+		.aks_cfg	= 0,
+		.burst_len	= 0x40,
+		.tch_det_thr	= 0x12,
+		.tch_det_int	= 0x2,
+		.mov_hyst_init	= 0xe,
+		.mov_hyst_next	= 0xe,
+		.mov_filter	= 0x9,
+		.num_touch	= 2,
+		.merge_hyst	= 0,
+		.merge_thresh	= 3,
+		.amp_hyst = 2,
+		.x_res = 0x0000,
+		.y_res = 0x0000,
+		.x_low_clip = 0x00,
+		.x_high_clip = 0x00,
+		.y_low_clip = 0x00,
+		.y_high_clip = 0x00,
+	},
+	.linear_tbl_cfg = {
+		.ctrl = 0x01,
+		.x_offset = 0x0000,
+		.x_segment = {
+			0x48, 0x3f, 0x3c, 0x3E,
+			0x3f, 0x3e, 0x3e, 0x3e,
+			0x3f, 0x42, 0x41, 0x3f,
+			0x41, 0x40, 0x41, 0x46
+		},
+		.y_offset = 0x0000,
+		.y_segment = {
+			0x44, 0x38, 0x37, 0x3e,
+			0x3e, 0x41, 0x41, 0x3f,
+			0x42, 0x41, 0x42, 0x42,
+			0x41, 0x3f, 0x41, 0x45
+		},
+	},
+	.grip_suppression_cfg = {
+		.ctrl		= 0x00,
+		.xlogrip	= 0x00,
+		.xhigrip	= 0x00,
+		.ylogrip	= 0x00,
+		.yhigrip	= 0x00,
+		.maxtchs	= 0x00,
+		.reserve0	= 0x00,
+		.szthr1		= 0x00,
+		.szthr2		= 0x00,
+		.shpthr1	= 0x00,
+		.shpthr2	= 0x00,
+	},
+	.noise1_suppression_cfg = {
+		.ctrl = 0x01,
+		.reserved = 0x01,
+		.atchthr = 0x64,
+		.duty_cycle = 0x08,
+	},
+	.key_array      = {
+		.cfg		= mapphone_key_array_data,
+		.num_keys   = ARRAY_SIZE(mapphone_key_array_data),
+	},
+	.vkeys			= {
+		.keys		= mapphone_touch_vkeys,
+		.count		= ARRAY_SIZE(mapphone_touch_vkeys),
+		.start		= 961,
+	},
+};
+
+static struct lm3530_platform_data omap3430_als_light_data = {
+	.power_up_gen_config = 0x0b,
+	.gen_config = 0x3b,
+	.als_config = 0x6c,
+	.brightness_ramp = 0x00,
+	.als_zone_info = 0x00,
+	.als_resistor_sel = 0x31,
+	.brightness_control = 0x00,
+	.zone_boundary_0 = 0x02,
+	.zone_boundary_1 = 0x10,
+	.zone_boundary_2 = 0x43,
+	.zone_boundary_3 = 0xfc,
+	.zone_target_0 = 0x51,
+	.zone_target_1 = 0x6c,
+	.zone_target_2 = 0x6c,
+	.zone_target_3 = 0x6c,
+	.zone_target_4 = 0x7e,
+	.manual_current = 0x33,
+	.upper_curr_sel = 6,
+	.lower_curr_sel = 3,
+	.lens_loss_coeff = 6,
+};
+
+static struct lm3554_platform_data mapphone_camera_flash = {
+	.torch_brightness_def = 0xa0,
+	.flash_brightness_def = 0x78,
+	.flash_duration_def = 0x28,
+	.config_reg_1_def = 0xe0,
+	.config_reg_2_def = 0xf0,
+	.vin_monitor_def = 0x01,
+	.gpio_reg_def = 0x0,
+};
+
+static struct i2c_board_info __initdata mapphone_i2c_bus1_board_info[] = {
+	{
+		I2C_BOARD_INFO(QTOUCH_TS_NAME, 0x11),
+		.platform_data = &mapphone_ts_platform_data,
+		.irq = OMAP_GPIO_IRQ(MAPPHONE_TOUCH_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO(LD_LM3530_NAME, 0x38),
+		.platform_data = &omap3430_als_light_data,
+		.irq = OMAP_GPIO_IRQ(MAPPHONE_LM_3530_INT_GPIO),
+	},
+};
+
+extern struct lis331dlh_platform_data mapphone_lis331dlh_data;
+static struct i2c_board_info __initdata mapphone_i2c_bus2_board_info[] = {
+	{
+		I2C_BOARD_INFO("akm8973", 0x1C),
+		.irq = OMAP_GPIO_IRQ(MAPPHONE_AKM8973_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO("lis331dlh", 0x19),
+		.platform_data = &mapphone_lis331dlh_data,
+	},
+};
+
+static struct i2c_board_info __initdata mapphone_i2c_bus3_board_info[] = {
+#if defined(CONFIG_VIDEO_OV8810)
+	{
+		I2C_BOARD_INFO("ov8810", OV8810_I2C_ADDR),
+		.platform_data = &mapphone_ov8810_platform_data,
+	},
+#endif
+	{
+		I2C_BOARD_INFO("lm3554_led", 0x53),
+		.platform_data = &mapphone_camera_flash,
+	},
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+	{
+		I2C_BOARD_INFO("mt9p012", 0x36),
+		.platform_data = &mapphone_mt9p012_platform_data,
+	},
+#endif
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+	{
+		I2C_BOARD_INFO("HP_GEN_LENS", 0x04),
+		.platform_data = &mapphone_hplens_platform_data,
+	},
+#endif
+};
+
+static int __init mapphone_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, mapphone_i2c_bus1_board_info,
+			      ARRAY_SIZE(mapphone_i2c_bus1_board_info));
+	omap_register_i2c_bus(2, 400, mapphone_i2c_bus2_board_info,
+			      ARRAY_SIZE(mapphone_i2c_bus2_board_info));
+	omap_register_i2c_bus(3, 400, mapphone_i2c_bus3_board_info,
+			      ARRAY_SIZE(mapphone_i2c_bus3_board_info));
+	return 0;
+}
+
+arch_initcall(mapphone_i2c_init);
+
+extern void __init mapphone_spi_init(void);
+extern void __init mapphone_flash_init(void);
+extern void __init mapphone_gpio_iomux_init(void);
+
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+
+static int mapphone_usb_port_startup(struct platform_device *dev, int port)
+{
+	int r;
+
+	if (port == 2) {
+		r = gpio_request(MAPPHONE_IPC_USB_SUSP_GPIO, "ipc_usb_susp");
+		if (r < 0) {
+			printk(KERN_WARNING "Could not request GPIO %d"
+			       " for IPC_USB_SUSP\n",
+			       MAPPHONE_IPC_USB_SUSP_GPIO);
+			return r;
+		}
+		gpio_direction_output(MAPPHONE_IPC_USB_SUSP_GPIO, 0);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void mapphone_usb_port_shutdown(struct platform_device *dev, int port)
+{
+	if (port == 2)
+		gpio_free(MAPPHONE_IPC_USB_SUSP_GPIO);
+}
+
+
+static void mapphone_usb_port_suspend(struct platform_device *dev,
+				    int port, int suspend)
+{
+	if (port == 2)
+		gpio_set_value(MAPPHONE_IPC_USB_SUSP_GPIO, suspend);
+}
+
+
+static struct omap_usb_port_data usb_port_data[] = {
+	[0] = { .flags = 0x0, }, /* disabled */
+	[1] = { .flags = 0x0, }, /* disabled */
+	[2] = {
+		.flags = OMAP_USB_PORT_FLAG_ENABLED |
+			OMAP_USB_PORT_FLAG_AUTOIDLE |
+			OMAP_USB_PORT_FLAG_NOBITSTUFF,
+		.mode = OMAP_USB_PORT_MODE_UTMI_PHY_4PIN,
+		.startup = mapphone_usb_port_startup,
+		.shutdown = mapphone_usb_port_shutdown,
+		.suspend = mapphone_usb_port_suspend,
+	},
+};
+
+static int omap_ohci_bus_check_ctrl_standby(void);
+static struct omap_usb_platform_data usb_platform_data = {
+	.port_data = usb_port_data,
+	.num_ports = ARRAY_SIZE(usb_port_data),
+	.usbhost_standby_status	= omap_ohci_bus_check_ctrl_standby,
+};
+
+static struct resource ehci_resources[] = {
+	[0] = {
+		.start	= OMAP34XX_HSUSB_HOST_BASE + 0x800,
+		.end	= OMAP34XX_HSUSB_HOST_BASE + 0x800 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {         /* general IRQ */
+		.start	= INT_34XX_EHCI_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+static struct platform_device ehci_device = {
+	.name		= "ehci-omap",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &usb_platform_data,
+	},
+	.num_resources	= ARRAY_SIZE(ehci_resources),
+	.resource	= ehci_resources,
+};
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE) || defined(CONFIG_USB_EHCI_HCD)
+static int omap_ohci_bus_check_ctrl_standby(void)
+{
+	u32 val;
+
+	val = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD, CM_IDLEST);
+	if (val & OMAP3430ES2_ST_USBHOST_STDBY_MASK)
+		return 1;
+	else
+		return 0;
+}
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+
+
+static struct resource ohci_resources[] = {
+	[0] = {
+		.start	= OMAP34XX_HSUSB_HOST_BASE + 0x400,
+		.end	= OMAP34XX_HSUSB_HOST_BASE + 0x400 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {         /* general IRQ */
+		.start	= INT_34XX_OHCI_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct omap_usb_config dummy_usb_config = {
+	.usbhost_standby_status	= omap_ohci_bus_check_ctrl_standby,
+	.usb_remote_wake_gpio = MAPPHONE_BP_READY2_AP_GPIO,
+};
+
+static struct platform_device ohci_device = {
+	.name		= "ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data	= &dummy_usb_config,
+	},
+	.num_resources	= ARRAY_SIZE(ohci_resources),
+	.resource	= ohci_resources,
+};
+#endif /* OHCI specific data */
+
+
+static void __init mapphone_ehci_init(void)
+{
+	omap_cfg_reg(AF5_34XX_GPIO142);		/*  IPC_USB_SUSP      */
+	omap_cfg_reg(AD1_3430_USB3FS_PHY_MM3_RXRCV);
+	omap_cfg_reg(AD2_3430_USB3FS_PHY_MM3_TXDAT);
+	omap_cfg_reg(AC1_3430_USB3FS_PHY_MM3_TXEN_N);
+	omap_cfg_reg(AE1_3430_USB3FS_PHY_MM3_TXSE0);
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+	platform_device_register(&ehci_device);
+#endif
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	if (is_cdma_phone())
+		platform_device_register(&ohci_device);
+#endif
+}
+
+static void __init mapphone_sdrc_init(void)
+{
+	/* Ensure SDRC pins are mux'd for self-refresh */
+	omap_cfg_reg(H16_34XX_SDRC_CKE0);
+	omap_cfg_reg(H17_34XX_SDRC_CKE1);
+}
+
+static void __init mapphone_serial_init(void)
+{
+	omap_cfg_reg(AA8_3430_UART1_TX);
+	omap_cfg_reg(Y8_3430_UART1_RX);
+	omap_cfg_reg(AA9_3430_UART1_RTS);
+	omap_cfg_reg(W8_3430_UART1_CTS);
+	omap_cfg_reg(AA25_34XX_UART2_TX);
+	omap_cfg_reg(AD25_34XX_UART2_RX);
+	omap_cfg_reg(AB25_34XX_UART2_RTS);
+	omap_cfg_reg(AB26_34XX_UART2_CTS);
+
+	omap_serial_init(MAPPHONE_BPWAKE_STROBE_GPIO, 0x01);
+}
+
+/* SMPS I2C voltage control register Address for VDD1 */
+#define MAPPHONE_R_VDD1_SR_CONTROL		0x00
+/* SMPS I2C voltage control register Address for VDD2 */
+#define MAPPHONE_R_VDD2_SR_CONTROL		0x00
+/* SMPS I2C Address for VDD1 */
+#define MAPPHONE_R_SRI2C_SLAVE_ADDR_SA0		0x1
+/* SMPS I2C Address for VDD2 */
+#define MAPPHONE_R_SRI2C_SLAVE_ADDR_SA1		0x2
+/* SMPS I2C voltage control register Address for VDD1, used for SR command */
+#define MAPPHONE_R_SMPS_VOL_CNTL_CMDRA0		0x01
+/* SMPS I2C voltage control register Address for VDD2, used for SR command */
+#define MAPPHONE_R_SMPS_VOL_CNTL_CMDRA1		0x01
+
+static struct prm_setup_vc mapphone_prm_setup = {
+	.clksetup = 0x4c,
+	.voltsetup_time1 = 0x94,
+	.voltsetup_time2 = 0x94,
+	.voltoffset = 0x0,
+	.voltsetup2 = 0x0,
+	.vdd0_on = 0x65,
+	.vdd0_onlp = 0x45,
+	.vdd0_ret = 0x19,
+	.vdd0_off = 0x00,
+	.vdd1_on = 0x65,
+	.vdd1_onlp = 0x45,
+	.vdd1_ret = 0x19,
+	.vdd1_off = 0x00,
+	.i2c_slave_ra = (MAPPHONE_R_SRI2C_SLAVE_ADDR_SA1 <<
+			OMAP3430_SMPS_SA1_SHIFT) |
+			(MAPPHONE_R_SRI2C_SLAVE_ADDR_SA0 <<
+			 OMAP3430_SMPS_SA0_SHIFT),
+	.vdd_vol_ra = (MAPPHONE_R_VDD2_SR_CONTROL << OMAP3430_VOLRA1_SHIFT) |
+			(MAPPHONE_R_VDD1_SR_CONTROL << OMAP3430_VOLRA0_SHIFT),
+	/* vdd_vol_ra controls both cmd and vol, set the address equal */
+	.vdd_cmd_ra = (MAPPHONE_R_SMPS_VOL_CNTL_CMDRA1 << OMAP3430_CMDRA1_SHIFT) |
+		(MAPPHONE_R_SMPS_VOL_CNTL_CMDRA0 << OMAP3430_CMDRA0_SHIFT),
+	.vdd_ch_conf = OMAP3430_CMD1 | OMAP3430_RACEN0 |
+			OMAP3430_PRM_VC_CH_CONF_SA1 | OMAP3430_RACEN1 |
+			OMAP3430_RAV1 | OMAP3430_RAC1, OMAP3430_GR_MOD,
+	.vdd_i2c_cfg = OMAP3430_HSEN,
+};
+
+#define R_SMPS_VOL_OPP1_RA0		0x02
+#define R_SMPS_VOL_OPP1_RA1		0x02
+#define R_SMPS_VOL_OPP2_RA0		0x03
+#define R_SMPS_VOL_OPP2_RA1		0x03
+
+
+#ifdef CONFIG_OMAP_SMARTREFLEX
+int mapphone_voltagescale_vcbypass(u32 target_opp, u32 current_opp,
+					u8 target_vsel, u8 current_vsel)
+{
+
+	int sr_status = 0;
+	u32 vdd, target_opp_no;
+	u8 slave_addr = 0, opp_reg_addr = 0, volt_reg_addr = 0;
+
+	vdd = get_vdd(target_opp);
+	target_opp_no = get_opp_no(target_opp);
+
+	if (vdd == VDD1_OPP) {
+		sr_status = sr_stop_vddautocomap(SR1);
+		slave_addr = MAPPHONE_R_SRI2C_SLAVE_ADDR_SA0;
+		volt_reg_addr = MAPPHONE_R_VDD1_SR_CONTROL;
+		opp_reg_addr = R_SMPS_VOL_OPP2_RA0;
+
+	} else if (vdd == VDD2_OPP) {
+		sr_status = sr_stop_vddautocomap(SR2);
+		slave_addr = MAPPHONE_R_SRI2C_SLAVE_ADDR_SA1;
+		volt_reg_addr = MAPPHONE_R_VDD2_SR_CONTROL;
+		opp_reg_addr = R_SMPS_VOL_OPP2_RA1;
+	}
+
+	/* Update the CPCAP SWx OPP2 register, stores the on voltage value */
+	omap3_bypass_cmd(slave_addr, opp_reg_addr, target_vsel);
+
+	/* Update the CPCAP SWx voltage register, change the output voltage */
+	omap3_bypass_cmd(slave_addr, volt_reg_addr, target_vsel);
+
+	if (target_vsel > current_vsel)
+		udelay(target_vsel - current_vsel + 4);
+
+	if (sr_status) {
+		if (vdd == VDD1_OPP)
+			sr_start_vddautocomap(SR1, target_opp_no);
+		else if (vdd == VDD2_OPP)
+			sr_start_vddautocomap(SR2, target_opp_no);
+	}
+
+	return SR_PASS;
+}
+#endif
+
+/* Mapphone specific PM */
+
+extern void omap_uart_block_sleep(int num);
+static struct wake_lock baseband_wakeup_wakelock;
+static int mapphone_bpwake_irqhandler(int irq, void *unused)
+{
+	omap_uart_block_sleep(0);
+	/*
+	 * uart_block_sleep keeps uart clock active for 500 ms,
+	 * prevent suspend for 1 sec to be safe
+	 */
+	wake_lock_timeout(&baseband_wakeup_wakelock, HZ);
+	return IRQ_HANDLED;
+}
+
+static int mapphone_bpwake_probe(struct platform_device *pdev)
+{
+	int rc;
+
+	gpio_request(MAPPHONE_APWAKE_TRIGGER_GPIO, "BP -> AP IPC trigger");
+	gpio_direction_input(MAPPHONE_APWAKE_TRIGGER_GPIO);
+
+	wake_lock_init(&baseband_wakeup_wakelock, WAKE_LOCK_SUSPEND, "bpwake");
+
+	rc = request_irq(gpio_to_irq(MAPPHONE_APWAKE_TRIGGER_GPIO),
+			 mapphone_bpwake_irqhandler,
+			 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			 "Remote Wakeup", NULL);
+	if (rc) {
+		wake_lock_destroy(&baseband_wakeup_wakelock);
+		printk(KERN_ERR
+		       "Failed requesting APWAKE_TRIGGER irq (%d)\n", rc);
+		return rc;
+	}
+
+	enable_irq_wake(gpio_to_irq(MAPPHONE_APWAKE_TRIGGER_GPIO));
+	return 0;
+}
+
+static int mapphone_bpwake_remove(struct platform_device *pdev)
+{
+	wake_lock_destroy(&baseband_wakeup_wakelock);
+	free_irq(gpio_to_irq(MAPPHONE_APWAKE_TRIGGER_GPIO), NULL);
+	return 0;
+}
+
+static int mapphone_bpwake_suspend(struct platform_device *pdev,
+					pm_message_t state)
+{
+	return 0;
+}
+
+static int mapphone_bpwake_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver mapphone_bpwake_driver = {
+	.probe		= mapphone_bpwake_probe,
+	.remove		= mapphone_bpwake_remove,
+	.suspend	= mapphone_bpwake_suspend,
+	.resume		= mapphone_bpwake_resume,
+	.driver		= {
+		.name		= "mapphone_bpwake",
+		.owner		= THIS_MODULE,
+	},
+};
+
+static struct platform_device mapphone_bpwake_device = {
+	.name		= "mapphone_bpwake",
+	.id		= -1,
+	.num_resources	= 0,
+};
+
+/* Choose cold or warm reset
+ *    RST_TIME1>4ms will trigger CPCAP to trigger a system cold reset */
+static void mapphone_pm_set_reset(char cold)
+{
+	if (cold) {
+		/* Configure RST_TIME1 to 6ms  */
+		prm_rmw_mod_reg_bits(OMAP_RSTTIME1_MASK,
+		0xc8<<OMAP_RSTTIME1_SHIFT,
+		OMAP3430_GR_MOD,
+		OMAP3_PRM_RSTTIME_OFFSET);
+	} else {
+		/* Configure RST_TIME1 to 30us  */
+		prm_rmw_mod_reg_bits(OMAP_RSTTIME1_MASK,
+		0x01<<OMAP_RSTTIME1_SHIFT,
+		OMAP3430_GR_MOD,
+		OMAP3_PRM_RSTTIME_OFFSET);
+	}
+}
+
+static int mapphone_pm_reboot_call(struct notifier_block *this,
+			unsigned long code, void *cmd)
+{
+	int result = NOTIFY_DONE;
+
+	if (code == SYS_RESTART) {
+		/* set cold reset */
+		mapphone_pm_set_reset(1);
+	}
+
+	return result;
+}
+
+static struct notifier_block mapphone_pm_reboot_notifier = {
+	.notifier_call = mapphone_pm_reboot_call,
+};
+
+#ifdef CONFIG_MEM_DUMP
+
+#define WARMRESET 1
+#define COLDRESET 0
+
+static unsigned long reset_status = COLDRESET ;
+#endif
+static void mapphone_pm_init(void)
+{
+	omap3_set_prm_setup_vc(&mapphone_prm_setup);
+	omap3_voltagescale_vcbypass_setup(mapphone_voltagescale_vcbypass);
+
+    /* Set CPCAP SW1/SW2 I2C CNTL Reg to 0x45(PSM/PSM mode, VPLL enabled) to
+	 * avoid extra current drain in active case before hit RET once*/
+
+	/* Initialize CPCAP SW1&SW2 OPP1&OPP2 registers */
+	/* SW1, OPP1 for RET Voltage --- 1.0V,
+	 * OPP2 for ON Voltge --- 1.225V(OPP3)
+	 */
+	omap3_bypass_cmd(MAPPHONE_R_SRI2C_SLAVE_ADDR_SA0,
+				MAPPHONE_R_SMPS_VOL_CNTL_CMDRA0, 0x45);
+	omap3_bypass_cmd(MAPPHONE_R_SRI2C_SLAVE_ADDR_SA0,
+				R_SMPS_VOL_OPP1_RA0, 0x20);
+	omap3_bypass_cmd(MAPPHONE_R_SRI2C_SLAVE_ADDR_SA0,
+				R_SMPS_VOL_OPP2_RA0, 0x32);
+
+	/* SW2, OPP1 for RET Voltage --- 1.0V,
+	 * OPP2 for ON Voltge --- 1.175V(OPP3)
+	 */
+	omap3_bypass_cmd(MAPPHONE_R_SRI2C_SLAVE_ADDR_SA1,
+				MAPPHONE_R_SMPS_VOL_CNTL_CMDRA1, 0x45);
+	omap3_bypass_cmd(MAPPHONE_R_SRI2C_SLAVE_ADDR_SA1,
+				R_SMPS_VOL_OPP1_RA1, 0x20);
+	omap3_bypass_cmd(MAPPHONE_R_SRI2C_SLAVE_ADDR_SA1,
+				R_SMPS_VOL_OPP2_RA1, 0x2E);
+
+	/* Configure BP <-> AP wake pins */
+	omap_cfg_reg(AA21_34XX_GPIO157_OUT);
+	omap_cfg_reg(AE6_34XX_GPIO141_DOWN);
+
+	platform_device_register(&mapphone_bpwake_device);
+	platform_driver_register(&mapphone_bpwake_driver);
+
+#ifdef CONFIG_MEM_DUMP
+	if (reset_status == COLDRESET)
+		mapphone_pm_set_reset(1);
+	else
+		mapphone_pm_set_reset(0);
+#else
+	/* set cold reset, will move to warm reset once ready */
+	mapphone_pm_set_reset(1);
+#endif
+	register_reboot_notifier(&mapphone_pm_reboot_notifier);
+}
+
+#ifdef CONFIG_MEM_DUMP
+static struct proc_dir_entry *proc_entry ;
+
+ssize_t reset_proc_read(char *page, char **start, off_t off, \
+   int count, int *eof, void *data)
+{
+	int len ;
+    /* don't visit offset */
+	if (off > 0) {
+		*eof = 1 ;
+		return 0 ;
+	}
+	len = snprintf(page, sizeof(page), "%x\n", (unsigned int)reset_status) ;
+	return len ;
+}
+
+ssize_t reset_proc_write(struct file *filp, const char __user *buff, \
+  unsigned long len, void *data)
+{
+#define MAX_UL_LEN 8
+	char k_buf[MAX_UL_LEN] ;
+	int count = min((unsigned long)MAX_UL_LEN, len) ;
+	int ret ;
+
+	if (copy_from_user(k_buf, buff, count)) {
+		ret = -EFAULT ;
+		goto err ;
+	} else{
+		if (k_buf[0] == '0') {
+			reset_status = COLDRESET;
+			mapphone_pm_set_reset(1);
+			printk(KERN_ERR"switch to cold reset\n");
+		} else if (k_buf[0] == '1') {
+			reset_status = WARMRESET;
+			mapphone_pm_set_reset(0);
+			printk(KERN_ERR"switch to warm reset\n");
+		} else{
+			ret = -EFAULT;
+			goto err;
+		}
+	return count ;
+	}
+err:
+	return ret ;
+}
+
+static void  reset_proc_init(void)
+{
+	proc_entry = create_proc_entry("reset_proc", 0666, NULL);
+	if (proc_entry == NULL) {
+		printk(KERN_INFO"Couldn't create proc entry\n") ;
+	} else{
+		proc_entry->read_proc = reset_proc_read ;
+		proc_entry->write_proc = reset_proc_write ;
+		proc_entry->owner = THIS_MODULE ;
+	}
+}
+
+int __init warmreset_init(char *s)
+{
+	/* configure to warmreset */
+	reset_status = WARMRESET;
+	mapphone_pm_set_reset(0);
+	return 1;
+}
+__setup("warmreset_debug=", warmreset_init);
+#endif
+
+static void __init config_wlan_gpio(void)
+{
+	/* WLAN PE and IRQ */
+	omap_cfg_reg(AE22_34XX_GPIO186_OUT);
+	omap_cfg_reg(J8_3430_GPIO65);
+}
+
+static void __init config_mmc2_init(void)
+{
+	u32 val;
+
+	/* MMC2 */
+	omap_cfg_reg(AE2_3430_MMC2_CLK);
+	omap_cfg_reg(AG5_3430_MMC2_CMD);
+	omap_cfg_reg(AH5_3430_MMC2_DAT0);
+	omap_cfg_reg(AH4_3430_MMC2_DAT1);
+	omap_cfg_reg(AG4_3430_MMC2_DAT2);
+	omap_cfg_reg(AF4_3430_MMC2_DAT3);
+
+	/* Set internal loopback clock */
+	val = omap_ctrl_readl(OMAP343X_CONTROL_DEVCONF1);
+	omap_ctrl_writel((val | OMAP2_MMCSDIO2ADPCLKISEL),
+				OMAP343X_CONTROL_DEVCONF1);
+}
+
+/* must match value in drivers/w1/w1_family.h */
+#define W1_EEPROM_DS2502        0x89
+static struct omap2_hdq_platform_config mapphone_hdq_data = {
+	.mode = OMAP_SDQ_MODE,
+	.id = W1_EEPROM_DS2502,
+};
+
+static int __init omap_hdq_init(void)
+{
+	omap_cfg_reg(J25_34XX_HDQ_SIO);
+	omap_hdq_device.dev.platform_data = &mapphone_hdq_data;
+	return platform_device_register(&omap_hdq_device);
+}
+
+static int mapphone_wl1271_init(void)
+{
+	int rc = 0;
+
+	/* wl1271 BT chip init sequence */
+	gpio_direction_output(MAPPHONE_WL1271_NSHUTDOWN_GPIO, 0);
+	msleep(5);
+	gpio_set_value(MAPPHONE_WL1271_NSHUTDOWN_GPIO, 1);
+	msleep(10);
+	gpio_set_value(MAPPHONE_WL1271_NSHUTDOWN_GPIO, 0);
+	msleep(5);
+
+	/* Reserve BT wake and hostwake GPIOs */
+	rc = gpio_request(MAPPHONE_WL1271_WAKE_GPIO, "wl127x_wake_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	rc = gpio_request(MAPPHONE_WL1271_HOSTWAKE_GPIO,
+				"wl127x_hostwake_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	gpio_direction_output(MAPPHONE_WL1271_WAKE_GPIO, 1);
+	gpio_direction_input(MAPPHONE_WL1271_HOSTWAKE_GPIO);
+
+	return 0;
+}
+
+static int mapphone_wl1271_release(void)
+{
+	gpio_free(MAPPHONE_WL1271_WAKE_GPIO);
+	gpio_free(MAPPHONE_WL1271_HOSTWAKE_GPIO);
+
+	return 0;
+}
+
+static int mapphone_wl1271_enable(void)
+{
+	gpio_set_value(MAPPHONE_WL1271_WAKE_GPIO, 0);
+	return 0;
+}
+
+static int mapphone_wl1271_disable(void)
+{
+	gpio_set_value(MAPPHONE_WL1271_WAKE_GPIO, 1);
+	return 0;
+}
+
+static struct wl127x_rfkill_platform_data mapphone_wl1271_pdata = {
+	.bt_nshutdown_gpio = MAPPHONE_WL1271_NSHUTDOWN_GPIO,
+	.fm_enable_gpio = -1,
+	.bt_hw_init = mapphone_wl1271_init,
+	.bt_hw_release = mapphone_wl1271_release,
+	.bt_hw_enable = mapphone_wl1271_enable,
+	.bt_hw_disable = mapphone_wl1271_disable,
+};
+
+static struct platform_device mapphone_wl1271_device = {
+	.name = "wl127x-rfkill",
+	.id = 0,
+	.dev.platform_data = &mapphone_wl1271_pdata,
+};
+
+static struct wl127x_test_platform_data mapphone_wl1271_test_pdata = {
+	.btwake_gpio = MAPPHONE_WL1271_WAKE_GPIO,
+	.hostwake_gpio = MAPPHONE_WL1271_HOSTWAKE_GPIO,
+};
+
+static struct platform_device mapphone_wl1271_test_device = {
+	.name = "wl127x-test",
+	.id = 0,
+	.dev.platform_data = &mapphone_wl1271_test_pdata,
+};
+
+static void __init mapphone_bt_init(void)
+{
+	/* Mux setup for Bluetooth chip-enable */
+	omap_cfg_reg(T3_34XX_GPIO_179);
+
+	/* Mux setup for BT wake GPIO and hostwake GPIO */
+	omap_cfg_reg(AF21_34XX_GPIO8);
+	omap_cfg_reg(W7_34XX_GPIO178_DOWN);
+
+	platform_device_register(&mapphone_wl1271_device);
+	platform_device_register(&mapphone_wl1271_test_device);
+}
+
+static struct omap_mdm_ctrl_platform_data omap_mdm_ctrl_platform_data = {
+	.bp_ready_ap_gpio = MAPPHONE_BP_READY_AP_GPIO,
+	.bp_ready2_ap_gpio = MAPPHONE_BP_READY2_AP_GPIO,
+	.bp_resout_gpio = MAPPHONE_BP_RESOUT_GPIO,
+	.bp_pwron_gpio = MAPPHONE_BP_PWRON_GPIO,
+	.ap_to_bp_pshold_gpio = MAPPHONE_AP_TO_BP_PSHOLD_GPIO,
+	.ap_to_bp_flash_en_gpio = MAPPHONE_AP_TO_BP_FLASH_EN_GPIO,
+};
+
+static struct platform_device omap_mdm_ctrl_platform_device = {
+	.name = OMAP_MDM_CTRL_MODULE_NAME,
+	.id = -1,
+	.dev = {
+		.platform_data = &omap_mdm_ctrl_platform_data,
+	},
+};
+
+static int __init mapphone_omap_mdm_ctrl_init(void)
+{
+	if (!is_cdma_phone())
+		return -ENODEV;
+
+	gpio_request(MAPPHONE_BP_READY2_AP_GPIO, "BP Flash Ready");
+	gpio_direction_input(MAPPHONE_BP_READY2_AP_GPIO);
+	omap_cfg_reg(T4_34XX_GPIO59_DOWN);
+
+	gpio_request(MAPPHONE_BP_RESOUT_GPIO, "BP Reset Output");
+	gpio_direction_input(MAPPHONE_BP_RESOUT_GPIO);
+	omap_cfg_reg(AE3_34XX_GPIO139_DOWN);
+
+	gpio_request(MAPPHONE_BP_PWRON_GPIO, "BP Power On");
+	gpio_direction_output(MAPPHONE_BP_PWRON_GPIO, 0);
+	omap_cfg_reg(AH3_34XX_GPIO137_OUT);
+
+	gpio_request(MAPPHONE_AP_TO_BP_PSHOLD_GPIO, "AP to BP PS Hold");
+	gpio_direction_output(MAPPHONE_AP_TO_BP_PSHOLD_GPIO, 0);
+	omap_cfg_reg(AF3_34XX_GPIO138_OUT);
+
+	return platform_device_register(&omap_mdm_ctrl_platform_device);
+}
+
+static struct omap_vout_config mapphone_vout_platform_data = {
+	.max_width = 864,
+	.max_height = 648,
+	.max_buffer_size = 0x112000,
+	.num_buffers = 8,
+	.num_devices = 2,
+	.device_ids = {1, 2},
+};
+
+static struct platform_device mapphone_vout_device = {
+	.name = "omapvout",
+	.id = -1,
+	.dev = {
+		.platform_data = &mapphone_vout_platform_data,
+	},
+};
+static void __init mapphone_vout_init(void)
+{
+	platform_device_register(&mapphone_vout_device);
+}
+
+#ifdef CONFIG_ANDROID_RAM_CONSOLE
+#define RAM_CONSOLE_START   0x8E000000
+#define RAM_CONSOLE_SIZE    0x20000
+static struct resource ram_console_resource = {
+       .start  = RAM_CONSOLE_START,
+       .end    = (RAM_CONSOLE_START + RAM_CONSOLE_SIZE - 1),
+       .flags  = IORESOURCE_MEM,
+};
+
+static struct platform_device ram_console_device = {
+       .name = "ram_console",
+       .id = 0,
+       .num_resources  = 1,
+       .resource       = &ram_console_resource,
+};
+
+static inline void mapphone_ramconsole_init(void)
+{
+	platform_device_register(&ram_console_device);
+}
+
+static inline void omap2_ramconsole_reserve_sdram(void)
+{
+	reserve_bootmem(RAM_CONSOLE_START, RAM_CONSOLE_SIZE, 0);
+}
+#else
+static inline void mapphone_ramconsole_init(void) {}
+
+static inline void omap2_ramconsole_reserve_sdram(void) {}
+#endif
+
+
+static struct platform_device mapphone_sgx_device = {
+       .name                   = "pvrsrvkm",
+       .id             = -1,
+};
+static struct platform_device mapphone_omaplfb_device = {
+	.name			= "omaplfb",
+	.id			= -1,
+};
+
+
+static void __init mapphone_sgx_init(void)
+{
+	platform_device_register(&mapphone_sgx_device);
+	platform_device_register(&mapphone_omaplfb_device);
+}
+
+static void __init mapphone_bp_model_init(void)
+{
+#ifdef CONFIG_OMAP_RESET_CLOCKS
+	struct clk *clkp;
+#endif
+
+#ifdef CONFIG_ARM_OF
+	struct device_node *bp_node;
+	const void *bp_prop;
+
+	if ((bp_node = of_find_node_by_path(DT_PATH_CHOSEN))) {
+		if ((bp_prop = of_get_property(bp_node, \
+			DT_PROP_CHOSEN_BP, NULL)))
+			bp_model = (char *)bp_prop;
+
+		of_node_put(bp_node);
+	}
+#endif
+#ifdef CONFIG_OMAP_RESET_CLOCKS
+	/* Enable sad2d iclk */
+	clkp = clk_get(NULL, "sad2d_ick");
+	if (clkp)
+		clk_enable(clkp);
+#endif
+}
+
+static void mapphone_pm_power_off(void)
+{
+	printk(KERN_INFO "mapphone_pm_power_off start...\n");
+	local_irq_disable();
+
+	/* config gpio 176 back from safe mode to reset the device */
+	omap_writew(0x4, 0x480021D2);
+	gpio_direction_output(MAPPHONE_POWER_OFF_GPIO, 0);
+
+	do {} while (1);
+
+	local_irq_enable();
+}
+
+static void mapphone_pm_reset(void)
+{
+	arch_reset('h');
+}
+
+static int cpcap_charger_connected_probe(struct platform_device *pdev)
+{
+	pm_power_off = mapphone_pm_reset;
+	return 0;
+}
+
+static int cpcap_charger_connected_remove(struct platform_device *pdev)
+{
+	pm_power_off = mapphone_pm_power_off;
+	return 0;
+}
+
+static struct platform_driver cpcap_charger_connected_driver = {
+	.probe		= cpcap_charger_connected_probe,
+	.remove		= cpcap_charger_connected_remove,
+	.driver		= {
+		.name	= "cpcap_charger_connected",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void __init mapphone_power_off_init(void)
+{
+	gpio_request(MAPPHONE_POWER_OFF_GPIO, "mapphone power off");
+	gpio_direction_output(MAPPHONE_POWER_OFF_GPIO, 1);
+	omap_cfg_reg(AB1_34XX_GPIO176_OUT);
+
+	/* config gpio176 into safe mode with the pull up enabled to avoid
+	 * glitch at reboot */
+	omap_writew(0x1F, 0x480021D2);
+	pm_power_off = mapphone_pm_power_off;
+
+	platform_driver_register(&cpcap_charger_connected_driver);
+}
+
+static void __init mapphone_init(void)
+{
+	int ret = 0;
+	struct kobject *properties_kobj = NULL;
+
+	omap_board_config = mapphone_config;
+	omap_board_config_size = ARRAY_SIZE(mapphone_config);
+
+	properties_kobj = kobject_create_and_add("board_properties", NULL);
+	if (properties_kobj)
+		ret = sysfs_create_group(properties_kobj,
+				 &mapphone_properties_attr_group);
+	if (!properties_kobj || ret)
+		pr_err("failed to create board_properties\n");
+
+	mapphone_bp_model_init();
+	mapphone_padconf_init();
+	mapphone_gpio_mapping_init();
+	mapphone_ramconsole_init();
+	mapphone_omap_mdm_ctrl_init();
+	mapphone_spi_init();
+	mapphone_flash_init();
+	mapphone_serial_init();
+	mapphone_als_init();
+	mapphone_panel_init();
+	mapphone_sensors_init();
+	mapphone_camera_init();
+	mapphone_touch_init();
+	mapphone_audio_init();
+	usb_musb_init();
+	mapphone_ehci_init();
+	mapphone_sdrc_init();
+	mapphone_pm_init();
+	config_mmc2_init();
+	config_wlan_gpio();
+	omap_hdq_init();
+	mapphone_bt_init();
+#if mapphone_MMCPROBE_ENABLED
+	mapphone_mmcprobe_init();
+#else
+	mapphone_hsmmc_init();
+#endif
+	mapphone_vout_init();
+	mapphone_sgx_init();
+	mapphone_power_off_init();
+	mapphone_gadget_init();
+#ifdef CONFIG_MEM_DUMP
+    reset_proc_init();
+#endif
+}
+
+static void __init mapphone_map_io(void)
+{
+	omap2_ramconsole_reserve_sdram();
+	omap2_set_globals_343x();
+	omap2_map_common_io();
+}
+
+MACHINE_START(MAPPHONE, "mapphone_")
+	/* Maintainer: Motorola, Inc. */
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80C00100,
+	.map_io		= mapphone_map_io,
+	.init_irq	= mapphone_init_irq,
+	.init_machine	= mapphone_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/board-sholes.c b/arch/arm/mach-omap2/board-sholes.c
index ef04fea..024425d 100755
--- a/arch/arm/mach-omap2/board-sholes.c
+++ b/arch/arm/mach-omap2/board-sholes.c
@@ -490,7 +490,7 @@ static struct qtouch_ts_platform_data sholes_ts_platform_data = {
 		.cfg		= sholes_key_array_data,
 		.num_keys   = ARRAY_SIZE(sholes_key_array_data),
 	},
-	.vkeys			= { 
+	.vkeys			= {
 		.keys		= sholes_touch_vkeys,
 		.count		= ARRAY_SIZE(sholes_touch_vkeys),
 		.start		= 961,
@@ -1229,7 +1229,7 @@ static void sholes_pm_power_off(void)
 	printk(KERN_INFO "sholes_pm_power_off start...\n");
 	local_irq_disable();
 
-        /* config gpio 176 back from safe mode to reset the device*/
+	/* config gpio 176 back from safe mode to reset the device*/
 	omap_writew(0x4, 0x480021D2);
 	gpio_direction_output(SHOLES_POWER_OFF_GPIO, 0);
 
diff --git a/arch/arm/mach-omap2/board-sholest-camera.c b/arch/arm/mach-omap2/board-sholest-camera.c
new file mode 100644
index 0000000..cbd8ab8
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-camera.c
@@ -0,0 +1,598 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-camera.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from mach-omap3/board-3430sdp.c
+ *
+ * Copyright (C) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-generic.c
+ *
+ * Initial code: Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/mux.h>
+#include <mach/board-sholest.h>
+#include <mach/omap-pm.h>
+#include <mach/control.h>
+#include <mach/resource.h>
+
+#ifdef CONFIG_VIDEO_OLDOMAP3
+#include <media/v4l2-int-device.h>
+#include <../drivers/media/video/oldomap34xxcam.h>
+#include <../drivers/media/video/oldisp/ispreg.h>
+#include <../drivers/media/video/oldisp/isp.h>
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+#include <media/mt9p012.h>
+#endif
+#endif
+#if defined(CONFIG_VIDEO_OV8810) || defined(CONFIG_VIDEO_OV8810_MODULE)
+#include <../drivers/media/video/ov8810.h>
+#include <../drivers/media/video/oldisp/ispcsi2.h>
+#if defined(CONFIG_LEDS_FLASH_RESET)
+#include <linux/spi/cpcap.h>
+#include <linux/spi/cpcap-regbits.h>
+#endif
+#define OV8810_CSI2_CLOCK_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA0_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA1_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_CLOCK_LANE		1	 /* Clock lane position: 1 */
+#define OV8810_CSI2_DATA0_LANE		2	 /* Data0 lane position: 2 */
+#define OV8810_CSI2_DATA1_LANE		3	 /* Data1 lane position: 3 */
+#define OV8810_CSI2_PHY_THS_TERM	1  /* GVH */
+#define OV8810_CSI2_PHY_THS_SETTLE	21  /* GVH */
+#define OV8810_CSI2_PHY_TCLK_TERM	0
+#define OV8810_CSI2_PHY_TCLK_MISS	1
+#define OV8810_CSI2_PHY_TCLK_SETTLE	14
+#define CPUCLK_LOCK_VAL			    0x5
+#endif
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+#include <../drivers/media/video/hplens.h>
+#endif
+
+static void sholest_camera_lines_safe_mode(void);
+static void sholest_camera_lines_func_mode(void);
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+static int hplens_power_set(enum v4l2_power power)
+{
+	(void)power;
+
+	return 0;
+}
+
+static int hplens_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_LENS;
+
+	return 0;
+}
+
+struct hplens_platform_data sholest_hplens_platform_data = {
+	.power_set = hplens_power_set,
+	.priv_data_set = hplens_set_prv_data,
+};
+#endif
+
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+static struct omap34xxcam_sensor_config mt9p012_cam_hwc = {
+	.sensor_isp = 0,
+	.xclk = OMAP34XXCAM_XCLK_A,
+	.capture_mem = PAGE_ALIGN(2592 * 1944 * 2) * 4,
+};
+
+static int mt9p012_sensor_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->u.sensor.xclk = mt9p012_cam_hwc.xclk;
+	hwc->u.sensor.sensor_isp = mt9p012_cam_hwc.sensor_isp;
+	hwc->u.sensor.capture_mem = mt9p012_cam_hwc.capture_mem;
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_SENSOR;
+	hwc->interface_type = ISP_PARLL;
+	return 0;
+}
+
+static struct isp_interface_config mt9p012_if_config = {
+	.ccdc_par_ser = ISP_PARLL,
+	.dataline_shift = 0x1,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.vdint0_timing = 0x0,
+	.vdint1_timing = 0x0,
+	.strobe = 0x0,
+	.prestrobe = 0x0,
+	.shutter = 0x0,
+	.wenlog = ISPCCDC_CFG_WENLOG_OR,
+	.dcsub = 42,
+	.raw_fmt_in = ISPCCDC_INPUT_FMT_GR_BG,
+	.wbal.coef0 = 0x23,
+	.wbal.coef1 = 0x20,
+	.wbal.coef2 = 0x20,
+	.wbal.coef3 = 0x30,
+	.u.par.par_bridge = 0x0,
+	.u.par.par_clk_pol = 0x0,
+};
+
+static int mt9p012_sensor_power_set(struct device* dev, enum v4l2_power power)
+{
+	static enum v4l2_power previous_power = V4L2_POWER_OFF;
+	static struct regulator *regulator;
+
+	switch (power) {
+	case V4L2_POWER_OFF:
+		/* Power Down Sequence */
+		gpio_free(GPIO_CAMERA_RESET);
+
+		/* Turn off power */
+		if (regulator != NULL) {
+			regulator_disable(regulator);
+			regulator_put(regulator);
+			regulator = NULL;
+		} else {
+			sholest_camera_lines_safe_mode();
+			pr_err("%s: Regulator for vcam is not "\
+					"initialized\n", __func__);
+			return -EIO;
+		}
+
+		/* Release pm constraints */
+		omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 0);
+		sholest_camera_lines_safe_mode();
+	break;
+	case V4L2_POWER_ON:
+		if (previous_power == V4L2_POWER_OFF) {
+			/* Power Up Sequence */
+			sholest_camera_lines_func_mode();
+
+			/* Set min throughput to:
+			 *  2592 x 1944 x 2bpp x 30fps x 3 L3 accesses */
+			omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 885735);
+
+			/* Configure pixel clock divider (here?) */
+			omap_writel(OMAP_MCAM_SRC_DIV, 0x48004f40);
+			isp_configure_interface(&mt9p012_if_config);
+
+			/* Request and configure gpio pins */
+			if (gpio_request(GPIO_CAMERA_RESET,
+						"mt9p012 camera reset") != 0)
+				return -EIO;
+
+			/* set to output mode */
+			gpio_direction_output(GPIO_CAMERA_RESET, 0);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_CAMERA_RESET, 1);
+
+			/* turn on digital power */
+			if (regulator != NULL) {
+				pr_warning("%s: Already have "\
+						"regulator\n", __func__);
+			} else {
+				regulator = regulator_get(NULL, "vcam");
+				if (IS_ERR(regulator)) {
+					pr_err("%s: Cannot get vcam "\
+						"regulator, err=%ld\n",
+						__func__, PTR_ERR(regulator));
+					return PTR_ERR(regulator);
+				}
+			}
+
+			if (regulator_enable(regulator) != 0) {
+				pr_err("%s: Cannot enable vcam regulator\n",
+						__func__);
+				return -EIO;
+			}
+		}
+
+		udelay(1000);
+
+		if (previous_power == V4L2_POWER_OFF) {
+			/* trigger reset */
+			gpio_direction_output(GPIO_CAMERA_RESET, 0);
+
+			udelay(1500);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_CAMERA_RESET, 1);
+
+			/* give sensor sometime to get out of the reset.
+			 * Datasheet says 2400 xclks. At 6 MHz, 400 usec is
+			 * enough
+			 */
+			udelay(300);
+		}
+		break;
+	case V4L2_POWER_STANDBY:
+		/* Stand By Sequence */
+		break;
+	}
+	/* Save powerstate to know what was before calling POWER_ON. */
+	previous_power = power;
+	return 0;
+}
+
+u32 mt9p012_set_xclk(u32 xclkfreq)
+{
+	return isp_set_xclk(xclkfreq, OMAP34XXCAM_XCLK_A);
+}
+
+
+struct mt9p012_platform_data sholest_mt9p012_platform_data = {
+	.power_set      = mt9p012_sensor_power_set,
+	.set_xclk	= mt9p012_set_xclk,
+	.priv_data_set  = mt9p012_sensor_set_prv_data,
+};
+
+#endif /* #ifdef CONFIG_VIDEO_MT9P012 || CONFIG_VIDEO_MT9P012_MODULE */
+
+#if defined(CONFIG_VIDEO_OV8810)
+
+static struct omap34xxcam_sensor_config ov8810_cam_hwc = {
+	.sensor_isp = 0,
+	.xclk = OMAP34XXCAM_XCLK_A,
+	.capture_mem = PAGE_ALIGN(3264 * 2448 * 2 * 2) * 4,
+};
+
+static void mapphone_lock_cpufreq(int lock){
+	static struct device *ov_dev;
+	static int flag;
+	if (lock == 1) {
+		resource_request("vdd1_opp", ov_dev, CPUCLK_LOCK_VAL);
+		flag = 1;
+	}
+	else {
+		if (flag == 1) {
+			resource_release("vdd1_opp", ov_dev);
+			flag = 0;
+		}
+	}
+}
+
+static int ov8810_sensor_set_prv_data(void *priv)
+{
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	hwc->u.sensor.xclk = ov8810_cam_hwc.xclk;
+	hwc->u.sensor.sensor_isp = ov8810_cam_hwc.sensor_isp;
+	hwc->u.sensor.capture_mem = ov8810_cam_hwc.capture_mem;
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_SENSOR;
+	hwc->interface_type = ISP_CSIA;
+
+	hwc->csi2.hw_csi2.lanes.clock.polarity = OV8810_CSI2_CLOCK_POLARITY;
+	hwc->csi2.hw_csi2.lanes.clock.position = OV8810_CSI2_CLOCK_LANE;
+	hwc->csi2.hw_csi2.lanes.data[0].polarity = OV8810_CSI2_DATA0_POLARITY;
+	hwc->csi2.hw_csi2.lanes.data[0].position = OV8810_CSI2_DATA0_LANE;
+	hwc->csi2.hw_csi2.lanes.data[1].polarity = OV8810_CSI2_DATA1_POLARITY;
+	hwc->csi2.hw_csi2.lanes.data[1].position = OV8810_CSI2_DATA1_LANE;
+	hwc->csi2.hw_csi2.phy.ths_term = OV8810_CSI2_PHY_THS_TERM;
+	hwc->csi2.hw_csi2.phy.ths_settle = OV8810_CSI2_PHY_THS_SETTLE;
+	hwc->csi2.hw_csi2.phy.tclk_term = OV8810_CSI2_PHY_TCLK_TERM;
+	hwc->csi2.hw_csi2.phy.tclk_miss = OV8810_CSI2_PHY_TCLK_MISS;
+	hwc->csi2.hw_csi2.phy.tclk_settle = OV8810_CSI2_PHY_TCLK_SETTLE;
+
+	return 0;
+}
+
+static struct isp_interface_config ov8810_if_config = {
+	.ccdc_par_ser = ISP_CSIA,
+	.dataline_shift = 0x0,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.vdint0_timing = 0x0,
+	.vdint1_timing = 0x0,
+	.strobe = 0x0,
+	.prestrobe = 0x0,
+	.shutter = 0x0,
+	.wenlog = ISPCCDC_CFG_WENLOG_OR,
+	.dcsub = OV8810_BLACK_LEVEL_10BIT,
+	.raw_fmt_in = ISPCCDC_INPUT_FMT_BG_GR,
+	.wbal.coef0		= 0x23,
+	.wbal.coef1		= 0x20,
+	.wbal.coef2		= 0x20,
+	.wbal.coef3		= 0x39,
+	.u.csi.crc = 0x0,
+	.u.csi.mode = 0x0,
+	.u.csi.edge = 0x0,
+	.u.csi.signalling = 0x0,
+	.u.csi.strobe_clock_inv = 0x0,
+	.u.csi.vs_edge = 0x0,
+	.u.csi.channel = 0x1,
+	.u.csi.vpclk = 0x1,
+	.u.csi.data_start = 0x0,
+	.u.csi.data_size = 0x0,
+	.u.csi.format = V4L2_PIX_FMT_SGRBG10,
+};
+
+static int ov8810_sensor_power_set(struct device *dev, \
+	struct i2c_client *i2c_client, enum v4l2_power power)
+{
+
+#if defined (CONFIG_VIDEO_MIPI_INTERFACE)
+	struct isp_csi2_lanes_cfg lanecfg;
+	struct isp_csi2_phy_cfg phyconfig;
+#endif
+
+	static enum v4l2_power previous_power = V4L2_POWER_OFF;
+	static struct regulator *regulator_vcam;
+	static struct regulator *regulator_vwlan1;
+	/*Basic turn on operation is will be first one time executed.*/
+	static bool regulator_poweron = 0;
+	
+#if defined(CONFIG_LEDS_FLASH_RESET)
+	static enum detect_type {
+		FLASH_COUPLE_LINE = 0,
+		FLASH_SINGLE_LINE,
+		FLASH_NOT_DETECTED,
+	} flash_detected = FLASH_NOT_DETECTED;
+#endif
+
+	switch (power) {
+	case V4L2_POWER_OFF:
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+		/* Power Down Sequence */
+		isp_csi2_complexio_power(ISP_CSI2_POWER_OFF);
+#endif
+
+		/* Release pm constraints */
+		omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 0);
+		/* Turn off power */
+		if (regulator_vcam != NULL) {
+			regulator_disable(regulator_vcam);
+			regulator_put(regulator_vcam);
+			regulator_vcam = NULL;
+		} else {
+			sholest_camera_lines_safe_mode();
+			pr_err("%s: Regulator for vcam is not "\
+					"initialized\n", __func__);
+			return -EIO;
+		}
+
+		/* Delay 6 msec for vcam to drop (4.7uF to 10uF change) */
+		msleep(6);
+
+		/* Turn off power */
+		if (regulator_vwlan1 != NULL) {
+			regulator_disable(regulator_vwlan1);
+			regulator_put(regulator_vwlan1);
+			regulator_vwlan1 = NULL;
+		} else {
+			sholest_camera_lines_safe_mode();
+			pr_err("%s: Regulator for vwlan1 is not "\
+					"initialized\n", __func__);
+			return -EIO;
+		}
+		gpio_set_value(GPIO_OV8810_RESET, 0);
+		gpio_set_value(GPIO_OV8810_STANDBY, 0);
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+		/*If Xenon flash module didn't detected,
+			FLASH_RESET pin control.*/
+		if (flash_detected == FLASH_COUPLE_LINE)
+			cpcap_direct_misc_write(CPCAP_REG_GPIO0,\
+				0, CPCAP_BIT_GPIO0DRV);
+#endif
+		gpio_free(GPIO_OV8810_RESET);
+		gpio_free(GPIO_OV8810_STANDBY);
+
+		sholest_camera_lines_safe_mode();
+	break;
+	case V4L2_POWER_ON:
+
+		sholest_camera_lines_func_mode();
+	        /* Set min throughput to:
+	         *  2592 x 1944 x 2bpp x 30fps x 3 L3 accesses */
+	         omap_pm_set_min_bus_tput(dev, OCP_INITIATOR_AGENT, 885735);
+
+#if defined (CONFIG_VIDEO_MIPI_INTERFACE)
+		printk(KERN_DEBUG "ov8810_sensor_power_set(ON)\n");
+		/*if (previous_power == V4L2_POWER_OFF)*/
+			isp_csi2_reset();
+
+		lanecfg.clk.pol = OV8810_CSI2_CLOCK_POLARITY;
+		lanecfg.clk.pos = OV8810_CSI2_CLOCK_LANE;
+		lanecfg.data[0].pol = OV8810_CSI2_DATA0_POLARITY;
+		lanecfg.data[0].pos = OV8810_CSI2_DATA0_LANE;
+		lanecfg.data[1].pol = OV8810_CSI2_DATA1_POLARITY;
+		lanecfg.data[1].pos = OV8810_CSI2_DATA1_LANE;
+		lanecfg.data[2].pol = 0;
+		lanecfg.data[2].pos = 0;
+		lanecfg.data[3].pol = 0;
+		lanecfg.data[3].pos = 0;
+		isp_csi2_complexio_lanes_config(&lanecfg);
+		isp_csi2_complexio_lanes_update(true);
+
+		phyconfig.ths_term = OV8810_CSI2_PHY_THS_TERM;
+		phyconfig.ths_settle = OV8810_CSI2_PHY_THS_SETTLE;
+		phyconfig.tclk_term = OV8810_CSI2_PHY_TCLK_TERM;
+		phyconfig.tclk_miss = OV8810_CSI2_PHY_TCLK_MISS;
+		phyconfig.tclk_settle = OV8810_CSI2_PHY_TCLK_SETTLE;
+		isp_csi2_phy_config(&phyconfig);
+		isp_csi2_phy_update(true);
+
+		isp_configure_interface(&ov8810_if_config);
+#endif
+
+		if ((previous_power == V4L2_POWER_OFF) && (regulator_poweron == 0)){
+
+			/* Disable Interface. */
+			isp_csi2_ctrl_config_if_enable(false);
+			isp_csi2_ctrl_update(false);
+
+			/* Configure pixel clock divider (here?) */
+			omap_writel(OMAP_MCAM_SRC_DIV, 0x48004f40);
+
+			/* turn on VWLAN1 power */
+			if (regulator_vwlan1 != NULL) {
+				pr_warning("%s: Already have "\
+						"regulator_vwlan1 \n", __func__);
+			} else {
+				regulator_vwlan1 = regulator_get(NULL, "vwlan1");
+				if (IS_ERR(regulator_vwlan1)) {
+					pr_err("%s: Cannot get vwlan1 "\
+						"regulator_vwlan1, err=%ld\n",
+						__func__, PTR_ERR(regulator_vwlan1));
+					return PTR_ERR(regulator_vwlan1);
+				}
+			}
+			
+			if (regulator_enable(regulator_vwlan1) != 0) {
+				pr_err("%s: Cannot enable vcam regulator_vwlan1\n",
+						__func__);
+				return -EIO;
+			}
+
+			/* turn on VCAM power */
+			if (regulator_vcam != NULL) {
+				pr_warning("%s: Already have "\
+						"regulator_vcam\n", __func__);
+			} else {
+				regulator_vcam = regulator_get(NULL, "vcam");
+				if (IS_ERR(regulator_vcam)) {
+					pr_err("%s: Cannot get vcam "\
+						"regulator_vcam, err=%ld\n",
+						__func__, PTR_ERR(regulator_vcam));
+					return PTR_ERR(regulator_vcam);
+				}
+			}
+
+			if (regulator_enable(regulator_vcam) != 0) {
+				pr_err("%s: Cannot enable vcam regulator_vcam\n",
+						__func__);
+				return -EIO;
+			}
+
+			mdelay(5);
+
+			/* Request and configure gpio pins */
+			if (gpio_request(GPIO_OV8810_STANDBY,
+						"ov8810 camera standby") != 0)
+				return -EIO;
+
+			/* set to output mode */
+			gpio_direction_output(GPIO_OV8810_STANDBY, 0);
+			gpio_set_value(GPIO_OV8810_STANDBY, 0);
+
+			if (gpio_request(GPIO_OV8810_RESET,
+						"ov8810 camera reset") != 0)
+				return -EIO;
+
+			/* trigger reset */
+			gpio_direction_output(GPIO_OV8810_RESET, 1);
+
+			/* nRESET is active LOW. set HIGH to release reset */
+			gpio_set_value(GPIO_OV8810_RESET, 1);
+			
+#if defined(CONFIG_LEDS_FLASH_RESET)
+			if (flash_detected == FLASH_NOT_DETECTED) {
+				if (bd7885_device_detection())
+					flash_detected = FLASH_SINGLE_LINE;
+				else
+					flash_detected = FLASH_COUPLE_LINE;
+			}
+			/*If Xenon flash module didn't detected,
+				FLASH_RESET pin control.*/
+			if (flash_detected == FLASH_COUPLE_LINE)
+				cpcap_direct_misc_write(CPCAP_REG_GPIO0,\
+					CPCAP_BIT_GPIO0DRV, CPCAP_BIT_GPIO0DRV);
+#endif
+			/* give sensor sometime to get out of the reset.
+			 * Datasheet says 2400 xclks. At 6 MHz, 400 usec is
+			 * enough
+			 */
+			mdelay(5);
+
+			ov8810_write_reg(i2c_client, OV8810_IMAGE_SYSTEM, 0x00);
+
+			pr_err("%s: OV8810 streaming off.\n",
+					__func__);
+
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+			/* Enable Interface. */
+			isp_csi2_ctrl_config_if_enable(true);
+			isp_csi2_ctrl_update(false);
+#endif
+
+                     /*Set regulator turned on.*/
+			/*regulator_poweron = 1;*/
+		}
+		break;
+	case V4L2_POWER_STANDBY:
+		/* stand by */
+		break;
+	}
+	/* Save powerstate to know what was before calling POWER_ON. */
+	previous_power = power;
+	return 0;
+}
+
+struct ov8810_platform_data sholest_ov8810_platform_data = {
+	.power_set      = ov8810_sensor_power_set,
+	.priv_data_set  = ov8810_sensor_set_prv_data,
+	.lock_cpufreq   = mapphone_lock_cpufreq,
+	.default_regs   = NULL,
+};
+
+#endif  /* #ifdef CONFIG_VIDEO_OV8810*/
+
+/* We can't change the IOMUX config after bootup
+ * with the current pad configuration architecture,
+ * the next two functions are hack to configure the
+ * camera pads at runtime to save power in standby */
+
+void sholest_camera_lines_safe_mode(void)
+{
+	omap_writew(0x0704, 0x4800207C);
+	/*omap_writew(0x0704, 0x480020D0);*/
+}
+
+void sholest_camera_lines_func_mode(void)
+{
+	omap_writew(0x0704, 0x4800207C);
+	/*omap_writew(0x061C, 0x480020D0);*/
+}
+
+void __init sholest_camera_init(void)
+{
+    omap_cfg_reg(C25_34XX_CAM_XCLKA);
+	omap_cfg_reg(C23_34XX_CAM_FLD);
+#if !defined (CONFIG_VIDEO_MIPI_INTERFACE)
+	omap_cfg_reg(AG17_34XX_CAM_D0);
+	omap_cfg_reg(AH17_34XX_CAM_D1);
+#endif
+    omap_cfg_reg(H2_34XX_GPMC_A3);
+
+#if defined (CONFIG_VIDEO_MIPI_INTERFACE)
+    omap_cfg_reg(AG17_34XX_CAM_D0);
+	omap_cfg_reg(AH17_34XX_CAM_D1);
+	omap_cfg_reg(AD17_34XX_CSI2_DX0);
+	omap_cfg_reg(AE18_34XX_CSI2_DY0);
+	omap_cfg_reg(AD16_34XX_CSI2_DX1);
+	omap_cfg_reg(AE17_34XX_CSI2_DY1);
+#endif
+
+    /*Initialize F_RDY_N pin for Xenon flash control.*/
+    if (gpio_request(36, "xenon flash ready pin") != 0)
+	pr_err("%s: Xenon flash ready pin control failure.\n",__func__);
+
+    gpio_direction_input(36);
+}
+
diff --git a/arch/arm/mach-omap2/board-sholest-flash.c b/arch/arm/mach-omap2/board-sholest-flash.c
new file mode 100644
index 0000000..e62a87c
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-flash.c
@@ -0,0 +1,120 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-flash.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Modified from mach-omap2/board-3430sdp-flash.c
+ *
+ * Copyright (c) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-2430sdp-flash.c
+ * Author: Rohit Choraria <rohitkc@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/onenand_regs.h>
+#include <linux/types.h>
+#include <linux/io.h>
+
+#include <asm/mach/flash.h>
+#include <mach/onenand.h>
+#include <mach/board.h>
+#include <mach/gpmc.h>
+#include <mach/nand.h>
+
+#define NAND_GPMC_CS		0
+
+static struct mtd_partition sdp_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name		= "X-Loader-NAND",
+		.offset		= 0,
+		.size		= 4 * (64 * 2048),
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "U-Boot-NAND",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x80000 */
+		.size		= 4 * (64 * 2048),
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "Boot Env-NAND",
+
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x100000 */
+		.size		= 2 * (64 * 2048),
+	},
+	{
+		.name		= "Kernel-NAND",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x140000 */
+		.size		= 32 * (64 * 2048),
+
+
+	},
+	{
+		.name		= "File System - NAND",
+		.size		= MTDPART_SIZ_FULL,
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x540000 */
+	},
+};
+
+
+static struct omap_nand_platform_data sdp_nand_data = {
+	.parts		= sdp_nand_partitions,
+	.nr_parts	= ARRAY_SIZE(sdp_nand_partitions),
+	.nand_setup	= NULL,
+	.dma_channel	= -1,		/* disable DMA in OMAP NAND driver */
+	.dev_ready	= NULL,
+	.cs		= NAND_GPMC_CS,
+	.gpmc_cs_baseaddr = (void *)(OMAP34XX_GPMC_VIRT + GPMC_CS0_BASE +
+		NAND_GPMC_CS*GPMC_CS_SIZE),
+	.gpmc_baseaddr  = (void *)(OMAP34XX_GPMC_VIRT),
+};
+
+
+static struct resource sdp_nand_resource = {
+	.flags		= IORESOURCE_MEM,
+};
+
+
+static struct platform_device sdp_nand_device = {
+	.name		= "omap2-nand",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &sdp_nand_data,
+	},
+	.num_resources	= 1,
+	.resource	= &sdp_nand_resource,
+};
+
+static int omap_nand_dev_ready(struct omap_nand_platform_data *data)
+{
+	printk(KERN_INFO "RDY/BSY line is connected!\n");
+	return 0;
+}
+
+/**
+ * sholest_flash_init - Identify devices connected to GPMC and register.
+ *
+ * @return - void.
+ */
+void __init sholest_flash_init(void)
+{
+#if !defined(CONFIG_CUP2TOUCH)
+	/* We know the RDY/BSY line is connected now */
+	sdp_nand_data.dev_ready = omap_nand_dev_ready;
+#endif
+
+	if (platform_device_register(&sdp_nand_device) < 0)
+		printk(KERN_ERR "Unable to register NAND device\n");
+
+	return;
+}
diff --git a/arch/arm/mach-omap2/board-sholest-gpio.c b/arch/arm/mach-omap2/board-sholest-gpio.c
new file mode 100644
index 0000000..7133644
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-gpio.c
@@ -0,0 +1,304 @@
+/*
+ * board-sholest-gpio.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Date	 Author	  Comment
+ * ===========  ==============  ==============================================
+ * Jun-23-2009  Motorola	Initial revision.
+ */
+
+#include <linux/module.h>
+
+#ifdef CONFIG_GPIODEV
+#include <linux/gpiodev.h>
+#endif
+
+#ifdef CONFIG_GPIO_MAPPING
+#include <linux/gpio_mapping.h>
+#endif
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#ifdef CONFIG_GPIODEV
+#define GPIO_DEVICE_SIZE 20
+#define GPIO_DEVICE_UNUSED 0xFFFF
+
+static struct gpio_device gpio_devs[GPIO_DEVICE_SIZE] = {
+	{
+		149,
+		"gps_rts",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		59,
+		"gps_reset",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		23,
+		"gps_standby",
+		GPIODEV_CONFIG_OUTPUT_LOW,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		160,
+		"gps_interrupt",
+		GPIODEV_CONFIG_INPUT | GPIODEV_CONFIG_INT_REDG,
+		GPIODEV_CONFIG_INVALID,
+		GPIODEV_FLAG_CONFIGURABLE | GPIODEV_FLAG_LOWLEVELACCESS,
+	},
+	{
+		GPIO_DEVICE_UNUSED,
+	},
+};
+
+static struct gpio_device_platform_data gpio_device_data = {
+	.name = "mapphone-gpiodev",
+	.info = gpio_devs,
+};
+
+static struct platform_device sholest_gpiodev_device = {
+	.name = GPIO_DEVICE_DEV_NAME,
+	.id = 0,
+	.dev = {
+		.platform_data = &gpio_device_data,
+	},
+};
+
+#ifdef CONFIG_ARM_OF
+/**
+ * Below structure definition should strictly comform to corresponding
+ * HW device tree format
+ */
+struct omap_gpiodev_entry {
+	u32 pin_num;				/* GPIO pin number  */
+	char name[GPIO_DEVICE_NAME_LEN];	/* GPIODev name */
+	u32 setting;				/* GPIO pin setting */
+} __attribute__ ((__packed__));
+
+static void gpiodev_devs_init(void *p_data)
+{
+	struct omap_gpiodev_entry *p = p_data;
+	struct gpio_device *p_devs = gpio_devs;
+	int i = 0;
+
+	while ((i < GPIO_DEVICE_NAME_LEN) && (' ' != p->name[i]))
+		i++;
+	p->name[i] = '\0';
+
+	for (i = 0; i < GPIO_DEVICE_SIZE; i++) {
+		if (p_devs[i].pin_nr == GPIO_DEVICE_UNUSED) {
+			p_devs[i].pin_nr = p->pin_num;
+			strcpy(p_devs[i].device_name, p->name);
+			p_devs[i].init_config = p->setting;
+			p_devs[i].current_config = GPIODEV_CONFIG_INVALID;
+			p_devs[i].flags = GPIODEV_FLAG_CONFIGURABLE |
+						GPIODEV_FLAG_LOWLEVELACCESS;
+
+			if (i != (GPIO_DEVICE_SIZE - 1))
+				p_devs[i + 1].pin_nr = GPIO_DEVICE_UNUSED;
+
+			printk(KERN_INFO "GPIODev: Add new device [%s] setting!\n",
+					p->name);
+			return;
+		}
+
+		if (strncmp(p_devs[i].device_name, p->name,
+			GPIO_DEVICE_NAME_LEN) == 0) {
+			p_devs[i].pin_nr = p->pin_num;
+			p_devs[i].init_config = p->setting;
+			p_devs[i].current_config = GPIODEV_CONFIG_INVALID;
+			p_devs[i].flags = GPIODEV_FLAG_CONFIGURABLE |
+						GPIODEV_FLAG_LOWLEVELACCESS;
+
+			printk(KERN_INFO "GPIODev: Overwrite device [%s] setting!\n",
+					p->name);
+			return;
+		}
+
+		if (i == (GPIO_DEVICE_SIZE - 1))
+			printk(KERN_ERR "GPIODev: Too big gpiodev count!\n");
+	}
+}
+
+static void gpio_devs_of_init(void)
+{
+	int size, unit_size, i, count;
+	struct device_node *node;
+	const void *prop;
+
+	node = of_find_node_by_path(DT_PATH_GPIOGEV);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_GPIOGEV);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_gpiodev_entry);
+	prop = of_get_property(node, DT_PROP_GPIODEV_INIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_GPIODEV_INIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "gpio_dev_size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		gpiodev_devs_init((struct omap_gpiodev_entry *)prop + i);
+
+	of_node_put(node);
+	return;
+}
+#endif
+
+static int __init sholest_init_gpiodev(void)
+{
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	gpio_devs_of_init();
+#endif
+
+	for (i = 0; i < GPIO_DEVICE_SIZE; i++) {
+		if (gpio_devs[i].pin_nr == GPIO_DEVICE_UNUSED)
+			break;
+	}
+	gpio_device_data.info_count = i;
+
+	return platform_device_register(&sholest_gpiodev_device);
+}
+device_initcall(sholest_init_gpiodev);
+#endif
+
+#ifdef CONFIG_GPIO_MAPPING
+#define GPIO_MAP_SIZE 50
+
+static struct gpio_mapping gpio_map_table[GPIO_MAP_SIZE] = {
+	{1, 27, "lcd_panel_reset"},
+	{1, 41, "lcd_panel_sd"},
+	{1, 149, "usb_ipc_phy_reset"},
+	{1, 164, "touch_panel_reset"},
+	{1, 163, "mmc_detect"},
+	{1, 110, "slider_data"},
+	{1, 65, "wlan_host_wake"},
+};
+
+#ifdef CONFIG_ARM_OF
+struct omap_gpio_map_entry {
+	u32 pin_num;
+	char name[GPIO_MAP_NAME_SIZE];
+} __attribute__ ((__packed__));
+
+void trim_gpio_map_string(char *s)
+{
+	int i;
+
+	/* ignore all characters behind space key */
+	for (i = 0; i < GPIO_MAP_NAME_SIZE; i++) {
+		if (' ' == s[i]) {
+			s[i] = '\0';
+			return;
+		}
+	}
+
+	printk(KERN_ERR "Too long gpio map string name!\n");
+}
+#endif
+#endif
+
+void __init sholest_gpio_mapping_init(void)
+{
+#ifdef CONFIG_GPIO_MAPPING
+#ifdef CONFIG_ARM_OF
+	struct device_node *node;
+	const void *prop;
+	int i, j, size, unit_size;
+	char name[GPIO_MAP_NAME_SIZE];
+
+	node = of_find_node_by_path(DT_PATH_GPIO);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_GPIO);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_gpio_map_entry);
+	prop = of_get_property(node, DT_PROP_GPIO_MAP, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_GPIO_MAP);
+		of_node_put(node);
+		return;
+	}
+
+	for (i = 0; i < size / unit_size; i++) {
+		struct omap_gpio_map_entry *p =
+				(struct omap_gpio_map_entry *) prop;
+
+		memcpy((void *) name, p->name, GPIO_MAP_NAME_SIZE);
+		trim_gpio_map_string(name);
+
+		for (j = 0; j < GPIO_MAP_SIZE; j++) {
+			if (gpio_map_table[j].used == 0) {
+				gpio_map_table[j].used = 1;
+				gpio_map_table[j].pin_num = p->pin_num;
+				strncpy(gpio_map_table[j].name, name,
+						GPIO_MAP_NAME_SIZE);
+				break;
+			} else if (strncmp(gpio_map_table[j].name, name,
+					GPIO_MAP_NAME_SIZE) == 0) {
+				gpio_map_table[j].pin_num = p->pin_num;
+				break;
+			}
+		}
+
+		if (j == GPIO_MAP_SIZE)
+			printk(KERN_ERR "Unable to write gpio_map_table\n");
+		else
+			printk(KERN_INFO "GPIO mapping write: pin = %d, name = %s\n",
+						gpio_map_table[j].pin_num,
+						gpio_map_table[j].name);
+
+		prop += unit_size;
+	}
+
+	of_node_put(node);
+	printk(KERN_INFO "DT overwrite GPIO Mapping done!\n");
+#else
+	printk(KERN_INFO "GPIO Mapping: Using no-dt configuration!\n");
+#endif
+	gpio_mapping_init(gpio_map_table, GPIO_MAP_SIZE);
+	printk(KERN_INFO "GPIO Mapping init done!\n");
+#else
+	printk(KERN_INFO "GPIO Mapping unused!\n");
+#endif
+}
diff --git a/arch/arm/mach-omap2/board-sholest-hsmmc.c b/arch/arm/mach-omap2/board-sholest-hsmmc.c
new file mode 100644
index 0000000..ae0282e
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-hsmmc.c
@@ -0,0 +1,350 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-hsmm.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from linux/arch/arm/mach-omap2/board-sdp-hsmmc.c
+ *
+ * Copyright (C) 2007-2008 Texas Instruments
+ * Copyright (C) 2008 Nokia Corporation
+ * Author: Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/hardware.h>
+#include <mach/control.h>
+#include <mach/mmc.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+
+#define GPIO_SIGNAL_MMC_DET 163
+
+static const int mmc2_cd_gpio = OMAP_MAX_GPIO_LINES + 1;
+
+static int hsmmc_card_detect(int irq)
+{
+	return !gpio_get_value_cansleep(GPIO_SIGNAL_MMC_DET);
+}
+
+#ifdef CONFIG_OMAP_HS_MMC2
+extern int sholest_wifi_status(int irq);
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+extern int sholest_wifi_status_register(void (*callback)(int card_present,
+						void *dev_id), void *dev_id);
+#endif
+
+static int hsmmc2_card_detect(int irq)
+{
+	return sholest_wifi_status(irq);
+}
+#endif
+
+/*
+ * MMC Slot Initialization.
+ */
+static struct regulator *hsmmc_regulator;
+static unsigned char hsmmc_regulator_is_on;
+DEFINE_MUTEX(regulator_lock);
+
+static int hsmmc_late_init(struct device *dev)
+{
+	int ret = 0;
+
+	/*
+	 * Configure GPIO parameters for MMC hotplug irq
+	 */
+	ret = gpio_request(GPIO_SIGNAL_MMC_DET, "mmc_detect");
+	if (ret < 0)
+		goto err;
+	ret = gpio_direction_input(GPIO_SIGNAL_MMC_DET);
+	if (ret < 0)
+		goto err2;
+
+	hsmmc_regulator = regulator_get(NULL, "vwlan2");
+	if (IS_ERR(hsmmc_regulator)) {
+		dev_dbg(dev, "vwlan2 regulator missing\n");
+		ret = PTR_ERR(hsmmc_regulator);
+		goto err2;
+	}
+
+	return ret;
+err2:
+	gpio_free(GPIO_SIGNAL_MMC_DET);
+err:
+	dev_err(dev, "Failed to configure GPIO MMC_DET\n");
+	return ret;
+}
+
+static void hsmmc_cleanup(struct device *dev)
+{
+	gpio_free(GPIO_SIGNAL_MMC_DET);
+	if (hsmmc_regulator)
+		regulator_put(hsmmc_regulator);
+}
+
+#ifdef CONFIG_PM
+/*
+ * To mask and unmask MMC Card Detect Interrupt
+ * mask : 1
+ * unmask : 0
+ */
+static int mask_cd_interrupt(int mask)
+{
+	return 0;
+}
+
+static int hsmmc_suspend(struct device *dev, int slot)
+{
+	int ret = 0;
+
+	disable_irq(gpio_to_irq(GPIO_SIGNAL_MMC_DET));
+	ret = mask_cd_interrupt(1);
+
+	return ret;
+}
+
+static int hsmmc_resume(struct device *dev, int slot)
+{
+	int ret = 0;
+
+	enable_irq(gpio_to_irq(GPIO_SIGNAL_MMC_DET));
+	ret = mask_cd_interrupt(0);
+
+	return ret;
+}
+#endif
+
+static int hsmmc_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	u32 reg;
+	int ret = 0;
+
+	if (power_on) {
+		reg = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0);
+		reg |= OMAP2_MMCSDIO1ADPCLKISEL;
+		omap_ctrl_writel(reg, OMAP2_CONTROL_DEVCONF0);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg &= ~OMAP2_PBIASSPEEDCTRL0;
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		mutex_lock(&regulator_lock);
+		if (!hsmmc_regulator_is_on) {
+			hsmmc_regulator_is_on = 1;
+			regulator_enable(hsmmc_regulator);
+			msleep(4);
+		}
+		mutex_unlock(&regulator_lock);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg |= OMAP2_PBIASLITEPWRDNZ0;
+		if ((1 << vdd) <= MMC_VDD_165_195)
+			reg &= ~OMAP2_PBIASLITEVMODE0;
+		else
+			reg |= OMAP2_PBIASLITEVMODE0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		return ret;
+	} else {
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg &= ~OMAP2_PBIASLITEPWRDNZ0;
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+
+		mutex_lock(&regulator_lock);
+		if (hsmmc_regulator_is_on) {
+			hsmmc_regulator_is_on = 0;
+			regulator_disable(hsmmc_regulator);
+			msleep(20);
+		}
+		mutex_unlock(&regulator_lock);
+
+		reg = omap_ctrl_readl(OMAP343X_CONTROL_PBIAS_LITE);
+		reg |= (OMAP2_PBIASLITEPWRDNZ0 | OMAP2_PBIASLITEVMODE0);
+		omap_ctrl_writel(reg, OMAP343X_CONTROL_PBIAS_LITE);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_MMC_TST
+int ex_hsmmc_set_power(struct device *dev, int slot, int power_on,
+						int vdd)
+{
+    hsmmc_set_power(dev, slot, power_on, vdd);
+    return 0;
+}
+EXPORT_SYMBOL(ex_hsmmc_set_power);
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+static int hsmmc2_late_init(struct device *dev)
+{
+	return 0;
+}
+
+static void hsmmc2_cleanup(struct device *dev)
+{
+}
+
+static int hsmmc2_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int hsmmc2_suspend(struct device *dev, int slot)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int hsmmc2_resume(struct device *dev, int slot)
+{
+	int ret = 0;
+	return ret;
+}
+#endif
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC3)
+static int hsmmc3_set_power(struct device *dev, int slot, int power_on,
+				int vdd)
+{
+	/* Power to the slot is hard wired */
+	return 0;
+}
+#endif
+
+static struct omap_mmc_platform_data mmc1_data = {
+	.nr_slots			= 1,
+	.init				= hsmmc_late_init,
+	.cleanup			= hsmmc_cleanup,
+#ifdef CONFIG_PM
+	.suspend			= hsmmc_suspend,
+	.resume				= hsmmc_resume,
+#endif
+	.dma_mask			= 0xffffffff,
+	.slots[0] = {
+		.wires			= 8,
+		.set_power		= hsmmc_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34 |
+						MMC_VDD_165_195,
+		.name			= "first slot",
+		/* we get car_detect_irq later */
+		.card_detect_irq	= 0,
+		.card_detect            = hsmmc_card_detect,
+	},
+};
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+static struct sdio_embedded_func wifi_func_array[] = {
+	{
+		.f_class        = SDIO_CLASS_NONE,
+		.f_maxblksize   = 0,
+	},
+	{
+		.f_class        = SDIO_CLASS_WLAN,
+		.f_maxblksize   = 512,
+	},
+};
+
+static struct embedded_sdio_data sholest_wifi_emb_data = {
+	.cis    = {
+		.vendor         = 0x104c,
+		.device         = 0x9066,
+		.blksize        = 512,
+		.max_dtr        = 24000000,
+	},
+	.cccr   = {
+		.multi_block    = 1,
+		.low_speed      = 0,
+		.wide_bus       = 1,
+		.high_power     = 0,
+		.high_speed     = 0,
+	},
+	.funcs  = wifi_func_array,
+	.num_funcs = 2,
+};
+#endif
+
+static struct omap_mmc_platform_data mmc2_data = {
+	.nr_slots			= 1,
+	.init				= hsmmc2_late_init,
+	.cleanup			= hsmmc2_cleanup,
+#ifdef CONFIG_PM
+	.suspend			= hsmmc2_suspend,
+	.resume				= hsmmc2_resume,
+#endif
+	.dma_mask			= 0xffffffff,
+#ifndef CONFIG_MMC_EMBEDDED_SDIO
+	.name				= "TIWLAN_SDIO",
+#endif
+	.slots[0] = {
+		.wires			= 4,
+		.set_power		= hsmmc2_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34 |
+						MMC_VDD_165_195,
+		.name			= "first slot",
+		.internal_clock		= 1,
+		.card_detect_irq        = 0,
+		.card_detect            = hsmmc2_card_detect,
+#ifdef CONFIG_MMC_EMBEDDED_SDIO
+		.embedded_sdio		= &sholest_wifi_emb_data,
+		.register_status_notify	= &sholest_wifi_status_register,
+#endif
+	},
+};
+#endif
+
+#if defined(CONFIG_OMAP_HS_MMC3)
+static struct omap_mmc_platform_data mmc3_data = {
+	.nr_slots			= 1,
+	.init				= NULL,
+	.cleanup			= NULL,
+	.dma_mask			= 0xffffffff,
+	.slots[0] = {
+		.wires			= 4,
+		.set_power		= hsmmc3_set_power,
+		.ocr_mask		= MMC_VDD_32_33 | MMC_VDD_33_34,
+		.name			= "first slot",
+
+		.card_detect_irq        = 0,
+		.card_detect            = NULL,
+	},
+};
+#endif
+
+static struct omap_mmc_platform_data *hsmmc_data[OMAP34XX_NR_MMC];
+
+void __init sholest_hsmmc_init(void)
+{
+	hsmmc_data[0] = &mmc1_data;
+
+	mmc1_data.slots[0].card_detect_irq = gpio_to_irq(GPIO_SIGNAL_MMC_DET);
+
+#if defined(CONFIG_OMAP_HS_MMC2)
+	hsmmc_data[1] = &mmc2_data;
+#endif
+#if defined(CONFIG_OMAP_HS_MMC3)
+	hsmmc_data[2] = &mmc3_data;
+#endif
+	omap2_init_mmc(hsmmc_data, OMAP34XX_NR_MMC);
+}
diff --git a/arch/arm/mach-omap2/board-sholest-keypad.c b/arch/arm/mach-omap2/board-sholest-keypad.c
new file mode 100644
index 0000000..b3af0a8
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-keypad.c
@@ -0,0 +1,158 @@
+/*
+ * arch/arm/mach-omap2/board-sholest-keypad.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/gpio_event.h>
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+#include <mach/board-sholest.h>
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+static unsigned int sholest_col_gpios[] = { 43, 56, 57 };
+static unsigned int sholest_row_gpios[] = { 37, 39 };
+
+#define KEYMAP_INDEX(col, row) ((col)*ARRAY_SIZE(sholest_row_gpios) + (row))
+
+static const unsigned short sholest_keymap[ARRAY_SIZE(sholest_col_gpios) *
+                                           ARRAY_SIZE(sholest_row_gpios)] = {
+	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEDOWN,
+    [KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,
+	
+	[KEYMAP_INDEX(1, 0)] = KEY_CAMERA-1,    /* camera 1 key, steal KEY_HP*/
+	[KEYMAP_INDEX(1, 1)] = KEY_CAMERA,      /* "camera 2" key */
+
+	[KEYMAP_INDEX(2, 0)] = KEY_RESERVED,
+	[KEYMAP_INDEX(2, 1)] = KEY_MACRO
+};
+
+static struct gpio_event_matrix_info sholest_keypad_matrix_info = {
+	.info.func = gpio_event_matrix_func,
+	.keymap = sholest_keymap,
+	.output_gpios = sholest_col_gpios,
+	.input_gpios = sholest_row_gpios,
+#ifndef CONFIG_ARM_OF
+	.sw_fixup = fixup,
+#endif
+	.noutputs = ARRAY_SIZE(sholest_col_gpios),
+	.ninputs = ARRAY_SIZE(sholest_row_gpios),
+	.settle_time.tv.nsec = 40 * NSEC_PER_USEC,
+	.poll_time.tv.nsec = 20 * NSEC_PER_MSEC,
+	.flags = GPIOKPF_LEVEL_TRIGGERED_IRQ | GPIOKPF_REMOVE_PHANTOM_KEYS |
+		 GPIOKPF_PRINT_UNMAPPED_KEYS /*| GPIOKPF_PRINT_MAPPED_KEYS*/
+};
+
+static struct gpio_event_direct_entry sholest_keypad_switch_map[] = {
+	{ GPIO_SILENCE_KEY,	SW_HEADPHONE_INSERT }
+};
+
+static struct gpio_event_input_info sholest_keypad_switch_info = {
+	.info.func = gpio_event_input_func,
+	.flags = 0,
+	.type = EV_SW,
+	.keymap = sholest_keypad_switch_map,
+	.keymap_size = ARRAY_SIZE(sholest_keypad_switch_map)
+};
+
+static struct gpio_event_info *sholest_keypad_info[] = {
+	&sholest_keypad_matrix_info.info,
+	&sholest_keypad_switch_info.info,
+};
+
+static struct gpio_event_platform_data sholest_keypad_data = {
+	.name = "sholes-keypad",
+	.info = sholest_keypad_info,
+	.info_count = ARRAY_SIZE(sholest_keypad_info)
+};
+
+static struct platform_device sholest_keypad_device = {
+	.name = GPIO_EVENT_DEV_NAME,
+	.id = 0,
+	.dev		= {
+		.platform_data	= &sholest_keypad_data,
+	},
+};
+
+#ifdef CONFIG_ARM_OF
+static int __init sholest_dt_kp_init(void)
+{
+	struct device_node *kp_node;
+	const void *kp_prop;
+
+	if ((kp_node = of_find_node_by_path(DT_PATH_KEYPAD))) {
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_ROWS, NULL)))
+			sholest_keypad_matrix_info.ninputs = \
+				*(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_COLS, NULL)))
+			sholest_keypad_matrix_info.noutputs = \
+				*(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_ROWREG, NULL)))
+			sholest_keypad_matrix_info.input_gpios = \
+				(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_COLREG, NULL)))
+			sholest_keypad_matrix_info.output_gpios = \
+				(int *)kp_prop;
+
+		if ((kp_prop = of_get_property(kp_node, \
+				DT_PROP_KEYPAD_MAPS, NULL)))
+			sholest_keypad_matrix_info.keymap = \
+				(unsigned short *)kp_prop;
+
+		of_node_put(kp_node);
+	}
+
+	return kp_node ? 0 : -ENODEV;
+}
+#endif
+
+static int __init sholest_init_keypad(void)
+{
+#ifdef CONFIG_ARM_OF
+	if (sholest_dt_kp_init())
+		printk(KERN_INFO "Keypad: using non-dt configuration\n");
+#endif
+
+	/* keypad rows */
+	omap_cfg_reg(K4_34XX_GPIO37);
+	omap_cfg_reg(R3_34XX_GPIO39);
+
+	/* keypad columns */
+	omap_cfg_reg(K3_34XX_GPIO43_OUT);
+	omap_cfg_reg(R8_34XX_GPIO56_OUT);
+	omap_cfg_reg(P8_34XX_GPIO57_OUT);
+
+	/* switches */
+	omap_cfg_reg(AB2_34XX_GPIO177);
+	omap_cfg_reg(AH17_34XX_GPIO100);
+
+	return platform_device_register(&sholest_keypad_device);
+}
+
+device_initcall(sholest_init_keypad);
diff --git a/arch/arm/mach-omap2/board-sholest-mdtv.c b/arch/arm/mach-omap2/board-sholest-mdtv.c
new file mode 100644
index 0000000..1c26d28
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-mdtv.c
@@ -0,0 +1,109 @@
+/*
+ * linux/arch/arm/mach-omap2/board-MAPPHONE-sensors.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+
+#include "linux/i2c/lp3907_i2c.h"
+
+#define SHOLEST_MDTV_INT_GPIO			38
+#define SHOLEST_MDTV_PWDN_GPIO			53
+#define SHOLEST_MDTV_RESET_N_GPIO		54
+#define SHOLEST_MDTV_REG_EN_GPIO		21
+
+static int sholest_lp3907_init(void)
+{
+	printk(KERN_INFO "sholest_lp3907_init()");
+	return 0;
+}
+
+static void sholest_lp3907_exit(void)
+{
+	/*regulator_put(sholest_akm8973_regulator);*/
+}
+
+static int sholest_lp3907_power_on(void)
+{
+	/* EN_T is high */
+	gpio_set_value(SHOLEST_MDTV_REG_EN_GPIO, 1);
+	mdelay(6);	/* stable time */
+
+	/* SPI pin control */
+	/*omap_cfg_reg(F1_34XX_MDTV_INT_ON);*/
+	omap_cfg_reg(AC3_34XX_MDTV_SIMO_ON);
+	omap_cfg_reg(AD4_34XX_MDTV_SOMI_ON);
+	omap_cfg_reg(AD3_34XX_MDTV_CS_ON);
+	omap_cfg_reg(AA3_34XX_MDTV_CLK_ON);
+	mdelay(5);
+
+	printk(KERN_INFO "sholest_lp3907_power_on()");
+	return 0;
+}
+
+static int sholest_lp3907_power_off(void)
+{
+	/* SPI pin control */
+	/*omap_cfg_reg(F1_34XX_MDTV_INT_OFF);*/
+	omap_cfg_reg(AC3_34XX_MDTV_SIMO_OFF);
+	omap_cfg_reg(AD4_34XX_MDTV_SOMI_OFF);
+	omap_cfg_reg(AD3_34XX_MDTV_CS_OFF);
+	omap_cfg_reg(AA3_34XX_MDTV_CLK_OFF);
+
+	/* EN_T is low */
+	gpio_set_value(SHOLEST_MDTV_REG_EN_GPIO, 0);
+	mdelay(6); /* stable time */
+
+	printk(KERN_INFO "sholest_lp3907_power_off()");
+	return 0;
+}
+
+struct lp3907_platform_data sholest_lp3907_data = {
+	.init = sholest_lp3907_init,
+	.exit = sholest_lp3907_exit,
+	.power_on = sholest_lp3907_power_on,
+	.power_off = sholest_lp3907_power_off,
+};
+
+/*
+*	TDMB module initialize.
+*/
+void __init sholest_mdtv_init(void)
+{
+	/* MTV_INT pin */
+	gpio_request(SHOLEST_MDTV_INT_GPIO, "sms1130 int");
+	gpio_direction_input(SHOLEST_MDTV_INT_GPIO);
+	omap_cfg_reg(T3_34XX_GPIO38);
+
+	/* MTV_PWDN pin - low */
+	gpio_request(SHOLEST_MDTV_PWDN_GPIO, "sms1130 pwdn");
+	gpio_direction_output(SHOLEST_MDTV_PWDN_GPIO, 0);
+	omap_cfg_reg(V8_34XX_GPIO53_OUT);
+
+	/* MTV_RST_N pin - low */
+	gpio_request(SHOLEST_MDTV_RESET_N_GPIO, "sms1130 reset");
+	gpio_direction_output(SHOLEST_MDTV_RESET_N_GPIO, 0);
+	omap_cfg_reg(U8_34XX_GPIO54_OUT);
+
+	/* MTV_REG_EN pin - low */
+	gpio_request(SHOLEST_MDTV_REG_EN_GPIO, "lp3907 en");
+	gpio_direction_output(SHOLEST_MDTV_REG_EN_GPIO, 0);
+	omap_cfg_reg(V8_34XX_GPIO53_OUT);
+
+	printk(KERN_INFO "[TDMB] sholest_mdtv_init()\n");
+}
diff --git a/arch/arm/mach-omap2/board-sholest-mmcprobe.c b/arch/arm/mach-omap2/board-sholest-mmcprobe.c
new file mode 100644
index 0000000..adf6c11
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-mmcprobe.c
@@ -0,0 +1,78 @@
+/*
+ * arch/arm/mach-omap2/board-sholest-mmcprobe.c
+ *
+ * Copyright (C) 2007-2009 Google Inc.
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * San Mehat (san@android.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/reboot.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/setup.h>
+
+#include <mach/board-sholest.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/common.h>
+#include <mach/control.h>
+#include <linux/delay.h>
+
+#define CH_BASE_GPIO 120
+
+void sholest_mmcprobe_strobe(int ch, int rpt)
+{
+	int i;
+
+	for (i = 0; i < rpt; i++) {
+		gpio_direction_output(CH_BASE_GPIO + ch, 1);
+		udelay(10);
+		gpio_direction_output(CH_BASE_GPIO + ch, 0);
+		udelay(10);
+	}
+}
+
+void sholest_mmcprobe_set(int ch, int lvl)
+{
+	gpio_direction_output(CH_BASE_GPIO + ch, lvl);
+}
+
+void __init sholest_mmcprobe_init(void)
+{
+	int i;
+
+	printk(KERN_INFO "sholest_mmcprobe: MMC subsystem ganked for debug\n");
+
+	omap_ctrl_writew(0x04, 0x144); /* MMC1_CLK/GPIO120 */
+	omap_ctrl_writew(0x04, 0x146); /* MMC1_CMD/GPIO121 */
+	omap_ctrl_writew(0x04, 0x148); /* MMC1_DAT0/GPIO122 */
+	omap_ctrl_writew(0x04, 0x14a); /* MMC1_DAT1/GPIO123 */
+	omap_ctrl_writew(0x04, 0x14c); /* MMC1_DAT2/GPIO124 */
+	omap_ctrl_writew(0x04, 0x14e); /* MMC1_DAT3/GPIO125 */
+
+	gpio_request(120, "mmcprobe-ch1");
+	gpio_request(121, "mmcprobe-ch2");
+	gpio_request(122, "mmcprobe-ch3");
+	gpio_request(123, "mmcprobe-ch4");
+	gpio_request(124, "mmcprobe-ch5");
+	gpio_request(125, "mmcprobe-ch6");
+
+	for (i = 0; i < 5; i++)
+		sholest_mmcprobe_strobe(i, 1 + i);
+}
diff --git a/arch/arm/mach-omap2/board-sholest-padconf.c b/arch/arm/mach-omap2/board-sholest-padconf.c
new file mode 100644
index 0000000..b6942ab
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-padconf.c
@@ -0,0 +1,1837 @@
+/*
+ * board-sholest-padconf.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+
+#include <mach/hardware.h>
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+#ifdef CONFIG_EMU_UART_DEBUG
+#include <mach/board-mapphone-emu_uart.h>
+#endif
+
+struct iomux_range {
+	unsigned int start;
+	unsigned int end;
+};
+
+static struct iomux_range iomux_range_base[] = {
+	{OMAP343X_PADCONF_CORE_CTRL_BASE, OMAP343X_PADCONF_CORE_CTRL_TOP},
+	{OMAP343X_PADCONF_CORE_ETK_BASE, OMAP343X_PADCONF_CORE_ETK_TOP},
+	{OMAP343X_PADCONF_CORE_D2D_BASE, OMAP343X_PADCONF_CORE_D2D_TOP},
+	{OMAP343X_PADCONF_WKUP_BASE, OMAP343X_PADCONF_WKUP_TOP},
+	{OMAP343X_PADCONF_WKUP_D2D_BASE, OMAP343X_PADCONF_WKUP_D2D_TOP}
+};
+
+inline bool is_omap343x_padconf_register(uint16_t offset)
+{
+	unsigned long addr = offset + OMAP343X_CTRL_BASE;
+	unsigned int i;
+
+	if  ((offset & 0x1) != 0x0)
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(iomux_range_base); i++)
+		if (addr >= iomux_range_base[i].start &&
+			 addr <= iomux_range_base[i].end)
+			return 1;
+
+	return 0;
+}
+
+static __initdata struct {
+	uint16_t offset;
+	uint16_t setting;
+} padconf_settings[] = {
+	/* SDRC_D0 */
+	{
+	0x0030,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D1 */
+	{
+	0x0032,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D2 */
+	{
+	0x0034,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D3 */
+	{
+	0x0036,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D4 */
+	{
+	0x0038,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D5 */
+	{
+	0x003A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D6 */
+	{
+	0x003C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D7 */
+	{
+	0x003E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D8 */
+	{
+	0x0040,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D9 */
+	{
+	0x0042,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D10 */
+	{
+	0x0044,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D11 */
+	{
+	0x0046,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D12 */
+	{
+	0x0048,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D13 */
+	{
+	0x004A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D14 */
+	{
+	0x004C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D15 */
+	{
+	0x004E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D16 */
+	{
+	0x0050,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D17 */
+	{
+	0x0052,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D18 */
+	{
+	0x0054,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D19 */
+	{
+	0x0056,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D20 */
+	{
+	0x0058,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D21 */
+	{
+	0x005A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D22 */
+	{
+	0x005C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D23 */
+	{
+	0x005E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D24 */
+	{
+	0x0060,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D25 */
+	{
+	0x0062,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D26 */
+	{
+	0x0064,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D27 */
+	{
+	0x0066,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D28 */
+	{
+	0x0068,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D29 */
+	{
+	0x006A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D30 */
+	{
+	0x006C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_D31 */
+	{
+	0x006E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CLK */
+	{
+	0x0070,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS0 */
+	{
+	0x0072,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS1 */
+	{
+	0x0074,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS2 */
+	{
+	0x0076,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_DQS3 */
+	{
+	0x0078,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_A1 */
+	{
+	0x007A,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A2 */
+	{
+	0x007C,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A3 */
+	{
+	0x007E,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A4 */
+	{
+	0x0080,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A5 */
+	{
+	0x0082,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A6 */
+	{
+	0x0084,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A7 */
+	{
+	0x0086,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A8 */
+	{
+	0x0088,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_A9 */
+	{
+	0x008A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* GPMC_A10 */
+	{
+	0x008C, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_D0 */
+	{
+	0x008E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D1 */
+	{
+	0x0090,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D2 */
+	{
+	0x0092,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D3 */
+	{
+	0x0094,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D4 */
+	{
+	0x0096,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D5 */
+	{
+	0x0098,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D6 */
+	{
+	0x009A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D7 */
+	{
+	0x009C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D8 */
+	{
+	0x009E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D9 */
+	{
+	0x00A0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D10 */
+	{
+	0x00A2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D11 */
+	{
+	0x00A4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D12 */
+	{
+	0x00A6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D13 */
+	{
+	0x00A8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D14 */
+	{
+	0x00AA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_D15 */
+	{
+	0x00AC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS0 */
+	{
+	0x00AE,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS1 */
+	{
+	0x00B0,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NCS2 */
+	{
+	0x00B2, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS3 */
+	{
+	0x00B4, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS4 */
+	{
+	0x00B6, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS5 */
+	{
+	0x00B8, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS6 */
+	{
+	0x00BA, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NCS7 */
+	{
+	0x00BC, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_CLK */
+	{
+	0x00BE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_NADV_ALE */
+	{
+	0x00C0,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NOE */
+	{
+	0x00C2,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NWE */
+	{
+	0x00C4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NBE0_CLE */
+	{
+	0x00C6,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NBE1 */
+	{
+	0x00C8,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_NWP */
+	{
+	0x00CA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_WAIT0 */
+	{
+	0x00CC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* GPMC_WAIT1 */
+	{
+	0x00CE, OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_WAIT2 */
+	{
+	0x00D0, OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* GPMC_WAIT3 */
+	{
+	0x00D2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_PCLK */
+	{
+	0x00D4, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_HSYNC */
+	{
+	0x00D6, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_VSYNC */
+	{
+	0x00D8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_ACBIAS */
+	{
+	0x00DA, OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA0 */
+	{
+	0x00DC,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA1 */
+	{
+	0x00DE,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA2 */
+	{
+	0x00E0,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA3 */
+	{
+	0x00E2,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA4 */
+	{
+	0x00E4,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA5 */
+	{
+	0x00E6,
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_MUXMODE1},
+	    /* DSS_DATA6 */
+	{
+	0x00E8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA7 */
+	{
+	0x00EA, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA8 */
+	{
+	0x00EC, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA9 */
+	{
+	0x00EE, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA10 */
+	{
+	0x00F0, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA11 */
+	{
+	0x00F2, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA12 */
+	{
+	0x00F4, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA13 */
+	{
+	0x00F6, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA14 */
+	{
+	0x00F8, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA15 */
+	{
+	0x00FA, OMAP343X_PADCONF_MUXMODE0},
+	    /* DSS_DATA16 */
+	{
+	0x00FC, OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA17 */
+	{
+	0x00FE,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA18 */
+	{
+	0x0100,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA19 */
+	{
+	0x0102, OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA20 */
+	{
+	0x0104,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA21 */
+	{
+	0x0106, OMAP343X_PADCONF_MUXMODE2},
+	    /* DSS_DATA22 */
+	{
+	0x0108,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* DSS_DATA23 */
+	{
+	0x010A, OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_HS */
+	{
+	0x010C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_VS */
+	{
+	0x010E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_XCLKA */
+	{
+	0x0110, OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_PCLK */
+	{
+	0x0112,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_FLD */
+	{
+	0x0114, OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D0 */
+	{
+	0x0116,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D1 */
+	{
+	0x0118,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_D2 */
+	{
+	0x011A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D3 */
+	{
+	0x011C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D4 */
+	{
+	0x011E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D5 */
+	{
+	0x0120,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D6 */
+	{
+	0x0122,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D7 */
+	{
+	0x0124,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D8 */
+	{
+	0x0126,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D9 */
+	{
+	0x0128,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D10 */
+	{
+	0x012A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_D11 */
+	{
+	0x012C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* CAM_XCLKB */
+	{
+	0x012E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* CAM_WEN */
+	{
+	0x0130, OMAP343X_PADCONF_MUXMODE2},
+	    /* CAM_STROBE */
+	{
+	0x0132, OMAP343X_PADCONF_MUXMODE0},
+	    /* CSI2_DX0 */
+	{
+	0x0134,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DY0 */
+	{
+	0x0136,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DX1 */
+	{
+	0x0138,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* CSI2_DY1 */
+	{
+	0x013A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE7},
+	    /* MCBSP2_FSX */
+	{
+	0x013C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_CLKX */
+	{
+	0x013E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_DR */
+	{
+	0x0140,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP2_DX */
+	{
+	0x0142,
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_CLK */
+	{
+	0x0144, OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_CMD */
+	{
+	0x0146,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT0 */
+	{
+	0x0148,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT1 */
+	{
+	0x014A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT2 */
+	{
+	0x014C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT3 */
+	{
+	0x014E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC1_DAT4 */
+	{
+	0x0150,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT5 */
+	{
+	0x0152,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT6 */
+	{
+	0x0154,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC1_DAT7 */
+	{
+	0x0156,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MMC2_CLK */
+	{
+	0x0158,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_CMD */
+	{
+	0x015A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT0 */
+	{
+	0x015C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT1 */
+	{
+	0x015E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT2 */
+	{
+	0x0160,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT3 */
+	{
+	0x0162,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MMC2_DAT4 */
+	{
+	0x0164, OMAP343X_PADCONF_MUXMODE4},
+	    /* MMC2_DAT5 */
+	{
+	0x0166,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MMC2_DAT6 */
+	{
+	0x0168,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MMC2_DAT7 */
+	{
+	0x016A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_DX */
+	{
+	0x016C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_DR */
+	{
+	0x016E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_CLKX */
+	{
+	0x0170,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP3_FSX */
+	{
+	0x0172,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* UART2_CTS */
+	{
+	0x0174,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_RTS */
+	{
+	0x0176, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_TX */
+	{
+	0x0178, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART2_RX */
+	{
+	0x017A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_TX */
+	{
+	0x017C, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_RTS */
+	{
+	0x017E, OMAP343X_PADCONF_MUXMODE0},
+	    /* UART1_CTS */
+	{
+	0x0180,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* UART1_RX */
+	{
+	0x0182,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCBSP4_CLKX */
+	{
+	0x0184,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_DR */
+	{
+	0x0186,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_DX */
+	{
+	0x0188,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP4_FSX */
+	{
+	0x018A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE5},
+	    /* MCBSP1_CLKR */
+	{
+	0x018C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_FSR */
+	{
+	0x018E, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCBSP1_DX */
+	{
+	0x0190,
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_DR */
+	{
+	0x0192,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP_CLKS */
+	{
+	0x0194,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCBSP1_FSX */
+	{
+	0x0196,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* MCBSP1_CLKX */
+	{
+	0x0198,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE2},
+	    /* UART3_CTS_RCTX */
+	{
+	0x019A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* UART3_RTS_SD */
+	{
+	0x019C,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* UART3_RX_IRRX */
+	{
+	0x019E,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* UART3_TX_IRTX */
+	{
+	0x01A0, OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_CLK */
+	{
+	0x01A2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_STP */
+	{
+	0x01A4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DIR */
+	{
+	0x01A6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_NXT */
+	{
+	0x01A8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA0 */
+	{
+	0x01AA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA1 */
+	{
+	0x01AC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA2 */
+	{
+	0x01AE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA3 */
+	{
+	0x01B0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA4 */
+	{
+	0x01B2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA5 */
+	{
+	0x01B4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA6 */
+	{
+	0x01B6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HSUSB0_DATA7 */
+	{
+	0x01B8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C1_SCL */
+	{
+	0x01BA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C1_SDA */
+	{
+	0x01BC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C2_SCL */
+	{
+	0x01BE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C2_SDA */
+	{
+	0x01C0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C3_SCL */
+	{
+	0x01C2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C3_SDA */
+	{
+	0x01C4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* HDQ_SIO */
+	{
+	0x01C6,
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CLK */
+	{
+	0x01C8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_SIMO */
+	{
+	0x01CA, OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_SOMI */
+	{
+	0x01CC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CS0 */
+	{
+	0x01CE, OMAP343X_PADCONF_MUXMODE0},
+	    /* MCSPI1_CS1 */
+	{
+	0x01D0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI1_CS2 */
+	{
+	0x01D2,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI1_CS3 */
+	{
+	0x01D4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CLK */
+	{
+	0x01D6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_SIMO */
+	{
+	0x01D8, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_SOMI */
+	{
+	0x01DA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CS0 */
+	{
+	0x01DC, OMAP343X_PADCONF_MUXMODE4},
+	    /* MCSPI2_CS1 */
+	{
+	0x01DE,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* SYS_NIRQ */
+	{
+	0x01E0,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_CLKOUT2 */
+	{
+	0x01E2, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_CLK */
+	{
+	0x05D8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_CTL */
+	{
+	0x05DA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D0 */
+	{
+	0x05DC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D1 */
+	{
+	0x05DE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D2 */
+	{
+	0x05E0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D3 */
+	{
+	0x05E2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D4 */
+	{
+	0x05E4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D5 */
+	{
+	0x05E6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D6 */
+	{
+	0x05E8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D7 */
+	{
+	0x05EA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D8 */
+	{
+	0x05EC, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D9 */
+	{
+	0x05EE, OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D10 */
+	{
+	0x05F0, OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D11 */
+	{
+	0x05F2,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D12 */
+	{
+	0x05F4,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* ETK_D13 */
+	{
+	0x05F6,
+		    OMAP343X_PADCONF_PULL_UP | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D14 */
+	{
+	0x05F8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* ETK_D15 */
+	{
+	0x05FA,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE3},
+	    /* SAD2D_MCAD0 */
+	{
+	0x01E4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD1 */
+	{
+	0x01E6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD2 */
+	{
+	0x01E8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD3 */
+	{
+	0x01EA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD4 */
+	{
+	0x01EC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD5 */
+	{
+	0x01EE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD6 */
+	{
+	0x01F0,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD7 */
+	{
+	0x01F2,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD8 */
+	{
+	0x01F4,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD9 */
+	{
+	0x01F6,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD10 */
+	{
+	0x01F8,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD11 */
+	{
+	0x01FA,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD12 */
+	{
+	0x01FC,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD13 */
+	{
+	0x01FE,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD14 */
+	{
+	0x0200,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD15 */
+	{
+	0x0202,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD16 */
+	{
+	0x0204,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD17 */
+	{
+	0x0206,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD18 */
+	{
+	0x0208,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD19 */
+	{
+	0x020A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD20 */
+	{
+	0x020C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD21 */
+	{
+	0x020E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD22 */
+	{
+	0x0210,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD23 */
+	{
+	0x0212,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD24 */
+	{
+	0x0214,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD25 */
+	{
+	0x0216,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD26 */
+	{
+	0x0218,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD27 */
+	{
+	0x021A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD28 */
+	{
+	0x021C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD29 */
+	{
+	0x021E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD30 */
+	{
+	0x0220,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD31 */
+	{
+	0x0222,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD32 */
+	{
+	0x0224,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD33 */
+	{
+	0x0226,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD34 */
+	{
+	0x0228,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD35 */
+	{
+	0x022A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MCAD36 */
+	{
+	0x022C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_CLK26MI */
+	{
+	0x022E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NRESPWRON */
+	{
+	0x0230,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NRESWARM */
+	{
+	0x0232,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_ARMNIRQ */
+	{
+	0x0234,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_UMAFIQ */
+	{
+	0x0236,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SPINT */
+	{
+	0x0238,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_FRINT */
+	{
+	0x023A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ0 */
+	{
+	0x023C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ1 */
+	{
+	0x023E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ2 */
+	{
+	0x0240,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_DMAREQ3 */
+	{
+	0x0242,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_NTRST */
+	{
+	0x0244,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TDI */
+	{
+	0x0246,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TDO */
+	{
+	0x0248,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TMS */
+	{
+	0x024A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_TCK */
+	{
+	0x024C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_RTCK */
+	{
+	0x024E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MSTDBY */
+	{
+	0x0250,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_IDLEREQ */
+	{
+	0x0252,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_IDLEACK */
+	{
+	0x0254,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MWRITE */
+	{
+	0x0256,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SWRITE */
+	{
+	0x0258,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MREAD */
+	{
+	0x025A,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SREAD */
+	{
+	0x025C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_MBUSFLAG */
+	{
+	0x025E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SBUSFLAG */
+	{
+	0x0260,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CKE0 */
+	{
+	0x0262,
+		    OMAP343X_PADCONF_PUD_DISABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SDRC_CKE1 */
+	{
+	0x0264,
+			OMAP343X_PADCONF_INPUT_ENABLED |
+			OMAP343X_PADCONF_PULL_UP |
+			OMAP343X_PADCONF_PUD_ENABLED |
+			OMAP343X_PADCONF_MUXMODE7},
+	    /* I2C4_SCL */
+	{
+	0x0A00,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* I2C4_SDA */
+	{
+	0x0A02,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_32K */
+	{
+	0x0A04,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_CLKREQ */
+	{
+	0x0A06,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_NRESWARM */
+	{
+	0x0A08,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT0 */
+	{
+	0x0A0A,
+		    OMAP343X_PADCONF_OFF_WAKEUP_ENABLED |
+		    OMAP343X_PADCONF_OFF_PULL_DOWN |
+		    OMAP343X_PADCONF_OFF_PUD_ENABLED |
+		    OMAP343X_PADCONF_OFF_OUTPUT_LOW |
+		    OMAP343X_PADCONF_OFF_OUTPUT_ENABLED |
+		    OMAP343X_PADCONF_OFFMODE_ENABLED |
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PUD_DISABLED |
+			OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT1 */
+	{
+	0x0A0C,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT2 */
+	{
+	0x0A0E,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT3 */
+	{
+	0x0A10,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT4 */
+	{
+	0x0A12,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT5 */
+	{
+	0x0A14,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SYS_BOOT6 */
+	{
+	0x0A16, OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_OFF_MODE */
+	{
+	0x0A18,
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* SYS_CLKOUT1 */
+	{
+	0x0A1A,
+		    OMAP343X_PADCONF_INPUT_ENABLED | OMAP343X_PADCONF_MUXMODE4},
+	    /* JTAG_NTRST */
+	{
+	0x0A1C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TCK */
+	{
+	0x0A1E,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TMS_TMSC */
+	{
+	0x0A20,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TDI */
+	{
+	0x0A22,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_EMU0 */
+	{
+	0x0A24,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_EMU1 */
+	{
+	0x0A26,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_UP |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* SAD2D_SWAKEUP */
+	{
+	0x0A4C,
+		    OMAP343X_PADCONF_INPUT_ENABLED |
+		    OMAP343X_PADCONF_PULL_DOWN |
+		    OMAP343X_PADCONF_PUD_ENABLED | OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_RTCK */
+	{
+	0x0A4E, OMAP343X_PADCONF_MUXMODE0},
+	    /* JTAG_TDO */
+	{
+	0x0A50, OMAP343X_PADCONF_MUXMODE0},};
+
+#ifdef CONFIG_ARM_OF
+static void __init mux_pad_callback(const void *p_data)
+{
+	struct mux_conf_entry *p = (struct mux_conf_entry *)p_data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (padconf_settings[i].offset == p->offset) {
+			padconf_settings[i].setting &= (~(OMAP343X_PAD_MASK));
+
+			padconf_settings[i].setting |=
+			    (MAKE_OMAP343X_PAD_VALUE
+			     (p->mode, p->input_en, p->pull_type));
+
+			return;
+		}
+	}
+
+	printk(KERN_ERR "padconf override failed, offset = 0x%04x\n",
+			p->offset);
+}
+
+static void __init mux_offmode_callback(const void *p_data)
+{
+	struct mux_offmode_conf_entry *p =
+	    (struct mux_offmode_conf_entry *)p_data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (padconf_settings[i].offset == p->offset) {
+			padconf_settings[i].setting &=
+			    (~(OMAP343X_OFFMODE_MASK));
+
+			padconf_settings[i].setting |=
+			    (MAKE_OMAP343X_OFFMODE_VALUE
+			     (p->offmode_en, p->offout_type, p->offpull_type,
+			      p->offwkup_en));
+
+			return;
+		}
+	}
+
+	printk(KERN_ERR "padconf offmode override failed, offset = 0x%04x\n",
+	       p->offset);
+}
+
+void dt_prop_or_init(struct dt_operation *op)
+{
+	struct device_node *node;
+	const void *prop;
+	int i, size;
+
+	node = of_find_node_by_path(op->path);
+	if (node == NULL) {
+		printk(KERN_ERR "Unable to read node %s from device tree!\n",
+		       op->path);
+		return;
+	}
+
+	prop = of_get_property(node, op->prop, &size);
+	if ((!prop) || (size % op->prop_unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n", op->prop);
+	} else {
+		for (i = 0; i < size / op->prop_unit_size; i++) {
+			(*op->callback) (prop);
+			prop += op->prop_unit_size;
+		}
+	}
+
+	of_node_put(node);
+	printk(KERN_INFO "Device tree prop %s override done\n", op->prop);
+}
+
+void __init mux_setting_init(void)
+{
+	struct dt_operation op;
+
+	/* Read and implement MUX pad setting for pad registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_PAD;
+	op.prop_unit_size = sizeof(struct mux_conf_entry);
+	op.callback = mux_pad_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX pad setting for pad wakeups registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_PADWKUPS;
+	op.prop_unit_size = sizeof(struct mux_conf_entry);
+	op.callback = mux_pad_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX off mode setting for pad registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_OFFMODE;
+	op.prop_unit_size = sizeof(struct mux_offmode_conf_entry);
+	op.callback = mux_offmode_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+
+	/* Read and implement MUX off mode setting for pad wakeups registers */
+	op.path = DT_PATH_MUX;
+	op.prop = DT_PROP_MUX_OFFMODEWKUPS;
+	op.prop_unit_size = sizeof(struct mux_offmode_conf_entry);
+	op.callback = mux_offmode_callback;
+	op.name_size = 2;
+	dt_prop_or_init(&op);
+}
+#endif
+
+void __init sholest_padconf_init(void)
+{
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	mux_setting_init();
+#endif
+
+	for (i = 0; i < ARRAY_SIZE(padconf_settings); i++) {
+		if (is_omap343x_padconf_register(padconf_settings[i].offset)) {
+			unsigned long addr = padconf_settings[i].offset
+			    + OMAP343X_CTRL_BASE;
+			/*
+			   despite the w, omap_readw actual reads a short which
+			   is a half word on this architecture
+			 */
+			unsigned short val = omap_readw(addr);
+#ifdef CONFIG_EMU_UART_DEBUG
+			if (is_emu_uart_iomux_reg(padconf_settings[i].offset)) {
+				printk(KERN_ERR "padconf ignored, offset = 0x%04x\n",
+						padconf_settings[i].offset);
+				continue;
+			}
+#endif
+			val &= ~(OMAP343X_PADCONF_SETTING_MASK);
+			val |= padconf_settings[i].setting;
+
+			omap_writew(val, addr);
+		} else {
+			printk(KERN_ERR "padconf check failed, offset = 0x%04x\n",
+						padconf_settings[i].offset);
+		}
+	}
+
+	return;
+}
diff --git a/arch/arm/mach-omap2/board-sholest-panel.c b/arch/arm/mach-omap2/board-sholest-panel.c
new file mode 100644
index 0000000..f1996e2
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-panel.c
@@ -0,0 +1,202 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-panel.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/omapfb.h>
+
+#include <mach/display.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/resource.h>
+
+#define SHOLEST_DISPLAY_RESET_GPIO	136
+
+#ifdef CONFIG_PANEL_HDTV /* charlotte */
+#define SHOLEST_HDMI_MUX_ENABLE_N_GPIO 69
+#define SHOLEST_HDMI_MUX_SELECT_GPIO     7
+#endif
+
+struct regulator *display_regulator;
+
+static int sholest_panel_enable(struct omap_dss_device *dssdev)
+{
+	if (!display_regulator) {
+		display_regulator = regulator_get(NULL, "vhvio");
+		if (IS_ERR(display_regulator)) {
+			printk(KERN_ERR "failed to get regulator for display");
+			return PTR_ERR(display_regulator);
+		}
+#ifndef CONFIG_FB_OMAP2_MTD_LOGO
+		regulator_enable(display_regulator);
+		return 0;
+#endif
+	}
+
+	regulator_enable(display_regulator);
+	msleep(1);
+	gpio_request(SHOLEST_DISPLAY_RESET_GPIO, "display reset");
+	gpio_direction_output(SHOLEST_DISPLAY_RESET_GPIO, 1);
+	msleep(5);
+	gpio_set_value(SHOLEST_DISPLAY_RESET_GPIO, 0);
+	msleep(12); // low pulse width 5 -> 12
+	gpio_set_value(SHOLEST_DISPLAY_RESET_GPIO, 1);
+	msleep(12); // power stabilize 10 -> 12
+	return 0;
+}
+
+static void sholest_panel_disable(struct omap_dss_device *dssdev)
+{
+	gpio_direction_output(SHOLEST_DISPLAY_RESET_GPIO, 1);
+	gpio_set_value(SHOLEST_DISPLAY_RESET_GPIO, 0);
+	msleep(1);
+	regulator_disable(display_regulator);
+}
+
+static struct omapfb_platform_data sholest_fb_data = {
+	.mem_desc = {
+		.region_cnt = 1,
+		.region = {
+			{
+				.format = OMAPFB_COLOR_ARGB32,
+				.format_used = 1,
+			},
+		},
+	},
+};
+
+
+static struct omap_dss_device sholest_lcd_device = {
+	.type = OMAP_DISPLAY_TYPE_DSI,
+	.name = "lcd",
+	.driver_name = "sholes-panel",
+	.phy.dsi.clk_lane = 3,
+	.phy.dsi.clk_pol = 0,
+	.phy.dsi.data1_lane = 1,
+	.phy.dsi.data1_pol = 0,
+	.phy.dsi.data2_lane = 2,
+	.phy.dsi.data2_pol = 0,
+	.phy.dsi.ddr_clk_hz = 160000000,
+	.phy.dsi.lp_clk_hz = 4000000,
+	.reset_gpio = SHOLEST_DISPLAY_RESET_GPIO,
+	.platform_enable = sholest_panel_enable,
+	.platform_disable = sholest_panel_disable,
+};
+
+#ifdef CONFIG_PANEL_HDTV /* charlotte */
+static int sholest_panel_enable_hdtv(struct omap_dss_device *dssdev)
+{
+	printk(KERN_INFO "%s IN\n", __func__);
+
+	omap_cfg_reg(AG22_34XX_DSS_DATA0);
+	omap_cfg_reg(AH22_34XX_DSS_DATA1);
+	omap_cfg_reg(AG23_34XX_DSS_DATA2);
+	omap_cfg_reg(AH23_34XX_DSS_DATA3);
+	omap_cfg_reg(AG24_34XX_DSS_DATA4);
+	omap_cfg_reg(AH24_34XX_DSS_DATA5);
+
+	gpio_request(SHOLEST_HDMI_MUX_ENABLE_N_GPIO, "HDMI-mux-enable");
+	gpio_direction_output(SHOLEST_HDMI_MUX_ENABLE_N_GPIO, 0);
+	gpio_set_value(SHOLEST_HDMI_MUX_ENABLE_N_GPIO, 0);
+
+	gpio_request(SHOLEST_HDMI_MUX_SELECT_GPIO, "HDMI-mux-select");
+	gpio_direction_output(SHOLEST_HDMI_MUX_SELECT_GPIO, 0);
+	gpio_set_value(SHOLEST_HDMI_MUX_SELECT_GPIO, 1);
+
+	printk(KERN_INFO "%s OUT\n", __func__);
+	/* backlight enable? */
+	return 0;
+}
+
+static void sholest_panel_disable_hdtv(struct omap_dss_device *dssdev)
+{
+	printk(KERN_INFO "%s IN\n", __func__);
+
+	omap_cfg_reg(AG22_34XX_DSI_DX0);
+	omap_cfg_reg(AH22_34XX_DSI_DY0);
+	omap_cfg_reg(AG23_34XX_DSI_DX1);
+	omap_cfg_reg(AH23_34XX_DSI_DY1);
+	omap_cfg_reg(AG24_34XX_DSI_DX2);
+	omap_cfg_reg(AH24_34XX_DSI_DY2);
+
+	gpio_request(SHOLEST_HDMI_MUX_SELECT_GPIO, "HDMI-mux-select");
+	gpio_direction_output(SHOLEST_HDMI_MUX_SELECT_GPIO, 0);
+	gpio_set_value(SHOLEST_HDMI_MUX_SELECT_GPIO, 0);
+
+	printk(KERN_INFO "%s OUT\n", __func__);
+}
+
+static struct omap_dss_device sholest_hdtv_device = {
+	.type = OMAP_DISPLAY_TYPE_DPI,
+	.name = "hdtv",
+	.driver_name = "hdtv-panel",
+
+	.phy.dpi.data_lines = 24,
+
+	.panel.config = OMAP_DSS_LCD_TFT,
+
+	.platform_enable = sholest_panel_enable_hdtv,
+	.platform_disable = sholest_panel_disable_hdtv,
+};
+#endif
+
+static struct omap_dss_device *sholest_dss_devices[] = {
+	&sholest_lcd_device,
+#ifdef CONFIG_PANEL_HDTV /* charlotte */
+	&sholest_hdtv_device,
+#endif
+};
+
+static struct omap_dss_board_info sholest_dss_data = {
+	.num_devices = ARRAY_SIZE(sholest_dss_devices),
+	.devices = sholest_dss_devices,
+	.default_device = &sholest_lcd_device,
+};
+
+struct platform_device sholest_dss_device = {
+	.name = "omapdss",
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_dss_data,
+	},
+};
+
+void __init sholest_panel_init(void)
+{
+	int ret;
+
+	omap_cfg_reg(AG22_34XX_DSI_DX0);
+	omap_cfg_reg(AH22_34XX_DSI_DY0);
+	omap_cfg_reg(AG23_34XX_DSI_DX1);
+	omap_cfg_reg(AH23_34XX_DSI_DY1);
+	omap_cfg_reg(AG24_34XX_DSI_DX2);
+	omap_cfg_reg(AH24_34XX_DSI_DY2);
+	/* disp reset b */
+	omap_cfg_reg(AE4_34XX_GPIO136_OUT);
+
+	omapfb_set_platform_data(&sholest_fb_data);
+
+	ret = gpio_request(SHOLEST_DISPLAY_RESET_GPIO, "display reset");
+	if (ret) {
+		printk(KERN_ERR "failed to get display reset gpio\n");
+		goto error;
+	}
+
+	platform_device_register(&sholest_dss_device);
+	return;
+
+error:
+	gpio_free(SHOLEST_DISPLAY_RESET_GPIO);
+}
diff --git a/arch/arm/mach-omap2/board-sholest-sensors.c b/arch/arm/mach-omap2/board-sholest-sensors.c
new file mode 100644
index 0000000..ec1d402
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-sensors.c
@@ -0,0 +1,382 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest-sensors.c
+ *
+ * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/sfh7743.h>
+#include <linux/bu52014hfv.h>
+#ifdef CONFIG_SENSORS_LIS331DLH
+#include <linux/lis331dlh.h>
+#endif
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/vib-gpio.h>
+#ifdef CONFIG_VIB_PWM
+#include <linux/vib-pwm.h>
+#endif
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#include <mach/mux.h>
+#include <mach/gpio.h>
+#include <mach/keypad.h>
+#ifdef CONFIG_VIB_PWM
+#include <mach/dmtimer.h>
+#endif
+
+#define SHOLEST_PROX_INT_GPIO		180
+#define SHOLEST_HF_NORTH_GPIO		10
+#define SHOLEST_HF_SOUTH_GPIO		111
+#define SHOLEST_AKM8973_INT_GPIO	175
+#define SHOLEST_AKM8973_RESET_GPIO	28
+#define SHOLEST_VIBRATOR_GPIO		181
+#ifdef CONFIG_VIB_PWM
+#define SHOLEST_VIBRATOR_EN_GPIO	9
+#define SHOLEST_LVIBRATOR_PERIOD	5714
+#define SHOLEST_LVIBRATOR_DUTY		2857
+#endif
+
+static struct regulator *sholest_vibrator_regulator;
+static int sholest_vibrator_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vvib");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	sholest_vibrator_regulator = reg;
+	return 0;
+}
+
+static void sholest_vibrator_exit(void)
+{
+	regulator_put(sholest_vibrator_regulator);
+}
+
+static int sholest_vibrator_power_on(void)
+{
+	regulator_set_voltage(sholest_vibrator_regulator, 3000000, 3000000);
+	return regulator_enable(sholest_vibrator_regulator);
+}
+
+static int sholest_vibrator_power_off(void)
+{
+	if (sholest_vibrator_regulator)
+		return regulator_disable(sholest_vibrator_regulator);
+	return 0;
+}
+
+static struct vib_gpio_platform_data sholest_vib_gpio_data = {
+	.gpio = SHOLEST_VIBRATOR_GPIO,
+	.max_timeout = 15000,
+	.active_low = 0,
+	.initial_vibrate = 0,
+
+	.init = sholest_vibrator_initialization,
+	.exit = sholest_vibrator_exit,
+	.power_on = sholest_vibrator_power_on,
+	.power_off = sholest_vibrator_power_off,
+};
+
+static struct platform_device sholest_vib_gpio = {
+	.name           = VIB_GPIO_NAME,
+	.id             = -1,
+	.dev            = {
+		.platform_data  = &sholest_vib_gpio_data,
+    },
+};
+
+#ifdef CONFIG_VIB_PWM
+static struct omap_dm_timer *vib_pwm_timer;
+static int sholest_lvibrator_initialization(void)
+{
+	unsigned long load_reg, cmp_reg;
+	uint32_t timer_rate = 0;
+	int ret = 0;
+	vib_pwm_timer = omap_dm_timer_request_specific(11);
+	if (vib_pwm_timer == NULL)
+		ret = -ENODEV;
+	timer_rate = clk_get_rate(omap_dm_timer_get_fclk(vib_pwm_timer));
+	load_reg = timer_rate * SHOLEST_LVIBRATOR_PERIOD / 1000000;
+	cmp_reg = timer_rate * (SHOLEST_LVIBRATOR_PERIOD -
+				SHOLEST_LVIBRATOR_DUTY) / 1000000;
+	omap_dm_timer_set_source(vib_pwm_timer, OMAP_TIMER_SRC_32_KHZ);
+	omap_dm_timer_set_load(vib_pwm_timer, 1, -load_reg);
+	omap_dm_timer_set_match(vib_pwm_timer, 1, -cmp_reg);
+	omap_dm_timer_set_pwm(vib_pwm_timer, 0, 1,
+			      OMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE);
+	omap_dm_timer_write_counter(vib_pwm_timer, -2);
+	return 0;
+}
+
+static void sholest_lvibrator_exit(void)
+{
+	omap_dm_timer_stop(vib_pwm_timer);
+	omap_dm_timer_disable(vib_pwm_timer);
+}
+
+static void sholest_lvibrator_power_on(void)
+{
+#ifdef CONFIG_VIB_PWM
+	gpio_set_value(SHOLEST_VIBRATOR_EN_GPIO, 1);
+#endif
+	if (vib_pwm_timer == NULL)
+		sholest_lvibrator_initialization();
+	omap_dm_timer_enable(vib_pwm_timer);
+	omap_dm_timer_start(vib_pwm_timer);
+}
+
+static void sholest_lvibrator_power_off(void)
+{
+#ifdef CONFIG_VIB_PWM
+	gpio_set_value(SHOLEST_VIBRATOR_EN_GPIO, 0);
+#endif
+	omap_dm_timer_stop(vib_pwm_timer);
+	omap_dm_timer_disable(vib_pwm_timer);
+}
+
+static struct vib_pwm_platform_data sholest_vib_pwm_data = {
+	.initial_vibrate = 500,
+	.init = sholest_lvibrator_initialization,
+	.exit = sholest_lvibrator_exit,
+	.power_on = sholest_lvibrator_power_on,
+	.power_off = sholest_lvibrator_power_off,
+};
+
+static struct platform_device sholest_vib_pwm = {
+	.name = VIB_PWM_NAME,
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_vib_pwm_data,
+	},
+};
+#endif
+
+static struct regulator *sholest_sfh7743_regulator;
+static int sholest_sfh7743_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vsdio");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	sholest_sfh7743_regulator = reg;
+	return 0;
+}
+
+static void sholest_sfh7743_exit(void)
+{
+	regulator_put(sholest_sfh7743_regulator);
+}
+
+static int sholest_sfh7743_power_on(void)
+{
+	return regulator_enable(sholest_sfh7743_regulator);
+}
+
+static int sholest_sfh7743_power_off(void)
+{
+	if (sholest_sfh7743_regulator)
+		return regulator_disable(sholest_sfh7743_regulator);
+	return 0;
+}
+
+static struct sfh7743_platform_data sholest_sfh7743_data = {
+	.init = sholest_sfh7743_initialization,
+	.exit = sholest_sfh7743_exit,
+	.power_on = sholest_sfh7743_power_on,
+	.power_off = sholest_sfh7743_power_off,
+
+	.gpio = SHOLEST_PROX_INT_GPIO,
+};
+
+static void __init sholest_sfh7743_init(void)
+{
+	gpio_request(SHOLEST_PROX_INT_GPIO, "sfh7743 proximity int");
+	gpio_direction_input(SHOLEST_PROX_INT_GPIO);
+	omap_cfg_reg(Y3_34XX_GPIO180);
+}
+
+static struct bu52014hfv_platform_data bu52014hfv_platform_data = {
+	.docked_north_gpio = SHOLEST_HF_NORTH_GPIO,
+	.docked_south_gpio = SHOLEST_HF_SOUTH_GPIO,
+	.north_is_desk = 1,
+};
+
+#ifdef CONFIG_SENSORS_LIS331DLH
+struct lis331dlh_platform_data sholest_lis331dlh_data;
+static void __init sholest_lis331dlh_init(void)
+{
+#ifdef CONFIG_ARM_OF
+	struct device_node *lis331dlh_node;
+	const void *lis331dlh_prop;
+	int len = 0;
+
+	lis331dlh_node = of_find_node_by_path(DT_PATH_LIS331DLH);
+	if (lis331dlh_node) {
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"axis_map_x", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.axis_map_x = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"axis_map_y", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.axis_map_y = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"axis_map_z", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.axis_map_z = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"negate_x", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.negate_x = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"negate_x", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.negate_x = \
+						*(u8 *)lis331dlh_prop;
+		lis331dlh_prop = of_get_property(lis331dlh_node, \
+						"negate_z", &len);
+		if (lis331dlh_prop && len)
+			sholest_lis331dlh_data.negate_z = \
+						*(u8 *)lis331dlh_prop;
+		of_node_put(lis331dlh_node);
+	}
+#endif
+}
+
+static struct regulator *sholest_lis331dlh_regulator;
+static int sholest_lis331dlh_initialization(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(NULL, "vhvio");
+	if (IS_ERR(reg))
+		return PTR_ERR(reg);
+	sholest_lis331dlh_regulator = reg;
+	return 0;
+}
+
+static void sholest_lis331dlh_exit(void)
+{
+	regulator_put(sholest_lis331dlh_regulator);
+}
+
+static int sholest_lis331dlh_power_on(void)
+{
+	return regulator_enable(sholest_lis331dlh_regulator);
+}
+
+static int sholest_lis331dlh_power_off(void)
+{
+	if (sholest_lis331dlh_regulator)
+		return regulator_disable(sholest_lis331dlh_regulator);
+	return 0;
+}
+
+struct lis331dlh_platform_data sholest_lis331dlh_data = {
+	.init = sholest_lis331dlh_initialization,
+	.exit = sholest_lis331dlh_exit,
+	.power_on = sholest_lis331dlh_power_on,
+	.power_off = sholest_lis331dlh_power_off,
+
+	.min_interval	= 1,
+	.poll_interval	= 200,
+
+	.g_range	= LIS331DLH_G_8G,
+
+	.axis_map_x	= 0,
+	.axis_map_y	= 1,
+	.axis_map_z	= 2,
+
+	.negate_x	= 0,
+	.negate_y	= 1,
+	.negate_z	= 1,
+};
+#endif
+
+static void __init sholest_akm8973_init(void)
+{
+	gpio_request(SHOLEST_AKM8973_RESET_GPIO, "akm8973 reset");
+	gpio_direction_output(SHOLEST_AKM8973_RESET_GPIO, 1);
+	omap_cfg_reg(AB10_34XX_GPIO28_OUT);
+
+	gpio_request(SHOLEST_AKM8973_INT_GPIO, "akm8973 irq");
+	gpio_direction_input(SHOLEST_AKM8973_INT_GPIO);
+	omap_cfg_reg(AC3_34XX_GPIO175);
+}
+
+struct platform_device sfh7743_platform_device = {
+	.name = "sfh7743",
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_sfh7743_data,
+	},
+};
+
+static struct platform_device omap3430_hall_effect_dock = {
+	.name	= BU52014HFV_MODULE_NAME,
+	.id	= -1,
+	.dev	= {
+		.platform_data  = &bu52014hfv_platform_data,
+	},
+};
+
+static void sholest_vibrator_init(void)
+{
+	gpio_request(SHOLEST_VIBRATOR_GPIO, "vibrator");
+	gpio_direction_output(SHOLEST_VIBRATOR_GPIO, 0);
+	omap_cfg_reg(Y4_34XX_GPIO181);
+
+#ifdef CONFIG_VIB_PWM
+	gpio_request(SHOLEST_VIBRATOR_EN_GPIO, "vibrator en");
+	gpio_direction_output(SHOLEST_VIBRATOR_EN_GPIO, 0);
+	omap_cfg_reg(AF22_34XX_GPIO9_OUT);
+#endif
+}
+
+static struct platform_device *sholest_sensors[] __initdata = {
+	&sfh7743_platform_device,
+	&omap3430_hall_effect_dock,
+	&sholest_vib_gpio,
+#ifdef CONFIG_VIB_PWM
+	&sholest_vib_pwm,
+#endif
+};
+
+static void sholest_hall_effect_init(void)
+{
+	gpio_request(SHOLEST_HF_NORTH_GPIO, "mapphone dock north");
+	gpio_direction_input(SHOLEST_HF_NORTH_GPIO);
+	omap_cfg_reg(AG25_34XX_GPIO10);
+
+	gpio_request(SHOLEST_HF_SOUTH_GPIO, "mapphone dock south");
+	gpio_direction_input(SHOLEST_HF_SOUTH_GPIO);
+	omap_cfg_reg(B26_34XX_GPIO111);
+}
+
+void __init sholest_sensors_init(void)
+{
+	sholest_sfh7743_init();
+	sholest_vibrator_init();
+	sholest_akm8973_init();
+#ifdef CONFIG_SENSORS_LIS331DLH
+	sholest_lis331dlh_init();
+#endif
+	platform_add_devices(sholest_sensors, ARRAY_SIZE(sholest_sensors));
+}
diff --git a/arch/arm/mach-omap2/board-sholest-spi.c b/arch/arm/mach-omap2/board-sholest-spi.c
new file mode 100644
index 0000000..fa2b079
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-spi.c
@@ -0,0 +1,698 @@
+/*
+ * arch/arm/mach-omap2/board-sholest-spi.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/spi/cpcap.h>
+#include <linux/spi/spi.h>
+#include <mach/mcspi.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/resource.h>
+#include <mach/omap34xx.h>
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+extern struct platform_device cpcap_disp_button_led;
+extern struct platform_device cpcap_rgb_led;
+#ifdef CONFIG_LEDS_AF_LED
+extern struct platform_device cpcap_af_led;
+#endif
+
+struct cpcap_spi_init_data sholest_cpcap_spi_init[CPCAP_REG_SIZE + 1] = {
+	{CPCAP_REG_ASSIGN1,   0x0101},
+	{CPCAP_REG_ASSIGN2,   0x0000},
+	{CPCAP_REG_ASSIGN3,   0x0000},
+	{CPCAP_REG_ASSIGN4,   0x0000},
+	{CPCAP_REG_ASSIGN5,   0x0000},
+	{CPCAP_REG_ASSIGN6,   0x0000},
+	{CPCAP_REG_UCC1,      0x0000},
+	{CPCAP_REG_PC1,       0x010A},
+	{CPCAP_REG_PC2,       0x0150},
+	{CPCAP_REG_PGC,       0x0000},
+	{CPCAP_REG_SDVSPLL,   0xDB14},
+	{CPCAP_REG_SI2CC1,    0x0281},
+	{CPCAP_REG_Si2CC2,    0x00C4},
+	{CPCAP_REG_S1C1,      0x6438},
+	{CPCAP_REG_S1C2,      0x3838},
+	{CPCAP_REG_S2C1,      0x6434},
+	{CPCAP_REG_S2C2,      0x3C14},
+	{CPCAP_REG_S3C,       0x0539},
+	{CPCAP_REG_S4C1,      0x0000},
+	{CPCAP_REG_S4C2,      0x0000},
+	{CPCAP_REG_S6C,       0x0000},
+	{CPCAP_REG_VWLAN2C,   0x0001},
+	{CPCAP_REG_VUSBINT1C, 0x0029},
+	{CPCAP_REG_VUSBINT2C, 0x0029},
+	{CPCAP_REG_VAUDIOC,   0x0060},
+	{CPCAP_REG_ADCC1,     0x9000},
+	{CPCAP_REG_ADCC2,     0x4136},
+	{CPCAP_REG_USBC1,     0x1201},
+	{CPCAP_REG_USBC3,     0x7DFB},
+	{CPCAP_REG_UIER2,     0x001F},
+	{CPCAP_REG_UIEF2,     0x001F},
+	{CPCAP_REG_OWDC,      0x0003},
+	{CPCAP_REG_GPIO0,     0x3004},
+	{CPCAP_REG_GPIO1,     0x3000},
+	{CPCAP_REG_GPIO2,     0x3204},
+	{CPCAP_REG_GPIO3,     0x3008},
+	{CPCAP_REG_GPIO4,     0x3204},
+	{CPCAP_REG_GPIO5,     0x3008},
+	{CPCAP_REG_GPIO6,     0x3004},
+	{CPCAP_REG_MDLC,      0x0000},
+	{CPCAP_REG_KLC,       0x0000},
+	{CPCAP_REG_UNUSED,    0x0000},
+};
+
+unsigned short cpcap_regulator_mode_values[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5]      = 0x0022,
+	[CPCAP_VCAM]     = 0x0003,
+	[CPCAP_VCSI]     = 0x0043,
+	[CPCAP_VDAC]     = 0x0003,
+	[CPCAP_VDIG]     = 0x0082,
+	[CPCAP_VFUSE]    = 0x0080,
+	[CPCAP_VHVIO]    = 0x0003,
+	[CPCAP_VSDIO]    = 0x0003,
+	[CPCAP_VPLL]     = 0x0042,
+	[CPCAP_VRF1]     = 0x0024,
+	[CPCAP_VRF2]     = 0x0001,
+	[CPCAP_VRFREF]   = 0x0023,
+	[CPCAP_VWLAN1]   = 0x0003,
+	[CPCAP_VWLAN2]   = 0x000C,
+	[CPCAP_VSIM]     = 0x0003,
+	[CPCAP_VSIMCARD] = 0x1E00,
+	[CPCAP_VVIB]     = 0x0001,
+	[CPCAP_VUSB]     = 0x000C,
+	[CPCAP_VAUDIO]   = 0x0014,
+};
+
+unsigned short cpcap_regulator_off_mode_values[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5]      = 0x0000,
+	[CPCAP_VCAM]     = 0x0000,
+	[CPCAP_VCSI]     = 0x0041,
+	[CPCAP_VDAC]     = 0x0000,
+	[CPCAP_VDIG]     = 0x0000,
+	[CPCAP_VFUSE]    = 0x0000,
+	[CPCAP_VHVIO]    = 0x0000,
+	[CPCAP_VSDIO]    = 0x0000,
+	[CPCAP_VPLL]     = 0x0000,
+	[CPCAP_VRF1]     = 0x0000,
+	[CPCAP_VRF2]     = 0x0000,
+	[CPCAP_VRFREF]   = 0x0000,
+	[CPCAP_VWLAN1]   = 0x0000,
+	[CPCAP_VWLAN2]   = 0x0000,
+	[CPCAP_VSIM]     = 0x0000,
+	[CPCAP_VSIMCARD] = 0x0000,
+	[CPCAP_VVIB]     = 0x0000,
+	[CPCAP_VUSB]     = 0x0000,
+	[CPCAP_VAUDIO]   = 0x0000,
+};
+
+#define CPCAP_GPIO 0
+
+#define REGULATOR_CONSUMER(name, device) { .supply = name, .dev = device, }
+
+struct regulator_consumer_supply cpcap_sw5_consumers[] = {
+	REGULATOR_CONSUMER("sw5", &cpcap_disp_button_led.dev),
+	REGULATOR_CONSUMER("sw5", &cpcap_rgb_led.dev),
+#ifdef CONFIG_LEDS_AF_LED
+	REGULATOR_CONSUMER("sw5", &cpcap_af_led.dev),
+#endif
+};
+
+struct regulator_consumer_supply cpcap_vcam_consumers[] = {
+	REGULATOR_CONSUMER("vcam", NULL /* cpcap_cam_device */),
+};
+
+extern struct platform_device sholest_dss_device;
+
+struct regulator_consumer_supply cpcap_vhvio_consumers[] = {
+	REGULATOR_CONSUMER("vhvio", NULL /* lighting_driver */),
+#if 0
+	REGULATOR_CONSUMER("vhvio", NULL /* lighting_driver */),
+	REGULATOR_CONSUMER("vhvio", NULL /* magnetometer */),
+	REGULATOR_CONSUMER("vhvio", NULL /* light sensor */),
+	REGULATOR_CONSUMER("vhvio", NULL /* accelerometer */),
+	REGULATOR_CONSUMER("vhvio", NULL /* display */),
+#endif
+};
+
+struct regulator_consumer_supply cpcap_vsdio_consumers[] = {
+	REGULATOR_CONSUMER("vsdio", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vcsi_consumers[] = {
+	REGULATOR_CONSUMER("vdds_dsi", &sholest_dss_device.dev),
+};
+
+struct regulator_consumer_supply cpcap_vwlan1_consumers[] = {
+	REGULATOR_CONSUMER("vwlan1", NULL /* cpcap_cam_device */),
+};
+
+struct regulator_consumer_supply cpcap_vwlan2_consumers[] = {
+	REGULATOR_CONSUMER("vwlan2", NULL /* sd slot */),
+};
+
+struct regulator_consumer_supply cpcap_vsim_consumers[] = {
+	REGULATOR_CONSUMER("vsim", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vsimcard_consumers[] = {
+	REGULATOR_CONSUMER("vsimcard", NULL),
+};
+
+struct regulator_consumer_supply cpcap_vvib_consumers[] = {
+	REGULATOR_CONSUMER("vvib", NULL /* vibrator */),
+};
+
+struct regulator_consumer_supply cpcap_vaudio_consumers[] = {
+	REGULATOR_CONSUMER("vaudio", NULL /* mic opamp */),
+};
+
+struct regulator_consumer_supply cpcap_vfuse_consumers[] = {
+    REGULATOR_CONSUMER("vfuse", NULL),
+};
+
+
+
+
+static struct regulator_init_data cpcap_regulator[CPCAP_NUM_REGULATORS] = {
+	[CPCAP_SW5] = {
+		.constraints = {
+			.min_uV			= 5050000,
+			.max_uV			= 5050000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_sw5_consumers),
+		.consumer_supplies	= cpcap_sw5_consumers,
+	},
+	[CPCAP_VCAM] = {
+		.constraints = {
+			.min_uV			= 2800000,
+			.max_uV			= 2800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vcam_consumers),
+		.consumer_supplies	= cpcap_vcam_consumers,
+	},
+	[CPCAP_VCSI] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.boot_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vcsi_consumers),
+		.consumer_supplies	= cpcap_vcsi_consumers,
+	},
+	[CPCAP_VDAC] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VDIG] = {
+		.constraints = {
+			.min_uV			= 1875000,
+			.max_uV			= 1875000,
+			.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VFUSE] = {
+		.constraints = {
+			.min_uV			= 1500000,
+			.max_uV			= 3150000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_VOLTAGE |
+						   REGULATOR_CHANGE_STATUS),
+		},
+		.num_consumer_supplies  = ARRAY_SIZE(cpcap_vfuse_consumers),
+		.consumer_supplies      = cpcap_vfuse_consumers,
+	},
+	[CPCAP_VHVIO] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vhvio_consumers),
+		.consumer_supplies	= cpcap_vhvio_consumers,
+	},
+	[CPCAP_VSDIO] = {
+		.constraints = {
+			.min_uV			= 2900000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsdio_consumers),
+		.consumer_supplies	= cpcap_vsdio_consumers,
+	},
+	[CPCAP_VPLL] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1800000,
+			.valid_ops_mask		= 0,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRF1] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRF2] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VRFREF] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VWLAN1] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 1900000,
+			.valid_ops_mask		= 0,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan1_consumers),
+		.consumer_supplies	= cpcap_vwlan1_consumers,
+	},
+	[CPCAP_VWLAN2] = {
+		.constraints = {
+			.min_uV			= 3000000,
+			.max_uV			= 3000000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vwlan2_consumers),
+		.consumer_supplies	= cpcap_vwlan2_consumers,
+	},
+	[CPCAP_VSIM] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsim_consumers),
+		.consumer_supplies	= cpcap_vsim_consumers,
+	},
+	[CPCAP_VSIMCARD] = {
+		.constraints = {
+			.min_uV			= 1800000,
+			.max_uV			= 2900000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_STATUS |
+						   REGULATOR_CHANGE_VOLTAGE),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vsimcard_consumers),
+		.consumer_supplies	= cpcap_vsimcard_consumers,
+	},
+	[CPCAP_VVIB] = {
+		.constraints = {
+			.min_uV			= 1300000,
+			.max_uV			= 3000000,
+			.valid_ops_mask		= (REGULATOR_CHANGE_VOLTAGE |
+						   REGULATOR_CHANGE_STATUS),
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vvib_consumers),
+		.consumer_supplies	= cpcap_vvib_consumers,
+	},
+	[CPCAP_VUSB] = {
+		.constraints = {
+			.min_uV			= 3300000,
+			.max_uV			= 3300000,
+			.valid_ops_mask		= REGULATOR_CHANGE_STATUS,
+			.apply_uV		= 1,
+		},
+	},
+	[CPCAP_VAUDIO] = {
+		.constraints = {
+			.min_uV			= 2775000,
+			.max_uV			= 2775000,
+			.valid_modes_mask	= (REGULATOR_MODE_NORMAL |
+						   REGULATOR_MODE_STANDBY),
+			.valid_ops_mask		= REGULATOR_CHANGE_MODE,
+			.always_on		= 1,
+			.apply_uV		= 1,
+		},
+		.num_consumer_supplies	= ARRAY_SIZE(cpcap_vaudio_consumers),
+		.consumer_supplies	= cpcap_vaudio_consumers,
+	},
+};
+
+static struct cpcap_adc_ato sholest_cpcap_adc_ato = {
+	.ato_in = 0x0480,
+	.atox_in = 0,
+	.adc_ps_factor_in = 0x0200,
+	.atox_ps_factor_in = 0,
+	.ato_out = 0,
+	.atox_out = 0,
+	.adc_ps_factor_out = 0,
+	.atox_ps_factor_out = 0,
+};
+
+static void ac_changed(struct power_supply *ac,
+		       struct cpcap_batt_ac_data *ac_state)
+{
+	static char requested;
+	int ret = 0;
+
+	if (!ac || !ac_state)
+		return;
+
+	if (ac_state->online) {
+		/* To reduce OMAP Vdd1 DC/DC converter output voltage dips as
+		 * much as possible, limit Vdd1 to OPP3-OPP5 when the phone is
+		 * connected to a charger. */
+		if (!requested)
+			ret = resource_request("vdd1_opp", ac->dev, VDD1_OPP3);
+
+		if (!ret)
+			requested = 1;
+	} else if (requested) {
+		ret = resource_release("vdd1_opp", ac->dev);
+
+		if (!ret)
+			requested = 0;
+	}
+}
+
+static void batt_changed(struct power_supply *batt,
+			 struct cpcap_batt_data *batt_state)
+{
+	static char requested;
+	int ret = 0;
+
+	if (!batt || !batt_state)
+		return;
+
+	if (batt_state->batt_temp < 0) {
+		/* To reduce OMAP Vdd1 DC/DC converter output voltage dips as
+		 * much as possible, limit Vdd1 to OPP3-OPP5 when the
+		 * temperature is below 0 degrees C. */
+		if (!requested)
+			ret = resource_request("vdd1_opp", batt->dev, \
+					       VDD1_OPP3);
+
+		if (!ret)
+			requested = 1;
+	} else if (requested) {
+		ret = resource_release("vdd1_opp", batt->dev);
+
+		if (!ret)
+			requested = 0;
+	}
+}
+
+
+static struct cpcap_platform_data sholest_cpcap_data = {
+	.init = sholest_cpcap_spi_init,
+	.regulator_mode_values = cpcap_regulator_mode_values,
+	.regulator_off_mode_values = cpcap_regulator_off_mode_values,
+	.regulator_init = cpcap_regulator,
+	.adc_ato = &sholest_cpcap_adc_ato,
+	.ac_changed = ac_changed,
+	.batt_changed = batt_changed,
+	.usb_changed = NULL,
+};
+
+static struct spi_board_info sholest_spi_board_info[] __initdata = {
+	{
+		.modalias = "cpcap",
+		.bus_num = 1,
+		.chip_select = 0,
+		.max_speed_hz = 20000000,
+		.controller_data = &sholest_cpcap_data,
+		.mode = SPI_CS_HIGH,
+	},
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+	{
+		.modalias = "smsmdtv", /* should match device driver name */
+		.bus_num  = 3,
+		.chip_select = 0,
+		.max_speed_hz = 6000000,
+		/*.mode = SPI_CS_LOW*/
+	},
+#endif
+};
+
+#ifdef CONFIG_ARM_OF
+struct omap_spi_init_entry {
+	u32 reg;
+	u32 data;
+} __attribute__ ((__packed__));
+
+struct omap_rgt_mode_entry {
+	u32 id;
+	u16 data;
+} __attribute__ ((__packed__));
+
+struct omap_rgt_init_entry {
+	u32 id;
+	u32 min_uV;
+	u32 max_uV;
+	u32 valid_ops_mask;
+	u8 always_on;
+	u8 boot_on;
+	u8 apply_uV;
+} __attribute__ ((__packed__));
+
+static void regulator_init(void *p_data)
+{
+	struct omap_rgt_init_entry *p = p_data;
+	struct regulator_init_data *p_devs = cpcap_regulator;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id].constraints.min_uV = p->min_uV;
+		p_devs[p->id].constraints.max_uV = p->max_uV;
+		p_devs[p->id].constraints.valid_ops_mask = p->valid_ops_mask;
+		p_devs[p->id].constraints.always_on = p->always_on;
+		p_devs[p->id].constraints.boot_on = p->boot_on;
+		p_devs[p->id].constraints.apply_uV = p->apply_uV;
+		printk(KERN_INFO "CPCAP: Overwrite regulator init [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void regulator_mode_init(void *p_data)
+{
+	struct omap_rgt_mode_entry *p = p_data;
+	unsigned short *p_devs = cpcap_regulator_mode_values;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id] = p->data;
+		printk(KERN_INFO "CPCAP: Overwrite regulator mode [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void regulator_off_mode_init(void *p_data)
+{
+	struct omap_rgt_mode_entry *p = p_data;
+	unsigned short *p_devs = cpcap_regulator_off_mode_values;
+
+	if (p->id < CPCAP_NUM_REGULATORS) {
+		p_devs[p->id] = p->data;
+		printk(KERN_INFO "CPCAP: Overwrite regulator off mode [%d]!\n",
+				p->id);
+	} else {
+		printk(KERN_ERR "CPCAP: Too big cpcap regulator count!\n");
+	}
+}
+
+static void cpcap_spi_init(void *p_data)
+{
+	struct omap_spi_init_entry *p = p_data;
+	struct cpcap_spi_init_data *p_devs = sholest_cpcap_spi_init;
+	int i = 0;
+
+	for (i = 0; i < CPCAP_REG_SIZE + 1; i++) {
+		if (p_devs[i].reg == CPCAP_REG_UNUSED) {
+			p_devs[i].reg = p->reg;
+			p_devs[i].data = p->data;
+
+			if (i != CPCAP_REG_SIZE)
+				p_devs[i + 1].reg = CPCAP_REG_UNUSED;
+
+			printk(KERN_INFO "CPCAP: Add new reg [%d] setting!\n",
+					p->reg);
+			return;
+		}
+
+		if (p_devs[i].reg == p->reg) {
+			p_devs[i].data = p->data;
+
+			printk(KERN_INFO "CPCAP: Overwrite reg [%d] setting!\n",
+					p->reg);
+			return;
+		}
+
+		if (i == CPCAP_REG_SIZE)
+			printk(KERN_ERR "CPCAP: Too big cpcap reg count!\n");
+	}
+}
+
+static void __init cpcap_of_init(void)
+{
+	int size, unit_size, i, count;
+	struct device_node *node;
+	const void *prop;
+
+	node = of_find_node_by_path(DT_PATH_CPCAP);
+	if (node == NULL) {
+		printk(KERN_ERR
+				"Unable to read node %s from device tree!\n",
+				DT_PATH_CPCAP);
+		return;
+	}
+
+	unit_size = sizeof(struct omap_spi_init_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_SPIINIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_SPIINIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		cpcap_spi_init((struct omap_spi_init_entry *)prop + i);
+
+#if 0 /* Temporary FOTA workaround:Do not allow the device tree to
+	 overwrite the board file regulator mode settings. */
+	unit_size = sizeof(struct omap_rgt_init_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTINIT, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTINIT);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_init((struct omap_rgt_init_entry *)prop + i);
+
+	unit_size = sizeof(struct omap_rgt_mode_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTMODE, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTMODE);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_mode_init((struct omap_rgt_mode_entry *)prop + i);
+
+	unit_size = sizeof(struct omap_rgt_mode_entry);
+	prop = of_get_property(node, DT_PROP_CPCAP_RGTOFFMODE, &size);
+	if ((!prop) || (size % unit_size)) {
+		printk(KERN_ERR "Read property %s error!\n",
+				DT_PROP_CPCAP_RGTOFFMODE);
+		of_node_put(node);
+		return;
+	}
+
+	count = size / unit_size;
+	printk(KERN_INFO "cpcap init size = %d\n", count);
+
+	for (i = 0; i < count; i++)
+		regulator_off_mode_init((struct omap_rgt_mode_entry *)prop + i);
+#endif
+	of_node_put(node);
+	return;
+}
+#endif
+
+void __init sholest_spi_init(void)
+{
+	int irq;
+	int ret;
+	int i;
+
+#ifdef CONFIG_ARM_OF
+	cpcap_of_init();
+#endif
+
+	for (i = 0; i < CPCAP_REG_SIZE; i++) {
+		if (sholest_cpcap_spi_init[i].reg == CPCAP_REG_UNUSED)
+			break;
+	}
+	sholest_cpcap_data.init_len = i;
+
+	ret = gpio_request(CPCAP_GPIO, "cpcap-irq");
+	if (ret)
+		return;
+	ret = gpio_direction_input(CPCAP_GPIO);
+	if (ret) {
+		gpio_free(CPCAP_GPIO);
+		return;
+	}
+
+	irq = gpio_to_irq(CPCAP_GPIO);
+	set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+	omap_cfg_reg(AF26_34XX_GPIO0);
+
+	sholest_spi_board_info[0].irq = irq;
+	spi_register_board_info(sholest_spi_board_info,
+				ARRAY_SIZE(sholest_spi_board_info));
+
+	/* regulator_has_full_constraints(); */
+}
diff --git a/arch/arm/mach-omap2/board-sholest-wifi.c b/arch/arm/mach-omap2/board-sholest-wifi.c
new file mode 100644
index 0000000..eec8778
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest-wifi.c
@@ -0,0 +1,202 @@
+/* linux/arch/arm/mach-omap2/board-sholest-wifi.c
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/err.h>
+
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/wifi_tiwlan.h>
+
+#include <linux/debugfs.h>
+
+#define SHOLEST_WIFI_PMENA_GPIO	186
+#define SHOLEST_WIFI_IRQ_GPIO	65
+
+static int sholest_wifi_cd = 0;		/* WIFI virtual 'card detect' status */
+static void (*wifi_status_cb)(int card_present, void *dev_id);
+static void *wifi_status_cb_devid;
+
+int sholest_wifi_status_register(void (*callback)(int card_present,
+						void *dev_id), void *dev_id)
+{
+	if (wifi_status_cb)
+		return -EAGAIN;
+	wifi_status_cb = callback;
+	wifi_status_cb_devid = dev_id;
+	return 0;
+}
+
+int sholest_wifi_status(int irq)
+{
+	return sholest_wifi_cd;
+}
+
+int sholest_wifi_set_carddetect(int val)
+{
+	printk("%s: %d\n", __func__, val);
+	sholest_wifi_cd = val;
+	if (wifi_status_cb) {
+		wifi_status_cb(val, wifi_status_cb_devid);
+	} else
+		printk(KERN_WARNING "%s: Nobody to notify\n", __func__);
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(sholest_wifi_set_carddetect);
+#endif
+
+static int sholest_wifi_power_state;
+
+int sholest_wifi_power(int on)
+{
+	printk("%s: %d\n", __func__, on);
+	gpio_set_value(SHOLEST_WIFI_PMENA_GPIO, on);
+	sholest_wifi_power_state = on;
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(sholest_wifi_power);
+#endif
+
+static int sholest_wifi_reset_state;
+int sholest_wifi_reset(int on)
+{
+	printk("%s: %d\n", __func__, on);
+	sholest_wifi_reset_state = on;
+	return 0;
+}
+#ifndef CONFIG_WIFI_CONTROL_FUNC
+EXPORT_SYMBOL(sholest_wifi_reset);
+#endif
+
+struct wifi_platform_data sholest_wifi_control = {
+        .set_power	= sholest_wifi_power,
+	.set_reset	= sholest_wifi_reset,
+	.set_carddetect	= sholest_wifi_set_carddetect,
+};
+
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+static struct resource sholest_wifi_resources[] = {
+	[0] = {
+		.name		= "device_wifi_irq",
+		.start		= OMAP_GPIO_IRQ(SHOLEST_WIFI_IRQ_GPIO),
+		.end		= OMAP_GPIO_IRQ(SHOLEST_WIFI_IRQ_GPIO),
+		.flags          = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,
+	},
+};
+
+static struct platform_device sholest_wifi_device = {
+        .name           = "device_wifi",
+        .id             = 1,
+        .num_resources  = ARRAY_SIZE(sholest_wifi_resources),
+        .resource       = sholest_wifi_resources,
+        .dev            = {
+                .platform_data = &sholest_wifi_control,
+        },
+};
+#endif
+
+static int __init sholest_wifi_init(void)
+{
+	int ret;
+
+	printk("%s: start\n", __func__);
+	ret = gpio_request(SHOLEST_WIFI_IRQ_GPIO, "wifi_irq");
+	if (ret < 0) {
+		printk(KERN_ERR "%s: can't reserve GPIO: %d\n", __func__,
+			SHOLEST_WIFI_IRQ_GPIO);
+		goto out;
+	}
+	ret = gpio_request(SHOLEST_WIFI_PMENA_GPIO, "wifi_pmena");
+	if (ret < 0) {
+		printk(KERN_ERR "%s: can't reserve GPIO: %d\n", __func__,
+			SHOLEST_WIFI_PMENA_GPIO);
+		gpio_free(SHOLEST_WIFI_IRQ_GPIO);
+		goto out;
+	}
+	gpio_direction_input(SHOLEST_WIFI_IRQ_GPIO);
+	gpio_direction_output(SHOLEST_WIFI_PMENA_GPIO, 0);
+#ifdef CONFIG_WIFI_CONTROL_FUNC
+	ret = platform_device_register(&sholest_wifi_device);
+#endif
+out:
+        return ret;
+}
+
+device_initcall(sholest_wifi_init);
+
+#if defined(CONFIG_DEBUG_FS)
+
+static int sholestmmc_dbg_wifi_reset_set(void *data, u64 val)
+{
+	sholest_wifi_reset((int) val);
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_reset_get(void *data, u64 *val)
+{
+	*val = sholest_wifi_reset_state;
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_cd_set(void *data, u64 val)
+{
+	sholest_wifi_set_carddetect((int) val);
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_cd_get(void *data, u64 *val)
+{
+	*val = sholest_wifi_cd;
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_pwr_set(void *data, u64 val)
+{
+	sholest_wifi_power((int) val);
+	return 0;
+}
+
+static int sholestmmc_dbg_wifi_pwr_get(void *data, u64 *val)
+{
+	*val = sholest_wifi_power_state;
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(sholestmmc_dbg_wifi_reset_fops,
+			sholestmmc_dbg_wifi_reset_get,
+			sholestmmc_dbg_wifi_reset_set, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(sholestmmc_dbg_wifi_cd_fops,
+			sholestmmc_dbg_wifi_cd_get,
+			sholestmmc_dbg_wifi_cd_set, "%llu\n");
+
+DEFINE_SIMPLE_ATTRIBUTE(sholestmmc_dbg_wifi_pwr_fops,
+			sholestmmc_dbg_wifi_pwr_get,
+			sholestmmc_dbg_wifi_pwr_set, "%llu\n");
+
+static int __init sholestmmc_dbg_init(void)
+{
+	struct dentry *dent;
+
+	dent = debugfs_create_dir("mapphone_mmc_dbg", 0);
+	if (IS_ERR(dent))
+		return PTR_ERR(dent);
+
+	debugfs_create_file("wifi_reset", 0644, dent, NULL,
+			    &sholestmmc_dbg_wifi_reset_fops);
+	debugfs_create_file("wifi_cd", 0644, dent, NULL,
+			    &sholestmmc_dbg_wifi_cd_fops);
+	debugfs_create_file("wifi_pwr", 0644, dent, NULL,
+			    &sholestmmc_dbg_wifi_pwr_fops);
+	return 0;
+}
+
+device_initcall(sholestmmc_dbg_init);
+#endif
diff --git a/arch/arm/mach-omap2/board-sholest.c b/arch/arm/mach-omap2/board-sholest.c
new file mode 100644
index 0000000..2842de5
--- /dev/null
+++ b/arch/arm/mach-omap2/board-sholest.c
@@ -0,0 +1,1820 @@
+/*
+ * linux/arch/arm/mach-omap2/board-sholest.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Modified from mach-omap3/board-mapphone.c
+ *
+ * Copyright (C) 2007 Texas Instruments
+ *
+ * Modified from mach-omap2/board-generic.c
+ *
+ * Initial code: Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/reboot.h>
+#include <linux/qtouch_obp_ts.h>
+#include <linux/led-cpcap-lm3554.h>
+#include <linux/led-lm3530.h>
+#include <linux/usb/omap.h>
+#include <linux/wl127x-rfkill.h>
+#include <linux/wl127x-test.h>
+#include <linux/omap_mdm_ctrl.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/setup.h>
+
+#include <mach/board-sholest.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/common.h>
+#include <mach/gpmc.h>
+#include <mach/usb.h>
+#include <linux/delay.h>
+#include <mach/control.h>
+#include <mach/hdq.h>
+#include <mach/system.h>
+#include <linux/usb/android.h>
+#include <linux/wakelock.h>
+
+#include "cm-regbits-34xx.h"
+
+#ifdef CONFIG_ARM_OF
+#include <mach/dt_path.h>
+#include <asm/prom.h>
+#endif
+
+#include "pm.h"
+#include "prm-regbits-34xx.h"
+#include "smartreflex.h"
+#include "omap3-opp.h"
+#include "sdram-toshiba-hynix-numonyx.h"
+#include "prcm-common.h"
+#include "cm.h"
+#include "clock.h"
+
+#ifdef CONFIG_VIDEO_OLDOMAP3
+#include <media/v4l2-int-device.h>
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+#include <media/mt9p012.h>
+
+#endif
+#if defined(CONFIG_VIDEO_OV8810) || defined(CONFIG_VIDEO_OV8810_MODULE)
+#include <../drivers/media/video/ov8810.h>
+#include <../drivers/media/video/oldisp/ispcsi2.h>
+#define OV8810_CSI2_CLOCK_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA0_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_DATA1_POLARITY	0	/* +/- pin order */
+#define OV8810_CSI2_CLOCK_LANE		1	 /* Clock lane position: 1 */
+#define OV8810_CSI2_DATA0_LANE		2	 /* Data0 lane position: 2 */
+#define OV8810_CSI2_DATA1_LANE		3	 /* Data1 lane position: 3 */
+#define OV8810_CSI2_PHY_THS_TERM	1  /* GVH */
+#define OV8810_CSI2_PHY_THS_SETTLE	21  /* GVH */
+#define OV8810_CSI2_PHY_TCLK_TERM	0
+#define OV8810_CSI2_PHY_TCLK_MISS	1
+#define OV8810_CSI2_PHY_TCLK_SETTLE	14
+#endif
+
+#if defined(CONFIG_LEDS_BD7885)
+#include <linux/leds-bd7885.h>
+#endif
+#if defined(CONFIG_LEDS_BU9847)
+#include <linux/leds-bu9847.h>
+#endif
+
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+#include <../drivers/media/video/hplens.h>
+#endif
+#endif
+
+#define SHOLEST_IPC_USB_SUSP_GPIO	142
+#define SHOLEST_AP_TO_BP_FLASH_EN_GPIO	157
+#define SHOLEST_TOUCH_RESET_N_GPIO	164
+#define SHOLEST_TOUCH_INT_GPIO		109
+#define SHOLEST_LM_3530_INT_GPIO	41
+#define SHOLEST_AKM8973_INT_GPIO	175
+#define SHOLEST_WL1271_NSHUTDOWN_GPIO	179
+#define SHOLEST_WL1271_WAKE_GPIO    8
+#define SHOLEST_WL1271_HOSTWAKE_GPIO    178
+#define SHOLEST_AUDIO_PATH_GPIO	    143
+#define SHOLEST_BP_READY_AP_GPIO	141
+#define SHOLEST_BP_READY2_AP_GPIO	59
+#define SHOLEST_BP_RESOUT_GPIO		139
+#define SHOLEST_BP_PWRON_GPIO		137
+#define SHOLEST_AP_TO_BP_PSHOLD_GPIO	138
+#define SHOLEST_AP_TO_BP_FLASH_EN_GPIO	157
+#define SHOLEST_POWER_OFF_GPIO		176
+#define SHOLEST_BPWAKE_STROBE_GPIO	157
+#define SHOLEST_APWAKE_TRIGGER_GPIO	141
+#define DIE_ID_REG_BASE			(L4_WK_34XX_PHYS + 0xA000)
+#define DIE_ID_REG_OFFSET		0x218
+#define MAX_USB_SERIAL_NUM		17
+#define MAPPHONE_VENDOR_ID		0x22B8
+#define MAPPHONE_PRODUCT_ID		0x41D9
+#define MAPPHONE_ADB_PRODUCT_ID		0x41DB
+#define FACTORY_PRODUCT_ID		0x41E3
+#define FACTORY_ADB_PRODUCT_ID		0x41E2
+
+#define SHOLEST_MMCPROBE_ENABLED 0
+
+static char device_serial[MAX_USB_SERIAL_NUM];
+char *bp_model = "UMTS";
+
+static struct omap_opp sholest_mpu_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{S125M, VDD1_OPP1, 0x20},
+	/*OPP2*/
+	{S250M, VDD1_OPP2, 0x27},
+	/*OPP3*/
+	{S500M, VDD1_OPP3, 0x32},
+	/*OPP4*/
+	{S550M, VDD1_OPP4, 0x38},
+	/*OPP5*/
+	{S600M, VDD1_OPP5, 0x3E},
+};
+
+#define S80M 80000000
+#define S160M 160000000
+
+static struct omap_opp sholest_l3_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{0, VDD2_OPP1, 0x20},
+	/*OPP2*/
+	{S80M, VDD2_OPP2, 0x27},
+	/*OPP3*/
+	{S160M, VDD2_OPP3, 0x2E},
+};
+
+static struct omap_opp sholest_dsp_rate_table[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{S90M, VDD1_OPP1, 0x20},
+	/*OPP2*/
+	{S180M, VDD1_OPP2, 0x27},
+	/*OPP3*/
+	{S360M, VDD1_OPP3, 0x32},
+	/*OPP4*/
+	{S400M, VDD1_OPP4, 0x38},
+	/*OPP5*/
+	{S430M, VDD1_OPP5, 0x3E},
+};
+
+static void __init sholest_init_irq(void)
+{
+	omap2_init_common_hw(JEDEC_JESD209A_sdrc_params,
+			sholest_mpu_rate_table, sholest_dsp_rate_table,
+			sholest_l3_rate_table);
+	omap_init_irq();
+#ifdef CONFIG_OMAP3_PM
+	scm_clk_init();
+#endif
+	omap_gpio_init();
+}
+
+#define BOOT_MODE_MAX_LEN 30
+static char boot_mode[BOOT_MODE_MAX_LEN+1];
+int __init board_boot_mode_init(char *s)
+
+{
+	strncpy(boot_mode, s, BOOT_MODE_MAX_LEN);
+
+	printk(KERN_INFO "boot_mode=%s\n", boot_mode);
+
+	return 1;
+}
+__setup("androidboot.mode=", board_boot_mode_init);
+
+
+
+static struct android_usb_platform_data andusb_plat = {
+	.vendor_id      = 0x22b8,
+	.product_id     = 0x41DA,
+	.adb_product_id = 0x41DA,
+	.product_name   = "XT701",
+	.manufacturer_name	= "Motorola",
+	.serial_number		= device_serial,
+};
+
+static struct platform_device androidusb_device = {
+	.name	= "android_usb",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &andusb_plat,
+	},
+};
+
+static struct usb_mass_storage_platform_data usbms_plat = {
+	.vendor			= "Motorola",
+	.product		= "XT701",
+	.release		= 1,
+};
+
+static struct platform_device usb_mass_storage_device = {
+	.name	= "usb_mass_storage",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &usbms_plat,
+	},
+};
+
+static int cpcap_usb_connected_probe(struct platform_device *pdev)
+{
+	android_usb_set_connected(1);
+	return 0;
+}
+
+static int cpcap_usb_connected_remove(struct platform_device *pdev)
+{
+	android_usb_set_connected(0);
+	return 0;
+}
+
+static struct platform_driver cpcap_usb_connected_driver = {
+	.probe		= cpcap_usb_connected_probe,
+	.remove		= cpcap_usb_connected_remove,
+	.driver		= {
+		.name	= "cpcap_usb_connected",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void sholest_gadget_init(void)
+{
+	unsigned int val[2];
+	unsigned int reg;
+
+	reg = DIE_ID_REG_BASE + DIE_ID_REG_OFFSET;
+	val[0] = omap_readl(reg);
+	val[1] = omap_readl(reg + 4);
+
+	snprintf(device_serial, MAX_USB_SERIAL_NUM, "%08X%08X", val[1], val[0]);
+
+	if (!strcmp(boot_mode, "factorycable"))
+		andusb_plat.factory_enabled = 1;
+	else
+		andusb_plat.factory_enabled = 0;
+
+	andusb_plat.vendor_id = MAPPHONE_VENDOR_ID;
+
+	/* check powerup reason - To be added once kernel support is available*/
+	if (andusb_plat.factory_enabled) {
+		andusb_plat.product_id = FACTORY_PRODUCT_ID;
+		andusb_plat.adb_product_id = FACTORY_ADB_PRODUCT_ID;
+	} else {
+		andusb_plat.product_id = MAPPHONE_PRODUCT_ID;
+		andusb_plat.adb_product_id = MAPPHONE_ADB_PRODUCT_ID;
+	}
+	platform_device_register(&androidusb_device);
+	platform_device_register(&usb_mass_storage_device);
+	platform_driver_register(&cpcap_usb_connected_driver);
+}
+
+static void sholest_audio_init(void)
+{
+	gpio_request(SHOLEST_AUDIO_PATH_GPIO, "mapphone audio path");
+
+	omap_cfg_reg(P21_OMAP34XX_MCBSP2_FSX);
+	omap_cfg_reg(N21_OMAP34XX_MCBSP2_CLKX);
+	omap_cfg_reg(R21_OMAP34XX_MCBSP2_DR);
+	omap_cfg_reg(M21_OMAP34XX_MCBSP2_DX);
+	omap_cfg_reg(K26_OMAP34XX_MCBSP3_FSX);
+	omap_cfg_reg(W21_OMAP34XX_MCBSP3_CLKX);
+	omap_cfg_reg(U21_OMAP34XX_MCBSP3_DR);
+	omap_cfg_reg(V21_OMAP34XX_MCBSP3_DX);
+
+	gpio_direction_output(SHOLEST_AUDIO_PATH_GPIO, 1);
+	omap_cfg_reg(AE5_34XX_GPIO143);
+}
+
+static struct omap_uart_config sholest_uart_config __initdata = {
+	.enabled_uarts = ((1 << 0) | (1 << 1) | (1 << 2)),
+};
+
+static struct omap_board_config_kernel sholest_config[] __initdata = {
+	{OMAP_TAG_UART,		&sholest_uart_config },
+};
+
+static int sholest_touch_reset(void)
+{
+	gpio_direction_output(SHOLEST_TOUCH_RESET_N_GPIO, 1);
+	msleep(1);
+	gpio_set_value(SHOLEST_TOUCH_RESET_N_GPIO, 0);
+	msleep(20);
+	gpio_set_value(SHOLEST_TOUCH_RESET_N_GPIO, 1);
+	msleep(45);
+
+	return 0;
+}
+
+static struct qtouch_ts_platform_data sholest_ts_platform_data;
+
+static ssize_t sholest_virtual_keys_show(struct kobject *kobj,
+					struct kobj_attribute *attr, char *buf)
+{
+	int key_num;
+	int string_loc = 0;
+	int num_chars;
+
+	for (key_num = 0; key_num < sholest_ts_platform_data.vkeys.count; key_num++) {
+		if (key_num != 0) {
+			num_chars = sprintf((buf + string_loc), ":");
+			string_loc += num_chars;
+		}
+
+		num_chars = sprintf((buf + string_loc),
+			__stringify(EV_KEY) ":%d:%d:%d:%d:%d",
+			sholest_ts_platform_data.vkeys.keys[key_num].code,
+			sholest_ts_platform_data.vkeys.keys[key_num].center_x,
+			sholest_ts_platform_data.vkeys.keys[key_num].center_y,
+			sholest_ts_platform_data.vkeys.keys[key_num].width,
+			sholest_ts_platform_data.vkeys.keys[key_num].height);
+		string_loc += num_chars;
+	}
+
+	sprintf((buf + string_loc), "\n");
+
+	return string_loc;
+}
+
+static struct kobj_attribute sholest_virtual_keys_attr = {
+	.attr = {
+		.name = "virtualkeys.qtouch-touchscreen",
+		.mode = S_IRUGO,
+	},
+	.show = &sholest_virtual_keys_show,
+};
+
+static struct attribute *sholest_properties_attrs[] = {
+	&sholest_virtual_keys_attr.attr,
+	NULL,
+};
+
+static struct attribute_group sholest_properties_attr_group = {
+	.attrs = sholest_properties_attrs,
+};
+
+static struct i2c_board_info __initdata sholest_i2c_bus1_board_info[];
+
+static void sholest_touch_init(void)
+{
+#ifdef CONFIG_ARM_OF
+	struct device_node *touch_node;
+	const void *touch_prop;
+	int len = 0;
+	const uint32_t *touch_val;
+
+	if ((touch_node = of_find_node_by_path(DT_PATH_TOUCH))) {
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_KEYMAP, &len)) \
+			&& len && (0 == len % sizeof(struct vkey))) {
+			sholest_ts_platform_data.vkeys.count = len / sizeof(struct vkey);
+			sholest_ts_platform_data.vkeys.keys = (struct vkey *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_I2C_ADDRESS, &len))) {
+			sholest_i2c_bus1_board_info[0].addr = *((int *)touch_prop);
+		}
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FLAGS, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.flags = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_X, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_x = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_X, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_x = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_Y, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_y = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_Y, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_y = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_P, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_p = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_P, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_p = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MIN_W, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_min_w = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_ABS_MAX_W, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.abs_max_w = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_X, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_x = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_Y, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_y = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_P, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_p = *touch_val;
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_FUZZ_W, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.fuzz_w = *touch_val;
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T15, &len))) {
+			sholest_ts_platform_data.key_array.cfg = (struct qtm_touch_keyarray_cfg *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_KEY_ARRAY_MAP, &len))) {
+			sholest_ts_platform_data.key_array.keys = (struct qtouch_key *)touch_prop;
+		}
+
+		touch_val = of_get_property(touch_node, DT_PROP_TOUCH_KEY_ARRAY_COUNT, &len);
+		if (touch_val && len)
+			sholest_ts_platform_data.key_array.num_keys = *touch_val;
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T7, &len))) {
+			sholest_ts_platform_data.power_cfg = *(struct qtm_gen_power_cfg *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T8, &len))) {
+			sholest_ts_platform_data.acquire_cfg = *(struct qtm_gen_acquire_cfg *)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T9, &len))) {
+			sholest_ts_platform_data.multi_touch_cfg = *(struct qtm_touch_multi_cfg *)touch_prop;
+		}
+
+ 		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T17, &len))) {
+			sholest_ts_platform_data.linear_tbl_cfg
+				= *(struct  qtm_proci_linear_tbl_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T19, &len))) {
+			sholest_ts_platform_data.gpio_pwm_cfg
+				= *(struct  qtm_spt_gpio_pwm_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T20, &len))) {
+			sholest_ts_platform_data.grip_suppression_cfg
+				= *(struct  qtm_proci_grip_suppression_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T22, &len))) {
+			sholest_ts_platform_data.noise_suppression_cfg
+				= *(struct  qtm_procg_noise_suppression_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T24, &len))) {
+			sholest_ts_platform_data.one_touch_gesture_proc_cfg
+				= *(struct  qtm_proci_one_touch_gesture_proc_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T25, &len))) {
+			sholest_ts_platform_data.self_test_cfg
+				= *(struct  qtm_spt_self_test_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T27, &len))) {
+			sholest_ts_platform_data.two_touch_gesture_proc_cfg
+				= *(struct  qtm_proci_two_touch_gesture_proc_cfg*)touch_prop;
+		}
+
+		if ((touch_prop = of_get_property(touch_node, DT_PROP_TOUCH_T28, &len))) {
+			sholest_ts_platform_data.cte_config_cfg = *(struct  qtm_spt_cte_config_cfg*)touch_prop;
+		}
+
+		of_node_put(touch_node);
+	}
+#endif
+
+	gpio_request(SHOLEST_TOUCH_RESET_N_GPIO, "mapphone touch reset");
+	gpio_direction_output(SHOLEST_TOUCH_RESET_N_GPIO, 1);
+	omap_cfg_reg(H19_34XX_GPIO164_OUT);
+
+	gpio_request(SHOLEST_TOUCH_INT_GPIO, "mapphone touch irq");
+	gpio_direction_input(SHOLEST_TOUCH_INT_GPIO);
+	omap_cfg_reg(D25_34XX_GPIO109);
+}
+
+static void sholest_als_init(void)
+{
+	printk(KERN_INFO "%s:Initializing\n", __func__);
+	gpio_request(SHOLEST_LM_3530_INT_GPIO, "mapphone als int");
+	gpio_direction_input(SHOLEST_LM_3530_INT_GPIO);
+	omap_cfg_reg(AC27_34XX_GPIO92);
+}
+
+static struct vkey sholest_touch_vkeys[] = {
+	{
+		.code		= KEY_MENU,
+		.center_x	= 32,
+		.center_y	= 906,
+		.width		= 63,
+		.height		= 57,
+	},
+	{
+		.code		= KEY_HOME,
+		.center_x	= 168,
+		.center_y	= 906,
+		.width		= 89,
+		.height		= 57,
+	},
+	{
+		.code		= KEY_BACK,
+		.center_x	= 314,
+		.center_y	= 906,
+		.width		= 89,
+		.height		= 57,
+	},
+	{
+		.code		= KEY_SEARCH,
+		.center_x	= 449,
+		.center_y	= 906,
+		.width		= 63,
+		.height		= 57,
+	},
+};
+
+static struct qtm_touch_keyarray_cfg sholest_key_array_data[] = {
+	{
+		.ctrl		= 0,
+		.x_origin	= 0,
+		.y_origin	= 0,
+		.x_size		= 0,
+		.y_size		= 0,
+		.aks_cfg	= 0,
+		.burst_len	= 0,
+		.tch_det_thr	= 0,
+		.tch_det_int	= 0,
+		.rsvd1		= 0,
+		.rsvd2		= 0,
+	},
+	{
+		.ctrl		= 0,
+		.x_origin	= 0,
+		.y_origin	= 0,
+		.x_size		= 0,
+		.y_size		= 0,
+		.aks_cfg	= 0,
+		.burst_len	= 0,
+		.tch_det_thr	= 0,
+		.tch_det_int	= 0,
+		.rsvd1		= 0,
+		.rsvd2		= 0,
+	},
+};
+
+static struct qtouch_ts_platform_data sholest_ts_platform_data = {
+	.flags		= (QTOUCH_SWAP_XY |
+			   QTOUCH_USE_MULTITOUCH |
+			   QTOUCH_CFG_BACKUPNV |
+			   QTOUCH_EEPROM_CHECKSUM),
+	.irqflags	= (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW),
+	.abs_min_x	= 0,
+	.abs_max_x	= 1024,
+	.abs_min_y	= 0,
+	.abs_max_y	= 960,
+	.abs_min_p	= 0,
+	.abs_max_p	= 255,
+	.abs_min_w	= 0,
+	.abs_max_w	= 15,
+        .x_delta        = 400,
+        .y_delta        = 250,
+	.nv_checksum	= 0xf429,
+	.fuzz_x		= 0,
+	.fuzz_y		= 0,
+	.fuzz_p		= 2,
+	.fuzz_w		= 2,
+	.hw_reset	= sholest_touch_reset,
+	.key_array = {
+		.cfg		= sholest_key_array_data,
+		.keys		= NULL,
+		.num_keys	= 0,
+	},
+	.power_cfg	= {
+		.idle_acq_int	= 0x0a,
+		.active_acq_int	= 0xff,
+		.active_idle_to	= 0x32,
+	},
+	.acquire_cfg	= {
+		.charge_time	= 0x08,
+		.reserve0	= 0x00,
+		.touch_drift	= 0x0a,
+		.drift_susp	= 0x01,
+		.touch_autocal	= 0x32,
+		.sync		= 0,
+		.anti_cal_susp	= 0x01,
+		.anti_cal_sthr	= 0x00,
+	},
+	.multi_touch_cfg	= {
+		.ctrl		= 0x0b,
+		.x_origin	= 0,
+		.y_origin	= 0,
+		.x_size		= 0x12,
+		.y_size		= 0x0a,
+		.aks_cfg	= 0,
+		.burst_len	= 0x11,
+		.tch_det_thr	= 0x24,
+		.tch_det_int	= 0x02,
+		.orient		= 0,
+		.mrg_to		= 0x19,
+		.mov_hyst_init	= 0x14,
+		.mov_hyst_next	= 0x05,
+		.mov_filter	= 0x30,
+		.num_touch	= 0x02,
+		.merge_hyst	= 0x05,
+		.merge_thresh	= 0x05,
+		.amp_hyst	= 0,
+		.x_res		= 0x0000,
+		.y_res		= 0x0000,
+		.x_low_clip	= 0x05,
+		.x_high_clip	= 0x00,
+		.y_low_clip	= 0x00,
+		.y_high_clip	= 0x05,
+		.x_edge_ori	= 0x00,
+		.x_edge_cdist	= 0x00,
+		.y_edge_ori	= 0x00,
+		.y_edge_cdist	= 0x00,
+	},
+	.linear_tbl_cfg = {
+		.ctrl = 0x00,
+		.x_offset = 0x0000,
+		.x_segment = {
+			0x00, 0x00, 0x00 , 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00
+		},
+		.y_offset = 0x0000,
+		.y_segment = {
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00
+		},
+	},
+	.gpio_pwm_cfg = {
+		.ctrl			= 0,
+		.report_mask		= 0,
+		.pin_direction		= 0,
+		.internal_pullup	= 0,
+		.output_value		= 0,
+		.wake_on_change		= 0,
+		.pwm_enable		= 0,
+		.pwm_period		= 0,
+		.duty_cycle_0		= 0,
+		.duty_cycle_1		= 0,
+		.duty_cycle_2		= 0,
+		.duty_cycle_3		= 0,
+		.trigger_0              = 0,
+		.trigger_1              = 0,
+		.trigger_2              = 0,
+		.trigger_3              = 0,
+	},
+	.com_cfg = {
+		.ctrl		= 0x00,
+		.cmd		= 0x00,
+	},
+	.grip_suppression_cfg = {
+		.ctrl		= 0x00,
+		.xlogrip	= 0x00,
+		.xhigrip	= 0x00,
+		.ylogrip	= 0x00,
+		.yhigrip	= 0x00,
+		.maxtchs	= 0x00,
+		.reserve0	= 0x00,
+		.szthr1		= 0x00,
+		.szthr2		= 0x00,
+		.shpthr1	= 0x00,
+		.shpthr2	= 0x00,
+	},
+	.noise_suppression_cfg = {
+		.ctrl			= 0x05,
+		.reserve0		= 0x0000,
+		.gcaf_upper_limit	= 0x0019,
+		.gcaf_lower_limit	= 0xffe7,
+		.gcaf_num_active	= 0x04,
+		.noise_threshold	= 0x12,
+		.reserve1		= 0,
+		.freq_hop_scale		= 0x01,
+		.burst_freq_0		= 0x06,
+		.burst_freq_1		= 0x0b,
+		.burst_freq_2		= 0x0f,
+		.burst_freq_3		= 0x13,
+		.burst_freq_4		= 0x15,
+		.gcaf_num_idle		= 0x04,
+	},
+	.one_touch_gesture_proc_cfg = {
+		.ctrl			= 0,
+		.reserve0		= 0,
+		.gesture_enable		= 0,
+		.pres_proc		= 0,
+		.tap_time_out		= 0,
+		.flick_time_out		= 0,
+		.drag_time_out		= 0,
+		.short_press_time_out	= 0,
+		.long_press_time_out	= 0,
+		.repeat_press_time_out	= 0,
+		.flick_threshold	= 0,
+		.drag_threshold		= 0,
+		.tap_threshold		= 0,
+		.throw_threshold	= 0,
+	},
+	.self_test_cfg = {
+		.ctrl			= 0,
+		.command		= 0,
+		.high_signal_limit_0	= 0,
+		.low_signal_limit_0	= 0,
+		.high_signal_limit_1	= 0,
+		.low_signal_limit_1	= 0,
+	},
+	.two_touch_gesture_proc_cfg = {
+		.ctrl			= 0,
+		.reserved0		= 0,
+		.reserved1		= 0,
+		.gesture_enable		= 0,
+		.rotate_threshold	= 0,
+		.zoom_threshold		= 0,
+	},
+	.cte_config_cfg = {
+		.ctrl			= 1,
+		.command		= 0,
+		.mode			= 3,
+		.idle_gcaf_depth	= 4,
+		.active_gcaf_depth	= 0x20,
+		.voltage		= 0x1e,
+	},
+	.noise1_suppression_cfg = {
+		.ctrl		= 0x00,
+		.reserved	= 0x00,
+		.atchthr	= 0x00,
+		.duty_cycle	= 0x00,
+	},
+	.userdata = {
+		.data_0		= 0x49,
+		.data_1		= 0x00,
+		.data_2		= 0x4C,
+		.data_3		= 0x00,
+		.data_4		= 0x48,
+		.data_5		= 0x00,
+		.data_6		= 0x4A,
+		.data_7		= 0x00,
+	},
+	.vkeys			= {
+		.count		= ARRAY_SIZE(sholest_touch_vkeys),
+		.keys		= sholest_touch_vkeys,
+	},
+};
+
+static struct lm3530_platform_data omap3430_als_light_data = {
+	.power_up_gen_config = 0x0b,
+	.gen_config = 0x33,
+	.als_config = 0x7B,
+	.brightness_ramp = 0x36,
+	.als_zone_info = 0x00,
+	.als_resistor_sel = 0x22,
+	.brightness_control = 0x00,
+	.zone_boundary_0 = 0x07,
+	.zone_boundary_1 = 0x29,
+	.zone_boundary_2 = 0x48,
+	.zone_boundary_3 = 0x94,
+	.zone_target_0 = 0x12,
+	.zone_target_1 = 0x1F,
+	.zone_target_2 = 0x28,
+	.zone_target_3 = 0x31,
+	.zone_target_4 = 0x3A,
+	.manual_current = 0x33,
+	.upper_curr_sel = 5,
+	.lower_curr_sel = 2,
+	.lens_loss_coeff = 6,
+};
+
+static struct lm3554_platform_data sholest_camera_flash = {
+	.torch_brightness_def = 0xa0,
+	.flash_brightness_def = 0x78,
+	.flash_duration_def = 0x28,
+	.config_reg_1_def = 0xe0,
+	.config_reg_2_def = 0xf0,
+	.vin_monitor_def = 0x03,
+	.gpio_reg_def = 0x0,
+};
+
+static struct i2c_board_info __initdata sholest_i2c_bus1_board_info[] = {
+	{
+		I2C_BOARD_INFO(QTOUCH_TS_NAME, 0x4A),
+		.platform_data = &sholest_ts_platform_data,
+		.irq = OMAP_GPIO_IRQ(SHOLEST_TOUCH_INT_GPIO),
+	},
+	{
+		I2C_BOARD_INFO(LD_LM3530_NAME, 0x38),
+		.platform_data = &omap3430_als_light_data,
+		.irq = OMAP_GPIO_IRQ(SHOLEST_LM_3530_INT_GPIO),
+	},
+};
+
+#ifdef CONFIG_SENSORS_LIS331DLH
+extern struct lis331dlh_platform_data sholest_lis331dlh_data;
+#endif
+#ifdef CONFIG_MOT_FEAT_LP3907
+extern struct lp3907_platform_data sholest_lp3907_data;
+#endif
+
+static struct i2c_board_info __initdata sholest_i2c_bus2_board_info[] = {
+	{
+		I2C_BOARD_INFO("akm8973", 0x1C),
+		.irq = OMAP_GPIO_IRQ(SHOLEST_AKM8973_INT_GPIO),
+	},
+#ifdef CONFIG_SENSORS_LIS331DLH
+	{
+		I2C_BOARD_INFO("lis331dlh", 0x19),
+		.platform_data = &sholest_lis331dlh_data,
+	},
+#endif
+#ifdef CONFIG_MOT_FEAT_LP3907
+	{
+		I2C_BOARD_INFO("lp3907", 0x61),
+		.platform_data = &sholest_lp3907_data,
+	},
+#endif
+};
+
+static struct i2c_board_info __initdata sholest_i2c_bus3_board_info[] = {
+	{
+		I2C_BOARD_INFO("lm3554_led", 0x53),
+		.platform_data = &sholest_camera_flash,
+	},
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+	{
+		I2C_BOARD_INFO("mt9p012", 0x36),
+		.platform_data = &sholest_mt9p012_platform_data,
+	},
+#endif
+#if defined(CONFIG_VIDEO_OV8810)
+	{
+		I2C_BOARD_INFO("ov8810", OV8810_I2C_ADDR),
+		.platform_data = &sholest_ov8810_platform_data,
+	},
+#endif
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+	{
+		I2C_BOARD_INFO("HP_GEN_LENS", 0x04),
+		.platform_data = &sholest_hplens_platform_data,
+	},
+#endif
+	{
+		I2C_BOARD_INFO("tda19989", 0x70),
+	},
+#if defined(CONFIG_LEDS_BD7885)
+	{
+		I2C_BOARD_INFO(BD7885_DEVICE_NAME, BD7885_SLAVE_ADDR),
+	},
+#endif	/* CONFIG_LEDS_BD7885 */
+#if defined(CONFIG_LEDS_BU9847)
+	{
+		I2C_BOARD_INFO(BU9847_DEVICE_NAME, BU9847_SLAVE_ADDR),
+	},
+#endif/*CONFIG_LEDS_BU9847*/
+};
+
+static int __init sholest_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 400, sholest_i2c_bus1_board_info,
+			      ARRAY_SIZE(sholest_i2c_bus1_board_info));
+	omap_register_i2c_bus(2, 400, sholest_i2c_bus2_board_info,
+			      ARRAY_SIZE(sholest_i2c_bus2_board_info));
+	omap_register_i2c_bus(3, 400, sholest_i2c_bus3_board_info,
+			      ARRAY_SIZE(sholest_i2c_bus3_board_info));
+	return 0;
+}
+
+arch_initcall(sholest_i2c_init);
+
+extern void __init sholest_spi_init(void);
+extern void __init sholest_flash_init(void);
+extern void __init sholest_gpio_iomux_init(void);
+#ifdef CONFIG_MOT_FEAT_MDTV
+extern void __init sholest_mdtv_init(void);
+#endif
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+
+static int sholest_usb_port_startup(struct platform_device *dev, int port)
+{
+	int r;
+
+	if (port == 2) {
+		r = gpio_request(SHOLEST_IPC_USB_SUSP_GPIO, "ipc_usb_susp");
+		if (r < 0) {
+			printk(KERN_WARNING "Could not request GPIO %d"
+			       " for IPC_USB_SUSP\n",
+			       SHOLEST_IPC_USB_SUSP_GPIO);
+			return r;
+		}
+		gpio_direction_output(SHOLEST_IPC_USB_SUSP_GPIO, 0);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void sholest_usb_port_shutdown(struct platform_device *dev, int port)
+{
+	if (port == 2)
+		gpio_free(SHOLEST_IPC_USB_SUSP_GPIO);
+}
+
+
+static void sholest_usb_port_suspend(struct platform_device *dev,
+				    int port, int suspend)
+{
+	if (port == 2)
+		gpio_set_value(SHOLEST_IPC_USB_SUSP_GPIO, suspend);
+}
+
+
+static struct omap_usb_port_data usb_port_data[] = {
+	[0] = { .flags = 0x0, }, /* disabled */
+	[1] = { .flags = 0x0, }, /* disabled */
+	[2] = {
+		.flags = OMAP_USB_PORT_FLAG_ENABLED |
+			OMAP_USB_PORT_FLAG_AUTOIDLE |
+			OMAP_USB_PORT_FLAG_NOBITSTUFF,
+		.mode = OMAP_USB_PORT_MODE_UTMI_PHY_4PIN,
+		.startup = sholest_usb_port_startup,
+		.shutdown = sholest_usb_port_shutdown,
+		.suspend = sholest_usb_port_suspend,
+	},
+};
+
+static int omap_ohci_bus_check_ctrl_standby(void);
+static struct omap_usb_platform_data usb_platform_data = {
+	.port_data = usb_port_data,
+	.num_ports = ARRAY_SIZE(usb_port_data),
+	.usbhost_standby_status	= omap_ohci_bus_check_ctrl_standby,
+};
+
+static struct resource ehci_resources[] = {
+	[0] = {
+		.start	= OMAP34XX_HSUSB_HOST_BASE + 0x800,
+		.end	= OMAP34XX_HSUSB_HOST_BASE + 0x800 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {         /* general IRQ */
+		.start	= INT_34XX_EHCI_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+static struct platform_device ehci_device = {
+	.name		= "ehci-omap",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data		= &usb_platform_data,
+	},
+	.num_resources	= ARRAY_SIZE(ehci_resources),
+	.resource	= ehci_resources,
+};
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE) || defined(CONFIG_USB_EHCI_HCD)
+static int omap_ohci_bus_check_ctrl_standby(void)
+{
+	u32 val;
+
+	val = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD, CM_IDLEST);
+	if (val & OMAP3430ES2_ST_USBHOST_STDBY_MASK)
+		return 1;
+	else
+		return 0;
+}
+#endif
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+
+
+static struct resource ohci_resources[] = {
+	[0] = {
+		.start	= OMAP34XX_HSUSB_HOST_BASE + 0x400,
+		.end	= OMAP34XX_HSUSB_HOST_BASE + 0x400 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {         /* general IRQ */
+		.start	= INT_34XX_OHCI_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static u64 ohci_dmamask = ~(u32)0;
+
+static struct omap_usb_config dummy_usb_config = {
+	.usbhost_standby_status	= omap_ohci_bus_check_ctrl_standby,
+	.usb_remote_wake_gpio = SHOLEST_BP_READY2_AP_GPIO,
+};
+
+static struct platform_device ohci_device = {
+	.name		= "ohci",
+	.id		= 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= 0xffffffff,
+		.platform_data	= &dummy_usb_config,
+	},
+	.num_resources	= ARRAY_SIZE(ohci_resources),
+	.resource	= ohci_resources,
+};
+#endif /* OHCI specific data */
+
+
+static void __init sholest_ehci_init(void)
+{
+	omap_cfg_reg(AF5_34XX_GPIO142);		/*  IPC_USB_SUSP      */
+	omap_cfg_reg(AD1_3430_USB3FS_PHY_MM3_RXRCV);
+	omap_cfg_reg(AD2_3430_USB3FS_PHY_MM3_TXDAT);
+	omap_cfg_reg(AC1_3430_USB3FS_PHY_MM3_TXEN_N);
+	omap_cfg_reg(AE1_3430_USB3FS_PHY_MM3_TXSE0);
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+	platform_device_register(&ehci_device);
+#endif
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	if (is_cdma_phone())
+		platform_device_register(&ohci_device);
+#endif
+}
+
+static void __init sholest_sdrc_init(void)
+{
+	/* Ensure SDRC pins are mux'd for self-refresh */
+	omap_cfg_reg(H16_34XX_SDRC_CKE0);
+	omap_cfg_reg(H17_34XX_SDRC_CKE1);
+}
+
+static void __init sholest_serial_init(void)
+{
+	omap_cfg_reg(AA8_3430_UART1_TX);
+	omap_cfg_reg(Y8_3430_UART1_RX);
+	omap_cfg_reg(AA9_3430_UART1_RTS);
+	omap_cfg_reg(W8_3430_UART1_CTS);
+	omap_cfg_reg(AA25_34XX_UART2_TX);
+	omap_cfg_reg(AD25_34XX_UART2_RX);
+	omap_cfg_reg(AB25_34XX_UART2_RTS);
+	omap_cfg_reg(AB26_34XX_UART2_CTS);
+
+	omap_serial_init(SHOLEST_BPWAKE_STROBE_GPIO, 0x01);
+}
+
+/* SMPS I2C voltage control register Address for VDD1 */
+#define SHOLEST_R_VDD1_SR_CONTROL		0x00
+/* SMPS I2C voltage control register Address for VDD2 */
+#define SHOLEST_R_VDD2_SR_CONTROL		0x00
+/* SMPS I2C Address for VDD1 */
+#define SHOLEST_R_SRI2C_SLAVE_ADDR_SA0		0x1
+/* SMPS I2C Address for VDD2 */
+#define SHOLEST_R_SRI2C_SLAVE_ADDR_SA1		0x2
+/* SMPS I2C voltage control register Address for VDD1, used for SR command */
+#define SHOLEST_R_SMPS_VOL_CNTL_CMDRA0		0x01
+/* SMPS I2C voltage control register Address for VDD2, used for SR command */
+#define SHOLEST_R_SMPS_VOL_CNTL_CMDRA1		0x01
+
+static struct prm_setup_vc sholest_prm_setup = {
+	.clksetup = 0x4c,
+	.voltsetup_time1 = 0x94,
+	.voltsetup_time2 = 0x94,
+	.voltoffset = 0x0,
+	.voltsetup2 = 0x0,
+	.vdd0_on = 0x65,
+	.vdd0_onlp = 0x45,
+	.vdd0_ret = 0x19,
+	.vdd0_off = 0x00,
+	.vdd1_on = 0x65,
+	.vdd1_onlp = 0x45,
+	.vdd1_ret = 0x19,
+	.vdd1_off = 0x00,
+	.i2c_slave_ra = (SHOLEST_R_SRI2C_SLAVE_ADDR_SA1 <<
+			OMAP3430_SMPS_SA1_SHIFT) |
+			(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0 <<
+			 OMAP3430_SMPS_SA0_SHIFT),
+	.vdd_vol_ra = (SHOLEST_R_VDD2_SR_CONTROL << OMAP3430_VOLRA1_SHIFT) |
+			(SHOLEST_R_VDD1_SR_CONTROL << OMAP3430_VOLRA0_SHIFT),
+	/* vdd_vol_ra controls both cmd and vol, set the address equal */
+	.vdd_cmd_ra = (SHOLEST_R_SMPS_VOL_CNTL_CMDRA1 << OMAP3430_CMDRA1_SHIFT) |
+		(SHOLEST_R_SMPS_VOL_CNTL_CMDRA0 << OMAP3430_CMDRA0_SHIFT),
+	.vdd_ch_conf = OMAP3430_CMD1 | OMAP3430_RACEN0 |
+			OMAP3430_PRM_VC_CH_CONF_SA1 | OMAP3430_RACEN1 |
+			OMAP3430_RAV1 | OMAP3430_RAC1, OMAP3430_GR_MOD,
+	.vdd_i2c_cfg = OMAP3430_HSEN,
+};
+
+#define R_SMPS_VOL_OPP1_RA0		0x02
+#define R_SMPS_VOL_OPP1_RA1		0x02
+#define R_SMPS_VOL_OPP2_RA0		0x03
+#define R_SMPS_VOL_OPP2_RA1		0x03
+
+#ifdef CONFIG_OMAP_SMARTREFLEX
+int sholest_voltagescale_vcbypass(u32 target_opp, u32 current_opp,
+					u8 target_vsel, u8 current_vsel)
+{
+
+	int sr_status = 0;
+	u32 vdd, target_opp_no;
+	u8 slave_addr = 0, opp_reg_addr = 0, volt_reg_addr = 0;
+
+	vdd = get_vdd(target_opp);
+	target_opp_no = get_opp_no(target_opp);
+
+	if (vdd == VDD1_OPP) {
+		sr_status = sr_stop_vddautocomap(SR1);
+		slave_addr = SHOLEST_R_SRI2C_SLAVE_ADDR_SA0;
+		volt_reg_addr = SHOLEST_R_VDD1_SR_CONTROL;
+		opp_reg_addr = R_SMPS_VOL_OPP2_RA0;
+
+	} else if (vdd == VDD2_OPP) {
+		sr_status = sr_stop_vddautocomap(SR2);
+		slave_addr = SHOLEST_R_SRI2C_SLAVE_ADDR_SA1;
+		volt_reg_addr = SHOLEST_R_VDD2_SR_CONTROL;
+		opp_reg_addr = R_SMPS_VOL_OPP2_RA1;
+	}
+
+	/* Update the CPCAP SWx OPP2 register, stores the on voltage value */
+	omap3_bypass_cmd(slave_addr, opp_reg_addr, target_vsel);
+
+	/* Update the CPCAP SWx voltage register, change the output voltage */
+	omap3_bypass_cmd(slave_addr, volt_reg_addr, target_vsel);
+
+	if (target_vsel > current_vsel)
+		udelay(target_vsel - current_vsel + 4);
+
+	if (sr_status) {
+		if (vdd == VDD1_OPP)
+			sr_start_vddautocomap(SR1, target_opp_no);
+		else if (vdd == VDD2_OPP)
+			sr_start_vddautocomap(SR2, target_opp_no);
+	}
+
+	return SR_PASS;
+}
+#endif
+
+/* Sholest specific PM */
+
+extern void omap_uart_block_sleep(int num);
+static struct wake_lock baseband_wakeup_wakelock;
+static int sholest_bpwake_irqhandler(int irq, void *unused)
+{
+	omap_uart_block_sleep(0);
+	/*
+	 * Ignore the BP pokes while we're awake
+	 * uart_block_sleep keeps uart clock active for 500 ms,
+	 * prevent suspend for 1 sec to be safe
+	 */
+	wake_lock_timeout(&baseband_wakeup_wakelock, HZ);
+	return IRQ_HANDLED;
+}
+
+static int sholest_bpwake_probe(struct platform_device *pdev)
+{
+	int rc;
+
+	gpio_request(SHOLEST_APWAKE_TRIGGER_GPIO, "BP -> AP IPC trigger");
+	gpio_direction_input(SHOLEST_APWAKE_TRIGGER_GPIO);
+
+	wake_lock_init(&baseband_wakeup_wakelock, WAKE_LOCK_SUSPEND, "bpwake");
+
+	rc = request_irq(gpio_to_irq(SHOLEST_APWAKE_TRIGGER_GPIO),
+			 sholest_bpwake_irqhandler,
+			 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			 "Remote Wakeup", NULL);
+	if (rc) {
+		wake_lock_destroy(&baseband_wakeup_wakelock);
+		printk(KERN_ERR
+		       "Failed requesting APWAKE_TRIGGER irq (%d)\n", rc);
+		return rc;
+	}
+
+	enable_irq_wake(gpio_to_irq(SHOLEST_APWAKE_TRIGGER_GPIO));
+	return 0;
+}
+
+static int sholest_bpwake_remove(struct platform_device *pdev)
+{
+	wake_lock_destroy(&baseband_wakeup_wakelock);
+	free_irq(gpio_to_irq(SHOLEST_APWAKE_TRIGGER_GPIO), NULL);
+	return 0;
+}
+
+static int sholest_bpwake_suspend(struct platform_device *pdev,
+					pm_message_t state)
+{
+	return 0;
+}
+
+static int sholest_bpwake_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver sholest_bpwake_driver = {
+	.probe		= sholest_bpwake_probe,
+	.remove		= sholest_bpwake_remove,
+	.suspend	= sholest_bpwake_suspend,
+	.resume		= sholest_bpwake_resume,
+	.driver		= {
+		.name		= "mapphone_bpwake",
+		.owner		= THIS_MODULE,
+	},
+};
+
+static struct platform_device sholest_bpwake_device = {
+	.name		= "mapphone_bpwake",
+	.id		= -1,
+	.num_resources	= 0,
+};
+
+/* Choose cold or warm reset
+ *    RST_TIME1>4ms will trigger CPCAP to trigger a system cold reset */
+static void sholest_pm_set_reset(char cold)
+{
+	if (cold) {
+		/* Configure RST_TIME1 to 6ms  */
+		prm_rmw_mod_reg_bits(OMAP_RSTTIME1_MASK,
+		0xc8<<OMAP_RSTTIME1_SHIFT,
+		OMAP3430_GR_MOD,
+		OMAP3_PRM_RSTTIME_OFFSET);
+	} else {
+		/* Configure RST_TIME1 to 30us  */
+		prm_rmw_mod_reg_bits(OMAP_RSTTIME1_MASK,
+		0x01<<OMAP_RSTTIME1_SHIFT,
+		OMAP3430_GR_MOD,
+		OMAP3_PRM_RSTTIME_OFFSET);
+	}
+}
+
+static int sholest_pm_reboot_call(struct notifier_block *this,
+			unsigned long code, void *cmd)
+{
+	int result = NOTIFY_DONE;
+
+	if (code == SYS_RESTART) {
+		/* set cold reset */
+		sholest_pm_set_reset(1);
+	}
+
+	return result;
+}
+
+static struct notifier_block sholest_pm_reboot_notifier = {
+	.notifier_call = sholest_pm_reboot_call,
+};
+
+#ifdef CONFIG_MEM_DUMP
+
+#define WARMRESET 1
+#define COLDRESET 0
+
+static unsigned long reset_status = COLDRESET ;
+#endif
+static void sholest_pm_init(void)
+{
+	omap3_set_prm_setup_vc(&sholest_prm_setup);
+	omap3_voltagescale_vcbypass_setup(sholest_voltagescale_vcbypass);
+
+    /* Set CPCAP SW1/SW2 I2C CNTL Reg to 0x45(PSM/PSM mode, VPLL enabled) to
+	 * avoid extra current drain in active case before hit RET once*/
+
+	/* Initialize CPCAP SW1&SW2 OPP1&OPP2 registers */
+	/* SW1, OPP1 for RET Voltage --- 1.0V,
+	 * OPP2 for ON Voltge --- 1.225V(OPP3)
+	 */
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0,
+				SHOLEST_R_SMPS_VOL_CNTL_CMDRA0, 0x45);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0,
+				R_SMPS_VOL_OPP1_RA0, 0x20);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA0,
+				R_SMPS_VOL_OPP2_RA0, 0x32);
+
+	/* SW2, OPP1 for RET Voltage --- 1.0V,
+	 * OPP2 for ON Voltge --- 1.175V(OPP3)
+	 */
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA1,
+				SHOLEST_R_SMPS_VOL_CNTL_CMDRA1, 0x45);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA1,
+				R_SMPS_VOL_OPP1_RA1, 0x20);
+	omap3_bypass_cmd(SHOLEST_R_SRI2C_SLAVE_ADDR_SA1,
+				R_SMPS_VOL_OPP2_RA1, 0x2E);
+
+	/* Configure BP <-> AP wake pins */
+	omap_cfg_reg(AA21_34XX_GPIO157_OUT);
+	omap_cfg_reg(AE6_34XX_GPIO141_DOWN);
+
+	platform_device_register(&sholest_bpwake_device);
+	platform_driver_register(&sholest_bpwake_driver);
+
+#ifdef CONFIG_MEM_DUMP
+	if (reset_status == COLDRESET)
+		sholest_pm_set_reset(1);
+	else
+		sholest_pm_set_reset(0);
+#else
+	/* set cold reset, will move to warm reset once ready */
+	sholest_pm_set_reset(1);
+
+#endif
+	register_reboot_notifier(&sholest_pm_reboot_notifier);
+}
+
+#ifdef CONFIG_MEM_DUMP
+static struct proc_dir_entry *proc_entry ;
+
+ssize_t reset_proc_read(char *page, char **start, off_t off, \
+   int count, int *eof, void *data)
+{
+	int len ;
+    /* don't visit offset */
+	if (off > 0) {
+		*eof = 1 ;
+		return 0 ;
+	}
+	len = snprintf(page, sizeof(page), "%x\n", (unsigned int)reset_status) ;
+	return len ;
+}
+
+ssize_t reset_proc_write(struct file *filp, const char __user *buff, \
+  unsigned long len, void *data)
+{
+#define MAX_UL_LEN 8
+	char k_buf[MAX_UL_LEN] ;
+	int count = min((unsigned long)MAX_UL_LEN, len) ;
+	int ret ;
+
+	if (copy_from_user(k_buf, buff, count)) {
+		ret = -EFAULT ;
+		goto err ;
+	} else{
+		if (k_buf[0] == '0') {
+			reset_status = COLDRESET;
+			sholest_pm_set_reset(1);
+			printk(KERN_ERR"switch to cold reset\n");
+		} else if (k_buf[0] == '1') {
+			reset_status = WARMRESET;
+			sholest_pm_set_reset(0);
+			printk(KERN_ERR"switch to warm reset\n");
+		} else{
+			ret = -EFAULT;
+			goto err;
+		}
+	return count ;
+	}
+err:
+	return ret ;
+}
+
+static void  reset_proc_init(void)
+{
+	proc_entry = create_proc_entry("reset_proc", 0666, NULL);
+	if (proc_entry == NULL) {
+		printk(KERN_INFO"Couldn't create proc entry\n") ;
+	} else{
+		proc_entry->read_proc = reset_proc_read ;
+		proc_entry->write_proc = reset_proc_write ;
+		proc_entry->owner = THIS_MODULE ;
+	}
+}
+
+int __init warmreset_init(char *s)
+{
+	/* configure to warmreset */
+	reset_status = WARMRESET;
+	sholest_pm_set_reset(0);
+	return 1;
+}
+__setup("warmreset_debug=", warmreset_init);
+#endif
+
+static void __init config_wlan_gpio(void)
+{
+	/* WLAN PE and IRQ */
+	omap_cfg_reg(AE22_34XX_GPIO186_OUT);
+	omap_cfg_reg(J8_3430_GPIO65);
+}
+
+static void __init config_mmc2_init(void)
+{
+	u32 val;
+
+	/* MMC2 */
+	omap_cfg_reg(AE2_3430_MMC2_CLK);
+	omap_cfg_reg(AG5_3430_MMC2_CMD);
+	omap_cfg_reg(AH5_3430_MMC2_DAT0);
+	omap_cfg_reg(AH4_3430_MMC2_DAT1);
+	omap_cfg_reg(AG4_3430_MMC2_DAT2);
+	omap_cfg_reg(AF4_3430_MMC2_DAT3);
+
+	/* Set internal loopback clock */
+	val = omap_ctrl_readl(OMAP343X_CONTROL_DEVCONF1);
+	omap_ctrl_writel((val | OMAP2_MMCSDIO2ADPCLKISEL),
+				OMAP343X_CONTROL_DEVCONF1);
+}
+
+/* must match value in drivers/w1/w1_family.h */
+#define W1_EEPROM_DS2502        0x89
+static struct omap2_hdq_platform_config sholest_hdq_data = {
+	.mode = OMAP_SDQ_MODE,
+	.id = W1_EEPROM_DS2502,
+};
+
+static int __init omap_hdq_init(void)
+{
+	omap_cfg_reg(J25_34XX_HDQ_SIO);
+	omap_hdq_device.dev.platform_data = &sholest_hdq_data;
+	return platform_device_register(&omap_hdq_device);
+}
+
+static int sholest_wl1271_init(void)
+{
+	int rc = 0;
+
+	/* wl1271 BT chip init sequence */
+	gpio_direction_output(SHOLEST_WL1271_NSHUTDOWN_GPIO, 0);
+	msleep(5);
+	gpio_set_value(SHOLEST_WL1271_NSHUTDOWN_GPIO, 1);
+	msleep(10);
+	gpio_set_value(SHOLEST_WL1271_NSHUTDOWN_GPIO, 0);
+	msleep(5);
+
+	/* Reserve BT wake and hostwake GPIOs */
+	rc = gpio_request(SHOLEST_WL1271_WAKE_GPIO, "wl127x_wake_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	rc = gpio_request(SHOLEST_WL1271_HOSTWAKE_GPIO,
+				"wl127x_hostwake_gpio");
+	if (unlikely(rc))
+		return rc;
+
+	gpio_direction_output(SHOLEST_WL1271_WAKE_GPIO, 1);
+	gpio_direction_input(SHOLEST_WL1271_HOSTWAKE_GPIO);
+
+	return 0;
+}
+
+static int sholest_wl1271_release(void)
+{
+	gpio_free(SHOLEST_WL1271_WAKE_GPIO);
+	gpio_free(SHOLEST_WL1271_HOSTWAKE_GPIO);
+
+	return 0;
+}
+
+static int sholest_wl1271_enable(void)
+{
+	gpio_set_value(SHOLEST_WL1271_WAKE_GPIO, 0);
+	return 0;
+}
+
+static int sholest_wl1271_disable(void)
+{
+	gpio_set_value(SHOLEST_WL1271_WAKE_GPIO, 1);
+	return 0;
+}
+
+static struct wl127x_rfkill_platform_data sholest_wl1271_pdata = {
+	.bt_nshutdown_gpio = SHOLEST_WL1271_NSHUTDOWN_GPIO,
+	.fm_enable_gpio = -1,
+	.bt_hw_init = sholest_wl1271_init,
+	.bt_hw_release = sholest_wl1271_release,
+	.bt_hw_enable = sholest_wl1271_enable,
+	.bt_hw_disable = sholest_wl1271_disable,
+};
+
+static struct platform_device sholest_wl1271_device = {
+	.name = "wl127x-rfkill",
+	.id = 0,
+	.dev.platform_data = &sholest_wl1271_pdata,
+};
+
+static struct wl127x_test_platform_data sholest_wl1271_test_pdata = {
+	.btwake_gpio = SHOLEST_WL1271_WAKE_GPIO,
+	.hostwake_gpio = SHOLEST_WL1271_HOSTWAKE_GPIO,
+};
+
+static struct platform_device sholest_wl1271_test_device = {
+	.name = "wl127x-test",
+	.id = 0,
+	.dev.platform_data = &sholest_wl1271_test_pdata,
+};
+
+static void __init sholest_bt_init(void)
+{
+	/* Mux setup for Bluetooth chip-enable */
+	omap_cfg_reg(T3_34XX_GPIO_179);
+
+	/* Mux setup for BT wake GPIO and hostwake GPIO */
+	omap_cfg_reg(AF21_34XX_GPIO8);
+	omap_cfg_reg(W7_34XX_GPIO178_DOWN);
+
+	platform_device_register(&sholest_wl1271_device);
+	platform_device_register(&sholest_wl1271_test_device);
+}
+
+static struct omap_mdm_ctrl_platform_data omap_mdm_ctrl_platform_data = {
+	.bp_ready_ap_gpio = SHOLEST_BP_READY_AP_GPIO,
+	.bp_ready2_ap_gpio = SHOLEST_BP_READY2_AP_GPIO,
+	.bp_resout_gpio = SHOLEST_BP_RESOUT_GPIO,
+	.bp_pwron_gpio = SHOLEST_BP_PWRON_GPIO,
+	.ap_to_bp_pshold_gpio = SHOLEST_AP_TO_BP_PSHOLD_GPIO,
+	.ap_to_bp_flash_en_gpio = SHOLEST_AP_TO_BP_FLASH_EN_GPIO,
+};
+
+static struct platform_device omap_mdm_ctrl_platform_device = {
+	.name = OMAP_MDM_CTRL_MODULE_NAME,
+	.id = -1,
+	.dev = {
+		.platform_data = &omap_mdm_ctrl_platform_data,
+	},
+};
+
+static int __init sholest_omap_mdm_ctrl_init(void)
+{
+	if (!is_cdma_phone())
+		return -ENODEV;
+
+	gpio_request(SHOLEST_BP_READY2_AP_GPIO, "BP Flash Ready");
+	gpio_direction_input(SHOLEST_BP_READY2_AP_GPIO);
+	omap_cfg_reg(T4_34XX_GPIO59_DOWN);
+
+	gpio_request(SHOLEST_BP_RESOUT_GPIO, "BP Reset Output");
+	gpio_direction_input(SHOLEST_BP_RESOUT_GPIO);
+	omap_cfg_reg(AE3_34XX_GPIO139_DOWN);
+
+	gpio_request(SHOLEST_BP_PWRON_GPIO, "BP Power On");
+	gpio_direction_output(SHOLEST_BP_PWRON_GPIO, 0);
+	omap_cfg_reg(AH3_34XX_GPIO137_OUT);
+
+	gpio_request(SHOLEST_AP_TO_BP_PSHOLD_GPIO, "AP to BP PS Hold");
+	gpio_direction_output(SHOLEST_AP_TO_BP_PSHOLD_GPIO, 0);
+	omap_cfg_reg(AF3_34XX_GPIO138_OUT);
+
+	return platform_device_register(&omap_mdm_ctrl_platform_device);
+}
+
+static struct omap_vout_config sholest_vout_platform_data = {
+	.max_width = 1280,
+	.max_height = 720,
+	.max_buffer_size = 0x1C3000,
+	.num_buffers = 8,
+	.num_devices = 2,
+	.device_ids = {1, 2},
+};
+
+static struct platform_device sholest_vout_device = {
+	.name = "omapvout",
+	.id = -1,
+	.dev = {
+		.platform_data = &sholest_vout_platform_data,
+	},
+};
+static void __init sholest_vout_init(void)
+{
+	platform_device_register(&sholest_vout_device);
+}
+
+#ifdef CONFIG_ANDROID_RAM_CONSOLE
+#define RAM_CONSOLE_START   0x8E000000
+#define RAM_CONSOLE_SIZE    0x20000
+static struct resource ram_console_resource = {
+       .start  = RAM_CONSOLE_START,
+       .end    = (RAM_CONSOLE_START + RAM_CONSOLE_SIZE - 1),
+       .flags  = IORESOURCE_MEM,
+};
+
+static struct platform_device ram_console_device = {
+       .name = "ram_console",
+       .id = 0,
+       .num_resources  = 1,
+       .resource       = &ram_console_resource,
+};
+
+static inline void sholest_ramconsole_init(void)
+{
+	platform_device_register(&ram_console_device);
+}
+
+static inline void omap2_ramconsole_reserve_sdram(void)
+{
+	reserve_bootmem(RAM_CONSOLE_START, RAM_CONSOLE_SIZE, 0);
+}
+#else
+static inline void sholest_ramconsole_init(void) {}
+
+static inline void omap2_ramconsole_reserve_sdram(void) {}
+#endif
+
+
+static struct platform_device sholest_sgx_device = {
+       .name                   = "pvrsrvkm",
+       .id             = -1,
+};
+static struct platform_device sholest_omaplfb_device = {
+	.name			= "omaplfb",
+	.id			= -1,
+};
+
+
+static void __init sholest_sgx_init(void)
+{
+	platform_device_register(&sholest_sgx_device);
+	platform_device_register(&sholest_omaplfb_device);
+}
+
+static void __init sholest_bp_model_init(void)
+{
+#ifdef CONFIG_OMAP_RESET_CLOCKS
+	struct clk *clkp;
+#endif
+
+#ifdef CONFIG_ARM_OF
+	struct device_node *bp_node;
+	const void *bp_prop;
+
+	if ((bp_node = of_find_node_by_path(DT_PATH_CHOSEN))) {
+		if ((bp_prop = of_get_property(bp_node, \
+			DT_PROP_CHOSEN_BP, NULL)))
+			bp_model = (char *)bp_prop;
+
+		of_node_put(bp_node);
+	}
+#endif
+#ifdef CONFIG_OMAP_RESET_CLOCKS
+	/* Enable sad2d iclk */
+	clkp = clk_get(NULL, "sad2d_ick");
+	if (clkp)
+		clk_enable(clkp);
+#endif
+}
+
+static void sholest_pm_power_off(void)
+{
+	printk(KERN_INFO "sholest_pm_power_off start...\n");
+	local_irq_disable();
+
+	/* config gpio 176 back from safe mode to reset the device */
+	omap_writew(0x4, 0x480021D2);
+	gpio_direction_output(SHOLEST_POWER_OFF_GPIO, 0);
+
+	do {} while (1);
+
+	local_irq_enable();
+}
+
+static void sholest_pm_reset(void)
+{
+	arch_reset('h');
+}
+
+static int cpcap_charger_connected_probe(struct platform_device *pdev)
+{
+	pm_power_off = sholest_pm_reset;
+	return 0;
+}
+
+static int cpcap_charger_connected_remove(struct platform_device *pdev)
+{
+	pm_power_off = sholest_pm_power_off;
+	return 0;
+}
+
+static struct platform_driver cpcap_charger_connected_driver = {
+	.probe		= cpcap_charger_connected_probe,
+	.remove		= cpcap_charger_connected_remove,
+	.driver		= {
+		.name	= "cpcap_charger_connected",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void __init sholest_power_off_init(void)
+{
+	gpio_request(SHOLEST_POWER_OFF_GPIO, "mapphone power off");
+	gpio_direction_output(SHOLEST_POWER_OFF_GPIO, 1);
+	omap_cfg_reg(AB1_34XX_GPIO176_OUT);
+
+	/* config gpio176 into safe mode with the pull up enabled to avoid
+	 * glitch at reboot */
+	omap_writew(0x1F, 0x480021D2);
+	pm_power_off = sholest_pm_power_off;
+
+	platform_driver_register(&cpcap_charger_connected_driver);
+}
+
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+static struct platform_device sholest_mipi_dli_device = {
+	.name = "mipi_dli_tester",
+	.id = -1,
+};
+static void __init sholest_mipi_dli_init(void)
+{
+	platform_device_register(&sholest_mipi_dli_device);
+}
+#endif
+
+static void __init sholest_init(void)
+{
+	int ret = 0;
+	struct kobject *properties_kobj = NULL;
+
+	prm_write_mod_reg(0xff, CORE_MOD, OMAP3430_PM_PREPWSTST);
+	omap_board_config = sholest_config;
+	omap_board_config_size = ARRAY_SIZE(sholest_config);
+
+	properties_kobj = kobject_create_and_add("board_properties", NULL);
+	if (properties_kobj)
+		ret = sysfs_create_group(properties_kobj,
+				 &sholest_properties_attr_group);
+	if (!properties_kobj || ret)
+		pr_err("failed to create board_properties\n");
+
+	sholest_bp_model_init();
+	sholest_padconf_init();
+	sholest_gpio_mapping_init();
+	sholest_ramconsole_init();
+	sholest_omap_mdm_ctrl_init();
+	sholest_spi_init();
+	sholest_flash_init();
+	sholest_serial_init();
+	sholest_als_init();
+	sholest_panel_init();
+	sholest_sensors_init();
+	sholest_camera_init();
+	sholest_touch_init();
+	sholest_audio_init();
+	usb_musb_init();
+	sholest_ehci_init();
+	sholest_sdrc_init();
+	sholest_pm_init();
+	config_mmc2_init();
+	config_wlan_gpio();
+	omap_hdq_init();
+	sholest_bt_init();
+#if SHOLEST_MMCPROBE_ENABLED
+	sholest_mmcprobe_init();
+#else
+	sholest_hsmmc_init();
+#endif
+	sholest_vout_init();
+	sholest_sgx_init();
+	sholest_power_off_init();
+	sholest_gadget_init();
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+	sholest_mipi_dli_init();
+#endif
+#ifdef CONFIG_MEM_DUMP
+    reset_proc_init();
+#endif
+}
+
+static void __init sholest_map_io(void)
+{
+	omap2_ramconsole_reserve_sdram();
+	omap2_set_globals_343x();
+	omap2_map_common_io();
+}
+
+MACHINE_START(MAPPHONE, "mapphone_")
+	/* Maintainer: Motorola, Inc. */
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80C00100,
+	.map_io		= sholest_map_io,
+	.init_irq	= sholest_init_irq,
+	.init_machine	= sholest_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff --git a/arch/arm/mach-omap2/board-zoom2.c b/arch/arm/mach-omap2/board-zoom2.c
index b8a3081..0678021 100644
--- a/arch/arm/mach-omap2/board-zoom2.c
+++ b/arch/arm/mach-omap2/board-zoom2.c
@@ -293,8 +293,8 @@ static void zoom2_lcd_tv_panel_init(void)
 	gpio_request(LCD_PANEL_QVGA_GPIO, "lcd qvga");
 	gpio_request(LCD_PANEL_ENABLE_GPIO, "lcd panel");
 	gpio_request(LCD_PANEL_BACKLIGHT_GPIO, "lcd backlight");
-	
-	gpio_request( TV_PANEL_ENABLE_GPIO, "tv panel");
+
+	gpio_request(TV_PANEL_ENABLE_GPIO, "tv panel");
 
 	gpio_direction_output(LCD_PANEL_QVGA_GPIO, 0);
 	gpio_direction_output(lcd_panel_reset_gpio, 0);
diff --git a/arch/arm/mach-omap2/clock34xx.c b/arch/arm/mach-omap2/clock34xx.c
index 3cee6b4..b6baa39 100644
--- a/arch/arm/mach-omap2/clock34xx.c
+++ b/arch/arm/mach-omap2/clock34xx.c
@@ -302,6 +302,17 @@ static int omap3_noncore_dpll_enable(struct clk *clk)
 	if (!dd)
 		return -EINVAL;
 
+	/*
+	* Ensure M/N register is confgured before
+	* Enable it, otherwise DPLL will fail to lock
+	*/
+	if (clk->rate == 0) {
+		WARN_ON(dd->default_rate == 0);
+		r = omap3_noncore_dpll_set_rate(clk, dd->default_rate);
+		if (r)
+			return r;
+	}
+
 	if (clk->rate == dd->bypass_clk->rate)
 		r = _omap3_noncore_dpll_bypass(clk);
 	else
diff --git a/arch/arm/mach-omap2/clock34xx.h b/arch/arm/mach-omap2/clock34xx.h
index e636090..b84d0d2 100644
--- a/arch/arm/mach-omap2/clock34xx.h
+++ b/arch/arm/mach-omap2/clock34xx.h
@@ -847,13 +847,14 @@ static struct clk emu_per_alwon_ck = {
 /* Type: DPLL */
 /* 3430ES2 only */
 static struct dpll_data dpll5_dd = {
+	.default_rate	= 120000000,
 	.mult_div1_reg	= OMAP3430ES2_CM_CLKSEL4,
 	.mult_mask	= OMAP3430ES2_PERIPH2_DPLL_MULT_MASK,
 	.div1_mask	= OMAP3430ES2_PERIPH2_DPLL_DIV_MASK,
 	.freqsel_mask	= OMAP3430ES2_PERIPH2_DPLL_FREQSEL_MASK,
 	.control_reg	= OMAP3430ES2_CM_CLKEN2,
 	.enable_mask	= OMAP3430ES2_EN_PERIPH2_DPLL_MASK,
-	.modes		= (1 << DPLL_LOW_POWER_STOP) | (1 << DPLL_LOCKED),
+	.modes		= (1 << DPLL_LOCKED),
 	.auto_recal_bit	= OMAP3430ES2_EN_PERIPH2_DPLL_DRIFTGUARD_SHIFT,
 	.recal_en_bit	= OMAP3430ES2_SND_PERIPH_DPLL_RECAL_EN_SHIFT,
 	.recal_st_bit	= OMAP3430ES2_SND_PERIPH_DPLL_ST_SHIFT,
@@ -2451,6 +2452,7 @@ static struct clk usim_fck = {
 	.flags		= CLOCK_IN_OMAP3430ES2 | WAIT_READY,
 	.clkdm		= { .name = "prm_clkdm" },
 	.recalc		= &omap2_clksel_recalc,
+	.set_rate       = &omap2_clksel_set_rate,
 };
 
 /* XXX should gpt1's clksel have wkup_32k_fck as the 32k opt? */
diff --git a/arch/arm/mach-omap2/cpuidle34xx.c b/arch/arm/mach-omap2/cpuidle34xx.c
index 6ac2c66..9e951c5 100644
--- a/arch/arm/mach-omap2/cpuidle34xx.c
+++ b/arch/arm/mach-omap2/cpuidle34xx.c
@@ -30,6 +30,7 @@
 #include <mach/control.h>
 #include <mach/serial.h>
 #include <mach/irqs.h>
+#include <linux/pm_qos_params.h>
 
 #include "pm.h"
 
@@ -59,6 +60,24 @@ struct omap3_processor_cx omap3_power_states[OMAP3_MAX_STATES];
 struct omap3_processor_cx current_cx_state;
 struct powerdomain *mpu_pd, *core_pd, *per_pd;
 
+/* Gate long latency C states for 60 seconds to reduce boot time */
+static unsigned int __initdata boot_noidle_time = 60;
+
+/* Command line override to allow matching with application start time */
+static int __init boot_noidle_time_setup(char *str)
+{
+	get_option(&str, &boot_noidle_time);
+	return 1;
+}
+__setup("boot_noidle_time=", boot_noidle_time_setup);
+
+
+struct timer_list boot_timer;
+static void omap_boot_timer(unsigned long arg)
+{
+	pm_qos_remove_requirement(PM_QOS_CPU_DMA_LATENCY, "idle_delay");
+}
+
 static int omap3_idle_bm_check(void)
 {
 	if (!omap3_can_sleep())
@@ -109,6 +128,9 @@ static int omap3_enter_idle(struct cpuidle_device *dev,
 		if (core_state < PWRDM_POWER_RET)
 			core_state = PWRDM_POWER_RET;
 	}
+	/* Temporarily disable CORE OFF mode */
+	if (core_state < PWRDM_POWER_RET)
+		core_state = PWRDM_POWER_RET;
 
 	pwrdm_set_next_pwrst(mpu_pd, mpu_state);
 	pwrdm_set_next_pwrst(core_pd, core_state);
@@ -183,7 +205,7 @@ void omap_init_power_states(void)
 	omap3_power_states[OMAP3_STATE_C1].sleep_latency = 0;
 	omap3_power_states[OMAP3_STATE_C1].wakeup_latency = 12;
 	omap3_power_states[OMAP3_STATE_C1].threshold = 15;
-	omap3_power_states[OMAP3_STATE_C1].mpu_state = PWRDM_POWER_INACTIVE;
+	omap3_power_states[OMAP3_STATE_C1].mpu_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C1].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C1].flags = CPUIDLE_FLAG_TIME_VALID;
 
@@ -204,18 +226,18 @@ void omap_init_power_states(void)
 	omap3_power_states[OMAP3_STATE_C3].wakeup_latency = 260;
 	omap3_power_states[OMAP3_STATE_C3].threshold = 500;
 	omap3_power_states[OMAP3_STATE_C3].mpu_state = PWRDM_POWER_RET;
-	omap3_power_states[OMAP3_STATE_C3].core_state = PWRDM_POWER_INACTIVE;
+	omap3_power_states[OMAP3_STATE_C3].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C3].flags = CPUIDLE_FLAG_TIME_VALID |
 				CPUIDLE_FLAG_CHECK_BM;
 
 	/* C4 . MPU OFF + Core inactive */
-	omap3_power_states[OMAP3_STATE_C4].valid = 1;
+	omap3_power_states[OMAP3_STATE_C4].valid = 0;
 	omap3_power_states[OMAP3_STATE_C4].type = OMAP3_STATE_C4;
 	omap3_power_states[OMAP3_STATE_C4].sleep_latency = 1600;
 	omap3_power_states[OMAP3_STATE_C4].wakeup_latency = 1850;
 	omap3_power_states[OMAP3_STATE_C4].threshold = 4000;
 	omap3_power_states[OMAP3_STATE_C4].mpu_state = PWRDM_POWER_OFF;
-	omap3_power_states[OMAP3_STATE_C4].core_state = PWRDM_POWER_INACTIVE;
+	omap3_power_states[OMAP3_STATE_C4].core_state = PWRDM_POWER_ON;
 	omap3_power_states[OMAP3_STATE_C4].flags = CPUIDLE_FLAG_TIME_VALID |
 				CPUIDLE_FLAG_CHECK_BM;
 
@@ -231,7 +253,7 @@ void omap_init_power_states(void)
 				CPUIDLE_FLAG_CHECK_BM;
 
 	/* C6 . MPU OFF + Core CSWR */
-	omap3_power_states[OMAP3_STATE_C6].valid = 1;
+	omap3_power_states[OMAP3_STATE_C6].valid = 0;
 	omap3_power_states[OMAP3_STATE_C6].type = OMAP3_STATE_C6;
 	omap3_power_states[OMAP3_STATE_C6].sleep_latency = 1800;
 	omap3_power_states[OMAP3_STATE_C6].wakeup_latency = 4450;
@@ -242,7 +264,7 @@ void omap_init_power_states(void)
 				CPUIDLE_FLAG_CHECK_BM;
 
 	/* C7 . MPU OFF + Core OFF */
-	omap3_power_states[OMAP3_STATE_C7].valid = 1;
+	omap3_power_states[OMAP3_STATE_C7].valid = 0;
 	omap3_power_states[OMAP3_STATE_C7].type = OMAP3_STATE_C7;
 	omap3_power_states[OMAP3_STATE_C7].sleep_latency = 10000;
 	omap3_power_states[OMAP3_STATE_C7].wakeup_latency = 30000;
@@ -271,6 +293,21 @@ int omap3_idle_init(void)
 	struct cpuidle_state *state;
 	struct cpuidle_device *dev;
 
+   /* To speed up boot process, restrict C-State to C0.
+      Below, we set the CPU_DMA_LATENCY to 10, which is
+	   less than the C1 state exit latency. This will ensure
+	   that the cpuidle governor does not transition to C1 or
+	   higher states till the CPU_DMA_LATENCY is relaxed.
+      The CPU_DMA_LATENCY requirement is removed when the
+      boot timer (which is set to 60 secs right now) expires.
+	*/
+	init_timer(&boot_timer);
+	boot_timer.function = omap_boot_timer;
+	boot_timer.data = (unsigned long)NULL;
+	boot_timer.expires = boot_noidle_time * HZ + jiffies;
+	add_timer(&boot_timer);
+	pm_qos_add_requirement(PM_QOS_CPU_DMA_LATENCY, "idle_delay", 10);
+
 	mpu_pd = pwrdm_lookup("mpu_pwrdm");
 	core_pd = pwrdm_lookup("core_pwrdm");
 	per_pd = pwrdm_lookup("per_pwrdm");
diff --git a/arch/arm/mach-omap2/gpmc.c b/arch/arm/mach-omap2/gpmc.c
index 9458869..dd415eb 100644
--- a/arch/arm/mach-omap2/gpmc.c
+++ b/arch/arm/mach-omap2/gpmc.c
@@ -36,10 +36,6 @@
 #define GPMC_ERR_TYPE		0x48
 #define GPMC_CONFIG		0x50
 #define GPMC_STATUS		0x54
-#define GPMC_PREFETCH_CONFIG1	0x1e0
-#define GPMC_PREFETCH_CONFIG2	0x1e4
-#define GPMC_PREFETCH_CONTROL	0x1ec
-#define GPMC_PREFETCH_STATUS	0x1f0
 #define GPMC_ECC_CONFIG		0x1f4
 #define GPMC_ECC_CONTROL	0x1f8
 #define GPMC_ECC_SIZE_CONFIG	0x1fc
@@ -87,19 +83,10 @@ static DEFINE_SPINLOCK(gpmc_mem_lock);
 static unsigned		gpmc_cs_map;
 static struct omap3_gpmc_regs gpmc_context;
 
-static void __iomem *gpmc_base;
+void __iomem *gpmc_base;
 
 static struct clk *gpmc_l3_clk;
 
-static void gpmc_write_reg(int idx, u32 val)
-{
-	__raw_writel(val, gpmc_base + idx);
-}
-
-static u32 gpmc_read_reg(int idx)
-{
-	return __raw_readl(gpmc_base + idx);
-}
 
 void gpmc_cs_write_reg(int cs, int idx, u32 val)
 {
@@ -411,6 +398,18 @@ void gpmc_cs_free(int cs)
 }
 EXPORT_SYMBOL(gpmc_cs_free);
 
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+/*
+ * gpmc_prefetch_init - configures default configuration for prefetch engine
+ */
+static void gpmc_prefetch_init(void)
+{
+	/* Setting the default threshold to 64 */
+	gpmc_write_reg(GPMC_PREFETCH_CONTROL, 0x0);
+	gpmc_write_reg(GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_INIT);
+	gpmc_write_reg(GPMC_PREFETCH_CONFIG2, 0x0);
+}
+#endif
 static void __init gpmc_mem_init(void)
 {
 	int cs;
@@ -475,6 +474,10 @@ void __init gpmc_init(void)
 	l |= (0x02 << 3) | (1 << 0);
 	gpmc_write_reg(GPMC_SYSCONFIG, l);
 
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+	gpmc_prefetch_init();
+	printk(KERN_INFO "GPMC Prefetch is enabled....\n");
+#endif
 	gpmc_mem_init();
 }
 
diff --git a/arch/arm/mach-omap2/mux.c b/arch/arm/mach-omap2/mux.c
index 71f10f8..2c901f7 100644
--- a/arch/arm/mach-omap2/mux.c
+++ b/arch/arm/mach-omap2/mux.c
@@ -458,7 +458,7 @@ MUX_CFG_34XX("AC1_3430_USB3FS_PHY_MM3_TXEN_N", 0x18a,
 MUX_CFG_34XX("AF26_34XX_GPIO0", 0x1e0,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
 MUX_CFG_34XX("AF21_34XX_GPIO8", 0xa16,
-                OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
 MUX_CFG_34XX("AF22_34XX_GPIO9", 0xa18,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
 MUX_CFG_34XX("AG25_34XX_GPIO10", 0xa1a,
@@ -551,11 +551,11 @@ MUX_CFG_34XX("AA21_34XX_GPIO157_OUT", 0x18e,
 MUX_CFG_34XX("W21_34XX_GPIO162", 0x198,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("H18_34XX_GPIO163", 0x19a,
-                OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("H19_34XX_GPIO164_OUT", 0x19c,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
 MUX_CFG_34XX("B23_34XX_GPIO167", 0x130,
-                OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
 MUX_CFG_34XX("J25_34XX_GPIO170", 0x1c6,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
 MUX_CFG_34XX("AC3_34XX_GPIO175", 0x1d0,
@@ -629,17 +629,17 @@ MUX_CFG_34XX("AE13_3430_MMC3_DAT3", 0x5e2,
 
 /* UART1 */
 MUX_CFG_34XX("AA8_34XX_UART1_TX", 0x17c,
-                OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
 MUX_CFG_34XX("Y8_34XX_UART1_RX", 0x182,
-                OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
 MUX_CFG_34XX("AA9_34XX_UART1_RTS", 0x17e,
-                OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
 MUX_CFG_34XX("W8_34XX_UART1_CTS", 0x180,
-                OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT | OMAP34XX_PIN_OFF_WAKEUPENABLE)
 
 /* McSPI */
 MUX_CFG_34XX("AB1_34XX_McSPI1_CS2", 0x1d2,
-                OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT_PULLDOWN)
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT_PULLDOWN)
 
 /* DSI */
 MUX_CFG_34XX("AG22_34XX_DSI_DX0", 0xdc,
@@ -702,10 +702,12 @@ MUX_CFG_34XX("C27_34XX_CAM_PCLK", 0x112,
 		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("C23_34XX_CAM_FLD", 0x114,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+#if !defined(CONFIG_VIDEO_MIPI_INTERFACE)
 MUX_CFG_34XX("AG17_34XX_CAM_D0", 0x116,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
 MUX_CFG_34XX("AH17_34XX_CAM_D1", 0x118,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+#endif
 MUX_CFG_34XX("B24_34XX_CAM_D2", 0x11A,
 		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
 MUX_CFG_34XX("C24_34XX_CAM_D3", 0x11C,
@@ -732,8 +734,72 @@ MUX_CFG_34XX("B23_34XX_CAM_WEN", 0x130,
 		OMAP34XX_MUX_MODE2)
 MUX_CFG_34XX("D25_34XX_CAM_STROBE", 0x132,
 		OMAP34XX_MUX_MODE0)
-MUX_CFG_34XX("K8_34XX_GPMC_WAIT2", 0x0D0,
+MUX_CFG_34XX("K8_34XX_GPMC_WAIT2", 0x0D2,
 		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("H2_34XX_GPMC_A3", 0x07E,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+
+/* MDTV off state */
+MUX_CFG_34XX("F1_34XX_MDTV_INT_OFF", 0x082,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AC3_34XX_MDTV_SIMO_OFF", 0x5DC,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD4_34XX_MDTV_SOMI_OFF", 0x5DE,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD3_34XX_MDTV_CS_OFF", 0x5E0,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AA3_34XX_MDTV_CLK_OFF", 0x5E2,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT)
+/* MDTV on state */
+MUX_CFG_34XX("F1_34XX_MDTV_INT_ON", 0x082,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT_PULLUP)
+MUX_CFG_34XX("AC3_34XX_MDTV_SIMO_ON", 0x5DC,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AD4_34XX_MDTV_SOMI_ON", 0x5DE,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT_PULLUP)
+MUX_CFG_34XX("AD3_34XX_MDTV_CS_ON", 0x5E0,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AA3_34XX_MDTV_CLK_ON", 0x5E2,
+		OMAP34XX_MUX_MODE1 | OMAP34XX_PIN_INPUT_PULLUP)
+/* DSS */
+#ifdef CONFIG_PANEL_HDTV
+MUX_CFG_34XX("AG22_34XX_DSS_DATA0", 0xdc, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH22_34XX_DSS_DATA1", 0xde, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AG23_34XX_DSS_DATA2", 0xe0, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH23_34XX_DSS_DATA3", 0xe2, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AG24_34XX_DSS_DATA4", 0xe4, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+MUX_CFG_34XX("AH24_34XX_DSS_DATA5", 0xe6, 
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_OUTPUT)
+#endif
+
+/* Touch IC state */
+MUX_CFG_34XX("D25_34XX_GPIO109", 0x12a,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_INPUT)
+/* Linear Vib. En state */
+#ifdef CONFIG_VIB_PWM
+MUX_CFG_34XX("AF22_34XX_GPIO9_OUT", 0xa18,
+		OMAP34XX_MUX_MODE4 | OMAP34XX_PIN_OUTPUT)
+#endif
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+	/*MIPI Camra*/
+MUX_CFG_34XX("AG17_34XX_CAM_D0", 0x116,
+		OMAP34XX_MUX_MODE2 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AH17_34XX_CAM_D1", 0x118,
+		OMAP34XX_MUX_MODE2 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD17_34XX_CSI2_DX0", 0x134,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AE18_34XX_CSI2_DY0", 0x136,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AD16_34XX_CSI2_DX1", 0x138,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+MUX_CFG_34XX("AE17_34XX_CSI2_DY1", 0x13A,
+		OMAP34XX_MUX_MODE0 | OMAP34XX_PIN_INPUT)
+#endif/*CONFIG_VIDEO_MIPI_INTERFACE*/
 };
 
 #define OMAP34XX_PINS_SZ	ARRAY_SIZE(omap34xx_pins)
diff --git a/arch/arm/mach-omap2/phoneid.c b/arch/arm/mach-omap2/phoneid.c
new file mode 100644
index 0000000..44ed004
--- /dev/null
+++ b/arch/arm/mach-omap2/phoneid.c
@@ -0,0 +1,66 @@
+/*
+  * Copyright (C) 2007-2009 Motorola, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+  * 02111-1307, USA
+  */
+
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/utsname.h>
+#include <linux/io.h>
+
+
+#define DIE_ID_REG_BASE                 (L4_WK_34XX_PHYS + 0xA000)
+#define DIE_ID_REG_OFFSET            	0x218
+#define DIE_ID_REG_NUM                  4
+
+static int phoneid_proc_show(struct seq_file *m, void *v)
+{
+	unsigned int val[DIE_ID_REG_NUM] = {0}; /* Num of DIE_ID reg = 4 */
+	unsigned int reg;
+	int i;
+
+	reg = (unsigned long)(DIE_ID_REG_BASE + DIE_ID_REG_OFFSET);
+
+	for (i = 0; i < DIE_ID_REG_NUM; i++)
+		val[i] = omap_readl(reg + 4 * i);
+
+	seq_printf(m, "%08x%08x%08x%08x\n", val[3], val[2], val[1], val[0]);
+
+	return 0;
+}
+
+static int phoneid_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, phoneid_proc_show, NULL);
+}
+
+static const struct file_operations phoneid_proc_fops = {
+	.open		= phoneid_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_phoneid_init(void)
+{
+	proc_create("phoneid", 0, NULL, &phoneid_proc_fops);
+	return 0;
+}
+
+module_init(proc_phoneid_init);
diff --git a/arch/arm/mach-omap2/pm.c b/arch/arm/mach-omap2/pm.c
index d07b722..1d1e584 100644
--- a/arch/arm/mach-omap2/pm.c
+++ b/arch/arm/mach-omap2/pm.c
@@ -43,6 +43,7 @@ unsigned short enable_off_mode;
 EXPORT_SYMBOL(enable_off_mode);
 unsigned short voltage_off_while_idle;
 unsigned short wakeup_timer_seconds;
+unsigned int wakeup_timer_nseconds;
 atomic_t sleep_block = ATOMIC_INIT(0);
 
 static ssize_t idle_show(struct kobject *, struct kobj_attribute *, char *);
diff --git a/arch/arm/mach-omap2/pm.h b/arch/arm/mach-omap2/pm.h
index 9e112b3..47a6146 100644
--- a/arch/arm/mach-omap2/pm.h
+++ b/arch/arm/mach-omap2/pm.h
@@ -30,6 +30,7 @@ extern atomic_t sleep_block;
 extern void *omap3_secure_ram_storage;
 
 extern unsigned short wakeup_timer_seconds;
+extern unsigned int wakeup_timer_nseconds;
 extern struct omap_dm_timer *gptimer_wakeup;
 
 #ifdef CONFIG_ARCH_OMAP3
diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 731bf0c..44b7592 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -3,6 +3,8 @@
  *
  * OMAP3 Power Management Routines
  *
+ * Copyright (C) 2009 Motorola Inc.
+ *
  * Copyright (C) 2006-2008 Nokia Corporation
  * Tony Lindgren <tony@atomide.com>
  * Jouni Hogander
@@ -20,6 +22,10 @@
  * published by the Free Software Foundation.
  */
 
+#ifdef CONFIG_PM_VERBOSE
+#define DEBUG
+#endif
+
 #include <linux/pm.h>
 #include <linux/suspend.h>
 #include <linux/interrupt.h>
@@ -60,6 +66,10 @@
 
 static int regset_save_on_suspend;
 
+#ifdef CONFIG_SUSPEND
+static suspend_state_t suspend_state_on;
+#endif
+
 /* Scratchpad offsets */
 #define OMAP343X_TABLE_ADDRESS_OFFSET	   0x31
 #define OMAP343X_TABLE_VALUE_OFFSET	   0x30
@@ -74,8 +84,6 @@ struct power_state {
 	struct list_head node;
 };
 
-static suspend_state_t suspend_state;
-
 static LIST_HEAD(pwrst_list);
 
 static void (*_omap_sram_idle)(u32 *addr, int save_state);
@@ -139,9 +147,9 @@ static void omap3_enable_io_chain(void)
 				       "activation failed.\n");
 				return;
 			}
-			prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN,
-					     WKUP_MOD, PM_WKST);
 		}
+		prm_set_mod_reg_bits(OMAP3430_ST_IO_CHAIN,
+				     WKUP_MOD, PM_WKST);
 	}
 }
 
@@ -213,6 +221,117 @@ static void omap3_save_secure_ram_context(u32 target_mpu_state)
 	}
 }
 
+#ifdef PM_DEBUG_INFO
+
+#define LAST_IDLE_ST_ARR_SIZE 10
+#define POWER_DOM_ARR_SIZE    16
+
+static int flag_sleep_while_idle;
+static int flag_enable_off_mode;
+static int flag_uart_can_sleep;
+static int flag_omap_dma_running;
+static int pwrst_idlest[2] = {0, 0};
+static int fclkst_array[8] = { 0 };
+static int iclkst_array[8][2] = { {0, 0} };
+static int pwrst_counter[POWER_DOM_ARR_SIZE][4] = { {0, 0, 0, 0} };
+static int mpu_core_last_state[LAST_IDLE_ST_ARR_SIZE][2] = { {0, 0} };
+static int modem_sad2d_idle_counter[2][2] = { {0, 0} };
+static char *state_to_str[] = {"OFF", "RET", "INA", " ON"};
+
+static void pwrdm_pre_transition_log(void)
+{
+	/* Read state of global setting before idle */
+	flag_sleep_while_idle = enable_dyn_sleep;
+	flag_enable_off_mode  = enable_off_mode;
+	flag_uart_can_sleep   = omap_uart_can_sleep();
+	flag_omap_dma_running = omap_dma_running();
+
+	/* Read state of modem and sad2d before idle */
+	pwrst_idlest[0] = cm_read_mod_reg(CORE_MOD, CM_IDLEST1);
+
+	/* omap function fclk status */
+	fclkst_array[0] = cm_read_mod_reg(CORE_MOD, CM_FCLKEN1);
+	fclkst_array[1] = cm_read_mod_reg(CORE_MOD, OMAP3430ES2_CM_FCLKEN3);
+	fclkst_array[2] = cm_read_mod_reg(OMAP3430ES2_SGX_MOD, CM_FCLKEN);
+	fclkst_array[3] = cm_read_mod_reg(OMAP3430_CAM_MOD, CM_FCLKEN);
+	fclkst_array[4] = cm_read_mod_reg(OMAP3430_PER_MOD, CM_FCLKEN);
+	fclkst_array[5] = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD, CM_FCLKEN);
+	fclkst_array[6] = cm_read_mod_reg(OMAP3430_DSS_MOD, CM_FCLKEN);
+
+	/* omap iclk status */
+	iclkst_array[0][0] = cm_read_mod_reg(CORE_MOD, CM_ICLKEN1);
+	iclkst_array[0][1] = cm_read_mod_reg(CORE_MOD, CM_AUTOIDLE1);
+	iclkst_array[1][0] = cm_read_mod_reg(CORE_MOD, CM_ICLKEN2);
+	iclkst_array[1][1] = cm_read_mod_reg(CORE_MOD, CM_AUTOIDLE2);
+	iclkst_array[2][0] = cm_read_mod_reg(CORE_MOD, CM_ICLKEN3);
+	iclkst_array[2][1] = cm_read_mod_reg(CORE_MOD, CM_AUTOIDLE3);
+	iclkst_array[3][0] = cm_read_mod_reg(OMAP3430ES2_SGX_MOD, CM_ICLKEN);
+	iclkst_array[3][1] = 0;
+	iclkst_array[4][0] = cm_read_mod_reg(OMAP3430_CAM_MOD, CM_ICLKEN);
+	iclkst_array[4][1] = cm_read_mod_reg(OMAP3430_CAM_MOD, CM_AUTOIDLE);
+	iclkst_array[5][0] = cm_read_mod_reg(OMAP3430_PER_MOD, CM_ICLKEN);
+	iclkst_array[5][1] = cm_read_mod_reg(OMAP3430_PER_MOD, CM_AUTOIDLE);
+	iclkst_array[6][0] = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
+			CM_ICLKEN);
+	iclkst_array[6][1] = cm_read_mod_reg(OMAP3430ES2_USBHOST_MOD,
+			CM_AUTOIDLE);
+	iclkst_array[7][0] = cm_read_mod_reg(OMAP3430_DSS_MOD, CM_ICLKEN);
+	iclkst_array[7][1] = cm_read_mod_reg(OMAP3430_DSS_MOD, CM_AUTOIDLE);
+}
+
+static void pwrdm_post_transition_log(void)
+{
+	int i = 0;
+	int idx = 0;
+	int state;
+	struct power_state *pwrst;
+
+	/* Read the last 10 times MPU+CORE state by sequence */
+	for (i = 0; i < LAST_IDLE_ST_ARR_SIZE-1; i++) {
+		mpu_core_last_state[i][0] = mpu_core_last_state[i+1][0];
+		mpu_core_last_state[i][1] = mpu_core_last_state[i+1][1];
+	}
+	mpu_core_last_state[i][0] = pwrdm_read_prev_pwrst(mpu_pwrdm);
+	mpu_core_last_state[i][1] = pwrdm_read_prev_pwrst(core_pwrdm);
+
+	/* counter of each power domain*/
+	list_for_each_entry(pwrst, &pwrst_list, node) {
+		state = pwrdm_read_prev_pwrst(pwrst->pwrdm);
+		pwrst_counter[idx][state]++;
+		idx++;
+	}
+
+	pwrst_idlest[1] = cm_read_mod_reg(CORE_MOD, CM_IDLEST1);
+
+	/* modem and sad2d states counter */
+	i = !!(pwrst_idlest[0] & 0x80000000);
+	modem_sad2d_idle_counter[0][i]++;
+
+	i = !!(pwrst_idlest[0] & 0x8);
+	modem_sad2d_idle_counter[1][i]++;
+}
+
+#endif /* PM_DEBUG_INFO */
+
+#ifdef CONFIG_SUSPEND
+static void dump_wkst_regs(s16 module, u16 wkst_off, u32 wkst)
+{
+	/* only dump info that wake up from suspend */
+	if (suspend_state_on != PM_SUSPEND_MEM &&
+		suspend_state_on != PM_SUSPEND_STANDBY)
+		return;
+
+	if ((WKUP_MOD == module) && (PM_WKST == wkst_off))
+		pr_debug("Waked up by WKUP. WKST 0x%x\n", wkst);
+	else if ((CORE_MOD == module) && (PM_WKST1 == wkst_off))
+		pr_debug("Waked up by CORE. WKST1 0x%x\n", wkst);
+	else if ((CORE_MOD == module) && (OMAP3430ES2_PM_WKST3 == wkst_off))
+		pr_debug("Waked up by CORE. WKST3 0x%x)\n", wkst);
+	else if ((OMAP3430_PER_MOD == module) && (PM_WKST == wkst_off))
+		pr_debug("Waked up by PER. WKST 0x%x)\n", wkst);
+}
+#endif /* CONFIG_SUSPEND */
+
 /*
  * PRCM Interrupt Handler Helper Function
  *
@@ -235,6 +354,9 @@ static void prcm_clear_mod_irqs(s16 module, u8 regs)
 	wkst = prm_read_mod_reg(module, wkst_off);
 	wkst &= prm_read_mod_reg(module, grpsel_off);
 	if (wkst) {
+#ifdef CONFIG_SUSPEND
+		dump_wkst_regs(module, wkst_off, wkst);
+#endif
 		iclk = cm_read_mod_reg(module, iclk_off);
 		fclk = cm_read_mod_reg(module, fclk_off);
 		while (wkst) {
@@ -322,9 +444,6 @@ static void restore_table_entry(void)
 	restore_control_register(control_reg_value);
 }
 
-extern int omap_wdt_suspend(void);
-extern int omap_wdt_resume(void);
-
 void omap_sram_idle(void)
 {
 	/* Variable to tell what needs to be saved and restored
@@ -344,10 +463,6 @@ void omap_sram_idle(void)
 	if (!_omap_sram_idle)
 		return;
 
-	/* Disable watchdog when going into suspend */
-	if (regset_save_on_suspend)
-		omap_wdt_suspend();
-
 	pwrdm_clear_all_prev_pwrst(mpu_pwrdm);
 	pwrdm_clear_all_prev_pwrst(neon_pwrdm);
 	pwrdm_clear_all_prev_pwrst(core_pwrdm);
@@ -369,6 +484,9 @@ void omap_sram_idle(void)
 		return;
 	}
 
+#ifdef PM_DEBUG_INFO
+	pwrdm_pre_transition_log();
+#endif
 	pwrdm_pre_transition();
 
 	/* NEON control */
@@ -395,7 +513,8 @@ void omap_sram_idle(void)
 		omap2_clkdm_deny_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 
 	/* CORE */
-	if (core_next_state < PWRDM_POWER_ON) {
+	if (core_next_state < PWRDM_POWER_ON ||
+		mpu_next_state < PWRDM_POWER_ON) {
 		/* Disable smartreflex before entering WFI */
 		disable_smartreflex(SR1);
 		disable_smartreflex(SR2);
@@ -447,7 +566,8 @@ void omap_sram_idle(void)
 
 
 	/* CORE */
-	if (core_next_state < PWRDM_POWER_ON) {
+	if (core_next_state < PWRDM_POWER_ON ||
+		mpu_next_state < PWRDM_POWER_ON) {
 		core_prev_state = pwrdm_read_prev_pwrst(core_pwrdm);
 		if (core_prev_state == PWRDM_POWER_OFF) {
 			omap3_core_restore_context();
@@ -481,16 +601,17 @@ void omap_sram_idle(void)
 	}
 
 	/* Disable IO-PAD and IO-CHAIN wakeup */
-	if (core_next_state < PWRDM_POWER_ON) {
+	if (core_next_state < PWRDM_POWER_ON ||
+		mpu_next_state < PWRDM_POWER_ON) {
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO, WKUP_MOD, PM_WKEN);
 		omap3_disable_io_chain();
 	}
 
 
 	pwrdm_post_transition();
-
-	if (regset_save_on_suspend)
-		omap_wdt_resume();
+#ifdef PM_DEBUG_INFO
+	pwrdm_post_transition_log();
+#endif
 
 	omap2_clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
@@ -503,6 +624,7 @@ int omap3_can_sleep(void)
 		return 0;
 	if (atomic_read(&sleep_block) > 0)
 		return 0;
+
 	return 1;
 }
 
@@ -571,20 +693,44 @@ out:
 
 #ifdef CONFIG_SUSPEND
 static void (*saved_idle)(void);
+static suspend_state_t suspend_state;
 
-static void omap2_pm_wakeup_on_timer(u32 seconds)
+static void omap2_pm_wakeup_on_timer(u32 seconds, u32 nseconds)
 {
 	u32 tick_rate, cycles;
-
-	if (!seconds)
-		return;
+	void __iomem *base;
+	u32 cnt = 10;
 
 	tick_rate = clk_get_rate(omap_dm_timer_get_fclk(gptimer_wakeup));
 	cycles = tick_rate * seconds;
+	cycles += ((nseconds / NSEC_PER_MSEC) * tick_rate) / MSEC_PER_SEC;
 	omap_dm_timer_stop(gptimer_wakeup);
+
+	/* Cleared pending gpt1 irq if there is. */
+	if (omap_dm_timer_read_status(gptimer_wakeup) & OMAP_TIMER_INT_OVERFLOW)
+		omap_dm_timer_write_status(gptimer_wakeup,
+				OMAP_TIMER_INT_OVERFLOW);
+
+	/* Make sure the intc pending irq37 is automatically cleared. */
+	base = OMAP2_IO_ADDRESS(OMAP34XX_IC_BASE);
+	while ((__raw_readl(base + 0x00B8) & 0x20) == 0x20 && cnt) {
+		udelay(1000000/tick_rate + 1);
+		cnt--;
+	}
+
+	/* If the INTC gpt1 signal to MPU is still there, then finally
+	 * refresh the IRQ INTC ouput to make sure it will not break wfi.
+	 */
+	if ((__raw_readl(base + 0x40) & 0x7F) == INT_24XX_GPTIMER1)
+		__raw_writel(0x1, base + 0x0048);
+
+	/* Not to start the timer again in airplane mode or no SIM insert */
+	if (!seconds && !nseconds)
+		return;
+
 	omap_dm_timer_set_load_start(gptimer_wakeup, 0, 0xffffffff - cycles);
 
-	pr_info("PM: Resume timer in %d secs (%d ticks at %d ticks/sec.)\n",
+	pr_debug("PM: Resume timer in %d secs (%d ticks at %d ticks/sec.)\n",
 		seconds, cycles, tick_rate);
 }
 
@@ -600,8 +746,7 @@ static int omap3_pm_suspend(void)
 	struct power_state *pwrst;
 	int state, ret = 0;
 
-	if (wakeup_timer_seconds)
-		omap2_pm_wakeup_on_timer(wakeup_timer_seconds);
+	omap2_pm_wakeup_on_timer(wakeup_timer_seconds, wakeup_timer_nseconds);
 
 	/* Read current next_pwrsts */
 	list_for_each_entry(pwrst, &pwrst_list, node)
@@ -635,7 +780,7 @@ restore:
 	if (ret)
 		printk(KERN_ERR "Could not enter target state in pm_suspend\n");
 	else
-		printk(KERN_INFO "Successfully put all powerdomains "
+		pr_debug(KERN_INFO "Successfully put all powerdomains "
 		       "to target state\n");
 
 	return ret;
@@ -667,6 +812,7 @@ static int omap3_pm_begin(suspend_state_t state)
 {
 	suspend_state = state;
 	omap_uart_enable_irqs(0);
+	suspend_state_on = suspend_state;
 	return 0;
 }
 
@@ -674,6 +820,7 @@ static void omap3_pm_end(void)
 {
 	suspend_state = PM_SUSPEND_ON;
 	omap_uart_enable_irqs(1);
+	suspend_state_on = suspend_state;
 	return;
 }
 
@@ -737,12 +884,6 @@ static void __init omap3_iva_idle(void)
 
 static void __init prcm_setup_regs(void)
 {
-	/* reset modem */
-	prm_write_mod_reg(OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON |
-			  OMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST,
-			  CORE_MOD, RM_RSTCTRL);
-	prm_write_mod_reg(0, CORE_MOD, RM_RSTCTRL);
-
 	/* XXX Reset all wkdeps. This should be done when initializing
 	 * powerdomains */
 	prm_write_mod_reg(0, OMAP3430_IVA2_MOD, PM_WKDEP);
@@ -795,6 +936,11 @@ static void __init prcm_setup_regs(void)
 		OMAP3430_AUTO_SSI,
 		CORE_MOD, CM_AUTOIDLE1);
 
+	prm_rmw_mod_reg_bits(0x80000008,
+		0,
+		CORE_MOD,
+		OMAP3430_PM_MPUGRPSEL1);
+
 	cm_write_mod_reg(
 		OMAP3430_AUTO_PKA |
 		OMAP3430_AUTO_AES1 |
@@ -917,6 +1063,12 @@ static void __init prcm_setup_regs(void)
 	/* Clear any pending PRCM interrupts */
 	prm_write_mod_reg(0, OCP_MOD, OMAP2_PRM_IRQSTATUS_MPU_OFFSET);
 
+	/* Initialize Domains PREPWSTST to ON */
+	pwrdm_clear_all_prev_pwrst(mpu_pwrdm);
+	pwrdm_clear_all_prev_pwrst(neon_pwrdm);
+	pwrdm_clear_all_prev_pwrst(core_pwrdm);
+	pwrdm_clear_all_prev_pwrst(per_pwrdm);
+
 	omap3_iva_idle();
 }
 
@@ -940,6 +1092,16 @@ void omap3_pm_off_mode_enable(int enable)
 #endif
 	list_for_each_entry(pwrst, &pwrst_list, node) {
 		pwrst->next_state = state;
+		/* Temporarily disable PER OFF mode*/
+		if (!strcmp(pwrst->pwrdm->name, "per_pwrdm"))
+			pwrst->next_state = PWRDM_POWER_RET;
+		/* Temporarily disable DSS OFF mode*/
+		if (!strcmp(pwrst->pwrdm->name, "dss_pwrdm"))
+			pwrst->next_state = PWRDM_POWER_RET;
+		/* Temporarily disable CORE OFF mode*/
+		if (!strcmp(pwrst->pwrdm->name, "core_pwrdm"))
+			pwrst->next_state = PWRDM_POWER_RET;
+
 		set_pwrdm_state(pwrst->pwrdm, state);
 	}
 }
@@ -1034,6 +1196,106 @@ void omap_push_sram_idle(void)
 				save_secure_ram_context_sz);
 }
 
+#ifdef PM_DEBUG_INFO
+static ssize_t pm_info_show(struct kobject *kobj, struct kobj_attribute *attr,
+		char *buf)
+{
+	int i = 0;
+	int len = 0;
+	int idx = 0;
+	struct power_state *pwrst;
+
+	len += sprintf(buf + len, "*************** PM info ****************\n");
+	len += sprintf(buf + len, "sleep_while_idle:    %s\n",
+			flag_sleep_while_idle ? "Enabled" : "Disabled");
+	len += sprintf(buf + len, "enable_off_mode:     %s\n",
+			flag_enable_off_mode ? "Enabled" : "Disabled");
+	len += sprintf(buf + len, "omap_uart_can_sleep: %s\n",
+			flag_uart_can_sleep ? "YES" : "NO");
+	len += sprintf(buf + len, "dma status check:    %s\n",
+			flag_omap_dma_running ? "Running" : "Not Running");
+
+	/* last 10 timers power domain status */
+	len += sprintf(buf + len, "\nLast 10 times state (MPU+CORE):\n");
+	for (i = 0; i < LAST_IDLE_ST_ARR_SIZE; i++) {
+		len += sprintf(buf + len, "#%d. MPU: %s CORE: %s\n",
+			i, state_to_str[mpu_core_last_state[i][0]],
+			state_to_str[mpu_core_last_state[i][1]]);
+	}
+
+	/* counter of each power domain*/
+	len += sprintf(buf + len, "\nPowerdomains state statistic:\n");
+	list_for_each_entry(pwrst, &pwrst_list, node) {
+		len += sprintf(buf + len, "%s: OFF: %d RET: %d "
+				"INA: %d ON: %d\n",
+				pwrst->pwrdm->name,
+				pwrst_counter[idx][PWRDM_POWER_OFF],
+				pwrst_counter[idx][PWRDM_POWER_RET],
+				pwrst_counter[idx][PWRDM_POWER_INACTIVE],
+				pwrst_counter[idx][PWRDM_POWER_ON]);
+		idx++;
+	}
+
+	/* modem and sad2d latest idle states */
+	len += sprintf(buf + len, "\nModem & sad2d Last idle state:\n");
+	len += sprintf(buf + len, "Before LPM: modem %s, sad2d %s\n",
+			(pwrst_idlest[0] & 0x80000000) ? "idle" : "active",
+			(pwrst_idlest[0] & 0x00000008) ? "idle" : "active");
+
+	len += sprintf(buf + len, "After  LPM: modem %s, sad2d %s\n",
+			(pwrst_idlest[1] & 0x80000000) ? "idle" : "active",
+			(pwrst_idlest[1] & 0x00000008) ? "idle" : "active");
+
+	/* modem and sad2d idle statistic */
+	len += sprintf(buf + len, "\nModem & sad2d states statistic:\n");
+	len += sprintf(buf + len, "modem: idle: %d, active: %d\n",
+			modem_sad2d_idle_counter[0][1],
+			modem_sad2d_idle_counter[0][0]);
+	len += sprintf(buf + len, "sad2d: idle: %d, active: %d\n",
+			modem_sad2d_idle_counter[1][1],
+			modem_sad2d_idle_counter[1][0]);
+
+	/* omap function fclk status */
+	len += sprintf(buf + len, "\nOmap fclk checking: Before LPM\n");
+	len += sprintf(buf + len, "CM_FCLKEN1_CORE   0x%x\n", fclkst_array[0]);
+	len += sprintf(buf + len, "CM_FCLKEN3_CORE   0x%x\n", fclkst_array[1]);
+	len += sprintf(buf + len, "CM_FCLKEN_SGX     0x%x\n", fclkst_array[2]);
+	len += sprintf(buf + len, "CM_FCLKEN_CAM     0x%x\n", fclkst_array[3]);
+	len += sprintf(buf + len, "CM_FCLKEN_PER     0x%x\n", fclkst_array[4]);
+	len += sprintf(buf + len, "CM_FCLKEN_USBHOST 0x%x\n", fclkst_array[5]);
+	len += sprintf(buf + len, "CM_FCLKEN_DSS     0x%x\n", fclkst_array[6]);
+
+	len += sprintf(buf + len, "\nOmap iclk checking:  Before LPM\n");
+
+	/* omap function iclk status */
+	len += sprintf(buf + len, "CM_ICLKEN1_CORE   0x%x, CM_AUTOIDLE1 0x%x\n",
+			iclkst_array[0][0], iclkst_array[0][1]);
+	len += sprintf(buf + len, "CM_ICLKEN2_CORE   0x%x, CM_AUTOIDLE2 0x%x\n",
+			iclkst_array[1][0], iclkst_array[1][1]);
+	len += sprintf(buf + len, "CM_ICLKEN3_CORE   0x%x, CM_AUTOIDLE3 0x%x\n",
+			iclkst_array[2][0], iclkst_array[2][1]);
+	len += sprintf(buf + len, "CM_ICLKEN_SGX     0x%x\n",
+			iclkst_array[3][0]);
+	len += sprintf(buf + len, "CM_ICLKEN_CAM     0x%x, CM_AUTOIDLE 0x%x\n",
+			iclkst_array[4][0], iclkst_array[4][1]);
+	len += sprintf(buf + len, "CM_ICLKEN_PER     0x%x, CM_AUTOIDLE 0x%x\n",
+			iclkst_array[5][0], iclkst_array[5][1]);
+	len += sprintf(buf + len, "CM_ICLKEN_USBHOST 0x%x, CM_AUTOIDLE 0x%x\n",
+			iclkst_array[6][0], iclkst_array[6][1]);
+	len += sprintf(buf + len, "CM_ICLKEN_DSS     0x%x, CM_AUTOIDLE 0x%x\n",
+			iclkst_array[7][0], iclkst_array[7][1]);
+
+	len += sprintf(buf + len, "\n************ PM info End ************\n");
+
+	WARN_ON(len > PAGE_SIZE);
+	return len;
+}
+
+static struct kobj_attribute pm_info_attr =
+__ATTR(pm_info, 0444, pm_info_show, NULL);
+
+#endif /* PM_DEBUG_INFO */
+
 #ifdef CONFIG_OMAP_PM_SRF
 static void set_opps_max(void)
 {
@@ -1134,7 +1396,7 @@ int __init omap3_pm_init(void)
 	 * waking up PER with every CORE wakeup - see
 	 * http://marc.info/?l=linux-omap&m=121852150710062&w=2
 	*/
-	pwrdm_add_wkdep(per_pwrdm, core_pwrdm);
+	/*pwrdm_add_wkdep(per_pwrdm, core_pwrdm);*/
 	/*
 	 * A part of the fix for errata 1.158.
 	 * GPIO pad spurious transition (glitch/spike) upon wakeup
@@ -1162,6 +1424,11 @@ int __init omap3_pm_init(void)
 		local_fiq_enable();
 	}
 
+#ifdef PM_DEBUG_INFO
+	if (sysfs_create_file(power_kobj, &pm_info_attr.attr))
+		printk(KERN_ERR "sysfs_create_file failed: pm_info\n");
+#endif
+
 	omap3_save_scratchpad_contents();
 	register_reboot_notifier(&prcm_notifier);
 	atomic_notifier_chain_register(&panic_notifier_list,
diff --git a/arch/arm/mach-omap2/powerdomain.c b/arch/arm/mach-omap2/powerdomain.c
index 7aa64a8..b43c4ee 100644
--- a/arch/arm/mach-omap2/powerdomain.c
+++ b/arch/arm/mach-omap2/powerdomain.c
@@ -1064,10 +1064,10 @@ int pwrdm_clear_all_prev_pwrst(struct powerdomain *pwrdm)
 	 * warn & fail if it is not ON.
 	 */
 
-	pr_debug("powerdomain: clearing previous power state reg for %s\n",
+	pr_debug("powerdomain: clearing previous power state to ON for %s\n",
 		 pwrdm->name);
 
-	prm_write_mod_reg(0, pwrdm->prcm_offs, OMAP3430_PM_PREPWSTST);
+	prm_write_mod_reg(0xFF, pwrdm->prcm_offs, OMAP3430_PM_PREPWSTST);
 
 	return 0;
 }
diff --git a/arch/arm/mach-omap2/powerdomains34xx.h b/arch/arm/mach-omap2/powerdomains34xx.h
index 87e8111..0c30799 100644
--- a/arch/arm/mach-omap2/powerdomains34xx.h
+++ b/arch/arm/mach-omap2/powerdomains34xx.h
@@ -224,7 +224,7 @@ static struct powerdomain core_34xx_es3_1_pwrdm = {
 	.name		  = "core_pwrdm",
 	.prcm_offs	  = CORE_MOD,
 	.omap_chip	  = OMAP_CHIP_INIT(CHIP_GE_OMAP3430ES3_1),
-	.pwrsts		  = PWRSTS_OFF_RET_ON,
+	.pwrsts		  = PWRSTS_RET_ON,/*Temporarily disable OFF*/
 	.dep_bit	  = OMAP3430_EN_CORE_SHIFT,
 	.flags		  = PWRDM_HAS_HDWR_SAR, /* for USBTLL only */
 	.banks		  = 2,
@@ -246,7 +246,7 @@ static struct powerdomain dss_pwrdm = {
 	.dep_bit	  = OMAP3430_PM_WKDEP_MPU_EN_DSS_SHIFT,
 	.wkdep_srcs	  = cam_dss_wkdeps,
 	.sleepdep_srcs	  = dss_per_usbhost_sleepdeps,
-	.pwrsts		  = PWRSTS_OFF_RET_ON,
+	.pwrsts		  = PWRSTS_RET_ON,/*Temporarily disable OFF*/
 	.pwrsts_logic_ret = PWRDM_POWER_RET,
 	.banks		  = 1,
 	.pwrsts_mem_ret	  = {
@@ -304,7 +304,7 @@ static struct powerdomain per_pwrdm = {
 	.dep_bit	  = OMAP3430_EN_PER_SHIFT,
 	.wkdep_srcs	  = per_usbhost_wkdeps,
 	.sleepdep_srcs	  = dss_per_usbhost_sleepdeps,
-	.pwrsts		  = PWRSTS_OFF_RET_ON,
+	.pwrsts		  = PWRSTS_RET_ON,/*Temporarily disable OFF*/
 	.pwrsts_logic_ret = PWRSTS_OFF_RET,
 	.banks		  = 1,
 	.pwrsts_mem_ret	  = {
diff --git a/arch/arm/mach-omap2/prcm.c b/arch/arm/mach-omap2/prcm.c
index 86c3fe3..a3f2ed0 100644
--- a/arch/arm/mach-omap2/prcm.c
+++ b/arch/arm/mach-omap2/prcm.c
@@ -147,7 +147,7 @@ void omap_prcm_arch_reset(char mode)
 	} else
 		WARN_ON(1);
 
-#ifdef CONFIG_MACH_SHOLES
+#if defined(CONFIG_MACH_SHOLES) || defined(CONFIG_MACH_MAPPHONE)
 	prm_set_mod_reg_bits(OMAP_RST_GS, prcm_offs, RM_RSTCTRL);
 #else
 	prm_set_mod_reg_bits(OMAP_RST_DPLL3, prcm_offs, RM_RSTCTRL);
diff --git a/arch/arm/mach-omap2/resource34xx.c b/arch/arm/mach-omap2/resource34xx.c
index 68616f0..20b5edd 100644
--- a/arch/arm/mach-omap2/resource34xx.c
+++ b/arch/arm/mach-omap2/resource34xx.c
@@ -19,6 +19,7 @@
 #include <linux/pm_qos_params.h>
 #include <linux/cpufreq.h>
 #include <linux/delay.h>
+#include <linux/spinlock.h>
 #include <mach/powerdomain.h>
 #include <mach/clockdomain.h>
 #include <mach/control.h>
@@ -29,6 +30,8 @@
 #include "cm.h"
 #include "cm-regbits-34xx.h"
 
+static DEFINE_SPINLOCK(dpll3_clock_lock);
+
 /**
  * init_latency - Initializes the mpu/core latency resource.
  * @resp: Latency resource to be initalized
@@ -237,8 +240,8 @@ static int program_opp_freq(int res, int target_level, int current_level)
 {
 	int ret = 0, l3_div;
 	int *curr_opp;
+	unsigned long flags;
 
-	lock_scratchpad_sem();
 	if (res == VDD1_OPP) {
 		curr_opp = &curr_vdd1_opp;
 		clk_set_rate(dpll1_clk, mpu_opps[target_level].rate);
@@ -249,21 +252,28 @@ static int program_opp_freq(int res, int target_level, int current_level)
 			mpu_opps[current_level].rate/1000,
 			mpu_opps[target_level].rate/1000);
 #endif
+#ifdef CONFIG_PM
+		omap3_save_scratchpad_contents();
+#endif
 	} else {
 		curr_opp = &curr_vdd2_opp;
 		l3_div = cm_read_mod_reg(CORE_MOD, CM_CLKSEL) &
 			OMAP3430_CLKSEL_L3_MASK;
+
+		spin_lock_irqsave(&dpll3_clock_lock, flags);
+		lock_scratchpad_sem();
 		ret = clk_set_rate(dpll3_clk,
 				l3_opps[target_level].rate * l3_div);
+#ifdef CONFIG_PM
+		if (!ret)
+			omap3_save_scratchpad_contents();
+#endif
+		unlock_scratchpad_sem();
+		spin_unlock_irqrestore(&dpll3_clock_lock, flags);
 	}
 	if (ret) {
-		unlock_scratchpad_sem();
 		return current_level;
 	}
-#ifdef CONFIG_PM
-	omap3_save_scratchpad_contents();
-#endif
-	unlock_scratchpad_sem();
 
 	*curr_opp = target_level;
 	return target_level;
@@ -363,7 +373,7 @@ int set_opp(struct shared_resource *resp, u32 target_level)
 
 	if (resp == vdd1_resp) {
 		if (target_level < 3)
-			resource_release("vdd2_opp", &vdd2_dev);
+			_resource_release(vdd2_resp, &vdd2_dev);
 
 		resource_set_opp_level(VDD1_OPP, target_level, 0);
 		/*
@@ -372,7 +382,7 @@ int set_opp(struct shared_resource *resp, u32 target_level)
 		 * throughput in KiB/s for 100 Mhz = 100 * 1000 * 4.
 		 */
 		if (target_level >= 3)
-			resource_request("vdd2_opp", &vdd2_dev, 400000);
+			_resource_request(vdd2_resp, &vdd2_dev, 400000);
 
 	} else if (resp == vdd2_resp) {
 		tput = target_level;
@@ -438,10 +448,10 @@ int set_freq(struct shared_resource *resp, u32 target_level)
 
 	if (strcmp(resp->name, "mpu_freq") == 0) {
 		vdd1_opp = get_opp(mpu_opps + MAX_VDD1_OPP, target_level);
-		resource_request("vdd1_opp", &dummy_mpu_dev, vdd1_opp);
+		_resource_request(vdd1_resp, &dummy_mpu_dev, vdd1_opp);
 	} else if (strcmp(resp->name, "dsp_freq") == 0) {
 		vdd1_opp = get_opp(dsp_opps + MAX_VDD1_OPP, target_level);
-		resource_request("vdd1_opp", &dummy_dsp_dev, vdd1_opp);
+		_resource_request(vdd1_resp, &dummy_dsp_dev, vdd1_opp);
 	}
 	resp->curr_level = target_level;
 	return 0;
diff --git a/arch/arm/mach-omap2/resource34xx.h b/arch/arm/mach-omap2/resource34xx.h
index 5b5618a..b43e737 100644
--- a/arch/arm/mach-omap2/resource34xx.h
+++ b/arch/arm/mach-omap2/resource34xx.h
@@ -31,6 +31,9 @@
 extern int sr_voltagescale_vcbypass(u32 t_opp, u32 c_opp, u8 t_vsel, u8 c_vsel);
 extern void lock_scratchpad_sem();
 extern void unlock_scratchpad_sem();
+extern int _resource_request(struct shared_resource *resp, struct device *dev,
+unsigned long level);
+extern int _resource_release(struct shared_resource *resp, struct device *dev);
 
 /*
  * mpu_latency/core_latency are used to control the cpuidle C state.
diff --git a/arch/arm/mach-omap2/sdram-toshiba-hynix-numonyx.h b/arch/arm/mach-omap2/sdram-toshiba-hynix-numonyx.h
index e8f34c0..4273aaf 100644
--- a/arch/arm/mach-omap2/sdram-toshiba-hynix-numonyx.h
+++ b/arch/arm/mach-omap2/sdram-toshiba-hynix-numonyx.h
@@ -15,17 +15,17 @@
 
 static struct omap_sdrc_params JEDEC_JESD209A_sdrc_params[] = {
     [0] = {
-        .rate        = 160500000,
+		.rate        = 160000000,
         .actim_ctrla = 0xBA9DB4C6,
-        .actim_ctrlb = 0x00022221,
-        .rfr_ctrl    = 0x0004B902,
+		.actim_ctrlb = 0x00022220,
+		.rfr_ctrl    = 0x0004AE02,
         .mr		     = 0x00000032,
     },
     [1] = {
-        .rate        = 80250000,
+		.rate        = 80000000,
         .actim_ctrla = 0x49512284,
         .actim_ctrlb = 0x0001120C,
-        .rfr_ctrl    = 0x23F02,
+		.rfr_ctrl    = 0x23E02,
         .mr		     = 0x00000032,
     },
     [2] = {
diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
index 98cd2f8..fa57f08 100755
--- a/arch/arm/mach-omap2/serial.c
+++ b/arch/arm/mach-omap2/serial.c
@@ -4,6 +4,7 @@
  * OMAP2 serial support.
  *
  * Copyright (C) 2005-2008 Nokia Corporation
+ * Copyright (C) 2009 Motorola, Inc.
  * Author: Paul Mundt <paul.mundt@nokia.com>
  *
  * Major rework for PM support by Kevin Hilman
@@ -38,7 +39,7 @@
 #include "pm.h"
 #include "prm-regbits-34xx.h"
 
-#define DEFAULT_TIMEOUT (HZ / 2)
+#define DEFAULT_TIMEOUT HZ
 
 struct omap_uart_state {
 	int num;
@@ -59,7 +60,7 @@ struct omap_uart_state {
 	struct clk *fck;
 	int clocked;
 
-        struct plat_serialomap_port *p;
+	struct plat_serialomap_port *p;
 	struct list_head node;
 
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
@@ -77,7 +78,7 @@ struct omap_uart_state {
 
 static struct omap_uart_state omap_uart[OMAP_MAX_NR_PORTS];
 static LIST_HEAD(uart_list);
-static unsigned int fifo_idleblks = 0;
+static unsigned int fifo_idleblks;
 
 #ifdef CONFIG_SERIAL_OMAP
 static struct plat_serialomap_port serial_platform_data[] = {
@@ -85,18 +86,27 @@ static struct plat_serialomap_port serial_platform_data[] = {
 		.membase	= IO_ADDRESS(OMAP_UART1_BASE),
 		.irq		= 72,
 		.regshift	= 2,
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+		.rtscts		= SERIALOMAP_AUTO_RTS,
+#endif
 		.flags		= UPF_BOOT_AUTOCONF,
 	},
 	{
 		.membase	= IO_ADDRESS(OMAP_UART2_BASE),
 		.irq		= 73,
 		.regshift	= 2,
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+		.rtscts		= SERIALOMAP_AUTO_RTS | SERIALOMAP_AUTO_CTS,
+#endif
 		.flags		= UPF_BOOT_AUTOCONF,
 	},
 	{
 		.membase	= IO_ADDRESS(OMAP_UART3_BASE),
 		.irq		= 74,
 		.regshift	= 2,
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+		.rtscts		= SERIALOMAP_AUTO_RTS,
+#endif
 		.flags		= UPF_BOOT_AUTOCONF,
 	},
 };
@@ -237,7 +247,9 @@ static void omap_uart_save_context(struct omap_uart_state *uart)
 	u16 lcr = 0;
 	struct plat_serialomap_port *p = uart->p;
 
-	if (!enable_off_mode)
+	/* Due to TI errata for OFF mode, we don't allow
+	*  CORE and PER to enter OFF mode */
+	if ((!enable_off_mode) || (omap_rev() <= OMAP3430_REV_ES3_1))
 		return;
 
 	lcr = serial_read_reg(p, UART_LCR);
@@ -258,7 +270,9 @@ static void omap_uart_restore_context(struct omap_uart_state *uart)
 	u16 efr = 0;
 	struct plat_serialomap_port *p = uart->p;
 
-	if (!enable_off_mode)
+	/* Due to TI errata for OFF mode, we don't allow
+	*  CORE and PER to enter OFF mode */
+	if ((!enable_off_mode) || (omap_rev() <= OMAP3430_REV_ES3_1))
 		return;
 
 	if (!uart->context_valid)
@@ -503,7 +517,7 @@ static void omap_uart_rtspad_init(struct omap_uart_state *uart)
 {
 	if (!cpu_is_omap34xx())
 		return;
-	switch(uart->num) {
+	switch (uart->num) {
 	case 0:
 		uart->rts_padconf = 0x17e;
 		break;
diff --git a/arch/arm/mach-omap2/sleep34xx.S b/arch/arm/mach-omap2/sleep34xx.S
index 1fbf3e0..068c1e4 100644
--- a/arch/arm/mach-omap2/sleep34xx.S
+++ b/arch/arm/mach-omap2/sleep34xx.S
@@ -291,13 +291,13 @@ restore:
 l2_inv_api_params:
 	.word   0x1, 0x00
 write_aux_control_params:
-	.word   0x1, 0x72
+	.word   0x1, 0xe2
 l2_inv_gp:
 	/* Execute smi to invalidate L2 cache */
 	mov r12, #0x1                         @ set up to invalide L2
 smi:    .word 0xE1600070		@ Call SMI monitor (smieq)
 	/* Write to Aux control register to set some bits */
-	mov	r0, #0x72
+	mov	r0, #0xe2
 	mov	r12, #0x3
 	.word 0xE1600070	@ Call SMI monitor (smieq)
 logic_l1_restore:
diff --git a/arch/arm/mach-omap2/smartreflex.c b/arch/arm/mach-omap2/smartreflex.c
index 15e8e14..448b078 100644
--- a/arch/arm/mach-omap2/smartreflex.c
+++ b/arch/arm/mach-omap2/smartreflex.c
@@ -50,13 +50,10 @@ struct omap_sr {
 	u32		senp_mod, senn_mod;
 	void __iomem	*srbase_addr;
 	void __iomem	*vpbase_addr;
-	u32		starting_ret_volt;
 };
 
 #define SR_REGADDR(offs)	(sr->srbase_addr + offset)
 
-static struct clk *dpll1_ck, *l3_ick;
-
 static omap3_voltagescale_vcbypass_t omap3_volscale_vcbypass_fun;
 
 static inline void sr_write_reg(struct omap_sr *sr, unsigned offset, u32 value)
@@ -172,14 +169,32 @@ static u16 get_opp(struct omap_opp *opp_freq_table,
 	return (prcm_config+1)->opp_id;
 }
 
-static inline u16 get_vdd1_opp(void)
+static u16 get_vdd1_opp(void)
 {
-	return get_opp(mpu_opps + MAX_VDD1_OPP, dpll1_ck->rate);
+	u16 opp;
+	struct clk *clk;
+
+	clk = clk_get(NULL, "dpll1_ck");
+
+	if (clk == NULL || IS_ERR(clk) || mpu_opps == NULL)
+		return 0;
+
+	opp = get_opp(mpu_opps + MAX_VDD1_OPP, clk->rate);
+	return opp;
 }
 
-static inline u16 get_vdd2_opp(void)
+static u16 get_vdd2_opp(void)
 {
-	return get_opp(l3_opps + MAX_VDD2_OPP, l3_ick->rate);
+	u16 opp;
+	struct clk *clk;
+
+	clk = clk_get(NULL, "l3_ick");
+
+	if (clk == NULL || IS_ERR(clk) || l3_opps == NULL)
+		return 0;
+
+	opp = get_opp(l3_opps + MAX_VDD2_OPP, clk->rate);
+	return opp;
 }
 
 
@@ -561,10 +576,8 @@ static int sr_enable(struct omap_sr *sr, u32 target_opp_no)
 
 	/* Enable the interrupt */
 	sr_modify_reg(sr, ERRCONFIG,
-			(ERRCONFIG_VPBOUNDINTEN | ERRCONFIG_VPBOUNDINTST |
-			ERRCONFIG_MCUBOUNDINTEN | ERRCONFIG_MCUBOUNDINTST),
-			(ERRCONFIG_VPBOUNDINTEN | ERRCONFIG_VPBOUNDINTST |
-			ERRCONFIG_MCUBOUNDINTEN | ERRCONFIG_MCUBOUNDINTST));
+			(ERRCONFIG_VPBOUNDINTEN | ERRCONFIG_VPBOUNDINTST),
+			(ERRCONFIG_VPBOUNDINTEN | ERRCONFIG_VPBOUNDINTST));
 
 	if (sr->srid == SR1) {
 		/* set/latch init voltage */
@@ -650,74 +663,6 @@ static void sr_disable(struct omap_sr *sr)
 	}
 }
 
-static void change_ret_volt(struct omap_sr *sr, u32 val)
-{
-	u32 prm_vc_cmd_val = 0;
-	if (sr == &sr1) {
-		prm_vc_cmd_val = prm_read_mod_reg(OMAP3430_GR_MOD,
-					OMAP3_PRM_VC_CMD_VAL_0_OFFSET);
-		prm_write_mod_reg((prm_vc_cmd_val &
-					~OMAP3430_VC_CMD_RET_MASK) |
-				(val << OMAP3430_VC_CMD_RET_SHIFT),
-				OMAP3430_GR_MOD,
-				OMAP3_PRM_VC_CMD_VAL_0_OFFSET);
-	}
-
-	if (sr == &sr2) {
-		prm_vc_cmd_val = prm_read_mod_reg(OMAP3430_GR_MOD,
-					OMAP3_PRM_VC_CMD_VAL_1_OFFSET);
-		prm_write_mod_reg((prm_vc_cmd_val &
-					~OMAP3430_VC_CMD_RET_MASK) |
-				(val << OMAP3430_VC_CMD_RET_SHIFT),
-				OMAP3430_GR_MOD,
-				OMAP3_PRM_VC_CMD_VAL_1_OFFSET);
-	}
-
-	return;
-}
-
-static void try_change_ret_volt(struct omap_sr *sr, u32 *cmd_volt)
-{
-	u32 vp_volt = 0;
-
-	if (sr != &sr1 && sr != &sr2)
-		return;
-
-	if (sr == &sr1 && get_vdd1_opp() == 1)
-		vp_volt = prm_read_mod_reg(OMAP3430_GR_MOD,
-				OMAP3_PRM_VP1_VOLTAGE_OFFSET);
-
-	if (sr == &sr2 && get_vdd2_opp() == 2)
-		vp_volt = prm_read_mod_reg(OMAP3430_GR_MOD,
-				OMAP3_PRM_VP2_VOLTAGE_OFFSET);
-
-	if (*cmd_volt != vp_volt) {
-		change_ret_volt(sr, vp_volt);
-		*cmd_volt = prm_read_mod_reg(OMAP3430_GR_MOD,
-				(sr == &sr1) ? OMAP3_PRM_VP1_VOLTAGE_OFFSET :
-					OMAP3_PRM_VP2_VOLTAGE_OFFSET);
-	}
-
-	return;
-}
-
-static u32 get_ret_volt(struct omap_sr *sr)
-{
-	if (sr == &sr1)
-		return (prm_read_mod_reg(OMAP3430_GR_MOD,
-				OMAP3_PRM_VC_CMD_VAL_0_OFFSET) &
-				OMAP3430_VC_CMD_RET_MASK) >>
-			OMAP3430_VC_CMD_RET_SHIFT;
-
-	if (sr == &sr2)
-		return (prm_read_mod_reg(OMAP3430_GR_MOD,
-				OMAP3_PRM_VC_CMD_VAL_1_OFFSET) &
-				OMAP3430_VC_CMD_RET_MASK) >>
-			OMAP3430_VC_CMD_RET_SHIFT;
-
-	return -EINVAL;
-}
-
 
 void sr_start_vddautocomap(int srid, u32 target_opp_no)
 {
@@ -766,7 +711,6 @@ int sr_stop_vddautocomap(int srid)
 		sr->is_autocomp_active = 0;
 		/* Reset the volatage for current OPP */
 		sr_reset_voltage(srid);
-		change_ret_volt(sr, sr->starting_ret_volt);
 		return true;
 	}
 	return false;
@@ -1037,22 +981,7 @@ static struct kobj_attribute sr_vdd2_autocomp = {
 	.store = omap_sr_vdd2_autocomp_store,
 };
 
-static irqreturn_t sr_omap_irq(int irq, void *dev_id)
-{
-	static u32 vp1_volt;
-	static u32 vp2_volt;
-
-	if (dev_id == &sr1)
-		try_change_ret_volt(dev_id, &vp1_volt);
-
-	if (dev_id == &sr2)
-		try_change_ret_volt(dev_id, &vp2_volt);
 
-	sr_modify_reg(dev_id, ERRCONFIG, ERRCONFIG_MCUBOUNDINTST,
-			ERRCONFIG_MCUBOUNDINTST);
-
-	return IRQ_HANDLED;
-}
 
 static int __init omap3_sr_init(void)
 {
@@ -1065,25 +994,6 @@ static int __init omap3_sr_init(void)
 		return -ENODEV;
         }
 
-	dpll1_ck = clk_get(NULL, "dpll1_ck");
-	if (dpll1_ck == NULL || IS_ERR(dpll1_ck))
-		return -ENODEV;
-
-	l3_ick = clk_get(NULL, "l3_ick");
-	if (l3_ick == NULL || IS_ERR(l3_ick))
-		return -ENODEV;
-
-	ret = get_ret_volt(&sr1);
-	if (ret == -EINVAL)
-		return -ENODEV;
-	sr1.starting_ret_volt = ret;
-
-	ret = get_ret_volt(&sr2);
-	if (ret == -EINVAL)
-		return -ENODEV;
-	sr2.starting_ret_volt = ret;
-
-
 #ifdef CONFIG_TWL4030_CORE
 	/* Enable SR on T2 */
 	ret = twl4030_i2c_read_u8(TWL4030_MODULE_PM_RECEIVER, &RdReg,
@@ -1108,14 +1018,6 @@ static int __init omap3_sr_init(void)
 	sr_set_nvalues(&sr2);
 	sr_configure_vp(SR2);
 
-	ret = request_irq(SR1_IRQ, sr_omap_irq, IRQF_DISABLED, "sr1", &sr1);
-	if (ret)
-		goto out1;
-
-	ret = request_irq(SR2_IRQ, sr_omap_irq, IRQF_DISABLED, "sr2", &sr2);
-	if (ret)
-		goto out2;
-
 	pr_info("SmartReflex driver initialized\n");
 
 	ret = sysfs_create_file(power_kobj, &sr_vdd1_autocomp.attr);
@@ -1127,17 +1029,6 @@ static int __init omap3_sr_init(void)
 		pr_err("sysfs_create_file failed: %d\n", ret);
 
 	return 0;
-
-	/*
-	 * TODO: Proper cleanup routines necessary like disabling SR on T2,
-	 * etc.
-	 */
-out1:
-
-out2:
-	free_irq(SR1_IRQ, &sr1);
-
-	return ret;
 }
 
 late_initcall(omap3_sr_init);
diff --git a/arch/arm/mach-omap2/smartreflex.h b/arch/arm/mach-omap2/smartreflex.h
index 7d1c470..7e06752 100644
--- a/arch/arm/mach-omap2/smartreflex.h
+++ b/arch/arm/mach-omap2/smartreflex.h
@@ -138,18 +138,14 @@
 
 #define ERRCONFIG_VPBOUNDINTEN		BIT(31)
 #define ERRCONFIG_VPBOUNDINTST		BIT(30)
-#define ERRCONFIG_MCUBOUNDINTEN		BIT(25)
-#define ERRCONFIG_MCUBOUNDINTST		BIT(24)
 
 #define SR1_ERRWEIGHT			(0x07 << 16)
 #define SR1_ERRMAXLIMIT			(0x02 << 8)
 #define SR1_ERRMINLIMIT			(0xFA << 0)
-#define SR1_IRQ				18
 
 #define SR2_ERRWEIGHT			(0x07 << 16)
 #define SR2_ERRMAXLIMIT			(0x02 << 8)
 #define SR2_ERRMINLIMIT			(0xF9 << 0)
-#define SR2_IRQ				19
 
 /* T2 SMART REFLEX */
 #define R_SRI2C_SLAVE_ADDR		0x12
diff --git a/arch/arm/mach-omap2/sram34xx.S b/arch/arm/mach-omap2/sram34xx.S
index b250535..0680377 100644
--- a/arch/arm/mach-omap2/sram34xx.S
+++ b/arch/arm/mach-omap2/sram34xx.S
@@ -89,6 +89,9 @@ ENTRY(omap3_sram_configure_core_dpll)
 	ldr	r6, [sp, #60]		@ load extra args from the stack
 	ldr	r7, [sp, #64]		@ load extra args from the stack
 	dsb				@ flush buffered writes to interconnect
+	mrc p15, 0, r10, c1, c0, 0  @ read control register
+	bic r10, r10, #0x800        @ clear the Z bit(disable branch prediction)
+	mcr p15, 0, r10, c1, c0, 0  @ write control register
 	cmp	r7, #1			@ if increasing SDRC clk rate,
 	bleq	configure_sdrc		@ program the SDRC regs early (for RFR)
 	cmp	r4, #SDRC_UNLOCK_DLL	@ set the intended DLL state
@@ -106,6 +109,9 @@ ENTRY(omap3_sram_configure_core_dpll)
 	beq	return_to_sdram		@ return to SDRAM code, otherwise,
 	bl	configure_sdrc		@ reprogram SDRC regs now
 return_to_sdram:
+	mrc p15, 0, r10, c1, c0, 0  @ read control register
+	orr r10, r10, #0x800        @ set the Z bit (enable branch prediction)
+	mcr p15, 0, r10, c1, c0, 0  @ write control register
 	isb				@ prevent speculative exec past here
 	mov 	r0, #0 			@ return value
 	ldmfd	sp!, {r1-r12, pc}	@ restore regs and return
diff --git a/arch/arm/mach-omap2/usb-musb.c b/arch/arm/mach-omap2/usb-musb.c
index fdcb28f..238ae44 100644
--- a/arch/arm/mach-omap2/usb-musb.c
+++ b/arch/arm/mach-omap2/usb-musb.c
@@ -25,6 +25,7 @@
 #include <linux/io.h>
 
 #include <linux/usb/musb.h>
+#include <linux/usb/android.h>
 
 #include <asm/sizes.h>
 
@@ -226,6 +227,7 @@ void __init usb_musb_init(void)
 
 	musb_resources[0].end = musb_resources[0].start + SZ_8K - 1;
 
+
 #ifdef CONFIG_NOP_USB_XCEIV
 	if (platform_device_register(&nop_xceiv_device) < 0) {
 		printk(KERN_ERR "Unable to register NOP-XCEIV device\n");
diff --git a/arch/arm/mach-omap2/wakeup-timer.c b/arch/arm/mach-omap2/wakeup-timer.c
new file mode 100644
index 0000000..0124a60
--- /dev/null
+++ b/arch/arm/mach-omap2/wakeup-timer.c
@@ -0,0 +1,801 @@
+/*
+ *  wakeup_timer.h
+ *
+ *  Copyright (C) 2009 Motorola, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Adds ability to program periodic interrupts from user space that
+ *  can wake the phone out of low power modes.
+ *
+ */
+ /*
+ * DATE			AUTHOR		 COMMENT
+ * -----		-----		 --------
+ * Jul 01, 2009		Motorola	 Initial version for omap Android
+ * Jul 27, 2009         Motorola         Timer granularity to be in msecs
+ * Aug 21, 2009		Motorola	 suspend optimization
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/moduleparam.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/poll.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/jiffies.h>
+#include <linux/time.h>
+#include <linux/ktime.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/wakeup_timer.h>
+#include <linux/wakeup_timer_kernel.h>
+#include "pm.h"
+
+
+
+#ifdef WAKEUP_TIMER_DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_INFO "%s: " fmt, __func__ , ## args)
+#else
+#define DPRINTK(fmt, args...) do {} while (0)
+#endif
+
+#define WAKEUP_LATENCY 0
+
+/*
+ * Wakeup timer state definition:
+ */
+enum timer_state {
+	/* Timer is inactive */
+	TIMER_INACTIVE = 0,
+	/* Timer is active, waitting for timeout */
+	TIMER_ACTIVE,
+	/* Timer is timeout, has wokenup process, waitting for next poll */
+	TIMER_PENDING,
+	/* Timer is unused. */
+	TIMER_INVALID
+};
+
+#ifdef CONFIG_HAS_WAKELOCK
+static struct wake_lock driver_wake_lock;
+#endif
+
+static LIST_HEAD(parent_node);
+static DEFINE_SPINLOCK(wakeup_timer_lock);
+static bool isSuspended;
+
+inline unsigned long get_expire_time(struct timer_cascade_root *pwkup_cascade)
+{
+	unsigned long clock;
+	unsigned long cur_time;
+	long delta;
+	unsigned long k32_max;
+	unsigned long long temp;
+
+	/* 32K timer max val is 131071999969482ns, or 0x07CFFFFF ms*/
+	k32_max = (unsigned long)0x07CFFFFF;
+	clock = pwkup_cascade->timer_base_time + pwkup_cascade->period_time;
+
+	temp = sched_clock();
+	do_div(temp, NSEC_PER_MSEC);
+	cur_time = (unsigned long)temp;
+	if (cur_time >= pwkup_cascade->timer_base_time)
+		delta = clock - cur_time;
+	else {
+		DPRINTK("32KHz clock roll-over \n");
+		clock = pwkup_cascade->period_time -
+			(k32_max - pwkup_cascade->timer_base_time);
+		delta = (long)(clock - cur_time);
+	}
+
+	if (delta < 0)
+		delta = 0;
+
+	return (unsigned long)delta;
+}
+
+static unsigned long get_nearest_wakeup_timer_ktime(void)
+{
+	unsigned long timer_fire;
+	unsigned long timer_temp;
+	struct timer_cascade_root *pwkup_cascade;
+
+	timer_fire = ULONG_MAX;
+	timer_temp = 0;
+
+	list_for_each_entry(pwkup_cascade, &parent_node, node) {
+		if (pwkup_cascade->state == TIMER_ACTIVE ||
+			pwkup_cascade->state == TIMER_INACTIVE) {
+			timer_temp = get_expire_time(pwkup_cascade);
+			if (timer_temp < timer_fire)
+				timer_fire = timer_temp;
+		}
+		DPRINTK("type=%d, timer_base=%lu ms, expired_time=%lu,"
+			" period=%lu ms, expired_interval=%lu ms now=%llu\n",
+			pwkup_cascade->cascade_type,
+			pwkup_cascade->timer_base_time,
+			pwkup_cascade->timer_base_time +
+				pwkup_cascade->period_time,
+			pwkup_cascade->period_time,
+			timer_temp,
+			sched_clock());
+	}
+	return timer_fire;
+}
+
+static void cascade_start_hrtimer(struct timer_cascade_root *pwkup_cascade)
+{
+	ktime_t tmp;
+	unsigned long expire_time;
+
+	expire_time = get_expire_time(pwkup_cascade);
+	tmp = ktime_set((long)expire_time/MSEC_PER_SEC,
+			(long)expire_time%MSEC_PER_SEC*NSEC_PER_MSEC);
+
+	hrtimer_start(&(pwkup_cascade->alarm_timer), tmp, HRTIMER_MODE_REL);
+
+	DPRINTK("type=%d, timer_base=%lu ms, period=%lu ms, now=%llu ns\n",
+			pwkup_cascade->cascade_type,
+			pwkup_cascade->timer_base_time,
+			pwkup_cascade->period_time,
+			sched_clock());
+}
+
+static enum hrtimer_restart wakeup_timer_callback(struct hrtimer *timer)
+{
+	unsigned long flags;
+	struct timer_cascade_root *pwkup_cascade;
+	enum hrtimer_restart ret = HRTIMER_NORESTART;
+
+	pwkup_cascade = container_of(timer,
+				struct timer_cascade_root, alarm_timer);
+	DPRINTK("type=%d, timer_base=%lu ms, period=%lu ms, "
+		"expected_time=%lu ms now=%llu ns\n",
+			pwkup_cascade->cascade_type,
+			pwkup_cascade->timer_base_time,
+			pwkup_cascade->period_time,
+			pwkup_cascade->timer_base_time +
+				pwkup_cascade->period_time,
+			sched_clock());
+
+	if (pwkup_cascade->cascade_type == TYPE_STATUS
+			&& pwkup_cascade->callback) {
+		spin_lock_irqsave(&wakeup_timer_lock, flags);
+		pwkup_cascade->state = TIMER_INVALID;
+		list_del(&(pwkup_cascade->node));
+		spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+		pwkup_cascade->callback();
+		return ret;
+	}
+
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+
+	pwkup_cascade->state = TIMER_PENDING;
+
+	if (pwkup_cascade->cascade_type == TYPE_PERIODIC) {
+		pwkup_cascade->timer_base_time += pwkup_cascade->period_time;
+		cascade_start_hrtimer(pwkup_cascade);
+	}
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_timeout(&(pwkup_cascade->wkuptimer_wake_lock), 5 * HZ);
+#endif
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+
+	wake_up_interruptible(&(pwkup_cascade->cascade_wq));
+
+	return ret;
+}
+
+static int cascade_create(struct timer_cascade_root **ppwkup_cascade)
+{
+	int ret = 0;
+	int sz = sizeof(struct timer_cascade_root);
+
+	*ppwkup_cascade = kzalloc(sz, GFP_KERNEL);
+	if (*ppwkup_cascade == NULL)
+		ret = -ENOMEM;
+
+	/* Initialize some of the members */
+	init_waitqueue_head(&((*ppwkup_cascade)->cascade_wq));
+
+	(*ppwkup_cascade)->process = current;
+
+	hrtimer_init(&((*ppwkup_cascade)->alarm_timer),
+			CLOCK_MONOTONIC,
+			HRTIMER_MODE_REL);
+
+	(*ppwkup_cascade)->alarm_timer.function = wakeup_timer_callback;
+
+	INIT_LIST_HEAD(&((*ppwkup_cascade)->node));
+
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&((*ppwkup_cascade)->wkuptimer_wake_lock),
+			WAKE_LOCK_SUSPEND, "wakeup_timer");
+#endif
+	return ret;
+}
+
+/* Attach timer request and attache timer cascade and start timers */
+static int cascade_attach(struct timer_cascade_root *new_pwkup_cascade)
+{
+	unsigned long flags;
+	struct timer_cascade_root *pwkup_cascade;
+	int type;
+	int has_period_timer = 0;
+
+	unsigned long new_period_time;
+	unsigned long base_first;
+	unsigned long cur_time;
+	unsigned long long temp;
+
+	base_first = 0;
+
+	new_period_time = new_pwkup_cascade->period_time;
+	type = new_pwkup_cascade->cascade_type;
+
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+
+	temp = sched_clock();
+	do_div(temp, NSEC_PER_MSEC);
+	cur_time = (unsigned long)temp;
+
+	if (type == TYPE_ONESHOT || type == TYPE_STATUS) {
+		/* Directly attach the one shot timer, time based is now. */
+		new_pwkup_cascade->timer_base_time = cur_time;
+		list_add(&(new_pwkup_cascade->node), &parent_node);
+		DPRINTK("type=%d, timer_base=%lu, period=%lu ms, now=%llu\n",
+			new_pwkup_cascade->cascade_type,
+			new_pwkup_cascade->timer_base_time,
+			new_pwkup_cascade->period_time,
+			sched_clock());
+	} else if (type == TYPE_PERIODIC) {
+		/* Align all period timers with the only one time base */
+		list_for_each_entry(pwkup_cascade, &parent_node, node) {
+			if (pwkup_cascade->cascade_type == TYPE_ONESHOT)
+				continue;
+			else if (pwkup_cascade->cascade_type == TYPE_PERIODIC ||
+				base_first == 0) {
+				base_first = pwkup_cascade->timer_base_time;
+				has_period_timer = 1;
+				break;
+			}
+		}
+
+		/* No period cascade yet */
+		if (base_first == 0)
+			new_pwkup_cascade->timer_base_time = cur_time;
+		else
+			/* Align base with the first found period timer */
+			new_pwkup_cascade->timer_base_time = base_first;
+
+		if (has_period_timer)
+			list_add(&(new_pwkup_cascade->node),
+				&(pwkup_cascade->node));
+		else
+			list_add_tail(&(new_pwkup_cascade->node),
+				&(pwkup_cascade->node));
+
+		DPRINTK("type=%d, timer_base=%lu ms, period=%lu ms, now=%llu\n",
+			new_pwkup_cascade->cascade_type,
+			new_pwkup_cascade->timer_base_time,
+			new_pwkup_cascade->period_time,
+			sched_clock());
+	}
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+
+	/* don't start hrtimer if we are suspended */
+	if (!isSuspended)
+		cascade_start_hrtimer(new_pwkup_cascade);
+
+	return 0;
+}
+
+static int cascade_deattach(struct timer_cascade_root *pwkup_cascade)
+{
+
+	if (pwkup_cascade->state == TIMER_INVALID)
+		return 0;
+
+	pwkup_cascade->state = TIMER_INVALID;
+	if (!isSuspended)
+		hrtimer_cancel(&(pwkup_cascade->alarm_timer));
+	list_del(&(pwkup_cascade->node));
+
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_unlock(&(pwkup_cascade->wkuptimer_wake_lock));
+#endif
+	return 0;
+}
+
+struct timer_cascade_root *wakeup_create_status_timer(int (*callback) (void))
+{
+	struct timer_cascade_root *new;
+
+	if (cascade_create(&new))
+		return NULL;
+
+	new->state = TIMER_INVALID;
+	new->cascade_type = TYPE_STATUS;
+	new->callback = callback;
+	return new;
+}
+EXPORT_SYMBOL_GPL(wakeup_create_status_timer);
+
+void wakeup_start_status_timer(struct timer_cascade_root *timer,
+		unsigned long period)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+	if (timer->state == TIMER_INACTIVE)
+		cascade_deattach(timer);
+
+	timer->state = TIMER_INACTIVE;
+	timer->cascade_type = TYPE_STATUS;
+	timer->period_time = period ;
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+	/* Now, the timer request is ready but not attached into the list */
+	cascade_attach(timer);
+
+	if (isSuspended) {
+		/* We are suspended, set wakeup timer to nearest timer. */
+		unsigned long expire = get_nearest_wakeup_timer_ktime();
+		if (expire == ULONG_MAX) {
+			wakeup_timer_seconds = 0;
+			wakeup_timer_nseconds = 0;
+			return;
+		}
+		wakeup_timer_seconds = (expire-WAKEUP_LATENCY)/MSEC_PER_SEC;
+		wakeup_timer_nseconds = ((expire-WAKEUP_LATENCY)%MSEC_PER_SEC)
+					*NSEC_PER_MSEC;
+		DPRINTK("set wakeup_timer_seconds: %d.%d \n",
+			wakeup_timer_seconds, wakeup_timer_nseconds);
+	}
+}
+EXPORT_SYMBOL_GPL(wakeup_start_status_timer);
+extern int wakeup_stop_status_timer(struct timer_cascade_root *timer)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+	cascade_deattach(timer);
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wakeup_stop_status_timer);
+extern int wakeup_del_status_timer(struct timer_cascade_root *timer)
+{
+	if (!timer)
+		return -EINVAL;
+
+	wakeup_stop_status_timer(timer);
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_unlock(&(timer->wkuptimer_wake_lock));
+	wake_lock_destroy(&(timer->wkuptimer_wake_lock));
+#endif
+	/* Free the memory for the timer request */
+	kfree(timer);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wakeup_del_status_timer);
+
+/*
+ * return -1 if no sim status timer pending, 0 if it has expired
+ * and time left in ms otherwise
+ */
+int wakeup_check_status_timer(struct timer_cascade_root *timer)
+{
+	if (timer->state == TIMER_INACTIVE)
+		return get_expire_time(timer);
+	return -1;
+}
+EXPORT_SYMBOL_GPL(wakeup_check_status_timer);
+
+/*
+ * Main function to add new timer.
+ */
+static int wakeup_timer_add
+(int type, struct file *filp, unsigned long timer_period)
+{
+	struct timer_cascade_root *pwkup_cascade;
+	unsigned long flags;
+
+	if ((type != TYPE_PERIODIC) && (type != TYPE_ONESHOT))
+		return -EINVAL;
+
+	/* Need create new request */
+	if (likely(filp->private_data == 0)) {
+		if (cascade_create(&pwkup_cascade))
+			return -ENOMEM;
+
+		/* Initialize more members in timer request */
+		filp->private_data = (void *)pwkup_cascade;
+	} else {
+		/* Remove the timer request from list */
+		pwkup_cascade = (struct timer_cascade_root *)filp->private_data;
+
+		spin_lock_irqsave(&wakeup_timer_lock, flags);
+		cascade_deattach(pwkup_cascade);
+		spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+	}
+
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+	pwkup_cascade->state = TIMER_INACTIVE;
+	pwkup_cascade->cascade_type = type;
+	pwkup_cascade->period_time = timer_period ;
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+
+	/* Now, the timer request is ready but not attached into the list */
+	return cascade_attach(pwkup_cascade);
+}
+
+/* This function will delete the timer request and free it,
+ * also it will delete and free the cascade if necessary
+ */
+static int wakeup_timer_destroy(struct file *filp)
+{
+	unsigned long flags;
+	struct timer_cascade_root *pwkup_cascade;
+
+	/* No wakeup timer request */
+	if (filp->private_data == 0)
+		return 0;
+
+	pwkup_cascade = (struct timer_cascade_root *)filp->private_data;
+
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+	cascade_deattach(pwkup_cascade);
+
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_unlock(&(pwkup_cascade->wkuptimer_wake_lock));
+	wake_lock_destroy(&(pwkup_cascade->wkuptimer_wake_lock));
+#endif
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+
+	/* Free the memory for the timer request */
+	kfree(pwkup_cascade);
+
+	filp->private_data = 0;
+
+	return 0;
+}
+
+/*
+ * Only one timer is allowed for each thread
+ * Driver will use filp->private_data as the reference for the timer request
+ * to avoid going through the whole list
+ */
+static int wakeup_timer_open(struct inode *inode, struct file *filp)
+{
+	if (filp->private_data == 0)
+		return nonseekable_open(inode, filp);
+	else
+		return -1;
+}
+
+static int wakeup_timer_release(struct inode *inode, struct file *filp)
+{
+	return wakeup_timer_destroy(filp);
+}
+
+/*
+ * This function will do strict check, so others will just assume the
+ * timer in timerlist are valid
+ */
+static int wakeup_timer_ioctl(struct inode *inode,
+		struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case IOC_WAKEUP_TIMER_SETPERIOD:
+		if (arg <= 0) {
+			printk(KERN_ERR "Period Timer Value is not valid.\n");
+			return -EINVAL;
+		}
+
+		if (arg < 20000) {
+			printk(KERN_ERR "Wakeup Timer Period < 20 seconds"
+					"is not supported.\n");
+			return -EINVAL;
+		}
+
+		DPRINTK("Period wake up timer has been set.\n");
+		ret = wakeup_timer_add(TYPE_PERIODIC, filp, (unsigned long)arg);
+		break;
+
+	case IOC_WAKEUP_TIMER_ONESHOT:
+		if (arg <= 0) {
+			printk(KERN_ERR "Oneshot Timer Value is not valid.\n");
+			return -EINVAL;
+		}
+
+		DPRINTK("Oneshot wake up timer has been set.\n");
+		ret = wakeup_timer_add(TYPE_ONESHOT, filp, (unsigned long)arg);
+		break;
+
+	case IOC_WAKEUP_TIMER_DELETE:
+		ret = wakeup_timer_destroy(filp);
+		break;
+
+	default:
+		printk(KERN_ERR "Invalid IOCTL command\n");
+		return -EINVAL;
+	}
+	return ret;
+}
+
+/* The POLL will mark the timer request as ACTIVE so timer
+* callback can mark this as pending timer
+*/
+static unsigned int wakeup_timer_poll(struct file *filp, poll_table *wait)
+{
+	unsigned long flags;
+	unsigned int ret = 0;
+	struct timer_cascade_root *pwkup_cascade;
+
+	/* If the timer is not present, do not permit this operation */
+	if (filp->private_data == NULL)
+		return -EPERM;
+
+	pwkup_cascade = (struct timer_cascade_root *)filp->private_data;
+	if (pwkup_cascade->state == TIMER_INVALID)
+		return -EPERM;
+
+	/* Check whether the timer has already expired */
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+	if (pwkup_cascade->state == TIMER_PENDING) {
+		pwkup_cascade->state = TIMER_ACTIVE;
+		if (pwkup_cascade->cascade_type == TYPE_ONESHOT)
+			cascade_deattach(pwkup_cascade);
+
+		spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+		return POLLIN;
+	}
+	pwkup_cascade->state = TIMER_ACTIVE;
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+
+	/* release the wake lock before wait */
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_unlock(&(pwkup_cascade->wkuptimer_wake_lock));
+#endif
+	poll_wait(filp, &(pwkup_cascade->cascade_wq), wait);
+
+	/* Check whether the timer has already expired */
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+	if (pwkup_cascade->state == TIMER_PENDING) {
+		pwkup_cascade->state = TIMER_ACTIVE;
+		ret = POLLIN;
+		if (pwkup_cascade->cascade_type == TYPE_ONESHOT)
+			cascade_deattach(pwkup_cascade);
+	}
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+
+	return ret;
+}
+
+static const struct file_operations wakeup_timer_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= wakeup_timer_ioctl,
+	.open		= wakeup_timer_open,
+	.release	= wakeup_timer_release,
+	.poll		= wakeup_timer_poll,
+};
+
+static struct miscdevice wakeup_timer_miscdev = {
+	.minor	= MISC_DYNAMIC_MINOR,
+	.name	= "wakeup_timer",
+	.fops	= &wakeup_timer_fops
+};
+
+static ssize_t wake_timer_list_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int len = 0;
+
+	struct timer_cascade_root *pwkup_cascade;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wakeup_timer_lock, flags);
+	list_for_each_entry(pwkup_cascade, &parent_node, node) {
+	len += sprintf(buf + len,
+			"Timer Type: %s, period:%lu ms, base:%lu ms\n",
+			(pwkup_cascade->cascade_type) ? "ONESHOT" : "PERIOD",
+			pwkup_cascade->period_time,
+			pwkup_cascade->timer_base_time);
+	}
+	spin_unlock_irqrestore(&wakeup_timer_lock, flags);
+
+	WARN_ON(len > PAGE_SIZE);
+	return len;
+}
+
+static DEVICE_ATTR(wake_timer_list, S_IRUGO | S_IWUSR,
+			wake_timer_list_show, NULL);
+
+static int __init wakeup_timer_probe(struct platform_device *pdev)
+{
+	int err;
+
+	err = device_create_file(&pdev->dev, &dev_attr_wake_timer_list);
+	if (err) {
+		dev_err(pdev->dev.parent,
+			"failed to create timer list attribute, %d\n", err);
+	}
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&driver_wake_lock,
+			WAKE_LOCK_SUSPEND,
+			"wakeup_driver");
+#endif
+
+	return misc_register(&wakeup_timer_miscdev);
+}
+
+static int wakeup_timer_remove(struct platform_device *pdev)
+{
+	return misc_deregister(&wakeup_timer_miscdev);
+}
+
+#ifdef CONFIG_SUSPEND
+
+
+static int wakeup_timer_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+	struct timer_cascade_root *pwkup_cascade;
+#ifdef CONFIG_HAS_WAKELOCK
+	long timeout;
+#endif
+
+	unsigned long expire = get_nearest_wakeup_timer_ktime();
+	DPRINTK("suspend expire %d\n", expire);
+	if (expire == ULONG_MAX) {
+		wakeup_timer_seconds = 0;
+		wakeup_timer_nseconds = 0;
+		return 0;
+	}
+
+	/* If expiration value is less than the total time of
+	* "suspend+resume+shedule", then don't get into suspend.
+	* Currently we suppose it will no more than 200ms in worst case,
+	* right? this might need change later with more statistic.
+	*/
+	if (expire <= 5000) {
+#ifdef CONFIG_HAS_WAKELOCK
+		timeout = (HZ*expire)/MSEC_PER_SEC + 1;
+		wake_lock_timeout(&driver_wake_lock , timeout);
+#endif
+		return -EBUSY;
+	}
+
+	/* Make sure system is waked up 200ms ahead of timer expiration,
+	* then the latency could be off-set and timer could be scheduled
+	* at accurate point.
+	*/
+	wakeup_timer_seconds = (expire-WAKEUP_LATENCY)/MSEC_PER_SEC;
+	wakeup_timer_nseconds = ((expire-WAKEUP_LATENCY)%MSEC_PER_SEC)
+				*NSEC_PER_MSEC;
+
+	DPRINTK("set wakeup_timer_seconds: %d.%d \n",
+		wakeup_timer_seconds, wakeup_timer_nseconds);
+
+	list_for_each_entry(pwkup_cascade, &parent_node, node) {
+		hrtimer_cancel(&(pwkup_cascade->alarm_timer));
+	}
+	isSuspended = true;
+	return 0;
+}
+
+static int wakeup_timer_resume(struct platform_device *pdev)
+{
+	struct timer_cascade_root *pwkup_cascade;
+	struct timer_cascade_root *tmp;
+#ifdef CONFIG_HAS_WAKELOCK
+	unsigned long expire;
+	long timeout;
+#endif
+	isSuspended = false;
+	DPRINTK("resume\n");
+
+#ifdef CONFIG_HAS_WAKELOCK
+	expire = get_nearest_wakeup_timer_ktime();
+
+	/* if expire >200ms, its not waked up by timer.
+	* if expire <50ms, hold a 50ms wakelock to make sure timer is scheduled.
+	* if 50~200ms, disable suspend but allow idle by setting wakelock.
+	*/
+	if (expire < 5000) {
+		if (expire <= 50)
+			timeout = (HZ*50)/MSEC_PER_SEC + 1;
+		else
+			timeout = (HZ*expire)/MSEC_PER_SEC + 1;
+
+		wake_lock_timeout(&driver_wake_lock, timeout);
+		DPRINTK("expire in %lu ms, taking wakelock for %ld tick.\n",
+				expire, timeout);
+	}
+#endif
+	list_for_each_entry_safe(pwkup_cascade, tmp, &parent_node, node) {
+		cascade_start_hrtimer(pwkup_cascade);
+	}
+	return 0;
+}
+
+#else /* !CONFIG_SUSPEND */
+
+#define wakeup_timer_suspend NULL
+#define wakeup_timer_resume  NULL
+
+#endif
+
+static struct platform_driver wakeup_timer_driver = {
+	.probe		= wakeup_timer_probe,
+	.remove		= wakeup_timer_remove,
+	.suspend	= wakeup_timer_suspend,
+	.resume		= wakeup_timer_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "wakeup_timer",
+	},
+};
+
+static struct platform_device *wakeup_timer_device;
+
+static int __init wakeup_timer_init(void)
+{
+	int ret = 0;
+
+	wakeup_timer_device =
+		platform_device_register_simple("wakeup_timer", 0, NULL, 0);
+
+	if (IS_ERR(wakeup_timer_device)) {
+		printk(KERN_ERR "Failed to register wakeup_timer device.\n");
+		ret = PTR_ERR(wakeup_timer_device);
+		return ret;
+	}
+
+	ret = platform_driver_register(&wakeup_timer_driver);
+	if (ret) {
+		printk(KERN_ERR "Failed to register wakeup_timer driver.\n");
+		platform_device_unregister(wakeup_timer_device);
+	}
+
+	return ret;
+}
+
+static void __exit wakeup_timer_exit(void)
+{
+	platform_driver_unregister(&wakeup_timer_driver);
+	platform_device_unregister(wakeup_timer_device);
+}
+
+module_init(wakeup_timer_init);
+module_exit(wakeup_timer_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Motorola wakeup timer driver");
diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index 0455557..5cb8f99 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -20,6 +20,7 @@
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
+#include <linux/lttlite-events.h>
 
 #include "fault.h"
 
@@ -260,6 +261,9 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 	 */
 	if (in_atomic() || !mm)
 		goto no_context;
+#ifdef CONFIG_LTT_LITE
+	ltt_ev_trap_entry(TRAP_T_PAGE_FAULT, instruction_pointer(regs));
+#endif
 
 	/*
 	 * As per x86, we may deadlock here.  However, since the kernel only
@@ -274,6 +278,9 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 
 	fault = __do_page_fault(mm, addr, fsr, tsk);
 	up_read(&mm->mmap_sem);
+#ifdef CONFIG_LTT_LITE
+	ltt_ev_trap_exit();
+#endif
 
 	/*
 	 * Handle the "normal" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 6031abc..3c2a9b8 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -14,6 +14,8 @@
 #include <linux/bootmem.h>
 #include <linux/mman.h>
 #include <linux/nodemask.h>
+#include <linux/ioport.h>
+#include <linux/lttlite-events.h>
 
 #include <asm/cputype.h>
 #include <asm/mach-types.h>
@@ -21,6 +23,7 @@
 #include <asm/setup.h>
 #include <asm/sizes.h>
 #include <asm/tlb.h>
+#include <asm/pgtable.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
@@ -747,6 +750,7 @@ static inline void prepare_page_table(void)
 {
 	unsigned long addr;
 
+
 	/*
 	 * Clear out all the mappings below the kernel image.
 	 */
@@ -775,6 +779,9 @@ static inline void prepare_page_table(void)
 void __init reserve_node_zero(pg_data_t *pgdat)
 {
 	unsigned long res_size = 0;
+#ifdef CONFIG_LTT_LITE
+	int res;
+#endif
 
 	/*
 	 * Register the kernel text and data with bootmem.
@@ -829,6 +836,19 @@ void __init reserve_node_zero(pg_data_t *pgdat)
 	 */
 	res_size = __pa(swapper_pg_dir) - PHYS_OFFSET;
 #endif
+#ifdef CONFIG_LTT_LITE
+	/* reserve memory for ltt lite */
+	if (ltt_lite_res.start) {
+		printk(KERN_DEBUG "LTT-LITE: reserve 0x%lx\n",
+			(unsigned long)ltt_lite_res.start);
+		res = reserve_bootmem_node(pgdat, ltt_lite_res.start,
+			ltt_lite_res.end - ltt_lite_res.start+1,
+			BOOTMEM_DEFAULT);
+		if (res)
+			printk(KERN_ERR "LTT-LITE: reserve memory failed, err=%d\n",
+					res);
+	}
+#endif
 	if (res_size)
 		reserve_bootmem_node(pgdat, PHYS_OFFSET, res_size,
 				BOOTMEM_DEFAULT);
diff --git a/arch/arm/plat-omap/Kconfig b/arch/arm/plat-omap/Kconfig
index 12ffecd..3ab203d 100644
--- a/arch/arm/plat-omap/Kconfig
+++ b/arch/arm/plat-omap/Kconfig
@@ -114,6 +114,13 @@ config OMAP_RESET_CLOCKS
 	  probably do not want this option enabled until your
 	  device drivers work properly.
 
+config OMAP_PM_POWER_OFF
+	bool "Power down the omap devices."
+	depends on ARCH_OMAP
+        default n
+	help
+	  Say Y if you want to power off the devices.
+
 config OMAP_BOOT_TAG
 	bool "OMAP bootloader information passing"
         depends on ARCH_OMAP
@@ -181,6 +188,14 @@ config OMAP_MCBSP
 	  Say Y here if you want support for the OMAP Multichannel
 	  Buffered Serial Port.
 
+config MEM_DUMP
+	bool " memory dump support"
+	depends on ARCH_OMAP
+	default y
+	help
+	  Say Y here if you want support for warmreset system when panic
+	  happens for memory dump purpose.
+
 config OMAP_MBOX_FWK
 	tristate "Mailbox framework support"
 	depends on ARCH_OMAP
diff --git a/arch/arm/plat-omap/dma.c b/arch/arm/plat-omap/dma.c
index cd53b28..e9eb2d9 100755
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@ -673,13 +673,16 @@ static inline void disable_lnk(int lch)
 static inline void omap2_enable_irq_lch(int lch)
 {
 	u32 val;
+	unsigned long flags;
 
 	if (!cpu_class_is_omap2())
 		return;
 
+	spin_lock_irqsave(&dma_chan_lock, flags);
 	val = dma_read(IRQENABLE_L0);
 	val |= 1 << lch;
 	dma_write(val, IRQENABLE_L0);
+	spin_unlock_irqrestore(&dma_chan_lock, flags);
 }
 
 int omap_request_dma(int dev_id, const char *dev_name,
@@ -749,11 +752,13 @@ int omap_request_dma(int dev_id, const char *dev_name,
 	}
 
 	if (cpu_class_is_omap2()) {
+		spin_lock_irqsave(&dma_chan_lock, flags);
 		omap2_enable_irq_lch(free_ch);
 		omap_enable_channel_irq(free_ch);
 		/* Clear the CSR register and IRQ status register */
 		dma_write(OMAP2_DMA_CSR_CLEAR_MASK, CSR(free_ch));
 		dma_write(1 << free_ch, IRQSTATUS_L0);
+		spin_unlock_irqrestore(&dma_chan_lock, flags);
 	}
 
 	*dma_ch_out = free_ch;
@@ -788,10 +793,12 @@ void omap_free_dma(int lch)
 
 	if (cpu_class_is_omap2()) {
 		u32 val;
+		spin_lock_irqsave(&dma_chan_lock, flags);
 		/* Disable interrupts */
 		val = dma_read(IRQENABLE_L0);
 		val &= ~(1 << lch);
 		dma_write(val, IRQENABLE_L0);
+		spin_unlock_irqrestore(&dma_chan_lock, flags);
 
 		/* Clear the CSR register and IRQ status register */
 		dma_write(OMAP2_DMA_CSR_CLEAR_MASK, CSR(lch));
diff --git a/arch/arm/plat-omap/dmtimer.c b/arch/arm/plat-omap/dmtimer.c
index a05205c..4759ce7 100644
--- a/arch/arm/plat-omap/dmtimer.c
+++ b/arch/arm/plat-omap/dmtimer.c
@@ -503,6 +503,14 @@ void omap_dm_timer_stop(struct omap_dm_timer *timer)
 	if (l & OMAP_TIMER_CTRL_ST) {
 		l &= ~0x1;
 		omap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);
+
+		/* Readback to make sure write has completed */
+		omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);
+		/*
+		 * Wait for functional clock period x 3.5 to make sure that
+		 * timer is stopped
+		 */
+		udelay(3500000 / clk_get_rate(timer->fclk) + 1);
 	}
 }
 EXPORT_SYMBOL_GPL(omap_dm_timer_stop);
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdefs.h b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
index 78be880..9b7b2aa 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -305,6 +305,7 @@
 		PROC_INVALIDATE_MEM = 0,
 		PROC_WRITEBACK_MEM,
 		PROC_WRITEBACK_INVALIDATE_MEM,
+		PROC_WRBK_INV_ALL,
 	} ;
 
 /* Memory Segment Status Values */
diff --git a/arch/arm/plat-omap/include/dspbridge/mem.h b/arch/arm/plat-omap/include/dspbridge/mem.h
index 535ac3a..8d598f4 100644
--- a/arch/arm/plat-omap/include/dspbridge/mem.h
+++ b/arch/arm/plat-omap/include/dspbridge/mem.h
@@ -185,7 +185,7 @@
  *  Ensures:
  *      Cache is synchronized
  */
-	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType);
+	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType);
 
 /*
  *  ======== MEM_Free ========
diff --git a/arch/arm/plat-omap/include/dspbridge/util.h b/arch/arm/plat-omap/include/dspbridge/util.h
new file mode 100644
index 0000000..e6815ca
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/util.h
@@ -0,0 +1,122 @@
+/*
+ * util.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ *  ======== util.h ========
+ *  Purpose:
+ *      Provide general purpose utility functions.
+ *
+ *  Public Functions:
+ *      UTIL_CDTestDll
+ *      UTIL_CmdLineToArgs
+ *      UTIL_Exit
+ *      UTIL_GetSysInfo
+ *      UTIL_Init
+ */
+
+#ifndef _UTIL_H
+#define _UTIL_H
+
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <dspbridge/utildefs.h>
+
+/*
+ *  ======== UTIL_CDTestDll ========
+ *  Purpose:
+ *      Provides test entry point in class driver context.
+ *  Parameters:
+ *      cArgc:  test module command line input count.
+ *      ppArgv: test module command line args.
+ *  Returns:
+ *      0 if successful, a negative value otherwise.
+ *  Requires:
+ *      UTIL initialized.
+ *  Ensures:
+ */
+	extern u32 UTIL_CDTestDll(IN s32 cArgc, IN char **ppArgv);
+
+/*
+ *  ======== UTIL_CmdLineToArgs ========
+ *  Purpose:
+ *      This function re-creates C-style cmd line argc & argv from WinMain()
+ *      cmd line args.
+ *  Parameters:
+ *      s8 *pszProgName   - The name of the program currently being executed.
+ *      s8 *argv[]        - The argument vector.
+ *      s8 *pCmdLine      - The pointer to the command line.
+ *      bool fHasProgName   - Indicats whether a program name is supplied.
+ *  Returns:
+ *      Returns the number of arguments found.
+ *  Requires:
+ *      UTIL initialized.
+ *  Ensures:
+ */
+	extern s32 UTIL_CmdLineToArgs(IN char *pszProgName,
+				      IN char *argv[UTIL_MAXARGVS],
+				      IN char *pCmdLine, IN bool fHasProgName);
+
+/*
+ *  ======== UTIL_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      UTIL initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern inline void UTIL_Exit(void)
+	{
+	}
+/*
+ *  ======== UTIL_GetSysInfo ========
+ *  Purpose:
+ *      This function return platform specific system information.
+ *
+ *  Parameters:
+ *      pSysInfo  - address to store the system information.
+ *  Returns:
+ *      DSP_SOK
+ *      S_FAIL
+ *  Requires:
+ *      UTIL initialized.
+ *      pSysInfo != NULL
+ *  Ensures:
+ */
+	extern DSP_STATUS UTIL_GetSysInfo(OUT struct UTIL_SYSINFO *pSysInfo);
+
+/*
+ *  ======== UTIL_Init ========
+ *  Purpose:
+ *      Initializes private state of UTIL module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if success, else FALSE.
+ *  Requires:
+ *  Ensures:
+ *      UTIL initialized.
+ */
+	extern inline bool UTIL_Init(void)
+	{
+		return true;
+	}
+
+#endif				/* _UTIL_H */
diff --git a/arch/arm/plat-omap/include/mach/board-mapphone-emu_uart.h b/arch/arm/plat-omap/include/mach/board-mapphone-emu_uart.h
new file mode 100644
index 0000000..8e6f1b3
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/board-mapphone-emu_uart.h
@@ -0,0 +1,43 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-mapphone-emu_uart.h
+ *
+ * Hardware definitions for OMAP3430-based Motorola reference design.
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_MAPPHONE_EMU_UART_H
+#define __ASM_ARCH_OMAP_MAPPHONE_EMU_UART_H
+
+#ifndef TRUE
+#define TRUE     (1)
+#endif
+#ifndef FALSE
+#define FALSE    (0)
+#endif
+
+extern void activate_emu_uart(void);
+extern int is_emu_uart_iomux_reg(unsigned short offset);
+extern bool is_emu_uart_active(void);
+
+#endif /*  __ASM_ARCH_OMAP_MAPPHONE_EMU_UART_H */
diff --git a/arch/arm/plat-omap/include/mach/board-mapphone-padconf.h b/arch/arm/plat-omap/include/mach/board-mapphone-padconf.h
new file mode 100644
index 0000000..76f4943
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/board-mapphone-padconf.h
@@ -0,0 +1,135 @@
+
+/*
+ * board-mapphone-padconf.h
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __BOARD_MAPPHONE_PADCONF_H
+#define __BOARD_MAPPHONE_PADCONF_H
+
+/* core control module padconf registers are at 0x48002030 - 0x480021E2 */
+#define OMAP343X_PADCONF_CORE_CTRL_BASE (OMAP343X_CTRL_BASE + 0x030)
+#define OMAP343X_PADCONF_CORE_CTRL_TOP  (OMAP343X_CTRL_BASE + 0x1E2)
+
+/* etk padconf registers are at 0x480025D8 - 0x480025FA */
+#define OMAP343X_PADCONF_CORE_ETK_BASE  (OMAP343X_CTRL_BASE + 0x5D8)
+#define OMAP343X_PADCONF_CORE_ETK_TOP   (OMAP343X_CTRL_BASE + 0x5FA)
+
+/* d2d padconf registers are at 0x480021E4 - 0x48002264 */
+#define OMAP343X_PADCONF_CORE_D2D_BASE  (OMAP343X_CTRL_BASE + 0x1E4)
+#define OMAP343X_PADCONF_CORE_D2D_TOP   (OMAP343X_CTRL_BASE + 0x264)
+
+/* wakeup module padconf registers are at 0x48002A00 - 0x48002A26 */
+#define OMAP343X_PADCONF_WKUP_BASE  (OMAP343X_CTRL_BASE + 0xA00)
+#define OMAP343X_PADCONF_WKUP_TOP   (OMAP343X_CTRL_BASE + 0xA26)
+
+/* d2d wakeup module padconf registers are at 0x48002A4C - 0x48002A50 */
+#define OMAP343X_PADCONF_WKUP_D2D_BASE  (OMAP343X_CTRL_BASE + 0xA4C)
+#define OMAP343X_PADCONF_WKUP_D2D_TOP   (OMAP343X_CTRL_BASE + 0xA50)
+
+#define OMAP343X_PADCONF_OFF_WAKEUP_ENABLED (1 << 14)
+
+#define OMAP343X_PADCONF_OFF_PULL_UP	    (1 << 13)
+#define OMAP343X_PADCONF_OFF_PULL_DOWN	    (0 << 13)
+
+#define OMAP343X_PADCONF_OFF_PUD_ENABLED    (1 << 12)
+#define OMAP343X_PADCONF_OFF_PUD_DISABLED   (0 << 12)
+
+#define OMAP343X_PADCONF_OFF_OUTPUT_HIGH    (1 << 11)
+#define OMAP343X_PADCONF_OFF_OUTPUT_LOW	    (0 << 11)
+
+#define OMAP343X_PADCONF_OFF_OUTPUT_ENABLED (1 << 10)
+#define OMAP343X_PADCONF_OFF_OUTPUT_DISABLED	(0 << 10)
+
+#define OMAP343X_PADCONF_OFFMODE_ENABLED    (1 << 9)
+#define OMAP343X_PADCONF_OFFMODE_DISABLED   (0 << 9)
+
+#define OMAP343X_PADCONF_INPUT_ENABLED	    (1 << 8)
+
+#define OMAP343X_PADCONF_PULL_UP	    (1 << 4)
+#define OMAP343X_PADCONF_PULL_DOWN	    (0 << 4)
+
+#define OMAP343X_PADCONF_PUD_ENABLED	    (1 << 3)
+#define OMAP343X_PADCONF_PUD_DISABLED	    (0 << 3)
+
+#define OMAP343X_PADCONF_MUXMODE0   (0x00)
+#define OMAP343X_PADCONF_MUXMODE1   (0x01)
+#define OMAP343X_PADCONF_MUXMODE2   (0x02)
+#define OMAP343X_PADCONF_MUXMODE3   (0x03)
+#define OMAP343X_PADCONF_MUXMODE4   (0x04)
+#define OMAP343X_PADCONF_MUXMODE5   (0x05)
+#define OMAP343X_PADCONF_MUXMODE6   (0x06)
+#define OMAP343X_PADCONF_MUXMODE7   (0x07)
+
+#define OMAP343X_PADCONF_SETTING_MASK (OMAP343X_PADCONF_OFF_WAKEUP_ENABLED | \
+		OMAP343X_PADCONF_OFF_PULL_UP | \
+		OMAP343X_PADCONF_OFF_PUD_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_HIGH | \
+		OMAP343X_PADCONF_OFF_OUTPUT_ENABLED | \
+		OMAP343X_PADCONF_OFFMODE_ENABLED | \
+		OMAP343X_PADCONF_INPUT_ENABLED | \
+		OMAP343X_PADCONF_PULL_UP | \
+		OMAP343X_PADCONF_PUD_ENABLED | \
+		OMAP343X_PADCONF_MUXMODE7)
+
+
+#ifdef CONFIG_ARM_OF
+#define OMAP343X_PAD_MASK (OMAP343X_PADCONF_MUXMODE7 | \
+		OMAP343X_PADCONF_INPUT_ENABLED | \
+		OMAP343X_PADCONF_PUD_ENABLED | \
+		OMAP343X_PADCONF_PULL_UP)
+
+#define OMAP343X_OFFMODE_MASK (OMAP343X_PADCONF_OFFMODE_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_HIGH | \
+		OMAP343X_PADCONF_OFF_PUD_ENABLED | \
+		OMAP343X_PADCONF_OFF_PULL_UP | \
+		OMAP343X_PADCONF_OFF_WAKEUP_ENABLED)
+
+#define MAKE_OMAP343X_PAD_VALUE(mode, input_en, pull) \
+		(((u16) mode) | ((u16) input_en) << 8 | ((u16) pull) << 3)
+
+#define MAKE_OMAP343X_OFFMODE_VALUE(offmode, offout, offpull, offwkup) \
+		(((u16) (offmode) << 9) | ((u16) (offout) << 10) | \
+		((u16) (offpull) << 12) | ((u16) (offwkup) << 14))
+
+struct dt_operation {
+	const char *path;
+	const char *prop;
+	u32 prop_unit_size;
+	void (*callback) (const void *p_data);
+	u32 name_size;
+} __attribute__ ((__packed__));
+
+struct mux_conf_entry {
+	u16 offset;
+	u8 mode;
+	u8 input_en;
+	u8 pull_type;
+} __attribute__ ((__packed__));
+
+struct mux_offmode_conf_entry {
+	u16 offset;
+	u8 offmode_en;
+	u8 offout_type;
+	u8 offpull_type;
+	u8 offwkup_en;
+} __attribute__ ((__packed__));
+#endif
+
+#endif
diff --git a/arch/arm/plat-omap/include/mach/board-mapphone.h b/arch/arm/plat-omap/include/mach/board-mapphone.h
new file mode 100644
index 0000000..08ffba0
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/board-mapphone.h
@@ -0,0 +1,68 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-mapphone.h
+ *
+ * Hardware definitions for OMAP3430-based Motorola reference design.
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from include/asm-arm/arch-omap/board-3430sdp.h
+ * Initial creation by Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_MAPPHONE_H
+#define __ASM_ARCH_OMAP_MAPPHONE_H
+
+#include <linux/init.h>
+#include "board-mapphone-padconf.h"
+
+extern void __init mapphone_usb_init(void);
+extern void __init mapphone_flash_init(void);
+extern void __init mapphone_panel_init(void);
+extern void __init mapphone_sensors_init(void);
+extern void __init mapphone_spi_init(void);
+extern void __init mapphone_flash_init(void);
+extern void __init mapphone_padconf_init(void);
+extern void __init mapphone_hsmmc_init(void);
+extern void __init mapphone_gpio_mapping_init(void);
+extern void __init mapphone_camera_init(void);
+extern void __init mapphone_mmcprobe_init(void);
+
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+extern struct mt9p012_platform_data mapphone_mt9p012_platform_data;
+#endif
+#if defined(CONFIG_VIDEO_OV8810)
+extern struct ov8810_platform_data mapphone_ov8810_platform_data;
+#endif
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+extern struct hplens_platform_data mapphone_hplens_platform_data;
+#endif
+
+#define GPIO_MT9P012_STANDBY		58
+#define GPIO_MT9P012_RESET		98
+#define GPIO_SILENCE_KEY		100
+#define GPIO_SLIDER			177
+
+#define is_cdma_phone() (!strcmp("CDMA", bp_model))
+extern char *bp_model;
+
+#endif /*  __ASM_ARCH_OMAP_MAPPHONE_H */
diff --git a/arch/arm/plat-omap/include/mach/board-sholest-padconf.h b/arch/arm/plat-omap/include/mach/board-sholest-padconf.h
new file mode 100644
index 0000000..e54285f
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/board-sholest-padconf.h
@@ -0,0 +1,135 @@
+
+/*
+ * board-sholest-padconf.h
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __BOARD_SHOLEST_PADCONF_H
+#define __BOARD_SHOLEST_PADCONF_H
+
+/* core control module padconf registers are at 0x48002030 - 0x480021E2 */
+#define OMAP343X_PADCONF_CORE_CTRL_BASE (OMAP343X_CTRL_BASE + 0x030)
+#define OMAP343X_PADCONF_CORE_CTRL_TOP  (OMAP343X_CTRL_BASE + 0x1E2)
+
+/* etk padconf registers are at 0x480025D8 - 0x480025FA */
+#define OMAP343X_PADCONF_CORE_ETK_BASE  (OMAP343X_CTRL_BASE + 0x5D8)
+#define OMAP343X_PADCONF_CORE_ETK_TOP   (OMAP343X_CTRL_BASE + 0x5FA)
+
+/* d2d padconf registers are at 0x480021E4 - 0x48002264 */
+#define OMAP343X_PADCONF_CORE_D2D_BASE  (OMAP343X_CTRL_BASE + 0x1E4)
+#define OMAP343X_PADCONF_CORE_D2D_TOP   (OMAP343X_CTRL_BASE + 0x264)
+
+/* wakeup module padconf registers are at 0x48002A00 - 0x48002A26 */
+#define OMAP343X_PADCONF_WKUP_BASE  (OMAP343X_CTRL_BASE + 0xA00)
+#define OMAP343X_PADCONF_WKUP_TOP   (OMAP343X_CTRL_BASE + 0xA26)
+
+/* d2d wakeup module padconf registers are at 0x48002A4C - 0x48002A50 */
+#define OMAP343X_PADCONF_WKUP_D2D_BASE  (OMAP343X_CTRL_BASE + 0xA4C)
+#define OMAP343X_PADCONF_WKUP_D2D_TOP   (OMAP343X_CTRL_BASE + 0xA50)
+
+#define OMAP343X_PADCONF_OFF_WAKEUP_ENABLED (1 << 14)
+
+#define OMAP343X_PADCONF_OFF_PULL_UP	    (1 << 13)
+#define OMAP343X_PADCONF_OFF_PULL_DOWN	    (0 << 13)
+
+#define OMAP343X_PADCONF_OFF_PUD_ENABLED    (1 << 12)
+#define OMAP343X_PADCONF_OFF_PUD_DISABLED   (0 << 12)
+
+#define OMAP343X_PADCONF_OFF_OUTPUT_HIGH    (1 << 11)
+#define OMAP343X_PADCONF_OFF_OUTPUT_LOW	    (0 << 11)
+
+#define OMAP343X_PADCONF_OFF_OUTPUT_ENABLED (1 << 10)
+#define OMAP343X_PADCONF_OFF_OUTPUT_DISABLED	(0 << 10)
+
+#define OMAP343X_PADCONF_OFFMODE_ENABLED    (1 << 9)
+#define OMAP343X_PADCONF_OFFMODE_DISABLED   (0 << 9)
+
+#define OMAP343X_PADCONF_INPUT_ENABLED	    (1 << 8)
+
+#define OMAP343X_PADCONF_PULL_UP	    (1 << 4)
+#define OMAP343X_PADCONF_PULL_DOWN	    (0 << 4)
+
+#define OMAP343X_PADCONF_PUD_ENABLED	    (1 << 3)
+#define OMAP343X_PADCONF_PUD_DISABLED	    (0 << 3)
+
+#define OMAP343X_PADCONF_MUXMODE0   (0x00)
+#define OMAP343X_PADCONF_MUXMODE1   (0x01)
+#define OMAP343X_PADCONF_MUXMODE2   (0x02)
+#define OMAP343X_PADCONF_MUXMODE3   (0x03)
+#define OMAP343X_PADCONF_MUXMODE4   (0x04)
+#define OMAP343X_PADCONF_MUXMODE5   (0x05)
+#define OMAP343X_PADCONF_MUXMODE6   (0x06)
+#define OMAP343X_PADCONF_MUXMODE7   (0x07)
+
+#define OMAP343X_PADCONF_SETTING_MASK (OMAP343X_PADCONF_OFF_WAKEUP_ENABLED | \
+		OMAP343X_PADCONF_OFF_PULL_UP | \
+		OMAP343X_PADCONF_OFF_PUD_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_HIGH | \
+		OMAP343X_PADCONF_OFF_OUTPUT_ENABLED | \
+		OMAP343X_PADCONF_OFFMODE_ENABLED | \
+		OMAP343X_PADCONF_INPUT_ENABLED | \
+		OMAP343X_PADCONF_PULL_UP | \
+		OMAP343X_PADCONF_PUD_ENABLED | \
+		OMAP343X_PADCONF_MUXMODE7)
+
+
+#ifdef CONFIG_ARM_OF
+#define OMAP343X_PAD_MASK (OMAP343X_PADCONF_MUXMODE7 | \
+		OMAP343X_PADCONF_INPUT_ENABLED | \
+		OMAP343X_PADCONF_PUD_ENABLED | \
+		OMAP343X_PADCONF_PULL_UP)
+
+#define OMAP343X_OFFMODE_MASK (OMAP343X_PADCONF_OFFMODE_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_ENABLED | \
+		OMAP343X_PADCONF_OFF_OUTPUT_HIGH | \
+		OMAP343X_PADCONF_OFF_PUD_ENABLED | \
+		OMAP343X_PADCONF_OFF_PULL_UP | \
+		OMAP343X_PADCONF_OFF_WAKEUP_ENABLED)
+
+#define MAKE_OMAP343X_PAD_VALUE(mode, input_en, pull) \
+		(((u16) mode) | ((u16) input_en) << 8 | ((u16) pull) << 3)
+
+#define MAKE_OMAP343X_OFFMODE_VALUE(offmode, offout, offpull, offwkup) \
+		(((u16) (offmode) << 9) | ((u16) (offout) << 10) | \
+		((u16) (offpull) << 12) | ((u16) (offwkup) << 14))
+
+struct dt_operation {
+	const char *path;
+	const char *prop;
+	u32 prop_unit_size;
+	void (*callback) (const void *p_data);
+	u32 name_size;
+} __attribute__ ((__packed__));
+
+struct mux_conf_entry {
+	u16 offset;
+	u8 mode;
+	u8 input_en;
+	u8 pull_type;
+} __attribute__ ((__packed__));
+
+struct mux_offmode_conf_entry {
+	u16 offset;
+	u8 offmode_en;
+	u8 offout_type;
+	u8 offpull_type;
+	u8 offwkup_en;
+} __attribute__ ((__packed__));
+#endif
+
+#endif
diff --git a/arch/arm/plat-omap/include/mach/board-sholest.h b/arch/arm/plat-omap/include/mach/board-sholest.h
new file mode 100644
index 0000000..1796f78
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/board-sholest.h
@@ -0,0 +1,73 @@
+/*
+ * linux/include/asm-arm/arch-omap/board-sholest.h
+ *
+ * Hardware definitions for OMAP3430-based Motorola reference design.
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Derived from include/asm-arm/arch-omap/board-3430sdp.h
+ * Initial creation by Syed Mohammed Khasim
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP_SHOLEST_H
+#define __ASM_ARCH_OMAP_SHOLEST_H
+
+#include <linux/init.h>
+#include "board-sholest-padconf.h"
+
+extern void __init sholest_usb_init(void);
+extern void __init sholest_flash_init(void);
+extern void __init sholest_panel_init(void);
+extern void __init sholest_sensors_init(void);
+extern void __init sholest_spi_init(void);
+extern void __init sholest_flash_init(void);
+extern void __init sholest_padconf_init(void);
+extern void __init sholest_hsmmc_init(void);
+extern void __init sholest_gpio_mapping_init(void);
+extern void __init sholest_camera_init(void);
+extern void __init sholest_mmcprobe_init(void);
+
+#if defined(CONFIG_VIDEO_MT9P012) || defined(CONFIG_VIDEO_MT9P012_MODULE)
+extern struct mt9p012_platform_data sholest_mt9p012_platform_data;
+#endif
+#if defined(CONFIG_VIDEO_OV8810)
+extern struct ov8810_platform_data sholest_ov8810_platform_data;
+#endif
+#ifdef CONFIG_VIDEO_OMAP3_HPLENS
+extern struct hplens_platform_data sholest_hplens_platform_data;
+#endif
+
+#define GPIO_CAMERA_RESET   98
+#define GPIO_SILENCE_KEY    110
+#if defined(CONFIG_VIDEO_OV8810)
+#define GPIO_OV8810_RESET	98
+#define GPIO_OV8810_STANDBY	64
+#endif
+
+#define OMAP_MCAM_SRC_CLK		864000000
+#define OMAP_MCAM_SRC_DIV		4
+
+#define is_cdma_phone() (!strcmp("CDMA", bp_model))
+extern char *bp_model;
+
+#endif /*  __ASM_ARCH_OMAP_SHOLEST_H */
diff --git a/arch/arm/plat-omap/include/mach/clock.h b/arch/arm/plat-omap/include/mach/clock.h
index 3927781..73368e0 100644
--- a/arch/arm/plat-omap/include/mach/clock.h
+++ b/arch/arm/plat-omap/include/mach/clock.h
@@ -36,6 +36,7 @@ struct dpll_data {
 	u32			mult_mask;
 	u32			div1_mask;
 	unsigned long		last_rounded_rate;
+	unsigned long		default_rate;
 	unsigned int		rate_tolerance;
 	u32			max_tolerance;
 	struct clk		*bypass_clk;
diff --git a/arch/arm/plat-omap/include/mach/display.h b/arch/arm/plat-omap/include/mach/display.h
index 85a5a93..f3f3066 100644
--- a/arch/arm/plat-omap/include/mach/display.h
+++ b/arch/arm/plat-omap/include/mach/display.h
@@ -345,6 +345,9 @@ struct omap_overlay_manager {
 	void (*get_manager_info)(struct omap_overlay_manager *mgr,
 			struct omap_overlay_manager_info *info);
 
+	void (*enable_alpha_blending)(struct omap_overlay_manager *mgr,
+		bool enable);
+
 	int (*apply)(struct omap_overlay_manager *mgr);
 	int (*wait_for_go)(struct omap_overlay_manager *mgr);
 };
@@ -503,7 +506,7 @@ struct omap_dss_driver {
 	int (*enable_te)(struct omap_dss_device *dssdev, bool enable);
 	int (*wait_for_te)(struct omap_dss_device *dssdev);
 
-	u8 (*get_rotate)(struct omap_dss_device *dssdev);
+    u8 (*get_rotate)(struct omap_dss_device *dssdev);
 	int (*set_rotate)(struct omap_dss_device *dssdev, u8 rotate);
 
 	bool (*get_mirror)(struct omap_dss_device *dssdev);
diff --git a/arch/arm/plat-omap/include/mach/dt_path.h b/arch/arm/plat-omap/include/mach/dt_path.h
new file mode 100644
index 0000000..1acc4da
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/dt_path.h
@@ -0,0 +1,107 @@
+/*
+ * File: arch/arm/plat-omap/include/mach/dt_path.h
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+/* Date	 Author	  Comment
+ * ===========  ==============  ==============================================
+ * Jun-08-2009  Motorola	Add MUX node
+ * Jun-10-2009  Motorola    Add GPIO node
+ */
+
+
+
+#ifndef _MACH_DT_PATH_H
+#define _MACH_DT_PATH_H
+#ifdef __KERNEL__
+
+/* Chosen */
+#define DT_PATH_CHOSEN		"/Chosen@0"
+#define DT_PROP_CHOSEN_BP	"bp_model"
+#define DT_PROP_CHOSEN_BP_LEN	16
+
+/* Keypad Node */
+#define DT_PATH_KEYPAD		"/System@0/Keypad@0"
+#define DT_PROP_KEYPAD_ROWS	"rows"
+#define DT_PROP_KEYPAD_COLS	"columns"
+#define DT_PROP_KEYPAD_ROWREG	"rowregister"
+#define DT_PROP_KEYPAD_COLREG	"columnregister"
+#define DT_PROP_KEYPAD_MAPNUM	"mapnum"
+#define DT_PROP_KEYPAD_MAPS	"maps"
+#define DT_PROP_KEYPAD_CLOSED_MAPS "closed_maps"
+#define DT_PROP_KEYPAD_NAME	"name"
+
+/* GPIODev Node */
+#define DT_PATH_GPIOGEV		"/System@0/GPIODev@0"
+#define DT_PROP_GPIODEV_INIT	"init"
+
+/* MUX Node */
+#define DT_PATH_MUX		"/System@0/IOMUX@0"
+#define DT_PROP_MUX_PAD	"padinit"
+#define DT_PROP_MUX_PADWKUPS	"padwkupsinit"
+#define DT_PROP_MUX_OFFMODE		"offmodeinit"
+#define DT_PROP_MUX_OFFMODEWKUPS	"offmodewkupsinit"
+
+/* Touch Node */
+#define DT_PATH_TOUCH		"/System@0/I2C@0/TouchOBP@0"
+#define DT_PROP_TOUCH_KEYMAP	"touch_key_map"
+#define DT_PROP_TOUCH_I2C_ADDRESS       "i2c,address"
+#define DT_PROP_TOUCH_KEYMAP		"touch_key_map"
+#define DT_PROP_TOUCH_NUM_TOUCH_KEYS	"number_of_touch_keys"
+#define DT_PROP_TOUCH_FLAGS		"touchobp-flags"
+#define DT_PROP_TOUCH_ABS_MIN_X		"abs_min_x"
+#define DT_PROP_TOUCH_ABS_MAX_X		"abs_max_x"
+#define DT_PROP_TOUCH_ABS_MIN_Y		"abs_min_y"
+#define DT_PROP_TOUCH_ABS_MAX_Y		"abs_max_y"
+#define DT_PROP_TOUCH_ABS_MIN_P		"abs_min_p"
+#define DT_PROP_TOUCH_ABS_MAX_P		"abs_max_p"
+#define DT_PROP_TOUCH_ABS_MIN_W		"abs_min_w"
+#define DT_PROP_TOUCH_ABS_MAX_W		"abs_max_w"
+#define DT_PROP_TOUCH_FUZZ_X		"fuzz_x"
+#define DT_PROP_TOUCH_FUZZ_Y		"fuzz_y"
+#define DT_PROP_TOUCH_FUZZ_P		"fuzz_p"
+#define DT_PROP_TOUCH_FUZZ_W		"fuzz_w"
+#define DT_PROP_TOUCH_KEY_ARRAY_MAP	"key_array_map"
+#define DT_PROP_TOUCH_KEY_ARRAY_COUNT	"key_array_count"
+#define DT_PROP_TOUCH_T7		"obj_t7"	/* power_cfg */
+#define DT_PROP_TOUCH_T8		"obj_t8"	/* acquire_cfg */
+#define DT_PROP_TOUCH_T9		"obj_t9"	/* multi_touch_cfg */
+#define DT_PROP_TOUCH_T15		"obj_t15"	/* key_array */
+#define DT_PROP_TOUCH_T17		"obj_t17"	/* linear_tbl_cfg */
+#define DT_PROP_TOUCH_T19		"obj_t19"	/* gpio_pwm_cfg */
+#define DT_PROP_TOUCH_T20		"obj_t20"	/* grip_suppression_cfg */
+#define DT_PROP_TOUCH_T22		"obj_t22"	/* noise_suppression_cfg */
+#define DT_PROP_TOUCH_T24		"obj_t24"	/* one_touch_gesture_proc_cfg */
+#define DT_PROP_TOUCH_T25		"obj_t25"	/* self_test_cfg */
+#define DT_PROP_TOUCH_T27		"obj_t27"	/* two_touch_gesture_proc_cfg */
+#define DT_PROP_TOUCH_T28		"obj_t28"	/* cte_config_cfg */
+
+/* Accelerometer Node */
+#define DT_PATH_LIS331DLH	"/System@0/I2C@0/Accelerometer@0"
+
+/* GPIO Node */
+#define DT_PATH_GPIO        "/System@0/GPIO@0"
+#define DT_PROP_GPIO_MAP    "signalmap"
+
+/* CPCAP Node */
+#define DT_PATH_CPCAP			"/System@0/SPI@0/PowerIC@0"
+#define DT_PROP_CPCAP_SPIINIT	 "spiinit"
+#define DT_PROP_CPCAP_RGTINIT	 "regulator_init"
+#define DT_PROP_CPCAP_RGTMODE	 "regulator_mode"
+#define DT_PROP_CPCAP_RGTOFFMODE "regulator_off_mode"
+#endif
+#endif
diff --git a/arch/arm/plat-omap/include/mach/gpmc.h b/arch/arm/plat-omap/include/mach/gpmc.h
index a37cfc6..299c227 100644
--- a/arch/arm/plat-omap/include/mach/gpmc.h
+++ b/arch/arm/plat-omap/include/mach/gpmc.h
@@ -62,8 +62,72 @@
 #define GPMC_CONFIG1_FCLK_DIV2          (GPMC_CONFIG1_FCLK_DIV(1))
 #define GPMC_CONFIG1_FCLK_DIV3          (GPMC_CONFIG1_FCLK_DIV(2))
 #define GPMC_CONFIG1_FCLK_DIV4          (GPMC_CONFIG1_FCLK_DIV(3))
+
+extern void __iomem *gpmc_base;
+#define gpmc_write_reg(idx, val)     __raw_writel((val), gpmc_base + (idx))
+#define gpmc_read_reg(idx)            __raw_readl(gpmc_base + (idx))
+
 #define GPMC_CONFIG7_CSVALID		(1 << 6)
 
+#define GPMC_PREFETCH_CONFIG1	0x1e0
+#define GPMC_PREFETCH_CONFIG2	0x1e4
+#define GPMC_PREFETCH_CONTROL	0x1ec
+
+
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+
+#define GPMC_PREFETCH_CONFIG1_INIT   0x4000
+#define GPMC_PREFETCH_STATUS	0x1f0
+#define CS_NUM_SHIFT		24
+#define ENABLE_PREFETCH		7
+#define DMA_MPU_MODE		2
+
+static inline void gpmc_prefetch_start(int cs, int dma_mode,
+					unsigned int u32_count, int is_write)
+{
+	uint32_t prefetch_config1;
+
+		/* Set the amount of bytes to be prefetched */
+		gpmc_write_reg(GPMC_PREFETCH_CONFIG2, u32_count);
+
+		/* Set dma/mpu mode, the prefetch read / post write and
+		 * enable the engine Set which cs is using the post write
+		 */
+		prefetch_config1 = GPMC_PREFETCH_CONFIG1_INIT |
+					((cs << CS_NUM_SHIFT) |
+					(dma_mode << DMA_MPU_MODE) |
+					(1 << ENABLE_PREFETCH) |
+					(is_write & 0x1));
+		gpmc_write_reg(GPMC_PREFETCH_CONFIG1, prefetch_config1);
+
+	/*  Start the prefetch engine */
+	gpmc_write_reg(GPMC_PREFETCH_CONTROL, 0x1);
+}
+
+/*
+ * gpmc_prefetch_stop - disables and stops the prefetch engine
+ */
+static inline void gpmc_prefetch_stop(void)
+{
+	uint32_t prefetch_config1;
+	/* stop the PFPW engine */
+	gpmc_write_reg(GPMC_PREFETCH_CONTROL, 0x0);
+
+	/* Disable the PFPW engine */
+	prefetch_config1 = gpmc_read_reg(GPMC_PREFETCH_CONFIG1);
+	prefetch_config1 &= ~((0x07 << CS_NUM_SHIFT) |
+				(1 << ENABLE_PREFETCH) |
+					(1 << DMA_MPU_MODE) | 0x1);
+	gpmc_write_reg(GPMC_PREFETCH_CONFIG1, prefetch_config1);
+}
+
+/*
+ * gpmc_prefetch_status - reads prefetch status of engine
+ */
+#define gpmc_prefetch_status()  gpmc_read_reg(GPMC_PREFETCH_STATUS)
+
+#endif
+
 /*
  * Note that all values in this struct are in nanoseconds, while
  * the register values are in gpmc_fck cycles.
diff --git a/arch/arm/plat-omap/include/mach/hardware.h b/arch/arm/plat-omap/include/mach/hardware.h
index 659300e..9a06f93 100644
--- a/arch/arm/plat-omap/include/mach/hardware.h
+++ b/arch/arm/plat-omap/include/mach/hardware.h
@@ -12,6 +12,8 @@
  * Reorganized for Linux-2.6 by Tony Lindgren <tony@atomide.com>
  *                          and Dirk Behme <dirk.behme@de.bosch.com>
  *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; either version 2 of the License, or (at your
@@ -379,6 +381,15 @@
 #include "board-sx1.h"
 #endif
 
+#ifdef CONFIG_MACH_SHOLEST
+#include "board-sholest.h"
+#else /* !CONFIG_MACH_SHOLEST */
+
+#ifdef CONFIG_MACH_MAPPHONE
+#include "board-mapphone.h"
+#endif
+
+#endif
 #endif /* !__ASSEMBLER__ */
 
 #endif	/* __ASM_ARCH_OMAP_HARDWARE_H */
diff --git a/arch/arm/plat-omap/include/mach/memory.h b/arch/arm/plat-omap/include/mach/memory.h
index 0b94bff..c78e055 100644
--- a/arch/arm/plat-omap/include/mach/memory.h
+++ b/arch/arm/plat-omap/include/mach/memory.h
@@ -9,6 +9,8 @@
  * This file was derived from arch/arm/mach-intergrator/include/mach/memory.h
  * Copyright (C) 1999 ARM Limited
  *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
  * Free Software Foundation; either version 2 of the License, or (at your
@@ -38,7 +40,7 @@
  */
 #if defined(CONFIG_ARCH_OMAP1)
 #define PHYS_OFFSET		UL(0x10000000)
-#elif defined(CONFIG_MACH_SHOLES_UMTS)
+#elif defined(CONFIG_MACH_SHOLES_UMTS) || defined(CONFIG_MACH_MAPPHONE)
 #define PHYS_OFFSET		UL(0x80C00000)
 #elif defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3)
 #define PHYS_OFFSET		UL(0x80000000)
diff --git a/arch/arm/plat-omap/include/mach/mux.h b/arch/arm/plat-omap/include/mach/mux.h
index 98e0a00..3ecbb1a 100644
--- a/arch/arm/plat-omap/include/mach/mux.h
+++ b/arch/arm/plat-omap/include/mach/mux.h
@@ -923,8 +923,10 @@ enum omap34xx_index {
 	C25_34XX_CAM_XCLKA,
 	C27_34XX_CAM_PCLK,
 	C23_34XX_CAM_FLD,
+#ifndef CONFIG_VIDEO_MIPI_INTERFACE
 	AG17_34XX_CAM_D0,
 	AH17_34XX_CAM_D1,
+#endif
 	B24_34XX_CAM_D2,
 	C24_34XX_CAM_D3,
 	D24_34XX_CAM_D4,
@@ -939,7 +941,42 @@ enum omap34xx_index {
 	B23_34XX_CAM_WEN,
 	D25_34XX_CAM_STROBE,
 	K8_34XX_GPMC_WAIT2,
-
+	H2_34XX_GPMC_A3,
+
+	/* MDTV, INT&SPI */
+	F1_34XX_MDTV_INT_OFF,
+	AC3_34XX_MDTV_SIMO_OFF,
+	AD4_34XX_MDTV_SOMI_OFF,
+	AD3_34XX_MDTV_CS_OFF,
+	AA3_34XX_MDTV_CLK_OFF,
+	F1_34XX_MDTV_INT_ON,
+	AC3_34XX_MDTV_SIMO_ON,
+	AD4_34XX_MDTV_SOMI_ON,
+	AD3_34XX_MDTV_CS_ON,
+	AA3_34XX_MDTV_CLK_ON,
+
+	/* DSS */
+#ifdef CONFIG_PANEL_HDTV
+	AG22_34XX_DSS_DATA0,
+	AH22_34XX_DSS_DATA1,
+	AG23_34XX_DSS_DATA2,
+	AH23_34XX_DSS_DATA3,
+	AG24_34XX_DSS_DATA4,
+	AH24_34XX_DSS_DATA5,
+#endif
+	D25_34XX_GPIO109,
+#ifdef CONFIG_VIB_PWM
+	AF22_34XX_GPIO9_OUT,
+#endif
+#if defined(CONFIG_VIDEO_MIPI_INTERFACE)
+	/*MIPI Camra*/
+	AG17_34XX_CAM_D0,
+	AH17_34XX_CAM_D1,
+	AD17_34XX_CSI2_DX0,
+	AE18_34XX_CSI2_DY0,
+	AD16_34XX_CSI2_DX1,
+	AE17_34XX_CSI2_DY1,
+#endif/*CONFIG_VIDEO_MIPI_INTERFACE*/
 };
 
 struct omap_mux_cfg {
diff --git a/arch/arm/plat-omap/include/mach/oldisp_user.h b/arch/arm/plat-omap/include/mach/oldisp_user.h
index 510f324..18826b6 100644
--- a/arch/arm/plat-omap/include/mach/oldisp_user.h
+++ b/arch/arm/plat-omap/include/mach/oldisp_user.h
@@ -45,6 +45,13 @@
    _IOWR('V', BASE_VIDIOC_PRIVATE + 12, struct isprsz_coef)
 #define VIDIOC_PRIVATE_ISP_RSZ_CFG \
    _IOWR('V', BASE_VIDIOC_PRIVATE + 13, struct isprsz_coef)
+#define VIDIOC_PRIVATE_ISP_HARDPIPE_CLEAR \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 14, struct ispprv_run_hardpipe)
+#define VIDIOC_PRIVATE_ISP_CCDC_BAYER_CFG \
+   _IOWR('V', BASE_VIDIOC_PRIVATE + 15, struct ispccdc_color_offset)
+#define VIDIOC_PRIVATE_ISP_LSC_WORKAROUND_CFG \
+   _IOW('V', BASE_VIDIOC_PRIVATE + 16, int)
+
 
 /* AE/AWB related structures and flags*/
 
@@ -699,5 +706,8 @@ struct ispprv_run_hardpipe {
 	__u32 crop_height;
 };
 
+struct ispccdc_color_offset{
+	__u16 offsetcode;
+};
 
 #endif /* OMAP_ISP_USER_H */
diff --git a/arch/arm/plat-omap/include/mach/powerdomain.h b/arch/arm/plat-omap/include/mach/powerdomain.h
index 6271d85..8375dd0 100644
--- a/arch/arm/plat-omap/include/mach/powerdomain.h
+++ b/arch/arm/plat-omap/include/mach/powerdomain.h
@@ -37,6 +37,8 @@
 
 #define PWRSTS_OFF_RET_ON	(PWRSTS_OFF_RET | (1 << PWRDM_POWER_ON))
 
+#define PWRSTS_RET_ON		((1 << PWRDM_POWER_RET) | \
+				1 << PWRDM_POWER_ON)
 
 /* Powerdomain flags */
 #define PWRDM_HAS_HDWR_SAR	(1 << 0) /* hardware save-and-restore support */
diff --git a/arch/arm/plat-omap/include/mach/prcm.h b/arch/arm/plat-omap/include/mach/prcm.h
index d0cbe80..cc61de8 100644
--- a/arch/arm/plat-omap/include/mach/prcm.h
+++ b/arch/arm/plat-omap/include/mach/prcm.h
@@ -25,7 +25,8 @@
 
 u32 omap_prcm_get_reset_sources(void);
 void omap_prcm_arch_reset(char mode);
-
+extern void omap2_block_sleep(void);
+extern void omap2_allow_sleep(void);
 void cm_write_mod_reg(u32 val, s16 module, u16 idx);
 u32 cm_read_mod_reg(s16 module, u16 idx);
 u32 cm_rmw_mod_reg_bits(u32 mask, u32 bits, s16 module, s16 idx);
diff --git a/arch/arm/plat-omap/resource.c b/arch/arm/plat-omap/resource.c
index 009a5a5..4c95764 100644
--- a/arch/arm/plat-omap/resource.c
+++ b/arch/arm/plat-omap/resource.c
@@ -310,34 +310,20 @@ int resource_unregister(struct shared_resource *resp)
 }
 EXPORT_SYMBOL(resource_unregister);
 
-/**
- * resource_request - Request for a required level of a resource
- * @name: The name of the resource requested
- * @dev: Uniquely identifes the caller
- * @level: The requested level for the resource
+/* _resource_request - Request for a required level of a resource
  *
- * This function recomputes the target level of the resource based on
- * the level requested by the user. The level of the resource is
- * changed to the target level, if it is not the same as the existing level
- * of the resource. Multiple calls to this function by the same device will
- * replace the previous level requested
- * Returns 0 on success, -EINVAL if the resource name passed in invalid.
- * -ENOMEM if no static pool available or dynamic allocations fails.
- * Else returns a non-zero error value returned by one of the failing
- * shared_resource_ops.
- */
-int resource_request(const char *name, struct device *dev,
-					unsigned long level)
+ * The res_mutex isn't needed to be required for this function, which
+ * can avoid a deadlock in set_opp()/set_freq() in which res_mutex will
+ * be required couple of times in a single excution path.
+ * */
+int _resource_request(struct shared_resource *resp, struct device *dev,
+		unsigned long level)
 {
-	struct shared_resource *resp;
 	struct  users_list *user;
 	int 	found = 0, ret = 0;
 
-	resp = resource_lookup(name);
-	if (!resp) {
-		printk(KERN_ERR "resource_request: Invalid resource name\n");
+	if (!resp)
 		return -EINVAL;
-	}
 
 	mutex_lock(&resp->resource_mutex);
 	/* Call the resource specific validate function */
@@ -374,32 +360,53 @@ res_unlock:
 	mutex_unlock(&resp->resource_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(resource_request);
 
 /**
- * resource_release - Release a previously requested level of a resource
- * @name: The name of the resource to be released
+ * resource_request - Request for a required level of a resource
+ * @name: The name of the resource requested
  * @dev: Uniquely identifes the caller
+ * @level: The requested level for the resource
  *
- * This function recomputes the target level of the resource after removing
+ * This function recomputes the target level of the resource based on
  * the level requested by the user. The level of the resource is
  * changed to the target level, if it is not the same as the existing level
- * of the resource.
- * Returns 0 on success, -EINVAL if the resource name or dev structure
- * is invalid.
+ * of the resource. Multiple calls to this function by the same device will
+ * replace the previous level requested
+ * Returns 0 on success, -EINVAL if the resource name passed in invalid.
+ * -ENOMEM if no static pool available or dynamic allocations fails.
+ * Else returns a non-zero error value returned by one of the failing
+ * shared_resource_ops.
  */
-int resource_release(const char *name, struct device *dev)
+int resource_request(const char *name, struct device *dev,
+					unsigned long level)
 {
 	struct shared_resource *resp;
-	struct users_list *user;
-	int found = 0, ret = 0;
 
 	resp = resource_lookup(name);
 	if (!resp) {
-		printk(KERN_ERR "resource_release: Invalid resource name\n");
+		printk(KERN_ERR "resource_request: Invalid resource name\n");
 		return -EINVAL;
 	}
 
+	return _resource_request(resp, dev, level);
+}
+EXPORT_SYMBOL(resource_request);
+
+
+/* _resource_release - Release a previously requested level of a resource
+ *
+ * The res_mutex isn't needed to be required for this function, which
+ * can avoid a deadlock in set_opp()/set_freq() in which res_mutex will
+ * be required couple of times in a single excution path.
+ * */
+int _resource_release(struct shared_resource *resp, struct device *dev)
+{
+	struct users_list *user;
+	int found = 0, ret = 0;
+
+	if (!resp)
+		return -EINVAL;
+
 	mutex_lock(&resp->resource_mutex);
 	list_for_each_entry(user, &resp->users_list, node) {
 		if (user->dev == dev) {
@@ -424,6 +431,31 @@ res_unlock:
 	mutex_unlock(&resp->resource_mutex);
 	return ret;
 }
+
+/**
+ * resource_release - Release a previously requested level of a resource
+ * @name: The name of the resource to be released
+ * @dev: Uniquely identifes the caller
+ *
+ * This function recomputes the target level of the resource after removing
+ * the level requested by the user. The level of the resource is
+ * changed to the target level, if it is not the same as the existing level
+ * of the resource.
+ * Returns 0 on success, -EINVAL if the resource name or dev structure
+ * is invalid.
+ */
+int resource_release(const char *name, struct device *dev)
+{
+	struct shared_resource *resp;
+
+	resp = resource_lookup(name);
+	if (!resp) {
+		printk(KERN_ERR "resource_release: Invalid resource name\n");
+		return -EINVAL;
+	}
+
+	return _resource_release(resp, dev);
+}
 EXPORT_SYMBOL(resource_release);
 
 /**
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index b974a1b..2dbc148 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -12,7 +12,7 @@
 #
 #   http://www.arm.linux.org.uk/developer/machines/?action=new
 #
-# Last update: Thu Mar 12 18:01:45 2009
+# Last update: Wed May 20 22:41:24 2009
 #
 # machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
 #
@@ -916,7 +916,7 @@ nxdb500			MACH_NXDB500		NXDB500			905
 apf9328			MACH_APF9328		APF9328			906
 omap_wipoq		MACH_OMAP_WIPOQ		OMAP_WIPOQ		907
 omap_twip		MACH_OMAP_TWIP		OMAP_TWIP		908
-palmt650		MACH_PALMT650		PALMT650		909
+treo650			MACH_TREO650		TREO650			909
 acumen			MACH_ACUMEN		ACUMEN			910
 xp100			MACH_XP100		XP100			911
 fs2410			MACH_FS2410		FS2410			912
@@ -1418,10 +1418,10 @@ looxc550		MACH_LOOXC550		LOOXC550		1417
 cnty_titan		MACH_CNTY_TITAN		CNTY_TITAN		1418
 app3xx			MACH_APP3XX		APP3XX			1419
 sideoatsgrama		MACH_SIDEOATSGRAMA	SIDEOATSGRAMA		1420
-palmtreo700p		MACH_PALMTREO700P	PALMTREO700P		1421
-palmtreo700w		MACH_PALMTREO700W	PALMTREO700W		1422
-palmtreo750		MACH_PALMTREO750	PALMTREO750		1423
-palmtreo755p		MACH_PALMTREO755P	PALMTREO755P		1424
+treo700p		MACH_TREO700P		TREO700P		1421
+treo700w		MACH_TREO700W		TREO700W		1422
+treo750			MACH_TREO750		TREO750			1423
+treo755p		MACH_TREO755P		TREO755P		1424
 ezreganut9200		MACH_EZREGANUT9200	EZREGANUT9200		1425
 sarge			MACH_SARGE		SARGE			1426
 a696			MACH_A696		A696			1427
@@ -1721,7 +1721,7 @@ sapphire		MACH_SAPPHIRE		SAPPHIRE		1729
 csb637xo		MACH_CSB637XO		CSB637XO		1730
 evisiong		MACH_EVISIONG		EVISIONG		1731
 stmp37xx		MACH_STMP37XX		STMP37XX		1732
-stmp378x		MACH_STMP38XX		STMP38XX		1733
+stmp378x		MACH_STMP378X		STMP378X		1733
 tnt			MACH_TNT		TNT			1734
 tbxt			MACH_TBXT		TBXT			1735
 playmate		MACH_PLAYMATE		PLAYMATE		1736
@@ -1817,7 +1817,7 @@ smdkc100		MACH_SMDKC100		SMDKC100		1826
 tavorevb		MACH_TAVOREVB		TAVOREVB		1827
 saar			MACH_SAAR		SAAR			1828
 deister_eyecam		MACH_DEISTER_EYECAM	DEISTER_EYECAM		1829
-at91sam9m10ek		MACH_AT91SAM9M10EK	AT91SAM9M10EK		1830
+at91sam9m10g45ek	MACH_AT91SAM9M10G45EK	AT91SAM9M10G45EK	1830
 linkstation_produo	MACH_LINKSTATION_PRODUO	LINKSTATION_PRODUO	1831
 hit_b0			MACH_HIT_B0		HIT_B0			1832
 adx_rmu			MACH_ADX_RMU		ADX_RMU			1833
@@ -2124,4 +2124,107 @@ mx27wallace		MACH_MX27WALLACE	MX27WALLACE		2133
 fmzwebmodul		MACH_FMZWEBMODUL	FMZWEBMODUL		2134
 rd78x00_masa		MACH_RD78X00_MASA	RD78X00_MASA		2135
 smallogger		MACH_SMALLOGGER		SMALLOGGER		2136
+ccw9p9215		MACH_CCW9P9215		CCW9P9215		2137
+dm355_leopard		MACH_DM355_LEOPARD	DM355_LEOPARD		2138
+ts219			MACH_TS219		TS219			2139
+tny_a9263		MACH_TNY_A9263		TNY_A9263		2140
+apollo			MACH_APOLLO		APOLLO			2141
+at91cap9stk		MACH_AT91CAP9STK	AT91CAP9STK		2142
+spc300			MACH_SPC300		SPC300			2143
+eko			MACH_EKO		EKO			2144
+ccw9m2443		MACH_CCW9M2443		CCW9M2443		2145
+ccw9m2443js		MACH_CCW9M2443JS	CCW9M2443JS		2146
+m2m_router_device	MACH_M2M_ROUTER_DEVICE	M2M_ROUTER_DEVICE	2147
+str9104nas		MACH_STAR9104NAS	STAR9104NAS		2148
+pca100			MACH_PCA100		PCA100			2149
+z3_dm365_mod_01		MACH_Z3_DM365_MOD_01	Z3_DM365_MOD_01		2150
+hipox			MACH_HIPOX		HIPOX			2151
+omap3_piteds		MACH_OMAP3_PITEDS	OMAP3_PITEDS		2152
+bm150r			MACH_BM150R		BM150R			2153
+tbone			MACH_TBONE		TBONE			2154
+merlin			MACH_MERLIN		MERLIN			2155
+falcon			MACH_FALCON		FALCON			2156
+davinci_da850_evm	MACH_DAVINCI_DA850_EVM	DAVINCI_DA850_EVM	2157
+s5p6440			MACH_S5P6440		S5P6440			2158
+at91sam9g10ek		MACH_AT91SAM9G10EK	AT91SAM9G10EK		2159
+omap_4430sdp		MACH_OMAP_4430SDP	OMAP_4430SDP		2160
+lpc313x			MACH_LPC313X		LPC313X			2161
+magx_zn5		MACH_MAGX_ZN5		MAGX_ZN5		2162
+magx_em30		MACH_MAGX_EM30		MAGX_EM30		2163
+magx_ve66		MACH_MAGX_VE66		MAGX_VE66		2164
+meesc			MACH_MEESC		MEESC			2165
+otc570			MACH_OTC570		OTC570			2166
+bcu2412			MACH_BCU2412		BCU2412			2167
+beacon			MACH_BEACON		BEACON			2168
+actia_tgw		MACH_ACTIA_TGW		ACTIA_TGW		2169
+e4430			MACH_E4430		E4430			2170
+ql300			MACH_QL300		QL300			2171
+btmavb101		MACH_BTMAVB101		BTMAVB101		2172
+btmawb101		MACH_BTMAWB101		BTMAWB101		2173
+sq201			MACH_SQ201		SQ201			2174
+quatro45xx		MACH_QUATRO45XX		QUATRO45XX		2175
+openpad			MACH_OPENPAD		OPENPAD			2176
+tx25			MACH_TX25		TX25			2177
+omap3_torpedo		MACH_OMAP3_TORPEDO	OMAP3_TORPEDO		2178
+htcraphael_k		MACH_HTCRAPHAEL_K	HTCRAPHAEL_K		2179
+lal43			MACH_LAL43		LAL43			2181
+htcraphael_cdma500	MACH_HTCRAPHAEL_CDMA500	HTCRAPHAEL_CDMA500	2182
+anw6410			MACH_ANW6410		ANW6410			2183
+deletethis		MACH_HPCPROPHET		HPCPROPHET		2184
+htcprophet		MACH_HTCPROPHET		HTCPROPHET		2185
+cfa_10022		MACH_CFA_10022		CFA_10022		2186
+imx27_visstrim_m10	MACH_IMX27_VISSTRIM_M10	IMX27_VISSTRIM_M10	2187
+px2imx27		MACH_PX2IMX27		PX2IMX27		2188
+stm3210e_eval		MACH_STM3210E_EVAL	STM3210E_EVAL		2189
+dvs10			MACH_DVS10		DVS10			2190
+portuxg20		MACH_PORTUXG20		PORTUXG20		2191
+arm_spv			MACH_ARM_SPV		ARM_SPV			2192
+smdkc110		MACH_SMDKC110		SMDKC110		2193
+cabespresso		MACH_CABESPRESSO	CABESPRESSO		2194
+hmc800			MACH_HMC800		HMC800			2195
 sholes			MACH_SHOLES		SHOLES			2196
+btmxc31			MACH_BTMXC31		BTMXC31			2197
+dt501			MACH_DT501		DT501			2198
+ktx			MACH_KTX		KTX			2199
+omap3517evm		MACH_OMAP3517EVM	OMAP3517EVM		2200
+netspace_v2		MACH_NETSPACE_V2	NETSPACE_V2		2201
+netspace_max_v2		MACH_NETSPACE_MAX_V2	NETSPACE_MAX_V2		2202
+d2net_v2		MACH_D2NET_V2		D2NET_V2		2203
+net2big_v2		MACH_NET2BIG_V2		NET2BIG_V2		2204
+net4big_v2		MACH_NET4BIG_V2		NET4BIG_V2		2205
+net5big_v2		MACH_NET5BIG_V2		NET5BIG_V2		2206
+endb2443		MACH_ENDB2443		ENDB2443		2207
+inetspace_v2		MACH_INETSPACE_V2	INETSPACE_V2		2208
+tros			MACH_TROS		TROS			2209
+pelco_homer		MACH_PELCO_HOMER	PELCO_HOMER		2210
+ofsp8			MACH_OFSP8		OFSP8			2211
+at91sam9g45ekes		MACH_AT91SAM9G45EKES	AT91SAM9G45EKES		2212
+guf_cupid		MACH_GUF_CUPID		GUF_CUPID		2213
+eab1r			MACH_EAB1R		EAB1R			2214
+desirec			MACH_DESIREC		DESIREC			2215
+cordoba			MACH_CORDOBA		CORDOBA			2216
+irvine			MACH_IRVINE		IRVINE			2217
+sff772			MACH_SFF772		SFF772			2218
+pelco_milano		MACH_PELCO_MILANO	PELCO_MILANO		2219
+pc7302			MACH_PC7302		PC7302			2220
+bip6000			MACH_BIP6000		BIP6000			2221
+silvermoon		MACH_SILVERMOON		SILVERMOON		2222
+vc0830			MACH_VC0830		VC0830			2223
+dt430			MACH_DT430		DT430			2224
+ji42pf			MACH_JI42PF		JI42PF			2225
+gnet_ksm		MACH_GNET_KSM		GNET_KSM		2226
+gnet_sgm		MACH_GNET_SGM		GNET_SGM		2227
+gnet_sgr		MACH_GNET_SGR		GNET_SGR		2228
+omap3_icetekevm		MACH_OMAP3_ICETEKEVM	OMAP3_ICETEKEVM		2229
+pnp			MACH_PNP		PNP			2230
+ctera_2bay_k		MACH_CTERA_2BAY_K	CTERA_2BAY_K		2231
+ctera_2bay_u		MACH_CTERA_2BAY_U	CTERA_2BAY_U		2232
+sas_c			MACH_SAS_C		SAS_C			2233
+vma2315			MACH_VMA2315		VMA2315			2234
+vcs			MACH_VCS		VCS			2235
+spear600		MACH_SPEAR600		SPEAR600		2236
+spear300		MACH_SPEAR300		SPEAR300		2237
+spear1300		MACH_SPEAR1300		SPEAR1300		2238
+lilly1131		MACH_LILLY1131		LILLY1131		2239
+arvoo_ax301		MACH_ARVOO_AX301	ARVOO_AX301		2240
+mapphone		MACH_MAPPHONE		MAPPHONE		2241
diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
index 161b9b9..5219148 100644
--- a/arch/powerpc/kernel/vmlinux.lds.S
+++ b/arch/powerpc/kernel/vmlinux.lds.S
@@ -248,6 +248,10 @@ SECTIONS
 		*(.toc)
 	}
 #endif
+	/* We need constructor data for the gcov patch. */
+	.data.gcov : {
+		CONSTRUCTORS
+	}
 
 	. = ALIGN(PAGE_SIZE);
 	_edata  =  .;
diff --git a/arch/s390/kernel/vdso32/Makefile b/arch/s390/kernel/vdso32/Makefile
index ca78ad6..675f527 100644
--- a/arch/s390/kernel/vdso32/Makefile
+++ b/arch/s390/kernel/vdso32/Makefile
@@ -10,7 +10,7 @@ obj-vdso32 := $(addprefix $(obj)/, $(obj-vdso32))
 KBUILD_AFLAGS_31 := $(filter-out -m64,$(KBUILD_AFLAGS))
 KBUILD_AFLAGS_31 += -m31 -s
 
-KBUILD_CFLAGS_31 := $(filter-out -m64,$(KBUILD_CFLAGS))
+KBUILD_CFLAGS_31 := $(filter-out -m64 $(KBUILD_GCOV_FLAGS),$(KBUILD_CFLAGS))
 KBUILD_CFLAGS_31 += -m31 -fPIC -shared -fno-common -fno-builtin
 KBUILD_CFLAGS_31 += -nostdlib -Wl,-soname=linux-vdso32.so.1 \
 			$(call ld-option, -Wl$(comma)--hash-style=sysv)
diff --git a/arch/s390/kernel/vdso64/Makefile b/arch/s390/kernel/vdso64/Makefile
index 6fc8e82..3074898 100644
--- a/arch/s390/kernel/vdso64/Makefile
+++ b/arch/s390/kernel/vdso64/Makefile
@@ -10,7 +10,7 @@ obj-vdso64 := $(addprefix $(obj)/, $(obj-vdso64))
 KBUILD_AFLAGS_64 := $(filter-out -m64,$(KBUILD_AFLAGS))
 KBUILD_AFLAGS_64 += -m64 -s
 
-KBUILD_CFLAGS_64 := $(filter-out -m64,$(KBUILD_CFLAGS))
+KBUILD_CFLAGS_64 := $(filter-out -m64 $(KBUILD_GCOV_FLAGS),$(KBUILD_CFLAGS))
 KBUILD_CFLAGS_64 += -m64 -fPIC -shared -fno-common -fno-builtin
 KBUILD_CFLAGS_64 += -nostdlib -Wl,-soname=linux-vdso64.so.1 \
 			$(call ld-option, -Wl$(comma)--hash-style=sysv)
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index d364df0..28eb0bd 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -24,6 +24,9 @@ CFLAGS_vsyscall_64.o	:= $(PROFILING) -g0 $(nostackp)
 CFLAGS_hpet.o		:= $(nostackp)
 CFLAGS_tsc.o		:= $(nostackp)
 
+# some files in this directory are causing crashes when profiled
+KBUILD_CFLAGS := $(KBUILD_CFLAGS_NOGCOV)
+
 obj-y			:= process_$(BITS).o signal.o entry_$(BITS).o
 obj-y			+= traps.o irq.o irq_$(BITS).o dumpstack_$(BITS).o
 obj-y			+= time_$(BITS).o ioport.o ldt.o dumpstack.o
diff --git a/drivers/Kconfig b/drivers/Kconfig
index e689fe7..fc1cc64 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -80,6 +80,7 @@ source "drivers/hid/Kconfig"
 
 source "drivers/usb/Kconfig"
 
+
 source "drivers/uwb/Kconfig"
 
 source "drivers/mmc/Kconfig"
@@ -111,4 +112,7 @@ source "drivers/xen/Kconfig"
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
+
+source "drivers/sim/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 0c0cee3..d1f2081 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -111,3 +111,4 @@ obj-$(CONFIG_SSB)		+= ssb/
 obj-$(CONFIG_VIRTIO)		+= virtio/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
+obj-y                           += sim/
diff --git a/drivers/base/devres.c b/drivers/base/devres.c
index e8beb8e..bb1ae7d 100644
--- a/drivers/base/devres.c
+++ b/drivers/base/devres.c
@@ -24,7 +24,11 @@ struct devres_node {
 struct devres {
 	struct devres_node		node;
 	/* -- 3 pointers */
+#ifdef CONFIG_DEBUG_MEMLEAK
+	unsigned long long		data[0];/* guarantee ull alignment */
+#else
 	unsigned long long		data[];	/* guarantee ull alignment */
+#endif
 };
 
 struct devres_group {
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 438f292..901b808 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -1118,5 +1118,18 @@ config DCC_TTY
 
 source "drivers/s390/char/Kconfig"
 
+config GPIODEV_DEVICE_TREE
+	bool "Motorola GPIODev configuration by device tree"
+	depends on ARM_OF
+	default n
+	help
+	  This feature enables configuration of GPIODev module node by device tree.
+
+config GPIODEV
+	tristate "Enable Motorola GPIODev"
+	default n
+	help
+	  This feature enables GPIODev for accessing GPIO pins in user space.
+
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 5ab656b..d1c362e 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -109,6 +109,8 @@ obj-$(CONFIG_TCG_TPM)		+= tpm/
 obj-$(CONFIG_DCC_TTY)		+= dcc_tty.o
 obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 
+obj-$(CONFIG_GPIODEV)		+= gpiodev.o
+
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
diff --git a/drivers/char/gpiodev.c b/drivers/char/gpiodev.c
new file mode 100644
index 0000000..baa3a12
--- /dev/null
+++ b/drivers/char/gpiodev.c
@@ -0,0 +1,682 @@
+/* 
+ * GPIODev                                       gpiodev.c
+ *
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ */
+
+/*
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <mach/gpio.h>
+#include <linux/autoconf.h>
+#include <linux/gpiodev.h>
+#include <linux/platform_device.h>
+
+MODULE_AUTHOR("Motorola, Inc.");
+MODULE_DESCRIPTION("GPIO device for user space accessing GPIO pins");
+MODULE_LICENSE("GPL");
+
+/*
+ * GPIODEV_DBG macro is for debugging purpose only
+ * Should turn it off while releasing official version
+ */
+#define GPIODEV_DBG 0
+
+#if GPIODEV_DBG
+#define trace_msg(fmt, args...)  printk("\n" KERN_ALERT fmt "\n", ##args)
+#else
+#define trace_msg(fmt, arg...) do { } while(0)
+#endif
+
+const unsigned int int_type[GPIODEV_INTTYPE_MAX] = {
+	IRQF_TRIGGER_NONE,
+	IRQF_TRIGGER_RISING,
+	IRQF_TRIGGER_FALLING,
+	(IRQF_TRIGGER_HIGH | IRQF_TRIGGER_RISING),
+	(IRQF_TRIGGER_LOW | IRQF_TRIGGER_FALLING)
+};
+
+#define GET_INT_TYPE(a)    (int_type[((a) & GPIODEV_CONFIG_INT_MASK) >> GPIODEV_CONFIG_INT_MASK_OFFSET])
+#define GPIODEV_IS_INTERRUPTABLE(a)    ((((a) & GPIODEV_CONFIG_INT_MASK) != GPIODEV_CONFIG_INT_NONE) ? 1 : 0)
+
+static unsigned long gpiodev_major = 0;
+static struct class *gpiodev_class;
+
+static struct gpio_device *gpio_devs;
+static int gpio_dev_count;
+
+/*
+ * gpiodev_isr handles an interrupt on a GPIO triggered by the parameters
+ * provided when setting up the line. The interrupt that occurs here will
+ * be for a specific GPIO previously configured for a particular interrupt.
+ * The function will wake up any process waiting for this interrupt to be 
+ * triggered.
+ */
+static irqreturn_t gpiodev_isr(int irq, void *param)
+{
+	struct gpio_device *dev;
+
+	dev = (struct gpio_device *) param;
+
+	dev->flags |= GPIODEV_FLAG_INTERRUPTED;
+
+	disable_irq(gpio_to_irq(dev->pin_nr));
+	wake_up_interruptible(&dev->event_queue);
+
+	trace_msg("gpio%d interrupt occurs", dev->pin_nr);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * config_gpio configures the way a GPIO operates and adjusts the
+ * current configuration byte appropriately. Any resources in use
+ * prior to the reconfiguration will be released and the new configuration
+ * will take effect.
+ */
+static unsigned long config_gpio(struct gpio_device *dev, u32 newconfig)
+{
+	unsigned long ret = 0;
+
+	trace_msg("Configure gpio%d with config 0x%04x instead of 0x%04x",
+		  dev->pin_nr, newconfig, dev->current_config);
+
+
+	/* If new conig is invalid, release gpio resource */
+	if ( newconfig & GPIODEV_CONFIG_INVALID ) {
+		/* Free any currently consumed resources */
+		if (!(dev->current_config & GPIODEV_CONFIG_INVALID)) {
+			if (GPIODEV_IS_INTERRUPTABLE(dev->current_config)) {
+				free_irq(gpio_to_irq(dev->pin_nr), dev);
+				dev->flags &= ~GPIODEV_FLAG_INTERRUPTED;
+			}
+			gpio_free(dev->pin_nr);
+		}
+	}
+	else {
+		/* If current gpio is invalid, request gpio resource*/
+		if (dev->current_config & GPIODEV_CONFIG_INVALID) {
+			if (gpio_request(dev->pin_nr, NULL) < 0) {
+				printk(KERN_ERR "Failed to request GPIO for %s \n",
+			    	   dev->device_name);
+				ret = -EBUSY;
+				goto end;
+			}
+		}
+
+		/* 
+		 * Configure GPIO with newconfig
+		 */
+		/* Step 1: direction and level setting */
+		if (newconfig & GPIODEV_CONFIG_INPUT) {
+			gpio_direction_input(dev->pin_nr);
+		} 
+		else if (newconfig & GPIODEV_CONFIG_OUTPUT_HIGH) {
+			gpio_direction_output(dev->pin_nr, 1);
+		}
+		else if (newconfig & GPIODEV_CONFIG_OUTPUT_LOW) {
+			gpio_direction_output(dev->pin_nr, 0);
+		}
+		/* Step 2: request interrupt */
+		if (GPIODEV_IS_INTERRUPTABLE(newconfig)) {
+			if (((newconfig & GPIODEV_CONFIG_INT_MASK) >> GPIODEV_CONFIG_INT_MASK_OFFSET)
+				>= GPIODEV_INTTYPE_MAX) {
+				ret = -EINVAL;
+				goto end;
+			}
+			else if (request_irq(gpio_to_irq(dev->pin_nr),
+					     &gpiodev_isr,
+					     GET_INT_TYPE(newconfig),
+					     dev->device_name, dev) ) {
+				printk(KERN_ERR "Fail to request irq for \"%s\"\n", 
+						dev->device_name);
+				gpio_free(dev->pin_nr);
+				ret = -EBUSY;
+				goto end;
+			}
+		}
+	}
+
+	dev->current_config = newconfig;
+end:
+	return ret;
+}
+
+
+/*
+ * gpiodev_open handles a userspace open() to our driver. This function takes
+ * the specified device out of the default state by configuring the GPIO.
+ */
+static int gpiodev_open(struct inode *inode, struct file *filp)
+{
+	struct gpio_device *dev;
+	unsigned long minor;
+	int ret = 0;
+
+	minor = MINOR(inode->i_rdev);
+
+	if (minor >= gpio_dev_count)
+		return -ENODEV;
+
+	dev = &gpio_devs[minor];
+
+	mutex_lock(&dev->lock);
+
+	if (dev->flags & GPIODEV_FLAG_OPEN) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+#if GPIODEV_DBG
+	if (dev->pin_nr == 111) {
+		free_irq(gpio_to_irq(dev->pin_nr), NULL);
+		gpio_free(dev->pin_nr);
+	}
+#endif
+
+	ret = config_gpio(dev, dev->init_config);
+	if (ret != 0) 
+		goto end;
+
+	dev->flags |= GPIODEV_FLAG_OPEN;
+	if (!try_module_get(THIS_MODULE)) {
+		ret = -EINVAL;
+		module_put(THIS_MODULE);
+		goto end;
+	}
+
+end:
+	mutex_unlock(&dev->lock);
+	trace_msg("open function return value 0x%04x", ret);
+	return ret;
+}
+
+/*
+ * gpiodev_close handles a userspace close() on a device previously
+ * opened. The close reverses any initialization done on a device.
+ */
+static int gpiodev_close(struct inode *inode, struct file *filp)
+{
+	struct gpio_device *dev;
+	unsigned long minor;
+	int ret = 0;
+
+	minor = MINOR(inode->i_rdev);
+
+	if (minor >= gpio_dev_count)
+		return -ENODEV;
+
+	dev = &gpio_devs[minor];
+
+	mutex_lock(&dev->lock);
+
+	if (!(dev->flags & GPIODEV_FLAG_OPEN)) {
+		ret = 0;
+		goto end;
+	}
+
+	if (dev->flags & GPIODEV_FLAG_CONFIGURABLE) {
+		ret = config_gpio(dev, GPIODEV_CONFIG_INVALID);
+		if (ret != 0)
+			goto end;
+	}
+
+	dev->flags &= ~GPIODEV_FLAG_OPEN;
+	module_put(THIS_MODULE);
+
+end:
+	mutex_unlock(&dev->lock);
+	trace_msg("close function return value 0x%04x", ret);
+	return ret;
+}
+
+/*
+ * gpiodev_read handles a userspace read() on an open device.
+ * The read will only read a single byte. A read on a GPIO
+ * configured for output will return the value currently in the output
+ * register.
+ */
+static ssize_t gpiodev_read(struct file *filp, char *buf, size_t count,
+			    loff_t * f_pos)
+{
+	struct gpio_device *dev;
+	unsigned long minor;
+	unsigned long result;
+	unsigned char value;
+	int ret = 1;
+
+	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
+
+	if (minor >= gpio_dev_count)
+		return -ENODEV;
+
+	dev = &gpio_devs[minor];
+
+	mutex_lock(&dev->lock);
+
+	if (!(dev->flags & GPIODEV_FLAG_OPEN)) {
+		ret = -EBADF;
+		goto end;
+	}
+	else if ((dev->current_config & GPIODEV_CONFIG_OUTPUT_LOW) 
+			|| (dev->current_config & GPIODEV_CONFIG_OUTPUT_HIGH)) {
+		ret = -EPERM;
+		goto end;
+	}
+
+	if (count < 1) {
+		ret = 0;
+		goto end;
+	}
+
+	value = gpio_get_value(dev->pin_nr);
+	trace_msg("Reading gpio%d with 0x%02x", dev->pin_nr, value);
+
+	result = copy_to_user(buf, &value, 1);
+	if (result)
+		ret = -EFAULT;
+
+end:
+	mutex_unlock(&dev->lock);
+	return ret;
+}
+
+/*
+ * gpiodev_write handles a userspace write() on an open device. The write
+ * must be one byte in length or the call will fail. A write on a GPIO
+ * configured for input will not affect the line's status.
+ */
+static ssize_t gpiodev_write(struct file *filp, const char *buf, size_t count,
+			     loff_t * f_pos)
+{
+	struct gpio_device *dev;
+	unsigned long minor;
+	unsigned long result;
+	unsigned char value;
+	int ret = 1;
+
+	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
+
+	if (minor >= gpio_dev_count)
+		return -ENODEV;
+
+	dev = &gpio_devs[minor];
+
+	mutex_lock(&dev->lock);
+
+	if (!(dev->flags & GPIODEV_FLAG_OPEN)) {
+		ret = -EBADF;
+		goto end;
+	}
+	else if (dev->current_config & GPIODEV_CONFIG_INPUT) {
+		ret = -EPERM;
+		goto end;
+	}
+
+	if (count < 1) {
+		ret = 0;
+		goto end;
+	}
+
+	value = 0;
+
+	result = copy_from_user(&value, buf, 1);
+	if (result) {
+		ret = -EFAULT;
+		goto end;
+	}
+
+	if (value > 1) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	gpio_set_value(dev->pin_nr, value);
+	trace_msg("Writing gpio%d with 0x%02x", dev->pin_nr, value);
+
+end:
+	mutex_unlock(&dev->lock);
+	trace_msg("write function return value = 0x%04x", ret);
+	return ret;
+}
+
+/*
+ * gpiodev_ioctl handles the configuration of a GPIO. The following commands are
+ * supported:
+ * GPIODEV_GET_CONFIG - returns the 1 byte configuration of the GPIO
+ * GPIODEV_SET_CONFIG - sets up the 1 byte configuration of the GPIO
+ * GPIODEV_INT_REENABLE - If the line is responsive to interrupts, ints will be
+ *                        reenabled.
+ * GPIODEV_GET_LOWLEVELCONFIG - Get the low level details of a device. If the device doesn't
+ *                              allow this operation an error is returned.
+ * GPIODEV_SET_LOWLEVELCONFIG - Set the low level details of a device. If the device
+ *                              doesn't allow this operation an error is returned. If
+ *                              the low level configuration to be set is invalid an
+ *                              error is returned.
+ * GPIODEV_INT_POLL - Wait for gpiodev interrupt occurrence.
+ *
+ */
+static int gpiodev_ioctl(struct inode *inode, struct file *filp,
+			 unsigned int cmd, unsigned long arg)
+{
+	GPIODEV_LOWLEVEL_CONFIG llconf;
+	struct gpio_device *dev;
+	unsigned long minor;
+	unsigned long result;
+	u32 value;
+	int ret = 0;
+
+	minor = MINOR(inode->i_rdev);
+
+	if (minor >= gpio_dev_count)
+		return -ENODEV;
+
+	dev = &gpio_devs[minor];
+
+	mutex_lock(&dev->lock);
+
+	if (!(dev->flags & GPIODEV_FLAG_OPEN)) {
+		ret = -EBADF;
+		goto end;
+	}
+
+	result = 0;
+
+	switch (cmd) {
+	case GPIODEV_GET_CONFIG:
+		{
+			result =
+			    copy_to_user((unsigned char *) arg,
+					 &dev->current_config, sizeof(u32));
+			if (result) {
+				ret = -EFAULT;
+				goto end;
+			}
+		}
+		break;
+
+	case GPIODEV_SET_CONFIG:
+		{
+			if (!(dev->flags & GPIODEV_FLAG_CONFIGURABLE)) {
+				ret = -EBADF;
+				goto end;
+			}
+
+			result =
+			    copy_from_user(&value, (unsigned char *) arg,
+								sizeof(u32));
+			if (result) {
+				ret = -EFAULT;
+				goto end;
+			}
+
+			ret = config_gpio(dev, value);
+		}
+		break;
+
+	case GPIODEV_INT_REENABLE:
+		{
+			if (!(GPIODEV_IS_INTERRUPTABLE(dev->current_config))) {
+				ret = -EPERM;
+				goto end;
+			}
+
+			dev->flags &= ~GPIODEV_FLAG_INTERRUPTED;
+			enable_irq(gpio_to_irq(dev->pin_nr));
+		}
+		break;
+
+	case GPIODEV_GET_LOWLEVELCONFIG:
+		{
+			if (!(dev->flags & GPIODEV_FLAG_LOWLEVELACCESS)) {
+				ret = -EPERM;
+				goto end;
+			}
+
+			llconf.config = dev->current_config;
+
+			result = copy_to_user((unsigned int *) arg, &llconf,
+					      sizeof(GPIODEV_LOWLEVEL_CONFIG));
+			if (result) {
+				ret = -EFAULT;
+				goto end;
+			}
+		}
+		break;
+
+	case GPIODEV_SET_LOWLEVELCONFIG:
+		{
+			if (!(dev->flags & GPIODEV_FLAG_LOWLEVELACCESS) ||
+				!(dev->flags & GPIODEV_FLAG_CONFIGURABLE)) {
+				ret = -EPERM;
+				goto end;
+			}
+
+			result =
+			    copy_from_user(&llconf, (unsigned int *) arg,
+					   sizeof(GPIODEV_LOWLEVEL_CONFIG));
+			if (result) {
+				ret = -EFAULT;
+				goto end;
+			}
+
+			ret = config_gpio(dev, llconf.config);
+		}
+		break;
+
+	case GPIODEV_INT_POLL:
+		if (!(GPIODEV_IS_INTERRUPTABLE(dev->current_config))) {
+			ret = -EPERM;
+			goto end;
+		}
+		else { 
+			trace_msg("evoke wait_event_interruptible calling \n");
+			wait_event_interruptible(dev->event_queue, (dev->flags & GPIODEV_FLAG_INTERRUPTED) != 0);
+			dev->flags &= ~GPIODEV_FLAG_INTERRUPTED;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+end:
+	mutex_unlock(&dev->lock);
+	return ret;
+}
+
+/*
+ * gpiodev_poll handles a user's select/poll call. This function will
+ * return whatever functionality is currently available on a device.
+ * The intended use is to wait for interrupts in a select call. By
+ * waiting on an exception, a select/poll call will block until an interrupt
+ * occurs.
+ */
+static unsigned int gpiodev_poll(struct file *filp, poll_table * table)
+{
+	struct gpio_device *dev;
+	unsigned long minor;
+	unsigned int mask = 0;
+
+	minor = MINOR(filp->f_dentry->d_inode->i_rdev);
+
+	if (minor >= gpio_dev_count)
+		return POLLERR;
+
+	dev = &gpio_devs[minor];
+
+	mutex_lock(&dev->lock);
+
+	if (!(dev->flags & GPIODEV_FLAG_OPEN)
+	    || !(GPIODEV_IS_INTERRUPTABLE(dev->current_config))) {
+		mask |= POLLNVAL;
+		goto end;
+	}
+
+	trace_msg("evoke poll_wait calling \n");
+	poll_wait(filp, &dev->event_queue, table);
+	if (dev->flags & GPIODEV_FLAG_INTERRUPTED)
+		mask |= POLLPRI;
+
+end:
+	dev->flags &= ~GPIODEV_FLAG_INTERRUPTED;
+	mutex_unlock(&dev->lock);
+	return mask;
+}
+
+static const struct file_operations gpiodev_fops = {
+	.owner = THIS_MODULE,
+	.open = gpiodev_open,
+	.release = gpiodev_close,
+	.read = gpiodev_read,
+	.write = gpiodev_write,
+	.ioctl = gpiodev_ioctl,
+	.poll = gpiodev_poll,
+};
+
+/*
+ * gpiodev_cleanup unregisters the character drivers and removes the /dev
+ * entries. If for some reason a GPIO still has a reference count, interrupts
+ * are disabled on to effectively 'shut it down.'
+ */
+static void gpiodev_cleanup(unsigned long device_nr)
+{
+	struct gpio_device *gpiodev;
+	unsigned long index;
+
+	for (index = 0; index < device_nr; index++) {
+		gpiodev = &gpio_devs[index];
+		device_destroy(gpiodev_class,
+				     MKDEV(gpiodev_major, index));
+	}
+
+	class_destroy(gpiodev_class);
+	unregister_chrdev(gpiodev_major, GPIO_DEVICE_DEV_NAME);
+
+}
+
+static void gpiodev_exit(void)
+{
+	gpiodev_cleanup(gpio_dev_count);
+}
+
+/*
+ * gpiodev_init sets up the character driver, configures the GPIOs specified
+ * in the gpiodevs list, and creates entries in /dev corresponding to
+ * each configured GPIO.
+ */
+static int __init gpiodev_init(void)
+{
+	struct gpio_device *gpiodev;
+	unsigned long index;
+	unsigned long result;
+
+	result = register_chrdev(0, GPIO_DEVICE_DEV_NAME, &gpiodev_fops);
+	if (result < 0) {
+		printk(KERN_ERR "Failed to register gpiodev %s \n",
+		       GPIO_DEVICE_DEV_NAME);
+
+		return result;
+	}
+
+	gpiodev_major = result;
+	gpiodev_class = class_create(THIS_MODULE, GPIO_DEVICE_DEV_NAME);
+
+	for (index = 0; index < gpio_dev_count; index++) {
+		gpiodev = &gpio_devs[index];
+
+		mutex_init(&gpiodev->lock);
+		init_waitqueue_head(&gpiodev->event_queue);
+		if (IS_ERR(device_create(gpiodev_class,
+					       NULL,
+					       MKDEV(gpiodev_major, index),
+					       NULL,
+					       "%s", gpiodev->device_name))) {
+			printk(KERN_ERR
+			       "Device \"%s\" could not be created properly\n",
+			       gpiodev->device_name);
+			gpiodev_cleanup(index);
+			return -1;
+		}
+		trace_msg("Created device %s", gpiodev->device_name);
+	}
+
+	printk(KERN_INFO "GPIODev init successfully \n");
+	return 0;
+}
+
+static int __init gpio_device_probe(struct platform_device *pdev)
+{
+	struct gpio_device_platform_data *data;
+
+	data = pdev->dev.platform_data;
+	if (data == NULL) {
+		printk(KERN_ERR "gpio_device_probe: No pdata!\n");
+		return -ENODEV;
+	}
+
+	if ((data->info == NULL) || (data->info_count == 0)) {
+		printk(KERN_ERR "gpio_device_probe: incomplete pdata!\n");
+		return -ENODEV;
+	}
+
+	gpio_devs = data->info;
+	gpio_dev_count = data->info_count;
+
+	gpiodev_init();
+	return 0;
+}
+
+static int gpio_device_remove(struct platform_device *pdev)
+{
+	gpiodev_exit();
+	return 0;
+}
+
+static struct platform_driver gpio_device_driver = {
+	.probe = gpio_device_probe,
+	.remove = gpio_device_remove,
+	.driver = {
+		.name = GPIO_DEVICE_DEV_NAME,
+	},
+};
+
+static int __devinit gpio_device_init(void)
+{
+	return platform_driver_register(&gpio_device_driver);
+}
+
+static void __exit gpio_device_exit(void)
+{
+	platform_driver_unregister(&gpio_device_driver);
+}
+
+module_init(gpio_device_init);
+module_exit(gpio_device_exit);
diff --git a/drivers/cpufreq/cpufreq_ondemand.c b/drivers/cpufreq/cpufreq_ondemand.c
index 2999fa7..b693484 100644
--- a/drivers/cpufreq/cpufreq_ondemand.c
+++ b/drivers/cpufreq/cpufreq_ondemand.c
@@ -21,6 +21,8 @@
 #include <linux/hrtimer.h>
 #include <linux/tick.h>
 #include <linux/ktime.h>
+#include <linux/earlysuspend.h>
+#include <linux/platform_device.h>
 
 /*
  * dbs is used in this file as a shortform for demandbased switching
@@ -95,13 +97,29 @@ static struct dbs_tuners {
 	unsigned int down_differential;
 	unsigned int ignore_nice;
 	unsigned int powersave_bias;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unsigned int is_suspended;
+	unsigned int susp_rate;
+#endif
 } dbs_tuners_ins = {
 	.up_threshold = DEF_FREQUENCY_UP_THRESHOLD,
 	.down_differential = DEF_FREQUENCY_DOWN_DIFFERENTIAL,
 	.ignore_nice = 0,
 	.powersave_bias = 0,
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	.is_suspended = 0,
+#endif
 };
 
+static inline unsigned int get_sampling_rate(void)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	if (dbs_tuners_ins.is_suspended)
+		return dbs_tuners_ins.susp_rate;
+#endif
+	return dbs_tuners_ins.sampling_rate;
+}
+
 static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu,
 							cputime64_t *wall)
 {
@@ -178,7 +196,7 @@ static unsigned int powersave_bias_target(struct cpufreq_policy *policy,
 		dbs_info->freq_lo_jiffies = 0;
 		return freq_lo;
 	}
-	jiffies_total = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+	jiffies_total = usecs_to_jiffies(get_sampling_rate());
 	jiffies_hi = (freq_avg - freq_lo) * jiffies_total;
 	jiffies_hi += ((freq_hi - freq_lo) / 2);
 	jiffies_hi /= (freq_hi - freq_lo);
@@ -225,6 +243,7 @@ static ssize_t show_##file_name						\
 	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
 }
 show_one(sampling_rate, sampling_rate);
+show_one(susp_rate, susp_rate);
 show_one(up_threshold, up_threshold);
 show_one(ignore_nice_load, ignore_nice);
 show_one(powersave_bias, powersave_bias);
@@ -249,6 +268,28 @@ static ssize_t store_sampling_rate(struct cpufreq_policy *unused,
 	return count;
 }
 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static ssize_t store_susp_rate(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input > MAX_SAMPLING_RATE
+			|| input < MIN_SAMPLING_RATE) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.susp_rate = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+#endif
+
 static ssize_t store_up_threshold(struct cpufreq_policy *unused,
 		const char *buf, size_t count)
 {
@@ -332,6 +373,9 @@ static struct freq_attr _name = \
 __ATTR(_name, 0644, show_##_name, store_##_name)
 
 define_one_rw(sampling_rate);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+define_one_rw(susp_rate);
+#endif
 define_one_rw(up_threshold);
 define_one_rw(ignore_nice_load);
 define_one_rw(powersave_bias);
@@ -343,6 +387,9 @@ static struct attribute * dbs_attributes[] = {
 	&up_threshold.attr,
 	&ignore_nice_load.attr,
 	&powersave_bias.attr,
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	&susp_rate.attr,
+#endif
 	NULL
 };
 
@@ -487,7 +534,7 @@ static void do_dbs_timer(struct work_struct *work)
 	int sample_type = dbs_info->sample_type;
 
 	/* We want all CPUs to do sampling nearly on same jiffy */
-	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+	int delay = usecs_to_jiffies(get_sampling_rate());
 
 	if (num_online_cpus() > 1)
 		delay -= jiffies % delay;
@@ -539,6 +586,56 @@ static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
 	cancel_delayed_work(&dbs_info->work);
 }
 
+
+static int __devinit ondemand_probe(struct platform_device *dev)
+{
+    return 0;
+}
+
+static int __devexit ondemand_remove(struct platform_device *dev)
+{
+    return 0;
+}
+static int ondemand_suspend(struct platform_device *dev, pm_message_t state)
+{
+    /* only for mono-cpu system */
+    int cpu = 0;
+    struct cpu_dbs_info_s *this_dbs_info;
+
+    this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+
+    dbs_timer_exit(this_dbs_info);
+    flush_workqueue(kondemand_wq);
+
+    /* force lowest opp available */
+    __cpufreq_driver_target(this_dbs_info->cur_policy, 0,
+		CPUFREQ_RELATION_L);
+    return 0;
+}
+
+static int ondemand_resume(struct platform_device *dev)
+{
+    int cpu = 0;
+    struct cpu_dbs_info_s *this_dbs_info;
+
+    this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+    dbs_timer_init(this_dbs_info);
+    return 0;
+}
+
+static struct platform_driver ondemand_dummy_driver = {
+    .probe      = ondemand_probe,
+    .remove     = ondemand_remove,
+    .suspend    = ondemand_suspend,
+    .resume     = ondemand_resume,
+    .driver     = {
+		.name   = "ondemand",
+		.owner  = THIS_MODULE,
+    },
+};
+
+static struct platform_device *pd;
+
 static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 				   unsigned int event)
 {
@@ -598,6 +695,11 @@ static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 				def_sampling_rate = MIN_STAT_SAMPLING_RATE;
 
 			dbs_tuners_ins.sampling_rate = def_sampling_rate;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+			dbs_tuners_ins.susp_rate = 3*def_sampling_rate;
+#endif
+			pd = platform_device_register_simple("ondemand", -1,
+					NULL, 0);
 		}
 		dbs_timer_init(this_dbs_info);
 
@@ -609,6 +711,8 @@ static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		dbs_timer_exit(this_dbs_info);
 		sysfs_remove_group(&policy->kobj, &dbs_attr_group);
 		dbs_enable--;
+		if (dbs_enable == 0)
+			platform_device_unregister(pd);
 		mutex_unlock(&dbs_mutex);
 
 		break;
@@ -639,6 +743,26 @@ struct cpufreq_governor cpufreq_gov_ondemand = {
 	.owner			= THIS_MODULE,
 };
 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+
+void dbs_suspend(struct early_suspend *h)
+{
+    dbs_tuners_ins.is_suspended = 1;
+}
+
+void dbs_resume(struct early_suspend *h)
+{
+    dbs_tuners_ins.is_suspended = 0;
+}
+
+struct early_suspend dbs_suspend_info = {
+    .suspend = dbs_suspend,
+    .resume = dbs_resume,
+    .level = EARLY_SUSPEND_LEVEL_STOP_DRAWING,
+};
+#endif
+
+
 static int __init cpufreq_gov_dbs_init(void)
 {
 	int err;
@@ -662,13 +786,30 @@ static int __init cpufreq_gov_dbs_init(void)
 	}
 	err = cpufreq_register_governor(&cpufreq_gov_ondemand);
 	if (err)
-		destroy_workqueue(kondemand_wq);
+		goto err2;
+
+    err = platform_driver_register(&ondemand_dummy_driver);
+    if (err)
+		goto err1;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    register_early_suspend(&dbs_suspend_info);
+#endif
+
+    return 0;
+
+ err1:
+    cpufreq_unregister_governor(&cpufreq_gov_ondemand);
+
+ err2:
+    destroy_workqueue(kondemand_wq);
 
 	return err;
 }
 
 static void __exit cpufreq_gov_dbs_exit(void)
 {
+	platform_driver_unregister(&ondemand_dummy_driver);
 	cpufreq_unregister_governor(&cpufreq_gov_ondemand);
 	destroy_workqueue(kondemand_wq);
 }
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
index 220c30a..652a40d 100644
--- a/drivers/dsp/bridge/pmgr/wcd.c
+++ b/drivers/dsp/bridge/pmgr/wcd.c
@@ -528,7 +528,7 @@ u32 MGRWRAP_RegisterObject(union Trapped_Args *args)
 	if (DSP_FAILED(status))
 		goto func_end;
 	pathSize = strlen_user((char *)
-				args->ARGS_MGR_REGISTEROBJECT.pszPathName);
+				args->ARGS_MGR_REGISTEROBJECT.pszPathName) + 1;
 	pszPathName = MEM_Alloc(pathSize, MEM_NONPAGED);
 	if (!pszPathName)
 		goto func_end;
@@ -539,7 +539,6 @@ u32 MGRWRAP_RegisterObject(union Trapped_Args *args)
 		status = DSP_EPOINTER;
 		goto func_end;
 	}
-	pszPathName[pathSize] = '\0';
 
 	GT_1trace(WCD_debugMask, GT_ENTER,
 		 "MGRWRAP_RegisterObject: entered pg2hMsg "
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index 6e730f9b..47eafc3 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -745,7 +745,6 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
 {
 	/* Keep STATUS here for future additions to this function */
 	DSP_STATUS status = DSP_SOK;
-	enum DSP_FLUSHTYPE FlushMemType = PROC_WRITEBACK_INVALIDATE_MEM;
 	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
 	DBC_Require(cRefs > 0);
 
@@ -756,7 +755,7 @@ DSP_STATUS PROC_FlushMemory(DSP_HPROCESSOR hProcessor, void *pMpuAddr,
 	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
 		/* Critical section */
 		(void)SYNC_EnterCS(hProcLock);
-		MEM_FlushCache(pMpuAddr, ulSize, FlushMemType);
+		MEM_FlushCache(pMpuAddr, ulSize, ulFlags);
 		(void)SYNC_LeaveCS(hProcLock);
 	} else {
 		status = DSP_EHANDLE;
@@ -950,6 +949,7 @@ DSP_STATUS PROC_GetState(DSP_HPROCESSOR hProcessor,
 			case BRD_STOPPED:
 				pProcStatus->iState = PROC_STOPPED;
 				break;
+			case BRD_SLEEP_TRANSITION:
 			case BRD_DSP_HIBERNATION:
 				/* Fall through */
 			case BRD_RUNNING:
@@ -1072,7 +1072,7 @@ DSP_STATUS PROC_Load(DSP_HPROCESSOR hProcessor, IN CONST s32 iArgc,
 	struct DCD_MANAGER *hDCDHandle;
 	struct DMM_OBJECT *hDmmMgr;
 	u32 dwExtEnd;
-	u32 uProcId;
+	u32 uProcId = 0;
 #ifdef DEBUG
 	BRD_STATUS uBrdState;
 #endif
diff --git a/drivers/dsp/bridge/services/mem.c b/drivers/dsp/bridge/services/mem.c
index 47ec09b..3b4dca5 100644
--- a/drivers/dsp/bridge/services/mem.c
+++ b/drivers/dsp/bridge/services/mem.c
@@ -478,7 +478,7 @@ void MEM_Exit(void)
  *  Purpose:
  *      Flush cache
  */
-void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
+void MEM_FlushCache(void *pMemBuf, u32 cBytes, u32 FlushType)
 {
 	DBC_Require(cRefs > 0);
 
@@ -501,6 +501,10 @@ void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
 		outer_flush_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
 				  cBytes));
 	break;
+    /* Writeback and Invalidate all */
+	case PROC_WRBK_INV_ALL:
+		__cpuc_flush_kern_all();
+	break;
 	default:
 		GT_1trace(MEM_debugMask, GT_6CLASS, "MEM_FlushCache: invalid "
 			  "FlushMemType 0x%x\n", FlushType);
diff --git a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
index 8c192fa..2c5639b 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
@@ -268,7 +268,7 @@ DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwCmd,
 	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
 			    &pwrState);
 	/* Wait for DSP to move into target power state */
-	while ((pwrState != targetPwrState) && usCount--) {
+	while ((pwrState != targetPwrState) && --usCount) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP to Suspend interrupted\n");
 			return DSP_EFAIL;
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 3d25654..38d713ca 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -176,4 +176,10 @@ config GPIO_MCP23S08
 	  SPI driver for Microchip MCP23S08 I/O expander.  This provides
 	  a GPIO interface supporting inputs and outputs.
 
+config GPIO_MAPPING
+	bool "Support GPIO mapping"
+	default n
+	help
+	  GPIO interface supports pin number and name mapping.
+
 endif
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 49ac64e..ab671c9 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -3,6 +3,7 @@
 ccflags-$(CONFIG_DEBUG_GPIO)	+= -DDEBUG
 
 obj-$(CONFIG_GPIOLIB)		+= gpiolib.o
+obj-$(CONFIG_GPIO_MAPPING)	+= gpio_mapping.o
 
 obj-$(CONFIG_GPIO_MAX7301)	+= max7301.o
 obj-$(CONFIG_GPIO_MAX732X)	+= max732x.o
diff --git a/drivers/gpio/gpio_mapping.c b/drivers/gpio/gpio_mapping.c
new file mode 100644
index 0000000..60a28c4
--- /dev/null
+++ b/drivers/gpio/gpio_mapping.c
@@ -0,0 +1,58 @@
+/*
+ *                                        gpio_mapping.c
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/* Date         Author      Comment
+ * ===========  ==========  ==================================================
+ * 10-Jun-2009  Motorola    Initial.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/gpio_mapping.h>
+
+static int gpio_map_size;
+static struct gpio_mapping *gpio_map_table;
+
+void __init gpio_mapping_init(struct gpio_mapping *table, int size)
+{
+	gpio_map_size = size;
+	gpio_map_table = table;
+}
+
+int get_gpio_by_name(char *name)
+{
+	int i;
+
+	for (i = 0; i < gpio_map_size; i++) {
+		if (gpio_map_table[i].used == 0)
+			continue;
+
+		if (strncmp(name, gpio_map_table[i].name, GPIO_MAP_NAME_SIZE)
+			== 0)
+			return gpio_map_table[i].pin_num;
+	}
+
+	printk(KERN_ERR "Unable to get gpio pin num for %s\n", name);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(get_gpio_by_name);
diff --git a/drivers/gpu/pvr/Kconfig b/drivers/gpu/pvr/Kconfig
index e750827..0ff0388 100644
--- a/drivers/gpu/pvr/Kconfig
+++ b/drivers/gpu/pvr/Kconfig
@@ -30,7 +30,7 @@ config SGX_MK_TRACE
        bool "MK Trace"
        ---help---
          Enable suppport for dumping EDM status tracing from userspace
-	
+
 config PVR_OMAPLFB
 	tristate "PowerVR OMAP buffer class"
 	depends on SGX
diff --git a/drivers/gpu/pvr/Makefile b/drivers/gpu/pvr/Makefile
index 5aa8671..3128a32 100644
--- a/drivers/gpu/pvr/Makefile
+++ b/drivers/gpu/pvr/Makefile
@@ -33,9 +33,6 @@ ccflags-$(CONFIG_SGX_EDM_TRACING) += -DPVRSRV_USSE_EDM_STATUS_DEBUG
 
 ccflags-$(CONFIG_SGX_MK_TRACE) += -DPVRSRV_DUMP_MK_TRACE
 
-ccflags-$(CONFIG_SGX_RELEASE_LOGGING) += -DPVRSRV_NEED_PVR_DPF \
-					 -DPVRSRV_NEED_PVR_ASSERT
-
 ccflags-$(CONFIG_SGX_BUILD_RELEASE) += \
 	-DPVR_BUILD_TYPE="\"release\""  -DRELEASE
 
diff --git a/drivers/gpu/pvr/buffer_manager.c b/drivers/gpu/pvr/buffer_manager.c
index 9ad4508..dd4cfe1 100644
--- a/drivers/gpu/pvr/buffer_manager.c
+++ b/drivers/gpu/pvr/buffer_manager.c
@@ -89,6 +89,99 @@ AllocMemory (BM_CONTEXT				*pBMContext,
 	
 
 
+
+	if (uFlags & PVRSRV_MEM_EXPORTABLEDEVICEMEM2)
+	{
+		IMG_UINT32 ui32PageSize;
+		IMG_VOID *pvCPUVAddr;
+		IMG_BOOL bStatus;
+		IMG_UINT32 ui32PageCount;
+
+		ui32PageSize = OSGetPageSize();
+		uSize = (uSize + ui32PageSize - 1) & -ui32PageSize;
+		uDevVAddrAlignment = MIN(ui32PageSize, uDevVAddrAlignment);
+
+		ui32PageCount = uSize / ui32PageSize;
+
+		bStatus = BM_ImportMemory ((IMG_VOID *)psBMHeap,
+								   uSize,
+								   &uSize,
+								   &pMapping,
+								   uFlags & ~PVRSRV_MEM_EXPORTABLEDEVICEMEM2,
+								   (IMG_UINTPTR_T *) &pvCPUVAddr);
+
+		if (!bStatus) return bStatus;
+
+		if(!pMapping)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "AllocMemory: internal error.  pMapping not set when it should have been\n"));
+
+			BM_FreeMemory ((IMG_VOID *)psBMHeap,
+						   (IMG_UINTPTR_T) pvCPUVAddr,
+						   pMapping);
+			
+			return IMG_FALSE;
+		}
+
+		if(pMapping->psSysAddr && (IMG_UINTPTR_T)pMapping->psSysAddr != 0x4b4b4b4b)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "AllocMemory: internal error.  psSysAddr set when it should not have been\n"));
+
+			BM_FreeMemory ((IMG_VOID *)psBMHeap,
+						   (IMG_UINTPTR_T) pvCPUVAddr,
+						   pMapping);
+			
+			return IMG_FALSE;
+		}
+		
+		pMapping->uSize = uSize;
+		pMapping->pBMHeap = psBMHeap;
+
+		pMapping->CpuVAddr = pvCPUVAddr;
+		pBuf->hOSMemHandle = pMapping->hOSMemHandle;
+		pBuf->pMapping = pMapping;
+
+		pBuf->DevVAddr = pMapping->DevVAddr;
+		pBuf->CpuVAddr = pMapping->CpuVAddr;
+		pBuf->CpuPAddr = pMapping->CpuPAddr;
+		
+		pMapping->pArena = pArena;
+
+		pMapping->pBMHeap = psBMHeap;
+		pBuf->pMapping = pMapping;
+
+		pBuf->pMapping->eCpuMemoryOrigin = hm_wrapped_virtaddr;
+
+		PVR_DPF ((PVR_DBG_MESSAGE,
+				  "AllocMemory: psMapping=%08x: DevV=%08X CpuV=%08x CpuP=%08X uSize=0x%x",
+				  (IMG_UINTPTR_T)pMapping,
+				  pMapping->DevVAddr.uiAddr,
+				  (IMG_UINTPTR_T)pMapping->CpuVAddr,
+				  pMapping->CpuPAddr.uiAddr,
+				  pMapping->uSize));
+		
+		PVR_DPF ((PVR_DBG_MESSAGE,
+				  "AllocMemory: pBuf=%08x: DevV=%08X CpuV=%08x CpuP=%08X uSize=0x%x",
+				  (IMG_UINTPTR_T)pBuf,
+				  pBuf->DevVAddr.uiAddr,
+				  (IMG_UINTPTR_T)pBuf->CpuVAddr,
+				  pBuf->CpuPAddr.uiAddr,
+				  uSize));
+		
+		if (((pBuf->DevVAddr.uiAddr) & (uDevVAddrAlignment - 1)) != 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "AllocMemory: assertion '((pBuf->DevVAddr.uiAddr) & (uDevVAddrAlignment - 1)) == 0)' failed.  pBuf->DevVAddr.uiAddr = 0x%08x, uDevVAddrAlignment = 0x%x",
+					 pBuf->DevVAddr.uiAddr, uDevVAddrAlignment));
+
+			BM_FreeMemory ((IMG_VOID *)psBMHeap,
+						   (IMG_UINTPTR_T) pvCPUVAddr,
+						   pMapping);
+			return IMG_FALSE;
+		}
+
+		return IMG_TRUE;
+	}
+
 	if(uFlags & PVRSRV_MEM_RAM_BACKED_ALLOCATION)
 	{
 		if(uFlags & PVRSRV_MEM_USER_SUPPLIED_DEVVADDR)
@@ -575,7 +668,14 @@ FreeBuf (BM_BUF *pBuf, IMG_UINT32 ui32Flags)
 		{
 			OSReleaseSubMemHandle(pBuf->hOSMemHandle, ui32Flags);
 		}
-		if(ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION)
+
+		if(ui32Flags & PVRSRV_MEM_EXPORTABLEDEVICEMEM2)
+		{
+			BM_FreeMemory ((IMG_VOID *)pMapping->pBMHeap,
+						   IMG_NULL,
+						   pMapping);
+		}
+		else if(ui32Flags & PVRSRV_MEM_RAM_BACKED_ALLOCATION)
 		{
 			
 
@@ -1715,6 +1815,8 @@ BM_ImportMemory (IMG_VOID *pH,
 		goto fail_exit;
 	}
 
+	pMapping->psSysAddr = (IMG_SYS_PHYADDR *)0x4b4b4b4b;
+
 	pMapping->hOSMemHandle = 0;
 	pMapping->CpuVAddr = 0;
 	pMapping->DevVAddr.uiAddr = 0;
diff --git a/drivers/gpu/pvr/mem_debug.c b/drivers/gpu/pvr/mem_debug.c
new file mode 100644
index 0000000..cbe9912
--- /dev/null
+++ b/drivers/gpu/pvr/mem_debug.c
@@ -0,0 +1,250 @@
+/**********************************************************************
+ *
+ * Copyright(c) 2008 Imagination Technologies Ltd. All rights reserved.
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ * 
+ * This program is distributed in the hope it will be useful but, except 
+ * as otherwise stated in writing, without any warranty; without even the 
+ * implied warranty of merchantability or fitness for a particular purpose. 
+ * See the GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * The full GNU General Public License is included in this distribution in
+ * the file called "COPYING".
+ *
+ * Contact Information:
+ * Imagination Technologies Ltd. <gpl-support@imgtec.com>
+ * Home Park Estate, Kings Langley, Herts, WD4 8LZ, UK 
+ *
+ ******************************************************************************/
+
+#ifndef MEM_DEBUG_C
+#define MEM_DEBUG_C
+
+#if defined(PVRSRV_DEBUG_OS_MEMORY)
+
+#include "img_types.h"
+#include "services_headers.h"
+
+#if defined (__cplusplus)
+extern "C"
+{
+#endif
+
+#define STOP_ON_ERROR 0
+
+	
+
+	
+
+
+
+
+
+	IMG_BOOL MemCheck(const IMG_PVOID pvAddr, const IMG_UINT8 ui8Pattern, IMG_SIZE_T uSize)
+	{
+		IMG_UINT8 *pui8Addr;
+		for (pui8Addr = (IMG_UINT8*)pvAddr; uSize > 0; uSize--, pui8Addr++)
+		{
+			if (*pui8Addr != ui8Pattern)
+			{
+				return IMG_FALSE;
+			}
+		}
+		return IMG_TRUE;
+	}
+
+	
+
+	IMG_VOID OSCheckMemDebug(IMG_PVOID pvCpuVAddr, IMG_SIZE_T uSize, const IMG_CHAR *pszFileName, const IMG_UINT32 uLine)
+	{
+		OSMEM_DEBUG_INFO const *psInfo = (OSMEM_DEBUG_INFO *)((IMG_UINT32)pvCpuVAddr - TEST_BUFFER_PADDING_STATUS);
+
+		
+		if (pvCpuVAddr == IMG_NULL)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : null pointer"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if (((IMG_UINT32)pvCpuVAddr&3) != 0)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : invalid alignment"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if (!MemCheck((IMG_PVOID)psInfo->sGuardRegionBefore, 0xB1, sizeof(psInfo->sGuardRegionBefore)))
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : guard region before overwritten"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if (uSize != psInfo->uSize)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "Pointer 0x%X : supplied size was different to stored size (0x%X != 0x%X)"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr, uSize, psInfo->uSize,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+
+		
+		if ((0x01234567 ^ psInfo->uSizeParityCheck) != psInfo->uSize)
+		{
+			PVR_DPF((PVR_DBG_WARNING, "Pointer 0x%X : stored size parity error (0x%X != 0x%X)"
+					 " - referenced %s:%d - allocated %s:%d",
+					 pvCpuVAddr, psInfo->uSize, 0x01234567 ^ psInfo->uSizeParityCheck,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+		else
+		{
+			
+			uSize = psInfo->uSize;
+		}
+
+		
+		if (uSize)
+		{
+			if (!MemCheck((IMG_VOID*)((IMG_UINT32)pvCpuVAddr + uSize), 0xB2, TEST_BUFFER_PADDING_AFTER))
+			{
+				PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : guard region after overwritten"
+						 " - referenced from %s:%d - allocated from %s:%d",
+						 pvCpuVAddr,
+						 pszFileName, uLine,
+						 psInfo->sFileName, psInfo->uLineNo));
+			}
+		}
+
+		
+		if (psInfo->eValid != isAllocated)
+		{
+			PVR_DPF((PVR_DBG_ERROR, "Pointer 0x%X : not allocated (freed? %d)"
+					 " - referenced %s:%d - freed %s:%d",
+					 pvCpuVAddr, psInfo->eValid == isFree,
+					 pszFileName, uLine,
+					 psInfo->sFileName, psInfo->uLineNo));
+			while (STOP_ON_ERROR);
+		}
+	}
+
+	IMG_VOID debug_strcpy(IMG_CHAR *pDest, const IMG_CHAR *pSrc)
+	{
+		IMG_SIZE_T i = 0;
+
+		for (; i < 128; i++) 
+		{
+			*pDest = *pSrc;
+			if (*pSrc == '\0') break;
+			pDest++;
+			pSrc++;
+		}
+	}
+
+	PVRSRV_ERROR OSAllocMem_Debug_Wrapper(IMG_UINT32 ui32Flags,
+										  IMG_UINT32 ui32Size,
+										  IMG_PVOID *ppvCpuVAddr,
+										  IMG_HANDLE *phBlockAlloc,
+										  IMG_CHAR *pszFilename,
+										  IMG_UINT32 ui32Line)
+	{
+		OSMEM_DEBUG_INFO *psInfo;
+
+		PVRSRV_ERROR eError;
+
+		eError = OSAllocMem_Debug_Linux_Memory_Allocations(ui32Flags,
+				 ui32Size + TEST_BUFFER_PADDING,
+				 ppvCpuVAddr,
+				 phBlockAlloc,
+				 pszFilename,
+				 ui32Line);
+
+		if (eError != PVRSRV_OK)
+		{
+			return eError;
+		}
+
+		
+		OSMemSet((IMG_CHAR *)(*ppvCpuVAddr) + TEST_BUFFER_PADDING_STATUS, 0xBB, ui32Size);
+		OSMemSet((IMG_CHAR *)(*ppvCpuVAddr) + ui32Size + TEST_BUFFER_PADDING_STATUS, 0xB2, TEST_BUFFER_PADDING_AFTER);
+
+		
+		psInfo = (OSMEM_DEBUG_INFO *)(*ppvCpuVAddr);
+
+		OSMemSet(psInfo->sGuardRegionBefore, 0xB1, sizeof(psInfo->sGuardRegionBefore));
+		debug_strcpy(psInfo->sFileName, pszFilename);
+		psInfo->uLineNo = ui32Line;
+		psInfo->eValid = isAllocated;
+		psInfo->uSize = ui32Size;
+		psInfo->uSizeParityCheck = 0x01234567 ^ ui32Size;
+
+		
+		*ppvCpuVAddr = (IMG_PVOID) ((IMG_UINT32)*ppvCpuVAddr)+TEST_BUFFER_PADDING_STATUS;
+
+#ifdef PVRSRV_LOG_MEMORY_ALLOCS
+		
+		PVR_TRACE(("Allocated pointer (after debug info): 0x%X from %s:%d", *ppvCpuVAddr, pszFilename, ui32Line));
+#endif
+
+		return PVRSRV_OK;
+	}
+
+	PVRSRV_ERROR OSFreeMem_Debug_Wrapper(IMG_UINT32 ui32Flags,
+										 IMG_UINT32 ui32Size,
+										 IMG_PVOID pvCpuVAddr,
+										 IMG_HANDLE hBlockAlloc,
+										 IMG_CHAR *pszFilename,
+										 IMG_UINT32 ui32Line)
+	{
+		OSMEM_DEBUG_INFO *psInfo;
+
+		
+		OSCheckMemDebug(pvCpuVAddr, ui32Size, pszFilename, ui32Line);
+
+		
+		OSMemSet(pvCpuVAddr, 0xBF, ui32Size + TEST_BUFFER_PADDING_AFTER);  
+
+		
+		psInfo = (OSMEM_DEBUG_INFO *)((IMG_UINT32) pvCpuVAddr - TEST_BUFFER_PADDING_STATUS);
+
+		
+		psInfo->uSize = 0;
+		psInfo->uSizeParityCheck = 0;
+		psInfo->eValid = isFree;
+		psInfo->uLineNo = ui32Line;
+		debug_strcpy(psInfo->sFileName, pszFilename);
+
+		return OSFreeMem_Debug_Linux_Memory_Allocations(ui32Flags, ui32Size + TEST_BUFFER_PADDING, psInfo, hBlockAlloc, pszFilename, ui32Line);
+	}
+
+#if defined (__cplusplus)
+
+}
+#endif
+
+#endif 
+
+#endif        
diff --git a/drivers/gpu/pvr/omap3430/sysutils_linux.c b/drivers/gpu/pvr/omap3430/sysutils_linux.c
index a8fb837..2266e89 100644
--- a/drivers/gpu/pvr/omap3430/sysutils_linux.c
+++ b/drivers/gpu/pvr/omap3430/sysutils_linux.c
@@ -233,14 +233,14 @@ IMG_VOID DisableSGXClocks(SYS_DATA *psSysData)
 #if !defined(NO_HARDWARE)
 	SYS_SPECIFIC_DATA *psSysSpecData = (SYS_SPECIFIC_DATA *) psSysData->pvSysSpecificData;
 
-	/* unpin the memory bus */
-	omap_pm_set_min_bus_tput(&gpsPVRLDMDev->dev, OCP_INITIATOR_AGENT, 0);
-
 	if (atomic_read(&psSysSpecData->sSGXClocksEnabled) == 0)
 	{
 		return;
 	}
 
+	/* unpin the memory bus */
+	omap_pm_set_min_bus_tput(&gpsPVRLDMDev->dev, OCP_INITIATOR_AGENT, 0);
+
 	PVR_DPF((PVR_DBG_MESSAGE, "DisableSGXClocks: Disabling SGX Clocks"));
 
 	if (psSysSpecData->psSGX_ICK)
diff --git a/drivers/gpu/pvr/pdump_osfunc.h b/drivers/gpu/pvr/pdump_osfunc.h
old mode 100755
new mode 100644
diff --git a/drivers/gpu/pvr/services.h b/drivers/gpu/pvr/services.h
index 0a2b181..6dbab08 100644
--- a/drivers/gpu/pvr/services.h
+++ b/drivers/gpu/pvr/services.h
@@ -56,6 +56,8 @@ extern "C" {
 #define PVRSRV_MEM_RAM_BACKED_ALLOCATION	(1UL<<9)
 #define PVRSRV_MEM_NO_RESMAN				(1UL<<10)
 #define PVRSRV_MEM_EXPORTED					(1UL<<11)
+#define PVRSRV_MEM_EXPORTABLEDEVICEMEM		(1UL<<28)
+#define PVRSRV_MEM_EXPORTABLEDEVICEMEM2		(1UL<<29)
 
 
 #define PVRSRV_HAP_CACHED					(1UL<<12)
diff --git a/drivers/gpu/pvr/sgx_mkif_km.h b/drivers/gpu/pvr/sgx_mkif_km.h
old mode 100755
new mode 100644
diff --git a/drivers/i2c/chips/Kconfig b/drivers/i2c/chips/Kconfig
index e1ad67a..a225c50 100644
--- a/drivers/i2c/chips/Kconfig
+++ b/drivers/i2c/chips/Kconfig
@@ -158,4 +158,12 @@ config SENSORS_PCA963X
 	 This driver can also be built as a module.  If so, the module
 	 will be called pca963X.
 
+##w21558, LP3907 regulator feature
+config MOT_FEAT_LP3907
+	tristate "LP3907 Voltage Regulator chip"
+	depends on I2C
+	help
+	  If you say yes or m here you get support for the National Semiconductor
+	  LP3907 Regulator driver.
+
 endmenu
diff --git a/drivers/i2c/chips/Makefile b/drivers/i2c/chips/Makefile
index c4877d9..05fff0e 100644
--- a/drivers/i2c/chips/Makefile
+++ b/drivers/i2c/chips/Makefile
@@ -21,7 +21,8 @@ obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
 obj-$(CONFIG_TWL4030_POWEROFF)	+= twl4030-poweroff.o
 obj-$(CONFIG_TWL4030_MADC)	+= twl4030-madc.o
 obj-$(CONFIG_RTC_X1205_I2C)	+= x1205.o
-
+#w21558, Add LP3907 module
+obj-$(CONFIG_MOT_FEAT_LP3907)  += lp3907_i2c.o
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
diff --git a/drivers/i2c/chips/lp3907_i2c.c b/drivers/i2c/chips/lp3907_i2c.c
new file mode 100644
index 0000000..99e2f36
--- /dev/null
+++ b/drivers/i2c/chips/lp3907_i2c.c
@@ -0,0 +1,529 @@
+/*
+ * drivers/i2c/chips/lp3907_i2c.c
+ *
+ * I2C slave driver for LP3907 device
+ *
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Revision History:
+ *
+ * Date          Author    Comment
+ * -----------   --------  -------------------
+ * Jun-16-2008   Motorola  Initial version
+ * Jan-04-2009   Motorola  Deleted atmega init irq
+ */
+
+/* enable/disable printk message */
+/*#define DEBUG*/
+#undef DEBUG
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/cdev.h>
+#include <asm/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+
+#include "linux/i2c/lp3907_i2c.h"
+
+#define LP3907_REG_ADDR_LEN    (1)    /* 1 BYTE */
+#define I2C_RETRIES		5
+#define I2C_RETRY_DELAY		5
+
+/* LP3907 control register map */
+
+/* LP3907 POWER STATUS */
+#define LP3907_INIT_STATUS	0
+#define LP3907_PWRUP_STATUS	1
+#define LP3907_PWRDOWN_STATUS 	2
+
+typedef enum {
+	LP3907_ICRA_REG		= 0x02,
+	LP3907_SCR1_REG         = 0x07,
+	LP3907_BKLDOEN_REG      = 0x10,
+	LP3907_BKLDOSR_REG      = 0x11,
+	LP3907_VCCR_REG         = 0x20,
+	LP3907_B1TV1_REG        = 0x23,
+	LP3907_B1TV2_REG        = 0x24,
+	LP3907_B1RC_REG         = 0x25,
+	LP3907_B2TV1_REG        = 0x29,
+	LP3907_B2TV2_REG        = 0x2A,
+	LP3907_B2RC_REG         = 0x2B,
+	LP3907_BFCR_REG         = 0x38,
+	LP3907_LDO1VCR_REG      = 0x39,
+	LP3907_LDO2VCR_REG      = 0x3A,
+	LP3907_REG_MAX          = LP3907_LDO2VCR_REG,
+} LP3907_REG;
+
+#define LP3907_INVALID_REG      (LP3907_REG_MAX+1)
+
+typedef struct {
+	LP3907_REG reg;
+	u8	   data;
+} LP3907_cfg;
+/* */
+
+static LP3907_cfg lp3907_init_tbl[] = {
+	{LP3907_SCR1_REG,    0x28,},
+	{LP3907_BKLDOEN_REG, 0x74,},
+	{LP3907_VCCR_REG,    0x00,},
+	{LP3907_B2TV1_REG,   0x09,},  /* BUCK2 - 1.8V */
+	{LP3907_B2RC_REG,    0x28,},
+	{LP3907_BFCR_REG,    0x04,},
+	{LP3907_LDO1VCR_REG, 0x02,},  /* LDO1 - 1.2V */
+	{LP3907_LDO2VCR_REG, 0x08,},  /* LDO2 - 1.8V */
+
+	/* must end invalid register */
+	{LP3907_INVALID_REG, 0x00,},
+};
+
+static LP3907_cfg lp3907_pwr_off_tbl[] = {
+	{LP3907_BKLDOEN_REG, 0x70,},    /* BUCK1 disable */
+	{LP3907_BKLDOEN_REG, 0x60,},    /* LDO1EN disable */
+	{LP3907_BKLDOEN_REG, 0x20,},    /* LDO2EN disable */
+
+	/* must end invalid register */
+	{LP3907_INVALID_REG, 0x00,},
+};
+
+struct lp3907_data {
+	struct i2c_client *client;
+	struct lp3907_platform_data *pdata;
+
+	struct mutex lock; /* lock lp3907 */
+
+	int mode;
+	atomic_t enabled;
+};
+
+struct lp3907_data *g_lp3907_data;
+
+static struct i2c_driver lp3907_driver;
+static struct class *lp3907_class;
+static struct cdev lp3907_cdev;
+
+/* device major number */
+int lp3907_major_num = 240;
+int lp3907_minor_num;
+
+/* *****************************************************
+
+	Low level interface routine.
+
+* *****************************************************/
+
+/* write only 1 byte */
+static int lp3907_i2c_write(struct lp3907_data *pLP3907, u8 reg_addr, u8 value)
+{
+	struct i2c_msg msg;
+	u8 buf[sizeof(u8) + sizeof(u8)];
+	int ret = 0, try_cnt = 0;
+
+	buf[0] = reg_addr;
+	memcpy((void *)&buf[LP3907_REG_ADDR_LEN], (void *)&value, sizeof(u8));
+
+	msg.addr  = pLP3907->client->addr;
+	msg.flags = 0;   /* I2C_M_WR write the register value */
+	msg.buf   = buf;
+	msg.len   = sizeof(buf);
+
+	do {
+		/* one messages */
+		ret = i2c_transfer(pLP3907->client->adapter, &msg, 1);
+
+		if (ret != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((ret != 1) && ((++try_cnt) < I2C_RETRIES));
+
+	if (ret != 1) {
+		dev_err(&pLP3907->client->dev, "[LP3907]write transfer error\n");
+		ret = -EIO;
+	} else
+		ret = 0;
+
+	return ret;
+}
+
+static int lp3907_i2c_read(struct lp3907_data *pLP3907, u8 reg_addr, u8 *buf)
+{
+	struct i2c_msg msg;
+	u8 value[sizeof(u8) + sizeof(u8)];
+	int ret = 0, try_cnt = 0;
+
+	value[0] = reg_addr;
+	memset((void *)&value[LP3907_REG_ADDR_LEN], 0, sizeof(u8));
+
+	/* */
+	msg.addr  = pLP3907->client->addr;
+	msg.flags = I2C_M_RD;
+	msg.buf   = buf;
+	msg.len = sizeof(u8);
+
+	do {
+		ret = i2c_transfer(pLP3907->client->adapter, &msg, 1);
+		if (ret != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((ret != 1) && (++try_cnt < I2C_RETRIES));
+
+	if (ret != 1) {
+		dev_err(&pLP3907->client->dev, "[LP3907] read transfer error\n");
+		ret = -EIO;
+	} else {
+		memcpy((void *)buf, value + LP3907_REG_ADDR_LEN, sizeof(u8));
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int lp3907_power_on_sequence(struct lp3907_data *pLP3907)
+{
+	int ret = 0;
+	int i = 0;
+	int line = 0;
+	u8 ldo_status = 0x00;
+
+	dev_info(&pLP3907->client->dev, "%s is called.\n", __func__);
+
+	/* 1. set voltage regulator level. */
+	for (; lp3907_init_tbl[i].reg != LP3907_INVALID_REG; i++) {
+		if (ret == 0) {
+			ret = lp3907_i2c_write(pLP3907, \
+					       lp3907_init_tbl[i].reg, \
+					       lp3907_init_tbl[i].data);
+			if (!ret) {
+				dev_info(&pLP3907->client->dev, "[LP3907]WR: reg = 0x%x, data = 0x%x\n",
+						lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			}
+		} else {
+			dev_err(&pLP3907->client->dev, "lp3907_i2c_write(0x%x, 0x%x) is failed!\n",
+			       lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			line = __LINE__;
+			goto lp3907_configure_exit;
+		}
+	}
+
+	/* MDTV_REG pin control */
+	if (pLP3907->pdata->power_on)
+		pLP3907->pdata->power_on();
+
+	/* 3. read status register */
+	ret = lp3907_i2c_read(pLP3907, LP3907_BKLDOSR_REG, &ldo_status);
+	if (!ret) {
+		dev_err(&pLP3907->client->dev, "LP3907 read status = %d\n", ldo_status);
+	}
+
+	return 0;
+
+lp3907_configure_exit:
+
+	dev_err(&pLP3907->client->dev, "LP3907-CONFIGURE: failed [%d] line=[%d]\n", ret, line);
+	return ret;
+}
+
+static int lp3907_power_off_sequence(struct lp3907_data *pLP3907)
+{
+	int i = 0;
+	int line = 0, ret = 0;
+
+	dev_info(&pLP3907->client->dev, "%s is called.\n", __func__);
+
+	/* MDTV_REG pin control */
+	if (pLP3907->pdata->power_off)
+		pLP3907->pdata->power_off();
+
+	/* LDO and BUCK disable */
+	for (; lp3907_pwr_off_tbl[i].reg != LP3907_INVALID_REG; i++) {
+		if (ret == 0) {
+			ret = lp3907_i2c_write(pLP3907, \
+					       lp3907_pwr_off_tbl[i].reg, \
+					       lp3907_pwr_off_tbl[i].data);
+			if (!ret) {
+				dev_info(&pLP3907->client->dev, "[LP3907]WR: reg = 0x%x, data = 0x%x\n",
+						lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			}
+		} else {
+			dev_err(&pLP3907->client->dev, "lp3907_i2c_write(%x, %x) is failed!\n",
+			       lp3907_init_tbl[i].reg, lp3907_init_tbl[i].data);
+			line = __LINE__;
+			goto lp3907_poweroff_exit;
+		}
+	}
+
+	return 0;
+
+lp3907_poweroff_exit:
+
+	dev_err(&pLP3907->client->dev, "LP3907-CONFIGURE: failed [%d] line=[%d]\n", ret, line);
+	return ret;
+}
+
+static int lp3907_open(struct inode *inode, struct file *file)
+{
+	int err;
+
+	err = nonseekable_open(inode, file);
+	if (err < 0)
+		return err;
+	file->private_data = g_lp3907_data;
+
+	return 0;
+}
+
+static int lp3907_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __func__);
+  return 0;
+}
+
+static int lp3907_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	/*void __user *argp = (void __user *)arg;*/
+	int status = -1;
+	struct lp3907_data *pLP3907 = file->private_data;
+
+	switch (cmd) {
+	case LP3907_PWR_OFF_CMD:
+		/* power off sequence */
+		status = lp3907_power_off_sequence(pLP3907);
+		break;
+
+	case LP3907_PWR_ON_CMD:
+		/* power on sequence */
+		status = lp3907_power_on_sequence(pLP3907);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return status;
+}
+
+struct file_operations lp3907_fops = {
+	.owner   = THIS_MODULE,
+	.open    = lp3907_open,
+	.release = lp3907_release,
+	.ioctl   = lp3907_ioctl,
+};
+
+/* *****************************************************
+
+	Probe, Remove
+
+* ******************************************************/
+static int lp3907_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct lp3907_data *pLP3907;
+	int ret = -1, line;
+
+	dev_info(&client->dev, "lp3907_probe() is called.\n");
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "[lp3907]platform data is NULL. exiting.\n");
+		ret = -ENODEV;
+		goto err0;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		ret  = -ENODEV;
+		goto err0;
+	}
+
+	pLP3907 = kzalloc(sizeof(*pLP3907), GFP_KERNEL);
+	if (pLP3907 == NULL) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	mutex_init(&pLP3907->lock);
+	mutex_lock(&pLP3907->lock);
+	pLP3907->client = client;
+
+	pLP3907->pdata = kmalloc(sizeof(*pLP3907->pdata), GFP_KERNEL);
+	if (pLP3907->pdata == NULL)
+		goto err1;
+	memcpy(pLP3907->pdata, client->dev.platform_data, sizeof(*pLP3907->pdata));
+
+	strncpy(client->name, LP3907_DRIVER_NAME, I2C_NAME_SIZE);
+	i2c_set_clientdata(client, pLP3907);
+
+	if (pLP3907->pdata->init) {
+		ret = pLP3907->pdata->init();
+		if (ret < 0)
+			goto err1;
+	}
+
+    /* store platform data*/
+	g_lp3907_data = pLP3907;
+
+	ret = lp3907_power_off_sequence(pLP3907);
+	if (ret < 0) {
+		dev_err(&pLP3907->client->dev, "LP3907 chip configure is failed!\n");
+		goto err2;
+	}
+
+	mutex_unlock(&pLP3907->lock);
+	return ret;
+
+err2:
+	if (pLP3907->pdata->exit)
+		pLP3907->pdata->exit();
+
+err1:
+	mutex_unlock(&pLP3907->lock);
+	kfree(pLP3907->pdata);
+
+err0:
+	return ret;
+
+}
+
+static int __devexit lp3907_remove(struct i2c_client *client)
+{
+	struct lp3907_data *pLP3907 = i2c_get_clientdata(client);
+
+	dev_info(&pLP3907->client->dev, "lp3907_remove() is called!\n");
+
+	if (pLP3907->pdata->exit)
+		pLP3907->pdata->exit();
+	kfree(pLP3907->pdata);
+	kfree(pLP3907);
+
+	return 0;
+}
+
+static int lp3907_resume(struct i2c_client *client)
+{
+	struct lp3907_data *pLP3907 = i2c_get_clientdata(client);
+
+	dev_info(&pLP3907->client->dev, "lp3907_resume() is called!\n");
+	return 0;
+}
+
+static int lp3907_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct lp3907_data *pLP3907 = i2c_get_clientdata(client);
+
+	dev_info(&pLP3907->client->dev, "lp3907_suspend() is called!\n");
+	return 0;
+}
+
+static const struct i2c_device_id lp3907_id[] = {
+	{ LP3907_DRIVER_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lp3907_id);
+
+static struct i2c_driver lp3907_driver = {
+	.driver = {
+		.name = LP3907_DRIVER_NAME,
+	},
+	.probe	  = lp3907_probe,
+	.remove	  = __devexit_p(lp3907_remove),
+	.resume   = lp3907_resume,
+	.suspend  = lp3907_suspend,
+	.id_table = lp3907_id,
+};
+
+/*
+ *  LP3907 voltage regulator init
+ */
+static int __init lp3907_init(void)
+{
+	struct device *lp3907_device;
+	dev_t devno;
+
+	int ret = -1;
+	int line;
+
+	printk(KERN_INFO "LP3907 voltage regulator driver : init.\n");
+
+	devno = MKDEV(lp3907_major_num, lp3907_minor_num);
+	ret = register_chrdev_region(devno, 1, "lp3907");
+	if (ret < 0) {
+		printk(KERN_ERR "[FATAL] LP3907 device is failed.\n");
+		return ret;
+	}
+
+	lp3907_class = class_create(THIS_MODULE, "lp3907");
+	if (IS_ERR(lp3907_class)) {
+		unregister_chrdev_region(devno, 1);
+		ret = -EFAULT;
+	} else {
+
+	lp3907_device = device_create(lp3907_class,
+			NULL,
+			MKDEV(lp3907_major_num, lp3907_minor_num),
+			NULL,
+			"lp3907");
+		if (IS_ERR(lp3907_device)) {
+			class_destroy(lp3907_class);
+			unregister_chrdev_region(devno, 1);
+			ret = -EFAULT;
+		} else {
+
+	cdev_init(&lp3907_cdev, &lp3907_fops);
+	lp3907_cdev.owner = THIS_MODULE;
+	lp3907_cdev.ops   = &lp3907_fops;
+	kobject_set_name(&lp3907_cdev.kobj, "lp3907");
+	cdev_add(&lp3907_cdev, MKDEV(lp3907_major_num, lp3907_minor_num), 1);
+
+	ret = i2c_add_driver(&lp3907_driver);
+	if (ret) {
+		line = __LINE__;
+		goto init_exit_path;
+	}
+    }
+	}
+
+	printk(KERN_INFO "LP3907 voltage regulator driver : init is completed.\n");
+	return ret;
+init_exit_path:
+	printk(KERN_ERR "[FATAL] Unable to register LP3907 i2c driver!\n");
+	i2c_del_driver(&lp3907_driver);
+	return ret;
+}
+
+static void __exit lp3907_exit(void)
+{
+	i2c_del_driver(&lp3907_driver);
+
+	class_destroy(lp3907_class);
+	unregister_chrdev_region(MKDEV(lp3907_major_num, lp3907_minor_num), 1);
+
+	cdev_del(&lp3907_cdev);
+	printk(KERN_INFO "LP3907 voltage regulator driver: exit\n");
+}
+
+module_init(lp3907_init);
+module_exit(lp3907_exit);
+
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("LP3907 voltage regulator driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 8790ee4..b3f8b53 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -271,4 +271,12 @@ config INPUT_HALLEFFECT_BU52014HV
 	  effect sensor.
 
 	  If unsure, say N.
+
+config DISABLE_IRQ_WAKE_KPD
+	tristate "Disable IRQ wakeup on Keypad"
+	default y
+	help
+	  Say Y here if you wish not to let Keypad input wake up the phone
+	  from sleep state.
+
 endif
diff --git a/drivers/input/misc/gpio_matrix.c b/drivers/input/misc/gpio_matrix.c
index 6d1c1a7..c739615 100644
--- a/drivers/input/misc/gpio_matrix.c
+++ b/drivers/input/misc/gpio_matrix.c
@@ -110,6 +110,9 @@ static void report_key(struct gpio_kp *kp, int key_index, int out, int in)
 	unsigned short keycode = keyentry & MATRIX_KEY_MASK;
 	unsigned short dev = keyentry >> MATRIX_CODE_BITS;
 
+	if (mi->sw_fixup && !mi->sw_fixup(key_index))
+		return;
+
 	if (pressed != test_bit(keycode, kp->input_devs->dev[dev]->key)) {
 		if (keycode == KEY_RESERVED) {
 			if (mi->flags & GPIOKPF_PRINT_UNMAPPED_KEYS)
@@ -266,11 +269,13 @@ static int gpio_keypad_request_irqs(struct gpio_kp *kp)
 				"irq %d\n", mi->input_gpios[i], irq);
 			goto err_request_irq_failed;
 		}
+#ifndef CONFIG_DISABLE_IRQ_WAKE_KPD
 		err = set_irq_wake(irq, 1);
 		if (err) {
 			pr_err("gpiomatrix: set_irq_wake failed for input %d, "
 				"irq %d\n", mi->input_gpios[i], irq);
 		}
+#endif
 		disable_irq(irq);
 	}
 	return 0;
diff --git a/drivers/input/touchscreen/qtouch_obp_ts.c b/drivers/input/touchscreen/qtouch_obp_ts.c
index 77a49f7..0f311d3 100644
--- a/drivers/input/touchscreen/qtouch_obp_ts.c
+++ b/drivers/input/touchscreen/qtouch_obp_ts.c
@@ -66,8 +66,8 @@ struct qtouch_ts_data {
 	uint32_t			last_keystate;
 	uint16_t			eeprom_checksum;
 	uint8_t			    checksum_cnt;
-	int					x_delta;
-	int					y_delta;
+        int                             x_delta;
+        int                             y_delta;
 
 	/* Note: The message buffer is reused for reading different messages.
 	 * MUST enforce that there is no concurrent access to msg_buf. */
@@ -407,6 +407,35 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 			return ret;
 		}
 	}
+
+	/* configure the COM CONFIG support */
+	obj = find_obj(ts, QTM_OBJ_SPT_COM_CONFIG);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->com_cfg,
+					min(sizeof(ts->pdata->com_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the COM CONFIG config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the GPIO PWM support */
+	obj = find_obj(ts, QTM_OBJ_SPT_GPIO_PWM);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->gpio_pwm_cfg,
+					min(sizeof(ts->pdata->gpio_pwm_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the GPIO PWM config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	/* configure the grip suppression table */
 	obj = find_obj(ts, QTM_OBJ_PROCI_GRIPFACESUPPRESSION);
 	if (obj && obj->entry.num_inst > 0) {
@@ -421,6 +450,76 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 		}
 	}
 
+	/* configure noise suppression */
+	obj = find_obj(ts, QTM_OBJ_PROCG_NOISE_SUPPRESSION);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->noise_suppression_cfg,
+					min(sizeof(ts->pdata->noise_suppression_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the noise suppression config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the one touch gesture processor */
+	obj = find_obj(ts, QTM_OBJ_PROCI_ONE_TOUCH_GESTURE_PROC);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->one_touch_gesture_proc_cfg,
+					min(sizeof(ts->pdata->one_touch_gesture_proc_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the one touch gesture processor config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure self test */
+	obj = find_obj(ts, QTM_OBJ_SPT_SELF_TEST);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->self_test_cfg,
+					min(sizeof(ts->pdata->self_test_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the self test config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the two touch gesture processor */
+	obj = find_obj(ts, QTM_OBJ_PROCI_TWO_TOUCH_GESTURE_PROC);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->two_touch_gesture_proc_cfg,
+					min(sizeof(ts->pdata->two_touch_gesture_proc_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the two touch gesture processor config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
+	/* configure the capacitive touch engine  */
+	obj = find_obj(ts, QTM_OBJ_SPT_CTE_CONFIG);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->cte_config_cfg,
+					min(sizeof(ts->pdata->cte_config_cfg),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the capacitive touch engine config\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	/* configure the noise suppression table */
 	obj = find_obj(ts, QTM_OBJ_NOISESUPPRESSION_1);
 	if (obj && obj->entry.num_inst > 0) {
@@ -435,6 +534,20 @@ static int qtouch_hw_init(struct qtouch_ts_data *ts)
 		}
 	}
 
+	/* configure the user data table */
+	obj = find_obj(ts, QTM_OBJ_CPT_USERDATA);
+	if (obj && obj->entry.num_inst > 0) {
+		ret = qtouch_write_addr(ts, obj->entry.addr,
+					&ts->pdata->userdata,
+					min(sizeof(ts->pdata->userdata),
+					    obj->entry.size));
+		if (ret != 0) {
+			pr_err("%s: Can't write the user data\n",
+			       __func__);
+			return ret;
+		}
+	}
+
 	ret = qtouch_force_calibration(ts);
 	if (ret != 0) {
 		pr_err("%s: Unable to recalibrate after reset\n", __func__);
@@ -573,6 +686,12 @@ static int do_touch_multi_msg(struct qtouch_ts_data *ts, struct qtm_object *obj,
 	width = msg->touch_area;
 	pressure = msg->touch_amp;
 
+	if (ts->pdata->flags & QTOUCH_FLIP_X)
+		x = (ts->pdata->abs_max_x-1)-x;
+
+	if (ts->pdata->flags & QTOUCH_FLIP_Y)
+		y = (ts->pdata->abs_max_y-1)-y;
+
 	if (ts->pdata->flags & QTOUCH_SWAP_XY)
 		swap(x, y);
 
@@ -582,23 +701,23 @@ static int do_touch_multi_msg(struct qtouch_ts_data *ts, struct qtm_object *obj,
 
 	down = !(msg->status & QTM_TOUCH_MULTI_STATUS_RELEASE);
 
-	/* The chip may report erroneous points way
-	beyond what a user could possibly perform so we filter
-	these out */
-	if (ts->finger_data[finger].down &&
-			(abs(ts->finger_data[finger].x_data - x) > ts->x_delta ||
-			abs(ts->finger_data[finger].y_data - y) > ts->y_delta)) {
-				down = 0;
-				if (qtouch_tsdebug & 2)
-					pr_info("%s: x0 %i x1 %i y0 %i y1 %i\n",
-						__func__,
-						ts->finger_data[finger].x_data, x,
-						ts->finger_data[finger].y_data, y);
-	} else {
-		ts->finger_data[finger].x_data = x;
-		ts->finger_data[finger].y_data = y;
-		ts->finger_data[finger].w_data = width;
-	}
+        /* The chip may report erroneous points way
+        beyond what a user could possibly perform so we filter
+        these out */
+        if (ts->finger_data[finger].down &&
+                       (abs(ts->finger_data[finger].x_data - x) > ts->x_delta ||
+                       abs(ts->finger_data[finger].y_data - y) > ts->y_delta)) {
+                               down = 0;
+                               if (qtouch_tsdebug & 2)
+                                       pr_info("%s: x0 %i x1 %i y0 %i y1 %i\n",
+                                               __func__,
+                                               ts->finger_data[finger].x_data, x,
+                                               ts->finger_data[finger].y_data, y);
+        } else {
+               ts->finger_data[finger].x_data = x;
+               ts->finger_data[finger].y_data = y;
+               ts->finger_data[finger].w_data = width;
+        }
 
 	/* The touch IC will not give back a pressure of zero
 	   so send a 0 when a liftoff is produced */
@@ -758,6 +877,17 @@ static int qtouch_process_info_block(struct qtouch_ts_data *ts)
 	addr = QTM_OBP_ID_INFO_ADDR + sizeof(qtm_info);
 	report_id = 1;
 
+	/* Clear the object table */
+	for (i = 0; i < QTM_OBP_MAX_OBJECT_NUM; ++i) {
+		ts->obj_tbl[i].entry.type = 0;
+		ts->obj_tbl[i].entry.addr = 0;
+		ts->obj_tbl[i].entry.size = 0;
+		ts->obj_tbl[i].entry.num_inst = 0;
+		ts->obj_tbl[i].entry.num_rids = 0;
+		ts->obj_tbl[i].report_id_min = 0;
+		ts->obj_tbl[i].report_id_max = 0;
+	}
+
 	/* read out the object entries table */
 	for (i = 0; i < qtm_info.num_objs; ++i) {
 		struct qtm_object *obj;
@@ -846,6 +976,26 @@ static int qtouch_process_info_block(struct qtouch_ts_data *ts)
 
 	ts->eeprom_checksum = ts->pdata->nv_checksum;
 
+/*below: use different setting for vf.5 && vf.6*/
+	if ((qtm_info.family_id == 0x80) && \
+		((qtm_info.version == 0xf5) || \
+		(qtm_info.version == 0xf6) || \
+		(qtm_info.version == 0x12) || \
+		(qtm_info.version == 0x14))) {
+		printk(KERN_INFO "use setting for old touch firmware \n");
+		/* ts->pdata->power_cfg.active_acq_int = 0x0a; */
+
+		/* ts->pdata->acquire_cfg.touch_autocal = 0; */
+		/* ts->pdata->acquire_cfg.anti_cal_sthr = 0x14; */
+
+		ts->pdata->multi_touch_cfg.burst_len = 0x21;
+		/* ts->pdata->multi_touch_cfg.tch_det_thr = 0x25; */
+
+		/* ts->pdata->noise_suppression_cfg.gcaf_num_active = 0x03; */
+		/* ts->pdata->noise_suppression_cfg.gcaf_num_idle = 0; */
+
+		/* ts->pdata->cte_config_cfg.active_gcaf_depth = 0x10; */
+	}
 	return 0;
 
 err_no_checksum:
@@ -894,8 +1044,8 @@ static int qtouch_ts_probe(struct i2c_client *client,
 	ts->client = client;
 	i2c_set_clientdata(client, ts);
 	ts->checksum_cnt = 0;
-	ts->x_delta = ts->pdata->x_delta;
-	ts->y_delta = ts->pdata->y_delta;
+        ts->x_delta = ts->pdata->x_delta;
+        ts->y_delta = ts->pdata->y_delta;
 
 	ts->input_dev = input_allocate_device();
 	if (ts->input_dev == NULL) {
@@ -1052,6 +1202,10 @@ static int qtouch_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 	if (qtouch_tsdebug & 4)
 		pr_info("%s: Suspending\n", __func__);
 
+	ret = qtouch_power_config(ts, 0);
+	if (ret < 0)
+		pr_err("%s: Cannot write power config\n", __func__);
+
 	disable_irq_nosync(ts->client->irq);
 	ret = cancel_work_sync(&ts->work);
 	if (ret) { /* if work was pending disable-count is now 2 */
@@ -1059,10 +1213,6 @@ static int qtouch_ts_suspend(struct i2c_client *client, pm_message_t mesg)
 		enable_irq(ts->client->irq);
 	}
 
-	ret = qtouch_power_config(ts, 0);
-	if (ret < 0)
-		pr_err("%s: Cannot write power config\n", __func__);
-
 	return 0;
 }
 
@@ -1091,14 +1241,32 @@ static int qtouch_ts_resume(struct i2c_client *client)
 	}
 	input_sync(ts->input_dev);
 
+	enable_irq(ts->client->irq);
+
 	ret = qtouch_power_config(ts, 1);
 	if (ret < 0) {
 		pr_err("%s: Cannot write power config\n", __func__);
 		return -EIO;
 	}
+
 	qtouch_force_reset(ts, 0);
 
-	enable_irq(ts->client->irq);
+	/* Below is a workaround for touch hang issue after toggling
+	   the power key */
+	ret = qtouch_force_calibration(ts);
+	if (ret != 0) {
+		pr_err("%s: Unable to recalibrate after reset\n", __func__);
+		return -EIO;
+	}
+	/* reset the address pointer */
+	ret = qtouch_set_addr(ts, ts->obj_tbl[QTM_OBJ_GEN_MSG_PROC].entry.addr);
+	if (ret != 0) {
+		pr_err("%s: Unable to reset address pointer after reset\n",
+		       __func__);
+		return -EIO;
+	}
+	msleep(50);
+
 	return 0;
 }
 
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index aecad1f..7e9955b 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -194,6 +194,12 @@ config LEDS_SHOLES
 	depends on LEDS_CLASS
 	help
 	  This option enables support for LEDs on Sholes.
+          
+config LEDS_SHOLEST
+	tristate "LED Support for Sholes Tablet device"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for LEDs on Sholes Tablet.
 
 config LEDS_LM3530
 	tristate "LM3530 ALS driver"
@@ -207,6 +213,32 @@ config LEDS_LM3554
 	help
 	  This option enables support for the LM3554 .
 
+config LEDS_BD7885
+	tristate "LED Support for BD7885 I2C chips"
+	depends on LEDS_CLASS && I2C
+	help
+	  This option enables support for LEDs connected to BD7885
+	  LED driver chips accessed via the I2C bus.  Supported
+
+config LEDS_BU9847
+	tristate "LED Support for BU9847 I2C chips"
+	depends on LEDS_CLASS && I2C
+	help
+	  This option enables support for LEDs connected to BU9847
+	  LED driver chips accessed via the I2C bus.  Supported
+
+config LEDS_AF_LED
+	tristate "LED Support for AF LED operatiion"
+	depends on LEDS_CLASS
+	help
+	  This option enables support for LEDs connected to CPCAP.
+	  
+config LEDS_FLASH_RESET
+	tristate "LED Support for FLASH_RESET pin control"
+	depends on LEDS_CLASS && LEDS_BD7885
+	help
+	  This option enables support for LED's FLASH_RESET pin operation.
+
 comment "LED Triggers"
 
 config LEDS_TRIGGERS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 4597956..2c4d4c9 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -26,6 +26,9 @@ obj-$(CONFIG_LEDS_FSG)			+= leds-fsg.o
 obj-$(CONFIG_LEDS_PCA955X)		+= leds-pca955x.o
 obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
+obj-$(CONFIG_LEDS_BD7885)		+= leds-bd7885.o
+obj-$(CONFIG_LEDS_BU9847)		+= leds-bu9847.o
+obj-$(CONFIG_LEDS_AF_LED)		+= leds-ld-cpcap-afled.o
 obj-$(CONFIG_LEDS_SHOLES)		+= leds-ld-cpcap-disp.o \
 					   leds-ld-cpcap-rgb.o \
 					   leds-ld-cpcap-kpad.o
diff --git a/drivers/leds/led-lm3530.c b/drivers/leds/led-lm3530.c
index e5033e4..c555202 100755
--- a/drivers/leds/led-lm3530.c
+++ b/drivers/leds/led-lm3530.c
@@ -27,6 +27,11 @@
 #include <linux/interrupt.h>
 #include <linux/led-lm3530.h>
 #include <linux/types.h>
+#include <linux/gpio_mapping.h>
+#ifdef CONFIG_LEDS_SHOLEST
+#include <linux/panel-suppliers.h>
+#endif
+#include <mach/gpio.h>
 
 int als_resistor_val[16] = {1, 9260, 4630, 3090, 2310,
 1850, 1540, 1320, 1160, 1030, 925, 842, 772, 712, 661, 617};
@@ -50,8 +55,39 @@ struct lm3530_data {
 	uint8_t current_divisor;
 	uint8_t current_array[8];
 	uint8_t led_on;
+#ifdef CONFIG_LEDS_SHOLEST
+	uint8_t als_circ;
+	uint16_t panel_supplier;
+#endif
 };
 
+#ifdef CONFIG_LEDS_SHOLEST
+/* For less power consumption */
+#define LM3530_LEDDRV_EN    get_gpio_by_name("lcd_panel_reset")
+/* Two-way ALS transition */
+#define ALS_INDOOR	0
+#define ALS_OUTDOOR	1
+
+/* Brightness converting table for AUO panel @ full current 22.5mA */
+uint8_t lm3530_auo_brt_cvt_tbl[128] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x09, 0x0A, 0x0C, 0x0E, 0x0F, 0x10, 0x11, 0x13,
+	0x14, 0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,
+	0x1B, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x20,
+	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x26, 0x27,
+	0x28, 0x29, 0x2A, 0x2B, 0x2B, 0x2C, 0x2D, 0x2E,
+	0x2F, 0x30, 0x31, 0x31, 0x32, 0x33, 0x34, 0x35,
+	0x36, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
+	0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x41, 0x42,
+	0x43, 0x44, 0x45, 0x46, 0x46, 0x47, 0x48, 0x49,
+	0x4A, 0x4B, 0x4C, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
+	0x51, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+	0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5C, 0x5D,
+	0x5E, 0x5F, 0x60, 0x61, 0x61, 0x62, 0x63, 0x64,
+	0x65, 0x66, 0x67, 0x67, 0x68, 0x69, 0x6A, 0x6B,
+	0x6C, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72};
+#endif
+
 struct lm3530_reg {
 	const char *name;
 	uint8_t reg;
@@ -79,6 +115,10 @@ static void lm3530_early_suspend(struct early_suspend *handler);
 static void lm3530_late_resume(struct early_suspend *handler);
 #endif
 
+#ifdef CONFIG_LEDS_SHOLEST
+static void ld_lm3530_lux_conv(struct lm3530_data *als_data);
+#endif
+
 static uint32_t lm3530_debug;
 module_param_named(als_debug, lm3530_debug, uint, 0664);
 
@@ -173,19 +213,98 @@ static int ld_lm3530_init_registers(struct lm3530_data *als_data)
 	return 0;
 }
 
+#ifdef CONFIG_LEDS_SHOLEST
+static int ld_lm3530_switch_als_circumstance(struct lm3530_data *als_data,
+					     uint8_t set_als)
+{
+	switch (set_als) {
+	case ALS_INDOOR:
+		/* Set ALS configuration for Indoor mode */
+		als_data->als_pdata->als_resistor_sel = 0x22;
+		als_data->als_pdata->zone_boundary_0  = 0x07;
+		als_data->als_pdata->zone_boundary_1  = 0x29;
+		als_data->als_pdata->zone_boundary_2  = 0x48;
+		als_data->als_pdata->zone_boundary_3  = 0x94;
+		als_data->als_pdata->zone_target_0    = 0x12;
+		als_data->als_pdata->zone_target_1    = 0x1F;
+		als_data->als_pdata->zone_target_2    = 0x28;
+		als_data->als_pdata->zone_target_3    = 0x31;
+		als_data->als_pdata->zone_target_4    = 0x3A;
+		/* Circumstance parameter */
+		als_data->als_circ = ALS_INDOOR;
+		break;
+	case ALS_OUTDOOR:
+		/* Set ALS configuration for Outdoor mode */
+		als_data->als_pdata->als_resistor_sel = 0xBC;
+		als_data->als_pdata->zone_boundary_0  = 0x09;
+		als_data->als_pdata->zone_boundary_1  = 0x39;
+		als_data->als_pdata->zone_boundary_2  = 0x86;
+		als_data->als_pdata->zone_boundary_3  = 0xC9;
+		als_data->als_pdata->zone_target_0    = 0x3A;
+		als_data->als_pdata->zone_target_1    = 0x42;
+		als_data->als_pdata->zone_target_2    = 0x4B;
+		als_data->als_pdata->zone_target_3    = 0x54;
+		als_data->als_pdata->zone_target_4    = 0x65;
+		/* Circumstance parameter */
+		als_data->als_circ = ALS_OUTDOOR;
+		break;
+	default:
+		pr_err("%s:Invalid ALS circumstance\n", __func__);
+		break;
+	}
+
+	/* Write registers set */
+	if (lm3530_write_reg(als_data, LM3530_ALS_RESISTOR_SELECT,
+			als_data->als_pdata->als_resistor_sel) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB0_REG,
+			als_data->als_pdata->zone_boundary_0) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB1_REG,
+			als_data->als_pdata->zone_boundary_1) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB2_REG,
+			als_data->als_pdata->zone_boundary_2) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_ZB3_REG,
+			als_data->als_pdata->zone_boundary_3) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z0T_REG,
+			als_data->als_pdata->zone_target_0) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z1T_REG,
+			als_data->als_pdata->zone_target_1) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z2T_REG,
+			als_data->als_pdata->zone_target_2) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z3T_REG,
+			als_data->als_pdata->zone_target_3) ||
+	    lm3530_write_reg(als_data, LM3530_ALS_Z4T_REG,
+			als_data->als_pdata->zone_target_4)) {
+		pr_err("%s:ALS indoor setting failed\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Update converting table */
+	ld_lm3530_lux_conv(als_data);
+
+	return 0;
+}
+#endif
+
 static void ld_lm3530_brightness_set(struct led_classdev *led_cdev,
 				     enum led_brightness value)
 {
 	int brightness = 0;
 	int error = 0;
 	int old_led_on;
+	int config;
 	struct lm3530_data *als_data =
 	    container_of(led_cdev, struct lm3530_data, led_dev);
 
-	if (als_data->mode == AUTOMATIC)
+#ifdef CONFIG_LEDS_SHOLEST
+	if (als_data->panel_supplier == SUPPLIER_ID_INVALID)
+		als_data->panel_supplier = SUPPLIER_ID_AUO;
+#endif
+
+	if (als_data->mode == AUTOMATIC) {
 		brightness = als_data->als_pdata->gen_config;
-	else
+	} else {
 		brightness = als_data->als_pdata->manual_current;
+	}
 
 	if (value == LED_OFF) {
 		als_data->led_on = 0;
@@ -195,19 +314,70 @@ static void ld_lm3530_brightness_set(struct led_classdev *led_cdev,
 				__func__, error);
 			return;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
+		gpio_set_value(LM3530_LEDDRV_EN, 0);
+#endif
 	} else {
 		brightness |= 0x01;
+#ifdef CONFIG_LEDS_SHOLEST
+		if (als_data->led_on == 0) {
+			/* Set LEDDRV_EN on */
+			gpio_set_value(LM3530_LEDDRV_EN, 1);
+			msleep(5);
+
+			/* Reinitialize lm3530 */
+			ld_lm3530_init_registers(als_data);
+
+			if (als_data->mode == AUTOMATIC) {
+				/* Set ALS as indoor mode */
+				ld_lm3530_switch_als_circumstance(als_data,
+								  ALS_INDOOR);
+			} else {
+				/* Restore configurations to disable ALS */
+				config = LM3530_MANUAL_VALUE;
+				if (als_data->mode != MANUAL)
+					config |= LM3530_SENSOR_ENABLE;
+				lm3530_write_reg(als_data, LM3530_ALS_CONFIG,
+						 config);
+				/* ALS resistance */
+				config = (als_data->mode == MANUAL ? 0 :
+					als_data->als_pdata->als_resistor_sel);
+				lm3530_write_reg(als_data,
+						 LM3530_ALS_RESISTOR_SELECT,
+						 config);
+				/* Set ramp rate for manual mode */
+				lm3530_write_reg(als_data,
+						 LM3530_BRIGHTNESS_RAMP_RATE,
+						 LM3530_MANUAL_RAMP_RATE_VALUE);
+				/* Update converting table */
+				ld_lm3530_lux_conv(als_data);
+			}
+		}
+#endif
+		if (lm3530_debug)
+			pr_info("%s:LM3530_GEN_CONFIG=%x\n",
+				__func__, brightness);
 		if (lm3530_write_reg(als_data, LM3530_GEN_CONFIG, brightness)) {
 			pr_err("%s:writing failed while setting brightness:%d\n",
 				__func__, error);
 			return;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
 		if (lm3530_write_reg(als_data, LM3530_BRIGHTNESS_CTRL_REG,
-			value / 2)) {
+			((als_data->panel_supplier == SUPPLIER_ID_AUO) ?
+			lm3530_auo_brt_cvt_tbl[value >> 1] : value >> 1))) {
 				pr_err("%s:Failed to set brightness:%d\n",
 				__func__, error);
 			return;
 		}
+#else
+		if (lm3530_write_reg(als_data, LM3530_BRIGHTNESS_CTRL_REG,
+			value >> 1)) {
+			pr_err("%s:Failed to set brightness:%d\n",
+				__func__, error);
+			return;
+		}
+#endif
 		als_data->last_requested_brightness = value;
 		old_led_on = als_data->led_on;
 		als_data->led_on = 1;
@@ -249,10 +419,11 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 		    && mode_value != MANUAL_SENSOR)
 		return -1;
 
-	if (mode_value == AUTOMATIC)
+	if (mode_value == AUTOMATIC) {
 		brightness = als_data->als_pdata->gen_config;
-	else
+	} else {
 		brightness = als_data->als_pdata->manual_current;
+	}
 
 	if (mode_value == AUTOMATIC) {
 		ld_lm3530_init_registers(als_data);
@@ -264,6 +435,19 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 			als_data->mode = -1;
 			return -1;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
+		/* Restore ramp rate for automatic ALS mode */
+		error = lm3530_write_reg(als_data,
+					 LM3530_BRIGHTNESS_RAMP_RATE,
+					 als_data->als_pdata->brightness_ramp);
+		if (error) {
+			pr_err("%s:Failed to restore ramp rate %d\n",
+			       __func__, error);
+			return -1;
+		}
+		/* Update converting table */
+		ld_lm3530_lux_conv(als_data);
+#endif
 		als_data->mode = AUTOMATIC;
 	} else {
 		als_data->mode = mode_value;
@@ -295,6 +479,17 @@ static ssize_t ld_lm3530_als_store(struct device *dev, struct device_attribute
 			       __func__, error);
 			return -1;
 		}
+#ifdef CONFIG_LEDS_SHOLEST
+		/* Set ramp rate for manual mode */
+		error = lm3530_write_reg(als_data,
+					 LM3530_BRIGHTNESS_RAMP_RATE,
+					 LM3530_MANUAL_RAMP_RATE_VALUE);
+		if (error) {
+			pr_err("%s:Failed to restore ramp rate %d\n",
+			       __func__, error);
+		return -1;
+	}
+#endif
 	}
 
 	if (mode_value != MANUAL) {
@@ -416,6 +611,61 @@ static ssize_t ld_lm3530_registers_store(struct device *dev,
 static DEVICE_ATTR(registers, 0644, ld_lm3530_registers_show,
 		ld_lm3530_registers_store);
 
+/*
+ * To handle panel dependent physical characteristic variances.
+ */
+#ifdef CONFIG_LEDS_SHOLEST
+static ssize_t
+ ld_lm3530_backlight_panel_show(struct device *dev, struct device_attribute
+			*attr, char *buf)
+{
+	struct i2c_client *client = container_of(dev->parent, struct i2c_client,
+						 dev);
+	struct lm3530_data *als_data = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%u", als_data->panel_supplier);
+}
+
+static ssize_t
+ ld_lm3530_panel_specific_tune(struct device *dev, struct device_attribute
+			*attr, const char *buf, size_t size)
+{
+	int error = 0;
+	unsigned long backlight_panel;
+	struct i2c_client *client = container_of(dev->parent, struct i2c_client,
+						 dev);
+	struct lm3530_data *als_data = i2c_get_clientdata(client);
+
+	error = strict_strtoul(buf, 10, &backlight_panel);
+	if (error < 0) {
+		pr_err("%s:Unable to read input, error=%d\n", __func__, error);
+		return -1;
+	}
+
+	pr_info("%s:Tuning full current according to given panel ID:%lu\n",
+		__func__, backlight_panel);
+
+	/* Store panel supplier ID */
+	als_data->panel_supplier = backlight_panel;
+
+	if (als_data->panel_supplier != SUPPLIER_ID_INVALID) {
+		/* Set current 26mA for TMD or 29.5mA for AUO */
+		als_data->als_pdata->gen_config =
+			(als_data->als_pdata->gen_config & 0xE3) |
+			((als_data->panel_supplier == SUPPLIER_ID_TMD) ?
+			 0x18 : 0x1C);
+		/* Set current 19mA for TMD or 22.5mA for AUO */
+		als_data->als_pdata->manual_current =
+			(als_data->als_pdata->manual_current & 0xE3) |
+			((als_data->panel_supplier == SUPPLIER_ID_TMD) ?
+			 0x10 : 0x14);
+	}
+	return backlight_panel;
+}
+static DEVICE_ATTR(backlight_panel, 0666, ld_lm3530_backlight_panel_show,
+			ld_lm3530_panel_specific_tune);
+#endif
+
 void ld_lm3530_work_queue(struct work_struct *work)
 {
 	int ret;
@@ -430,7 +680,6 @@ void ld_lm3530_work_queue(struct work_struct *work)
 		       __func__, ret);
 
 		enable_irq(als_data->client->irq);
-
 		return;
 	}
 	/* Don't allow the data to be sent if the LED is supposed to
@@ -438,6 +687,7 @@ void ld_lm3530_work_queue(struct work_struct *work)
 	if (als_data->led_on == 0) {
 		if (lm3530_debug)
 			pr_info("%s:Skipping this interrupt\n", __func__);
+
 		enable_irq(als_data->client->irq);
 		return;
 	}
@@ -447,7 +697,27 @@ void ld_lm3530_work_queue(struct work_struct *work)
 		pr_info("%s:ALS Zone read back: %d\n",
 		       __func__, als_data->zone);
 
-	light_value = als_data->zone *  (als_data->current_divisor - 1);
+#ifdef CONFIG_LEDS_SHOLEST
+	if ((als_data->als_circ == ALS_OUTDOOR) &&
+	    (als_data->zone == LM3530_ALS_ZONE_MIN)) {
+		pr_info("%s:Switch ALS configuratiosn into indoor mode\n",
+			__func__);
+		ld_lm3530_switch_als_circumstance(als_data, ALS_INDOOR);
+
+		queue_work(als_data->working_queue, &als_data->wq);
+		return;
+	} else if ((als_data->als_circ == ALS_INDOOR) &&
+		   (als_data->zone == LM3530_ALS_ZONE_MAX)) {
+		pr_info("%s:Switch ALS configuratiosn into outdoor mode\n",
+			__func__);
+		ld_lm3530_switch_als_circumstance(als_data, ALS_OUTDOOR);
+
+		queue_work(als_data->working_queue, &als_data->wq);
+		return;
+	}
+#endif
+
+	light_value = als_data->zone * (als_data->current_divisor - 1);
 
 	/* Need to indicate a zone 0 but this would indicate it is off
 	so send up a low value and not a 0 */
@@ -581,6 +851,10 @@ static int ld_lm3530_probe(struct i2c_client *client,
 	als_data->led_dev.name = LD_LM3530_LED_DEV;
 	als_data->led_dev.brightness_set = ld_lm3530_brightness_set;
 	als_data->led_on = 1;
+#ifdef CONFIG_LEDS_SHOLEST
+	als_data->als_circ = ALS_INDOOR;
+	als_data->panel_supplier = SUPPLIER_ID_TMD;
+#endif
 
 	als_data->working_queue = create_singlethread_workqueue("als_wq");
 	if (!als_data->working_queue) {
@@ -654,6 +928,15 @@ static int ld_lm3530_probe(struct i2c_client *client,
 		goto err_create_registers_file_failed;
 	}
 
+#ifdef CONFIG_LEDS_SHOLEST
+	error = device_create_file(als_data->led_dev.dev, &dev_attr_backlight_panel);
+	if (error < 0) {
+		pr_err("%s:File device creation failed: %d\n", __func__, error);
+		error = -ENODEV;
+		goto err_create_backlight_panel_file_failed;
+	}
+#endif
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	als_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	als_data->early_suspend.suspend = lm3530_early_suspend;
@@ -665,6 +948,10 @@ static int ld_lm3530_probe(struct i2c_client *client,
 
 	return 0;
 
+#ifdef CONFIG_LEDS_SHOLEST
+err_create_backlight_panel_file_failed:
+	device_remove_file(als_data->led_dev.dev, &dev_attr_backlight_panel);
+#endif
 err_create_registers_file_failed:
 	device_remove_file(als_data->led_dev.dev, &dev_attr_pwm_mode);
 err_create_pwm_file_failed:
@@ -693,6 +980,9 @@ static int ld_lm3530_remove(struct i2c_client *client)
 	device_remove_file(als_data->led_dev.dev, &dev_attr_als);
 	device_remove_file(als_data->led_dev.dev, &dev_attr_pwm_mode);
 	device_remove_file(als_data->led_dev.dev, &dev_attr_registers);
+#ifdef CONFIG_LEDS_SHOLEST
+	device_remove_file(als_data->led_dev.dev, &dev_attr_backlight_panel);
+#endif
 	led_classdev_unregister(&als_data->led_dev);
 	free_irq(als_data->client->irq, als_data);
 	if (als_data->working_queue)
diff --git a/drivers/leds/leds-bd7885.c b/drivers/leds/leds-bd7885.c
new file mode 100644
index 0000000..6dfe3de
--- /dev/null
+++ b/drivers/leds/leds-bd7885.c
@@ -0,0 +1,661 @@
+/*
+ * drivers/i2c/chips/leds-bd7885.c
+ *
+ * I2C slave driver for BD7885 device
+ *
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Revision History:
+ *
+ * Date          Author    Comment
+ * -----------   --------  -------------------
+ * Jun-24-2008   Motorola  Initial version
+ * 
+ */
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/cdev.h>
+#include <asm/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+
+#include <linux/leds-bd7885.h>
+
+#if defined(CONFIG_LEDS_BU9847)
+#include <linux/leds-bu9847.h>
+#endif
+
+static int bd7885_open(struct inode *inode, struct file *file);
+static int bd7885_release(struct inode *inode, struct file *file);
+static int bd7885_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+
+/*Below two external definition is for strobe manual control.*/
+extern int ov8810_strobe_manual_ready(void);
+extern int ov8810_strobe_manual_trigger(void);
+
+#if defined(CONFIG_LEDS_BU9847)
+int bu9847_fetch_regs(void);
+#endif
+
+struct bd7885_chip {
+	struct mutex lock;
+	struct i2c_client *client;
+	int status;               /* flag indicate chip current power state */
+};
+
+struct file_operations bd7885_fops = {
+	.owner   = THIS_MODULE,
+	.open    = bd7885_open,
+	.release = bd7885_release,
+	.ioctl   = bd7885_ioctl,
+};
+
+static struct miscdevice bd7885_device = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = BD7885_DEVICE_NAME,
+  .fops = &bd7885_fops,
+};
+
+const static bd7885_cfg bd7885_charege_enalbe_tbl[4] = {
+	{BD7885_DRVCNT_REG, 0x03},
+	{BD7885_RECHG_REG, 0x11},
+	{BD7885_IPEAKADJ_REG, 0x07},
+	/* must end invalid register */
+	{BD7885_REG_TERM, BD7885_VAL_TERM}
+};
+
+const static bd7885_cfg bd7885_charge_disable_tbl[2] = {
+       {BD7885_DRVCNT_REG, 0x00},
+	/* must end invalid register */
+	{BD7885_REG_TERM, BD7885_VAL_TERM}
+};
+
+/*for register value keep here.*/
+static char bd7885_reg_status_tbl[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+/* for ioctl */
+struct i2c_client *bd7885_i2c_client;
+
+/* device major number */
+int bd7885_major_num = 0;
+int bd7885_minor_num = 0;
+
+#if defined(CONFIG_LEDS_BU9847)
+/*for register value keep here.*/
+extern char bu9847_reg_info_tbl[18];
+#endif
+
+#define BD7885_I2C_RETRY_MAX 3
+
+/* *****************************************************
+
+	Low level interface routine.
+
+* *****************************************************/
+static int bd7885_reg_read(struct i2c_client *client, u8 reg_addr, u8 *buf)
+{
+    /** \var error
+     *  \brief Return error code, initialized to no error
+     */
+    int error = E_OK;
+    /** \var i
+     *  \brief Retry counter
+     */
+    int i = 0;
+    unsigned char value[BD7885_REG_DATA_LEN];
+
+    /* If number of bytes is out of range or buffer is incorrect, report, exit */
+    if ((buf == NULL) || (reg_addr > BD7885_STATUS_REG)) {
+	printk(KERN_ERR "invalid read parameter(s)\n");
+	return -EINVAL;
+    }
+    /* If I2C client doesn't exist */
+    if (client == NULL) {
+	printk(KERN_ERR "bd7885 null i2c read client\n");
+	return -EUNATCH;
+    }
+
+    /* Do read */
+    do {
+	/* Establish read address
+	*  i2c_master_send returns either the number of bytes sent or negative error from
+	*  i2c_transfer
+	*/
+	/* Copy the data into a buffer for correct format */
+	value[0] = reg_addr & 0xFF;
+	error = i2c_master_send(client, value, BD7885_REG_DATA_LEN);
+	/* Read data if send address succeeded (i2c_master_send returns the number
+	*  of bytes transferred) */
+	if (error == BD7885_REG_DATA_LEN) {
+		/* Retreive data
+		*  i2c_master_recv returns either the number of bytes received or negative error
+		*  from i2c_transfer
+		*/
+		error = i2c_master_recv(client, buf, BD7885_REG_DATA_LEN);
+	} else {
+		printk(KERN_ERR "bd7885 write of address %d failed: %d\n", value[0], error);
+	}
+
+	/* On failure (error will contain num_bytes if succeeded), print error code and
+	* delay before trying again */
+	if (error != BD7885_REG_DATA_LEN) {
+		printk(KERN_ERR "bd7885 read[%i] failed: %d\n", i, error);
+		msleep(10);
+	}
+    /* Do while an error exists and we haven't exceeded retry attempts */
+    } while ((error != BD7885_REG_DATA_LEN) && ((++i) < BD7885_I2C_RETRY_MAX));
+
+
+
+    /* On success, set error to E_OK (i2c_master_recv returns the number of bytes
+     *  transferred) */
+    if (error == BD7885_REG_DATA_LEN) {
+	error = E_OK;
+    }
+
+    return error;
+}
+
+static int bd7885_reg_write(struct i2c_client *client, u8 reg_addr, u8 reg_value)
+{
+    unsigned char value[BD7885_REG_ADDR_DATA_LEN];
+    int retval = 0;
+    int i =  BD7885_I2C_RETRY_MAX;
+    
+    /* Fail if the length is too small */
+    if ((reg_addr == BD7885_HW_ID_REG) || (reg_addr == BD7885_STATUS_REG) \
+		|| (reg_addr > BD7885_STATUS_REG)) {
+	printk(KERN_ERR "bd7885_reg_write: length is invalid\n");
+	return -EINVAL;
+    }
+
+    /* Fail if we weren't able to initialize (yet) */
+    if (client == NULL) {
+	printk(KERN_ERR "bd7885_reg_write: initialization failed\n");
+	return -EINVAL;
+    }
+
+    /* Copy the data into a buffer for correct format */
+    value[0] = reg_addr & 0xFF;
+    memcpy(&value[1], &reg_value, BD7885_REG_DATA_LEN);
+
+    /* Write the data to the device (retrying if necessary) */
+    do {
+	retval = i2c_master_send(client, value, BD7885_REG_ADDR_DATA_LEN);
+
+	/* On failure, output the error code and delay before trying again */
+	if (retval < 0) {
+		printk(KERN_ERR "bd7885 write 0x%X failed: %d\n",\
+				value[0], retval);
+		msleep(5);
+	}
+    } while ((retval < 0) && (i-- >= 0));
+
+    /* On success, set retval to 0 (i2c_master_send returns no. of bytes transfered) */
+    if (retval == BD7885_REG_ADDR_DATA_LEN) {
+	retval = 0;
+	/*Store write value to global status table.*/
+	bd7885_reg_status_tbl[reg_addr] = reg_value;
+    }
+
+    /* Delay after every I2C access or IC will NAK */
+    msleep(5);
+
+    return retval;
+}
+
+static int bd7885_reg_writes(struct i2c_client *client, const bd7885_cfg *reglist)
+{
+	int err = 0;
+	const bd7885_cfg *next = reglist;
+
+	while (!((next->reg == BD7885_REG_TERM)
+		&& (next->data == BD7885_VAL_TERM))) {
+		err = bd7885_reg_write(client, next->reg, next->data);
+		udelay(100);
+		if (err)
+			return err;
+		next++;
+	}
+	return 0;
+}
+
+/*
+It shoudl be called just one time.
+Because it include gpio request. If it is call many time, it makes error condition.
+*/
+static int bd7885_io_init(void)
+{
+    return 0;
+}
+
+#if defined(CONFIG_LEDS_BU9847)
+static int bd7885_quench_level_set(struct i2c_client *client,
+    unsigned char level)
+{
+    int ret = 0;
+
+    /*Quench level is from 1 to 12 if using bu9847.*/
+    if ((level < 1) || (level > 12))
+		return -1;
+
+    ret = bd7885_reg_write(client, BD7885_QUENCHADJ_REG,
+    bu9847_reg_info_tbl[BU9847_QCHC1_REG + level - 1]);
+
+    if (ret != 0) {
+		printk(KERN_ERR "bd7885_quench_level_set failed\n");
+		return -1;
+    }
+
+    return 0;
+}
+#endif/*CONFIG_LEDS_BU9847*/
+
+static int bd7885_charge_enable_sequence(struct i2c_client *client)
+{
+    printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+
+    /*Register value write down for charge enable.*/
+    if (bd7885_reg_writes(client, bd7885_charege_enalbe_tbl) != 0) {
+	printk(KERN_ERR "bd7885_reg_writes failed\n");
+	return -EFAULT;
+    }
+
+    return 0;
+}
+
+int bd7885_charge_disable_sequence(struct i2c_client *client)
+{
+    printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+
+    /*Register value write down for charge disable.*/
+    if (bd7885_reg_writes(client, bd7885_charge_disable_tbl) != 0) {
+	printk(KERN_ERR "bd7885_reg_writes failed\n");
+	return -EFAULT;
+    }
+
+    return 0;
+}
+
+static int bd7885_charge_enable(struct i2c_client *client)
+{
+
+    if (bd7885_charge_enable_sequence(client) != 0) {
+	printk(KERN_ERR "%s: bd7885_reg_writes failed\n", __FUNCTION__);
+	return -EFAULT;
+    }
+
+    return 0;
+}
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+bool bd7885_device_detection(void)
+{
+	u8 reg_val = 0;
+	int ret = 0;
+
+	/*Driver ID fetch and de*/
+	ret = bd7885_reg_read(bd7885_i2c_client, BD7885_HW_ID_REG, &reg_val);
+
+	if (ret != 0) {
+		printk(KERN_ERR "Xenon flash HW ID read fail\n");
+		return false;
+	}
+
+	if (reg_val == BD7885_HW_ID_VAL)
+		return true;
+
+	return false;
+}
+#endif
+
+/* *****************************************************
+
+	Probe, Remove
+
+* ******************************************************/
+static int bd7885_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct bd7885_chip *chip;
+	int ret = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE))  {
+		ret  = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+       bd7885_i2c_client = client;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)	{
+		return -ENOMEM;
+	}
+
+	printk(KERN_INFO "BD7885 driver: bd7885_probe()\n");
+
+	chip->client = client;
+	strncpy(client->name, BD7885_DRIVER_NAME, I2C_NAME_SIZE);
+	i2c_set_clientdata(client, chip);
+
+       ret = misc_register(&bd7885_device);
+	if (ret != 0)
+		printk(KERN_INFO "misc_register failed\n");
+
+	mutex_init(&chip->lock);
+
+	printk(KERN_INFO "BD7885 chip probe is finished.\n");
+
+	return ret;
+
+exit_check_functionality_failed:
+	return ret;
+}
+
+static int bd7885_remove(struct i2c_client *client)
+{
+	struct bd7885_chip *chip = i2c_get_clientdata(client);
+
+	printk(KERN_INFO "bd7885_remove() is called!\n");
+	kfree(chip);
+
+	return 0;
+}
+
+static const struct i2c_device_id bd7885_id[] = {
+	{ BD7885_DRIVER_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bd7885_id);
+
+static struct i2c_driver bd7885_driver = {
+	.driver = {
+		.name = BD7885_DRIVER_NAME,
+	},
+	.probe	  = bd7885_probe,
+	.remove	  = __devexit_p(bd7885_remove),
+	.id_table = bd7885_id,
+};
+
+static int bd7885_open(struct inode *inode, struct file *file)
+{
+	unsigned char reg_cnt = 0;
+
+	for (reg_cnt = 0; reg_cnt <= BD7885_STATUS_REG; reg_cnt++) {
+		if (bd7885_reg_read(bd7885_i2c_client, reg_cnt,\
+					&bd7885_reg_status_tbl[reg_cnt]) != 0) {
+			printk(KERN_ERR "bd7885_read failed. addr = %d\n",\
+					reg_cnt);
+			return -EFAULT;
+		}
+	}
+
+	printk(KERN_INFO "%s is called.\n",\
+					__func__);
+	return nonseekable_open(inode, file);
+}
+
+static int bd7885_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+  return 0;
+}
+
+static int bd7885_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    void __user *argp = (void __user *)arg;
+    unsigned char rwbuf, data1, data2;
+    bd7885_cfg rw_reg_buf;
+
+    int error = E_OK;
+
+    /* get information from user */
+    switch (cmd) {
+    case BD7885_IOCTL_GET_REGISTER:
+    case BD7885_IOCTL_SET_REGISTER:
+      if (copy_from_user(&rw_reg_buf, argp, sizeof(rw_reg_buf)))
+	return -EFAULT;
+	break;
+
+    case BD7885_IOCTL_SET_CHARGING:
+    case BD7885_IOCTL_SET_CHARGE_LEVEL:
+    case BD7885_IOCTL_SET_MODE:
+    case BD7885_IOCTL_SET_QUENCH_THRESHOLD:
+    case BD7885_IOCTL_GET_STATUS:
+    case BD7885_IOCTL_READY_STROBE_MANUAL:
+    case BD7885_IOCTL_FIRE_STROBE_MANUAL:
+      if (copy_from_user(&rwbuf, argp, sizeof(rwbuf)))
+		return -EFAULT;
+      break;
+
+    default:
+      printk(KERN_ERR "Abnormal value input = %d.\n", cmd);
+      break;
+    }
+
+    printk(KERN_ERR "BD7785_cmd = %d.\n", cmd);
+
+    /* interact with driver */
+    switch (cmd) {
+    case BD7885_IOCTL_GET_REGISTER:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_REGISTER is called.\n");
+       error = bd7885_reg_read(bd7885_i2c_client, rw_reg_buf.reg,\
+							&rw_reg_buf.data);
+	if (error != 0) {
+		printk(KERN_ERR "bd7885_read failed. addr = %d\n",\
+						rw_reg_buf.reg);
+		return error;
+	}
+      break;
+
+    case BD7885_IOCTL_SET_REGISTER:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_REGISTER is called.\n");
+
+	error = bd7885_reg_write(bd7885_i2c_client, rw_reg_buf.reg,\
+							rw_reg_buf.data);
+	if (error != 0) {
+		printk(KERN_ERR "bd7885_read failed. addr = %d\n",\
+						rw_reg_buf.reg);
+		return error;
+	}
+	break;
+
+    case BD7885_IOCTL_SET_CHARGING:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_CHARGING is called.\n");
+
+	if (rwbuf == BD7885_CHARGE_ENABLE) {
+		error = bd7885_charge_enable(bd7885_i2c_client);
+		if (error != 0) {
+			printk(KERN_ERR "BD7885 cmd = %d\n", cmd);
+			return error;
+		}
+
+	} else if (rwbuf == BD7885_CHARGE_DISABLE) {
+		error = bd7885_charge_disable_sequence(bd7885_i2c_client);
+		if (error != 0) {
+			printk(KERN_ERR "BD7885 cmd = %d\n", cmd);
+			return error;
+		}
+	} else {
+		printk(KERN_ERR "BD7885 charging status abnormal.\n");
+		return -EFAULT;
+	}
+	break;
+
+    case BD7885_IOCTL_SET_CHARGE_LEVEL:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_CHARGE_LEVEL is called.\n");
+
+	rwbuf &= BD7885_FULL_ADJ_LVL_MASK;
+       /*Apply FULLADJ setting.*/
+       error = bd7885_reg_write(bd7885_i2c_client, BD7885_FULLADJ_REG, rwbuf);
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+	break;
+
+    case BD7885_IOCTL_GET_STATUS:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_STATUS is called.\n");
+
+       error = bd7885_reg_read(bd7885_i2c_client, BD7885_STATUS_REG, &rwbuf);
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+	break;
+
+    case BD7885_IOCTL_SET_MODE:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_MODE is called.\n");
+
+       /*Apply Mode setting.*/
+       if (rwbuf == BD7885_STROBE_QUENCH_MODE) {
+		/* Set QUENCH_EN, Set PCNT_EN */
+		data1 = bd7885_reg_status_tbl[BD7885_QUENCHCNT_REG] | \
+				BD7885_QUENCH_EN_MASK;
+		data2 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] | \
+				BD7885_PCNT_EN_MASK;
+       }
+      else if (rwbuf == BD7885_STROBE_MANUAL_MODE) {
+		/* Clr QUENCH_EN, Set PCNT_EN */
+		data1 = bd7885_reg_status_tbl[BD7885_QUENCHCNT_REG] & \
+				(~BD7885_QUENCH_EN_MASK);
+		data2 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] | \
+				BD7885_PCNT_EN_MASK;
+      }
+       else {
+		/* Clr QUENCH_EN & PCNT_EN */
+		data1 = bd7885_reg_status_tbl[BD7885_QUENCHCNT_REG] & \
+				(~BD7885_QUENCH_EN_MASK);
+		data2 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] & \
+				(~BD7885_PCNT_EN_MASK);
+       }
+
+       error = bd7885_reg_write(bd7885_i2c_client, BD7885_QUENCHCNT_REG, data1);
+       error |= bd7885_reg_write(bd7885_i2c_client, BD7885_DRVCNT_REG, data2);
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+       break;
+
+    case BD7885_IOCTL_SET_QUENCH_THRESHOLD:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_SET_QUENCH_THRESHOLD is called.\n");
+
+       /*Apply VSTOPADJ & PTR value to Xenon flash.*/
+#if defined(CONFIG_LEDS_BU9847)
+	   /*Quench level fetch from EEPROM.*/
+		   error = bu9847_fetch_regs();
+		   if (error != 0)
+				return error;
+
+       /*Quench level fetch from EEPROM.*/
+       if (rwbuf != 0) {
+		/*Enable PCNT_EN*/
+		data1 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] | \
+				BD7885_PCNT_EN_MASK;
+		error = bd7885_reg_write(bd7885_i2c_client, \
+				BD7885_DRVCNT_REG, data1);
+		error |= bd7885_quench_level_set(bd7885_i2c_client, rwbuf);
+       } else {
+		/*Disable PCNT_EN*/
+		data1 = bd7885_reg_status_tbl[BD7885_DRVCNT_REG] & \
+				(~BD7885_PCNT_EN_MASK);
+		error = bd7885_reg_write(bd7885_i2c_client, \
+				BD7885_DRVCNT_REG, data1);
+       }
+	if (error != 0) {
+		printk(KERN_ERR "BD7885 cmd = %d write failure.\n", cmd);
+		return error;
+	}
+#endif
+	break;
+
+    case BD7885_IOCTL_READY_STROBE_MANUAL:
+		ov8810_strobe_manual_ready();
+	break;
+
+    case BD7885_IOCTL_FIRE_STROBE_MANUAL:
+		ov8810_strobe_manual_trigger();
+	break;
+
+    default:
+      return -ENOTTY;
+    }
+
+    /* return information to user */
+    switch (cmd) {
+    case BD7885_IOCTL_GET_REGISTER:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_REGISTER copy to user.\n");
+
+      if (copy_to_user(argp, &rw_reg_buf, sizeof(rw_reg_buf)))
+	return -EFAULT;
+      break;
+
+    case BD7885_IOCTL_GET_STATUS:
+	printk(KERN_ERR "BD7785_cmd = BD7885_IOCTL_GET_STATUS copy to user.\n");
+	printk(KERN_ERR "status value = %d\n", rwbuf);
+
+      if (copy_to_user(argp, &rwbuf, sizeof(rwbuf)))
+	return -EFAULT;
+      break;
+
+    default:
+      break;
+    }
+
+    return error;
+}
+
+/*
+ *  BD7885 voltage regulator init
+ */
+static int __init bd7885_init(void)
+{
+    int ret = -EFAULT;
+
+    ret = i2c_add_driver(&bd7885_driver);
+    if (ret != 0) {
+	printk(KERN_INFO "BD7885 init failed.\n");
+    }
+    printk(KERN_INFO "BD7885 i2c driver : init is completed.\n");
+
+    /*Base IO initialize.*/
+    bd7885_io_init();
+
+    return ret;
+}
+
+static void __exit bd7885_exit(void)
+{
+	i2c_del_driver(&bd7885_driver);
+
+	printk(KERN_INFO "BD7885  flash driver: exit\n");
+}
+
+module_init(bd7885_init);
+module_exit(bd7885_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("BD7885 flash regulator driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/leds/leds-bu9847.c b/drivers/leds/leds-bu9847.c
new file mode 100644
index 0000000..282a393
--- /dev/null
+++ b/drivers/leds/leds-bu9847.c
@@ -0,0 +1,297 @@
+/*
+ * drivers/i2c/chips/leds-bu9847.c
+ *
+ * I2C slave driver for BU9847 device
+ *
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Revision History:
+ *
+ * Date          Author    Comment
+ * -----------   --------  -------------------
+ * Jun-24-2008   Motorola  Initial version
+ *
+ */
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/cdev.h>
+#include <asm/gpio.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+
+#include "linux/leds-bu9847.h"
+
+static int bu9847_open(struct inode *inode, struct file *file);
+static int bu9847_release(struct inode *inode, struct file *file);
+static int bu9847_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+
+typedef struct {
+	unsigned char reg;
+	unsigned char	   data;
+} bu9847_cfg;
+
+struct bu9847_chip {
+	struct mutex lock;
+	struct i2c_client *client;
+	int status;               /* flag indicate chip current power state */
+};
+
+struct file_operations bu9847_fops = {
+	.owner   = THIS_MODULE,
+	.open    = bu9847_open,
+	.release = bu9847_release,
+	.ioctl   = bu9847_ioctl,
+};
+
+static struct miscdevice bu9847_device = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = BU9847_DEVICE_NAME,
+  .fops = &bu9847_fops,
+};
+
+/*for register value keep here.*/
+char bu9847_reg_info_tbl[18] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+/* for ioctl */
+struct i2c_client *bu9847_i2c_client;
+
+/* device major number */
+int bu9847_major_num = 0;
+int bu9847_minor_num = 0;
+
+#define BU9847_I2C_RETRY_MAX 3
+
+/* *****************************************************
+
+	Low level interface routine.
+
+* *****************************************************/
+static int bu9847_reg_read(struct i2c_client *client, u8 reg_addr, u8 *buf)
+{
+    /** \var error
+     *  \brief Return error code, initialized to no error
+     */
+    int error = E_OK;
+    /** \var i
+     *  \brief Retry counter
+     */
+    int i = 0;
+    unsigned char value[BU9847_REG_DATA_LEN];
+
+    /* If number of bytes is out of range or buffer is incorrect, report, exit */
+    if ((buf == NULL) || (reg_addr > BU9847_PRLDT_REG)) {
+	printk(KERN_ERR "invalid read parameter(s)\n");
+	return -EINVAL;
+    }
+    /* If I2C client doesn't exist */
+    if (client == NULL) {
+	printk(KERN_ERR "bu9847 null i2c read client\n");
+	return -EUNATCH;
+    }
+
+	/* Do read */
+    do {
+	/* Establish read address
+	*  i2c_master_send returns either the number of bytes sent or negative error from
+	*  i2c_transfer
+	*/
+	/* Copy the data into a buffer for correct format */
+	value[0] = reg_addr & 0xFF;
+	error = i2c_master_send(client, value , BU9847_REG_DATA_LEN);
+	/* Read data if send address succeeded (i2c_master_send returns the number
+	*  of bytes transferred) */
+	if (error == BU9847_REG_DATA_LEN) {
+		/* Retreive data
+		*  i2c_master_recv returns either the number of bytes received or negative error
+		*  from i2c_transfer
+		*/
+		error = i2c_master_recv(client, buf, BU9847_REG_DATA_LEN);
+	} else {
+		printk(KERN_ERR "bu9847 write of address %d failed: %d\n", value[0], error);
+	}
+
+	/* On failure (error will contain num_bytes if succeeded), print error code and
+	* delay before trying again */
+        if (error != BU9847_REG_DATA_LEN) {
+		printk(KERN_ERR "bu9847 read[%i] failed: %d\n", i, error);
+		msleep(10);
+	}
+    /* Do while an error exists and we haven't exceeded retry attempts */
+    } while ((error != BU9847_REG_DATA_LEN) && ((++i) < 5));
+
+    /* On success, set error to E_OK (i2c_master_recv returns the number of bytes
+     *  transferred) */
+    if (error == BU9847_REG_DATA_LEN)
+	error = E_OK;
+
+    return error;
+}
+
+int bu9847_fetch_regs(void)
+{
+    unsigned char reg_cnt = 0;
+    unsigned int ret = 0;
+
+    /*Read out status register information.*/
+    for (reg_cnt = BU9847_HW_ID_REG; reg_cnt <= BU9847_PRLDT_REG; reg_cnt++) {
+	ret = bu9847_reg_read(bu9847_i2c_client, reg_cnt, &bu9847_reg_info_tbl[reg_cnt]);
+	if (ret != 0) {
+		printk(KERN_INFO "bu9847_reg_read_filed. reg_addr = %d\n", reg_cnt);
+		return ret;
+	}
+    }
+
+    return 0;
+}
+
+/* *****************************************************
+
+	Probe, Remove
+
+* ******************************************************/
+static int bu9847_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct bu9847_chip *chip;
+	int ret = 0;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {
+		ret  = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+       bu9847_i2c_client = client;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	printk(KERN_INFO "BU9847 driver: bu9847_probe()\n");
+
+	chip->client = client;
+	strncpy(client->name, BU9847_DRIVER_NAME, I2C_NAME_SIZE);
+	i2c_set_clientdata(client, chip);
+
+#if 0
+       ret = i2c_attach_client(client);
+       if (ret != 0)
+	    printk(KERN_INFO "i2c_attach_client failed\n");
+#endif
+
+       ret = misc_register(&bu9847_device);
+       if (ret != 0)
+	    printk(KERN_INFO "misc_register failed\n");
+
+	mutex_init(&chip->lock);
+
+	printk(KERN_INFO "BU9847 chip probe is finished.\n");
+
+	return ret;
+
+exit_check_functionality_failed:
+	return ret;
+}
+
+static int bu9847_remove(struct i2c_client *client)
+{
+	struct bu9847_chip *chip = i2c_get_clientdata(client);
+
+	printk(KERN_INFO "bu9847_remove() is called!\n");
+	kfree(chip);
+
+	return 0;
+}
+
+static const struct i2c_device_id bu9847_id[] = {
+	{ BU9847_DRIVER_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, bu9847_id);
+
+static struct i2c_driver bu9847_driver = {
+	.driver = {
+		.name = BU9847_DRIVER_NAME,
+	},
+	.probe	  = bu9847_probe,
+	.remove	  = __devexit_p(bu9847_remove),
+	.id_table = bu9847_id,
+};
+
+static int bu9847_open(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+  return nonseekable_open(inode, file);
+}
+
+static int bu9847_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_INFO "%s is called.\n", __FUNCTION__);
+  return 0;
+}
+static int bu9847_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+
+    /* Do the handling. */
+    switch (cmd) {
+	case BU9847_IOCTL_INIT:
+		/*EEPROM data fetch from HW.*/
+		ret = bu9847_fetch_regs();
+	break;
+
+	default:
+		printk(KERN_INFO "%s's default called. %d\n", __FUNCTION__, cmd);
+	break;
+    }
+
+    return ret;
+}
+/*
+ *  BU9847 voltage regulator init
+ */
+static int __init bu9847_init(void)
+{
+    int ret = -1;
+
+    ret = i2c_add_driver(&bu9847_driver);
+    if (ret != 0)
+	printk(KERN_INFO "BU9847 init failed.\n");
+
+     printk(KERN_INFO "BU9847 i2c driver : init is completed.\n");
+
+    return ret;
+}
+
+static void __exit bu9847_exit(void)
+{
+	i2c_del_driver(&bu9847_driver);
+
+	printk(KERN_INFO "BU9847  flash driver: exit\n");
+}
+
+module_init(bu9847_init);
+module_exit(bu9847_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("BU9847 flash regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/leds/leds-ld-cpcap-afled.c b/drivers/leds/leds-ld-cpcap-afled.c
new file mode 100644
index 0000000..29bea70
--- /dev/null
+++ b/drivers/leds/leds-ld-cpcap-afled.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free dispware; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free dispware Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free dispware
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ */
+
+#include <linux/err.h>
+#include <linux/leds.h>
+#include <linux/leds-ld-cpcap.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/cpcap.h>
+#include <linux/spi/cpcap-regbits.h>
+
+struct af_led_data {
+	struct led_classdev af_led_class_dev;
+	struct cpcap_device *cpcap;
+	struct regulator *regulator;
+	int regulator_state;
+};
+
+static void af_led_set(struct led_classdev *led_cdev,
+			    enum led_brightness value)
+{
+	unsigned short brightness = 0;
+	int cpcap_status = 0;
+	struct af_led_data *af_led_data =
+	    container_of(led_cdev, struct af_led_data,
+			 af_led_class_dev);
+
+	if (value > 0) {
+		/*Set max bright level.*/
+		/* need to add dynamic control */
+		brightness = LD_MSG_IND_CPCAP_MASK >> 2;
+
+		if ((af_led_data->regulator) &&
+		    (af_led_data->regulator_state == 0)) {
+			regulator_enable(af_led_data->regulator);
+			af_led_data->regulator_state = 1;
+		}
+
+		/*cpcap_uc_stop(af_led_data->cpcap, CPCAP_MACRO_6);*/
+
+		cpcap_status = cpcap_regacc_write(af_led_data->cpcap,
+			CPCAP_REG_REDC, brightness, LD_MSG_IND_CPCAP_MASK);
+		if (cpcap_status < 0)
+			pr_err("%s: Writing to the register failed for %i\n",
+			       __func__, cpcap_status);
+	} else {
+		if ((af_led_data->regulator) &&
+		    (af_led_data->regulator_state == 1)) {
+			regulator_disable(af_led_data->regulator);
+			af_led_data->regulator_state = 0;
+		}
+
+		/* Due to a HW issue turn off the current then
+		turn off the duty cycle */
+		brightness = 1;
+
+		/*cpcap_uc_start(af_led_data->cpcap, CPCAP_MACRO_6);*/
+		/*cpcap_uc_start(af_led_data->cpcap, CPCAP_MACRO_4);*/
+
+		cpcap_status = cpcap_regacc_write(af_led_data->cpcap,
+			CPCAP_REG_REDC, brightness, LD_MSG_IND_CPCAP_MASK);
+		if (cpcap_status < 0)
+			pr_err("%s: Writing to the register failed for %i\n",
+			       __func__, cpcap_status);
+
+		brightness = 0;
+
+		cpcap_status = cpcap_regacc_write(af_led_data->cpcap,
+			CPCAP_REG_REDC, brightness, LD_MSG_IND_CPCAP_MASK);
+		if (cpcap_status < 0)
+			pr_err("%s: Writing to the register failed for %i\n",
+			       __func__, cpcap_status);
+	}
+
+}
+EXPORT_SYMBOL(af_led_set);
+
+static int af_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct af_led_data *info;
+
+	if (pdev == NULL) {
+		pr_err("%s: platform data required\n", __func__);
+		return -ENODEV;
+	}
+
+	info = kzalloc(sizeof(struct af_led_data), GFP_KERNEL);
+	if (info == NULL) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	info->cpcap = pdev->dev.platform_data;
+	platform_set_drvdata(pdev, info);
+
+	info->regulator = regulator_get(&pdev->dev, LD_SUPPLY);
+	if (IS_ERR(info->regulator)) {
+		pr_err("%s: Cannot get %s regulator\n", __func__, LD_SUPPLY);
+		ret = PTR_ERR(info->regulator);
+		goto exit_request_reg_failed;
+
+	}
+
+	info->regulator_state = 0;
+
+	info->af_led_class_dev.name = "af-led";
+	info->af_led_class_dev.brightness_set = af_led_set;
+	ret = led_classdev_register(&pdev->dev, &info->af_led_class_dev);
+	if (ret < 0) {
+		pr_err("%s:Register Auto focus LED class failed\n", __func__);
+		goto err_reg_af_led_class_failed;
+	}
+
+	return ret;
+
+err_reg_af_led_class_failed:
+	if (info->regulator)
+		regulator_put(info->regulator);
+exit_request_reg_failed:
+	kfree(info);
+	return ret;
+}
+
+static int af_remove(struct platform_device *pdev)
+{
+	struct af_led_data *info = platform_get_drvdata(pdev);
+
+	if (info->regulator)
+		regulator_put(info->regulator);
+
+	led_classdev_unregister(&info->af_led_class_dev);
+	return 0;
+}
+
+static struct platform_driver ld_af_driver = {
+	.probe = af_probe,
+	.remove = af_remove,
+	.driver = {
+		   .name = LD_AF_LED_DEV,
+		   },
+};
+
+static int __init led_af_init(void)
+{
+	return platform_driver_register(&ld_af_driver);
+}
+
+static void __exit led_af_exit(void)
+{
+	platform_driver_unregister(&ld_af_driver);
+}
+
+module_init(led_af_init);
+module_exit(led_af_exit);
+
+MODULE_DESCRIPTION("AF LED driver");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
diff --git a/drivers/leds/leds-ld-cpcap-disp.c b/drivers/leds/leds-ld-cpcap-disp.c
index ecd5318..de69fb2 100755
--- a/drivers/leds/leds-ld-cpcap-disp.c
+++ b/drivers/leds/leds-ld-cpcap-disp.c
@@ -27,8 +27,10 @@
 struct disp_button_led_data {
 	struct led_classdev disp_button_class_dev;
 	struct cpcap_device *cpcap;
+#ifndef CONFIG_LEDS_SHOLEST
 	struct regulator *regulator;
 	int regulator_state;
+#endif
 };
 
 static void disp_button_set(struct led_classdev *led_cdev,
@@ -41,6 +43,10 @@ static void disp_button_set(struct led_classdev *led_cdev,
 			 disp_button_class_dev);
 
 	if (value > 0) {
+#ifdef CONFIG_LEDS_SHOLEST
+		brightness = (LD_BLED_CPCAP_DUTY_CYCLE |
+			LD_BLED_CPCAP_CURRENT | LD_DISP_BUTTON_ON);
+#else
 		brightness = (LD_DISP_BUTTON_DUTY_CYCLE |
 			LD_DISP_BUTTON_CURRENT | LD_DISP_BUTTON_ON);
 
@@ -49,34 +55,53 @@ static void disp_button_set(struct led_classdev *led_cdev,
 			regulator_enable(disp_button_led_data->regulator);
 			disp_button_led_data->regulator_state = 1;
 		}
+#endif
 
+#ifdef CONFIG_LEDS_SHOLEST
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_BLEDC,
+						  brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
 						  CPCAP_REG_KLC,
 						  brightness,
 						  LD_DISP_BUTTON_CPCAP_MASK);
-
+#endif
 		if (cpcap_status < 0)
 			pr_err("%s: Writing to the register failed for %i\n",
 			       __func__, cpcap_status);
 
 	} else {
+#ifndef CONFIG_LEDS_SHOLEST
 		if ((disp_button_led_data->regulator) &&
 		    (disp_button_led_data->regulator_state == 1)) {
 			regulator_disable(disp_button_led_data->regulator);
 			disp_button_led_data->regulator_state = 0;
 		}
+#endif
 		/* Due to a HW issue turn off the current then
 		turn off the duty cycle */
 		brightness = 0x01;
+#ifdef CONFIG_LEDS_SHOLEST
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
-					  CPCAP_REG_KLC, brightness,
-					  LD_DISP_BUTTON_CPCAP_MASK);
-
+						  CPCAP_REG_BLEDC, brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_KLC, brightness,
+						  LD_DISP_BUTTON_CPCAP_MASK);
+#endif
 		brightness = 0x00;
+#ifdef CONFIG_LEDS_SHOLEST
+		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
+						  CPCAP_REG_BLEDC, brightness,
+						  LD_BLED_CPCAP_MASK);
+#else
 		cpcap_status = cpcap_regacc_write(disp_button_led_data->cpcap,
 						  CPCAP_REG_KLC, brightness,
 						  LD_DISP_BUTTON_CPCAP_MASK);
-
+#endif
 		if (cpcap_status < 0)
 			pr_err("%s: Writing to the register failed for %i\n",
 			       __func__, cpcap_status);
@@ -104,6 +129,7 @@ static int disp_button_probe(struct platform_device *pdev)
 	info->cpcap = pdev->dev.platform_data;
 	platform_set_drvdata(pdev, info);
 
+#ifndef CONFIG_LEDS_SHOLEST
 	info->regulator = regulator_get(&pdev->dev, LD_SUPPLY);
 	if (IS_ERR(info->regulator)) {
 		pr_err("%s: Cannot get %s regulator\n", __func__, LD_SUPPLY);
@@ -113,6 +139,7 @@ static int disp_button_probe(struct platform_device *pdev)
 	}
 
 	info->regulator_state = 0;
+#endif
 
 	info->disp_button_class_dev.name = "button-backlight";
 	info->disp_button_class_dev.brightness_set = disp_button_set;
@@ -125,8 +152,10 @@ static int disp_button_probe(struct platform_device *pdev)
 	return ret;
 
 err_reg_button_class_failed:
+#ifndef CONFIG_LEDS_SHOLEST
 	if (info->regulator)
 		regulator_put(info->regulator);
+#endif
 exit_request_reg_failed:
 	kfree(info);
 	return ret;
@@ -136,8 +165,10 @@ static int disp_button_remove(struct platform_device *pdev)
 {
 	struct disp_button_led_data *info = platform_get_drvdata(pdev);
 
+#ifndef CONFIG_LEDS_SHOLEST
 	if (info->regulator)
 		regulator_put(info->regulator);
+#endif
 
 	led_classdev_unregister(&info->disp_button_class_dev);
 	return 0;
diff --git a/drivers/leds/leds-ld-cpcap-rgb.c b/drivers/leds/leds-ld-cpcap-rgb.c
index c0406c6..0b4131f 100755
--- a/drivers/leds/leds-ld-cpcap-rgb.c
+++ b/drivers/leds/leds-ld-cpcap-rgb.c
@@ -36,12 +36,20 @@ struct msg_ind_led_data {
 void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 				int color, enum led_brightness value)
 {
+#ifdef CONFIG_LEDS_SHOLEST
+	unsigned short brightness = LD_MSG_IND_LO_CURRENT | LD_MSG_IND_ON;
+#else
 	unsigned short brightness = LD_MSG_IND_CURRENT | LD_MSG_IND_ON;
+#endif
 	int cpcap_status = 0;
 	int cpcap_register = 0;
 
 	if (color & LD_LED_RED)
+#ifdef CONFIG_LEDS_SHOLEST
+        cpcap_register = CPCAP_REG_ADLC;
+#else
 		cpcap_register = CPCAP_REG_REDC;
+#endif
 	else if (color & LD_LED_GREEN)
 		cpcap_register = CPCAP_REG_GREENC;
 	else if (color & LD_LED_BLUE)
@@ -56,7 +64,25 @@ void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 					  LD_MSG_IND_CPCAP_MASK);
 
 		brightness = 0x00;
-	} else if (value <= 51)
+	}
+#ifdef CONFIG_LEDS_SHOLEST
+	else if (value <= 51)
+		brightness |= (LD_MSG_IND_LOW << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 104)
+		brightness |= (LD_MSG_IND_LOW_MED << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 155)
+		brightness |= (LD_MSG_IND_MEDIUM << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else if (value <= 201)
+		brightness |= (LD_MSG_IND_MED_HIGH << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+	else
+		brightness |= (LD_MSG_IND_HIGH << \
+				((cpcap_register == CPCAP_REG_ADLC) << 1));
+#else
+    else if (value <= 51)
 		brightness |= LD_MSG_IND_LOW;
 	else if (value <= 104)
 		brightness |= LD_MSG_IND_LOW_MED;
@@ -66,6 +92,7 @@ void msg_ind_set_rgb_brightness(struct msg_ind_led_data *msg_ind_data,
 		brightness |= LD_MSG_IND_MED_HIGH;
 	else
 		brightness |= LD_MSG_IND_HIGH;
+#endif
 
 	cpcap_status = cpcap_regacc_write(msg_ind_data->cpcap,
 					  cpcap_register, brightness,
diff --git a/drivers/media/dvb/siano/Kconfig b/drivers/media/dvb/siano/Kconfig
index dd863f2..80a4dfa 100644
--- a/drivers/media/dvb/siano/Kconfig
+++ b/drivers/media/dvb/siano/Kconfig
@@ -2,25 +2,68 @@
 # Siano Mobile Silicon Digital TV device configuration
 #
 
-config DVB_SIANO_SMS1XXX
-	tristate "Siano SMS1XXX USB dongle support"
-	depends on DVB_CORE && USB
+# w21558, SPI interface between OMAP and SMS1130
+config MOT_FEAT_SPI_SMS1130
+	bool "Siano and OMAP SPI interface support"
+	default n
+
+config SMS_SIANO_MDTV_TDMB
+	tristate "Siano SMS1xxx based MDTV receiver"
+	default n
+	---help---
+	Choose Y or M here if you have MDTV receiver with a Siano chipset.
+	To compile this driver as a module, choose M here
+	(The modules will be called smsmdtv).
+	Note: All dependents, if selected, will be part of this module.
+	Further documentation on this driver can be found on the WWW at http://www.siano-ms.com/
+
+if SMS_SIANO_MDTV_TDMB
+menu "Siano module components"
+
+# Kernel sub systems support
+
+config SMS_DVB3_SUBSYS
+	bool "DVB v.3 Subsystem support"
+	default n
+	---help---
+	Choose
+
+config SMS_HOSTLIB_SUBSYS
+	bool "Host Library Subsystem support."
+	default n
+	---help---
+	Choose if you would like to have Siano's host library kernel sub-system support.
+
+if SMS_HOSTLIB_SUBSYS
+
+config SMS_NET_SUBSYS
+	bool "Siano Network Adapter"
+	default n
 	---help---
-	  Choose Y here if you have a USB dongle with a SMS1XXX chipset.
+	Choose if you would like to have Siano's network adapter support.
+
+endif # SMS_HOSTLIB_SUBSYS
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called sms1xxx.
+# Hardware interfaces support
 
-config DVB_SIANO_SMS1XXX_SMS_IDS
-	bool "Enable support for Siano Mobile Silicon default USB IDs"
-	depends on DVB_SIANO_SMS1XXX
-	default y
+config SMS_SPI_DRV
+	bool "SPI interface support"
+	default n
 	---help---
-	  Choose Y here if you have a USB dongle with a SMS1XXX chipset
-	  that uses Siano Mobile Silicon's default usb vid:pid.
+	Choose if you would like to have Siano's support for OMAP34XX SPI interface
+
+config SMS_USB_DRV
+        bool "USB inteface support"
+        default n
+        ---help---
+        Choose
 
-	  Choose N here if you would prefer to use Siano's external driver.
+config SMS_SDIO_DRV
+        bool "SDIO interface support"
+        default n
+        ---help---
+        Choose
 
-	  Further documentation on this driver can be found on the WWW at
-	  <http://www.siano-ms.com/>.
+endmenu
+endif # SMS_SIANO_MDTV_TDMB
 
diff --git a/drivers/media/dvb/siano/Makefile b/drivers/media/dvb/siano/Makefile
index ee0737a..f2fcbc0 100644
--- a/drivers/media/dvb/siano/Makefile
+++ b/drivers/media/dvb/siano/Makefile
@@ -1,8 +1,42 @@
-sms1xxx-objs := smscoreapi.o smsusb.o smsdvb.o sms-cards.o
+#sms1xxx-objs := smscoreapi.o smsusb.o smsdvb.o sms-cards.o
 
-obj-$(CONFIG_DVB_SIANO_SMS1XXX) += sms1xxx.o
+#obj-$(CONFIG_DVB_SIANO_SMS1XXX) += sms1xxx.o
 
-EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
+#EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 
-EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
+#EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
+###############################################################################
+#
+# Siano Mobile Silicon, Inc.
+# MDTV receiver kernel modules.
+# Copyright (C) 2006-2008, Uri Shkolnik
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+###############################################################################
 
+#Local variables initailization
+MODULE_NAME = smsmdtv
+
+SMSOBJ := smscoreapi.o sms-cards.o smsendian.o smsir.o
+
+EXTRA_CFLAGS += -DSMS_HOSTLIB_SUBSYS
+SMSOBJ += smschar.o
+
+EXTRA_CFLAGS += -DSMS_SPI_DRV
+SMSOBJ += smsspilog.o smsspicommon.o smsspiphy_omap34xx.o
+
+smsmdtv-objs := $(SMSOBJ)
+
+obj-m := smsmdtv.o
diff --git a/drivers/media/dvb/siano/compat.h b/drivers/media/dvb/siano/compat.h
new file mode 100644
index 0000000..66cf6d6
--- /dev/null
+++ b/drivers/media/dvb/siano/compat.h
@@ -0,0 +1,238 @@
+/*
+ * $Id: compat.h,v 1.44 2006/01/15 09:35:16 mchehab Exp $
+ */
+
+#ifndef _COMPAT_H
+#define _COMPAT_H
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+#define	KERN_CONT	""
+#endif
+
+/* To allow I2C compatibility code to work */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+#include <linux/i2c-dev.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#ifdef CONFIG_PROC_FS
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#endif
+#endif
+
+/* To allow alsa code to work */
+#ifdef NEED_SOUND_DRIVER_H
+#include <sound/driver.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+#define set_freezable()
+#define cancel_delayed_work_sync cancel_rearming_delayed_work
+#endif
+
+#ifndef __pure
+#  define __pure __attribute__((pure))
+#endif
+
+#ifndef I2C_M_IGNORE_NAK
+# define I2C_M_IGNORE_NAK 0x1000
+#endif
+
+/* device_create/destroy added in 2.6.18 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+/* on older kernels, class_device_create will in turn be a compat macro */
+# define device_create(a, b, c, d, e, f, g) class_device_create(a, NULL, c, b, d, e, f, g)
+# define device_destroy(a, b) class_device_destroy(a, b)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+#define IRQF_SHARED		SA_SHIRQ
+#define IRQF_DISABLED		SA_INTERRUPT
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+# define PCIAGP_FAIL 0
+
+#define vmalloc_32_user(a) vmalloc_32(a)
+
+#endif
+
+/* bool type and enum-based definition of true and false was added in 2.6.19 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+typedef int bool;
+#define true 1
+#define false 0
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+#define sony_pic_camera_command(a, b) sonypi_camera_command(a, b)
+
+#define SONY_PIC_COMMAND_SETCAMERAAGC        SONYPI_COMMAND_SETCAMERAAGC
+#define SONY_PIC_COMMAND_SETCAMERABRIGHTNESS SONYPI_COMMAND_SETCAMERABRIGHTNESS
+#define SONY_PIC_COMMAND_SETCAMERACOLOR      SONYPI_COMMAND_SETCAMERACOLOR
+#define SONY_PIC_COMMAND_SETCAMERACONTRAST   SONYPI_COMMAND_SETCAMERACONTRAST
+#define SONY_PIC_COMMAND_SETCAMERAHUE        SONYPI_COMMAND_SETCAMERAHUE
+#define SONY_PIC_COMMAND_SETCAMERAPICTURE    SONYPI_COMMAND_SETCAMERAPICTURE
+#define SONY_PIC_COMMAND_SETCAMERASHARPNESS  SONYPI_COMMAND_SETCAMERASHARPNESS
+#define SONY_PIC_COMMAND_SETCAMERA           SONYPI_COMMAND_SETCAMERA
+#endif
+
+/* pci_dev got a new revision field in 2.6.23-rc1 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23) && defined(LINUX_PCI_H)
+/* Just make it easier to subsitute pci_dev->revision with
+ * v4l_compat_pci_rev(pci_dev).  It's too bad there isn't some kind of context
+ * sensitive macro in C that could do this for us.  */
+static inline u8 v4l_compat_pci_rev(struct pci_dev *pci)
+{ u8 rev; pci_read_config_byte(pci, PCI_REVISION_ID, &rev); return rev; }
+#endif
+
+#if defined(COMPAT_PCM_TO_RATE_BIT) && defined(__SOUND_PCM_H)
+/* New alsa core utility function */
+static inline unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate)
+{
+	static const unsigned int rates[] = { 5512, 8000, 11025, 16000, 22050,
+		32000, 44100, 48000, 64000, 88200, 96000, 176400, 192000 };
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(rates); i++)
+		if (rates[i] == rate)
+			return 1u << i;
+	return SNDRV_PCM_RATE_KNOT;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+# define task_pid_nr(current) ((current)->pid)
+
+# define sg_init_table(a, b)
+# define sg_page(p) (sg->page)
+# define sg_set_page(sglist, pg, sz, off)	\
+do {						\
+	struct scatterlist *p = sglist;		\
+	p->page   = pg;				\
+	p->length = sz;				\
+	p->offset = off;			\
+} while (0)
+
+#define pr_err(fmt, arg...) \
+	printk(KERN_ERR fmt, ##arg)
+#endif
+
+#ifndef BIT_MASK
+# define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+# define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+#define i2c_verify_client(dev)	\
+	((dev->bus == &i2c_bus_type) ? to_i2c_client(dev) : NULL)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+#define i2c_verify_client(dev) \
+	((dev->bus && 0 == strcmp(dev->bus->name, "i2c")) ? to_i2c_client(dev) : NULL)
+#endif
+
+#ifndef USB_DEVICE_AND_INTERFACE_INFO
+# define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
+		| USB_DEVICE_ID_MATCH_DEVICE, \
+	.idVendor = (vend), .idProduct = (prod), \
+	.bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#define get_unaligned_be16(a)					\
+	be16_to_cpu(get_unaligned((unsigned short *)(a)))
+#define put_unaligned_be16(r, a)				\
+	put_unaligned(cpu_to_be16(r), ((unsigned short *)(a)))
+#define get_unaligned_le16(a)					\
+	le16_to_cpu(get_unaligned((unsigned short *)(a)))
+#define put_unaligned_le16(r, a)				\
+	put_unaligned(cpu_to_le16(r), ((unsigned short *)(a)))
+#define get_unaligned_be32(a)					\
+	be32_to_cpu(get_unaligned((u32 *)(a)))
+#define put_unaligned_be32(r, a)				\
+	put_unaligned(cpu_to_be32(r), ((u32 *)(a)))
+#define get_unaligned_le32(a)					\
+	le32_to_cpu(get_unaligned((u32 *)(a)))
+#define put_unaligned_le32(r, a)				\
+	put_unaligned(cpu_to_le32(r), ((u32 *)(a)))
+#define get_unaligned_le64(a)					\
+	le64_to_cpu(get_unaligned((u64 *)(a)))
+#define put_unaligned_le64(r, a)				\
+	put_unaligned(cpu_to_le64(r), ((u64 *)(a)))
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+#ifdef CONFIG_PROC_FS
+static inline struct proc_dir_entry *proc_create(const char *a,
+	mode_t b, struct proc_dir_entry *c, const struct file_operations *d)
+{
+	struct proc_dir_entry *e;
+
+	e = create_proc_entry(a, b, c);
+	if (e) {
+		e->owner = THIS_MODULE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
+		e->proc_fops = d;
+#else
+		e->proc_fops = (struct file_operations *)d;
+#endif
+	}
+	return e;
+}
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#ifdef CONFIG_PROC_FS
+static inline struct proc_dir_entry *proc_create_data(const char *a,
+	mode_t b, struct proc_dir_entry *c, const struct file_operations *d,
+	void *f)
+{
+	struct proc_dir_entry *e;
+
+	e = create_proc_entry(a, b, c);
+	if (e) {
+		e->owner = THIS_MODULE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
+		e->proc_fops = d;
+#else
+		e->proc_fops = (struct file_operations *)d;
+#endif
+		e->data = f;
+	}
+	return e;
+}
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#define hweight64(x)  generic_hweight64(x)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#define div64_u64(a, b) div64_64(a, b)
+
+#define clamp (x, l, h)		max_t(__typeof__(x),		\
+				(l),			\
+				min_t(__typeof__(x),	\
+				(h),        	\
+				(x)))
+
+#define dev_name(dev)	((dev)->bus_id)
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+typedef unsigned long uintptr_t;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static inline int list_is_singular(const struct list_head *head)
+{
+	return !list_empty(head) && (head->next == head->prev);
+}
+#endif
+
+#endif
diff --git a/drivers/media/dvb/siano/sms-cards.c b/drivers/media/dvb/siano/sms-cards.c
index 4307e4e..27ccb97 100644
--- a/drivers/media/dvb/siano/sms-cards.c
+++ b/drivers/media/dvb/siano/sms-cards.c
@@ -18,9 +18,9 @@
  */
 
 #include "sms-cards.h"
+#include "smsir.h"
 
 struct usb_device_id smsusb_id_table[] = {
-#ifdef CONFIG_DVB_SIANO_SMS1XXX_SMS_IDS
 	{ USB_DEVICE(0x187f, 0x0010),
 		.driver_info = SMS1XXX_BOARD_SIANO_STELLAR },
 	{ USB_DEVICE(0x187f, 0x0100),
@@ -31,7 +31,6 @@ struct usb_device_id smsusb_id_table[] = {
 		.driver_info = SMS1XXX_BOARD_SIANO_NOVA_B },
 	{ USB_DEVICE(0x187f, 0x0300),
 		.driver_info = SMS1XXX_BOARD_SIANO_VEGA },
-#endif
 	{ USB_DEVICE(0x2040, 0x1700),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_CATAMOUNT },
 	{ USB_DEVICE(0x2040, 0x1800),
@@ -60,167 +59,265 @@ struct usb_device_id smsusb_id_table[] = {
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
 	{ USB_DEVICE(0x2040, 0x5590),
 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
-	{ }		/* Terminating entry */
-};
+	{ USB_DEVICE(0x187f, 0x0202),
+		.driver_info = SMS1XXX_BOARD_SIANO_NICE },
+	{ USB_DEVICE(0x187f, 0x0301),
+		.driver_info = SMS1XXX_BOARD_SIANO_VENICE },
+	{ } /* Terminating entry */
+	};
+
 MODULE_DEVICE_TABLE(usb, smsusb_id_table);
 
 static struct sms_board sms_boards[] = {
 	[SMS_BOARD_UNKNOWN] = {
-		.name	= "Unknown board",
+	/* 0 */
+		.name = "Unknown board",
 	},
 	[SMS1XXX_BOARD_SIANO_STELLAR] = {
-		.name	= "Siano Stellar Digital Receiver",
-		.type	= SMS_STELLAR,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-stellar-dvbt-01.fw",
+	/* 1 */
+		.name =
+		"Siano Stellar Digital Receiver",
+		.type = SMS_STELLAR,
 	},
 	[SMS1XXX_BOARD_SIANO_NOVA_A] = {
-		.name	= "Siano Nova A Digital Receiver",
-		.type	= SMS_NOVA_A0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-a-dvbt-01.fw",
+	/* 2 */
+		.name = "Siano Nova A Digital Receiver",
+		.type = SMS_NOVA_A0,
 	},
 	[SMS1XXX_BOARD_SIANO_NOVA_B] = {
-		.name	= "Siano Nova B Digital Receiver",
-		.type	= SMS_NOVA_B0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-b-dvbt-01.fw",
+	/* 3 */
+		.name = "Siano Nova B Digital Receiver",
+		.type = SMS_NOVA_B0,
 	},
 	[SMS1XXX_BOARD_SIANO_VEGA] = {
-		.name	= "Siano Vega Digital Receiver",
-		.type	= SMS_VEGA,
+	/* 4 */
+		.name = "Siano Vega Digital Receiver",
+		.type = SMS_VEGA,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_CATAMOUNT] = {
-		.name	= "Hauppauge Catamount",
-		.type	= SMS_STELLAR,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-stellar-dvbt-01.fw",
+	/* 5 */
+		.name = "Hauppauge Catamount",
+		.type = SMS_STELLAR,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-stellar-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_OKEMO_A] = {
-		.name	= "Hauppauge Okemo-A",
-		.type	= SMS_NOVA_A0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-a-dvbt-01.fw",
+	/* 6 */
+		.name = "Hauppauge Okemo-A",
+		.type = SMS_NOVA_A0,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-nova-a-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_OKEMO_B] = {
-		.name	= "Hauppauge Okemo-B",
-		.type	= SMS_NOVA_B0,
-		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-nova-b-dvbt-01.fw",
+	/* 7 */
+		.name = "Hauppauge Okemo-B",
+		.type = SMS_NOVA_B0,
+		.fw[DEVICE_MODE_DVBT_BDA] =
+		"sms1xxx-nova-b-dvbt-01.fw",
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_WINDHAM] = {
-		.name	= "Hauppauge WinTV MiniStick",
-		.type	= SMS_NOVA_B0,
+	/* 8 */
+		.name = "Hauppauge WinTV MiniStick",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.led_power = 26,
-		.led_lo    = 27,
-		.led_hi    = 28,
+		.board_cfg.leds_power = 26,
+		.board_cfg.led0 = 27,
+		.board_cfg.led1 = 28,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD] = {
-		.name	= "Hauppauge WinTV MiniCard",
-		.type	= SMS_NOVA_B0,
+	/* 9 */
+		.name = "Hauppauge WinTV MiniCard",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.lna_ctrl  = 29,
+		.board_cfg.foreign_lna0_ctrl = 29,
 	},
 	[SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2] = {
-		.name	= "Hauppauge WinTV MiniCard",
-		.type	= SMS_NOVA_B0,
+	/* 10 */
+		.name = "Hauppauge WinTV MiniCard",
+		.type = SMS_NOVA_B0,
 		.fw[DEVICE_MODE_DVBT_BDA] = "sms1xxx-hcw-55xxx-dvbt-02.fw",
-		.lna_ctrl  = -1,
+		.board_cfg.foreign_lna0_ctrl = 1,
+	},
+	[SMS1XXX_BOARD_SIANO_NICE] = {
+	/* 11 */
+		.name = "Siano Nice Digital Receiver",
+		.type = SMS_NOVA_B0,
+	},
+	[SMS1XXX_BOARD_SIANO_VENICE] = {
+	/* 12 */
+		.name = "Siano Venice Digital Receiver",
+		.type = SMS_VEGA,
 	},
 };
 
 struct sms_board *sms_get_board(int id)
 {
 	BUG_ON(id >= ARRAY_SIZE(sms_boards));
-
 	return &sms_boards[id];
 }
 
-static int sms_set_gpio(struct smscore_device_t *coredev, int pin, int enable)
-{
-	int lvl, ret;
-	u32 gpio;
-	struct smscore_gpio_config gpioconfig = {
-		.direction            = SMS_GPIO_DIRECTION_OUTPUT,
-		.pullupdown           = SMS_GPIO_PULLUPDOWN_NONE,
-		.inputcharacteristics = SMS_GPIO_INPUTCHARACTERISTICS_NORMAL,
-		.outputslewrate       = SMS_GPIO_OUTPUTSLEWRATE_FAST,
-		.outputdriving        = SMS_GPIO_OUTPUTDRIVING_4mA,
-	};
-
-	if (pin == 0)
-		return -EINVAL;
-
-	if (pin < 0) {
-		/* inverted gpio */
-		gpio = pin * -1;
-		lvl = enable ? 0 : 1;
-	} else {
-		gpio = pin;
-		lvl = enable ? 1 : 0;
-	}
-
-	ret = smscore_configure_gpio(coredev, gpio, &gpioconfig);
-	if (ret < 0)
-		return ret;
-
-	return smscore_set_gpio(coredev, gpio, lvl);
+static inline void sms_gpio_assign_11xx_default_led_config(
+		struct smscore_gpio_config *pGpioConfig) {
+	pGpioConfig->Direction = SMS_GPIO_DIRECTION_OUTPUT;
+	pGpioConfig->InputCharacteristics =
+		SMS_GPIO_INPUTCHARACTERISTICS_NORMAL;
+	pGpioConfig->OutputDriving = SMS_GPIO_OUTPUTDRIVING_4mA;
+	pGpioConfig->OutputSlewRate = SMS_GPIO_OUTPUTSLEWRATE_0_45_V_NS;
+	pGpioConfig->PullUpDown = SMS_GPIO_PULLUPDOWN_NONE;
 }
 
-int sms_board_setup(struct smscore_device_t *coredev)
-{
+int sms_board_event(struct smscore_device_t *coredev,
+		enum SMS_BOARD_EVENTS gevent) {
 	int board_id = smscore_get_board_id(coredev);
 	struct sms_board *board = sms_get_board(board_id);
+	struct smscore_gpio_config MyGpioConfig;
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		/* turn off all LEDs */
-		sms_set_gpio(coredev, board->led_power, 0);
-		sms_set_gpio(coredev, board->led_hi, 0);
-		sms_set_gpio(coredev, board->led_lo, 0);
-		break;
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
-		/* turn off LNA */
-		sms_set_gpio(coredev, board->lna_ctrl, 0);
-		break;
-	}
-	return 0;
-}
+	sms_gpio_assign_11xx_default_led_config(&MyGpioConfig);
 
-int sms_board_power(struct smscore_device_t *coredev, int onoff)
-{
-	int board_id = smscore_get_board_id(coredev);
-	struct sms_board *board = sms_get_board(board_id);
+	switch (gevent) {
+	case BOARD_EVENT_POWER_INIT: /* including hotplug */
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			/* set I/O and turn off all LEDs */
+			smscore_gpio_configure(coredev,
+					board->board_cfg.leds_power,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.leds_power, 0);
+			smscore_gpio_configure(coredev, board->board_cfg.led0,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.led0, 0);
+			smscore_gpio_configure(coredev, board->board_cfg.led1,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			/* set I/O and turn off LNA */
+			smscore_gpio_configure(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					&MyGpioConfig);
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					0);
+			break;
+		}
+		break; /* BOARD_EVENT_BIND */
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		/* power LED */
-		sms_set_gpio(coredev,
-			     board->led_power, onoff ? 1 : 0);
-		break;
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
-	case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
-		/* LNA */
-		sms_set_gpio(coredev,
-			     board->lna_ctrl, onoff ? 1 : 0);
-		break;
-	}
-	return 0;
-}
+	case BOARD_EVENT_POWER_SUSPEND:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.leds_power, 0);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led0, 0);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					0);
+			break;
+		}
+		break; /* BOARD_EVENT_POWER_SUSPEND */
 
-int sms_board_led_feedback(struct smscore_device_t *coredev, int led)
-{
-	int board_id = smscore_get_board_id(coredev);
-	struct sms_board *board = sms_get_board(board_id);
+	case BOARD_EVENT_POWER_RESUME:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.leds_power, 1);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led0, 1);
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					1);
+			break;
+		}
+		break; /* BOARD_EVENT_POWER_RESUME */
 
-	/* dont touch GPIO if LEDs are already set */
-	if (smscore_led_state(coredev, -1) == led)
-		return 0;
+	case BOARD_EVENT_BIND:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.leds_power, 1);
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.led0, 1);
+			smscore_gpio_set_level(coredev,
+				board->board_cfg.led1, 0);
+			break;
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2:
+		case SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD:
+			smscore_gpio_set_level(coredev,
+					board->board_cfg.foreign_lna0_ctrl,
+					1);
+			break;
+		}
+		break; /* BOARD_EVENT_BIND */
 
-	switch (board_id) {
-	case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
-		sms_set_gpio(coredev,
-			     board->led_lo, (led & SMS_LED_LO) ? 1 : 0);
-		sms_set_gpio(coredev,
-			     board->led_hi, (led & SMS_LED_HI) ? 1 : 0);
+	case BOARD_EVENT_SCAN_PROG:
+		break; /* BOARD_EVENT_SCAN_PROG */
+	case BOARD_EVENT_SCAN_COMP:
+		break; /* BOARD_EVENT_SCAN_COMP */
+	case BOARD_EVENT_EMERGENCY_WARNING_SIGNAL:
+		break; /* BOARD_EVENT_EMERGENCY_WARNING_SIGNAL */
+	case BOARD_EVENT_FE_LOCK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+			board->board_cfg.led1, 1);
+			break;
+		}
+		break; /* BOARD_EVENT_FE_LOCK */
+	case BOARD_EVENT_FE_UNLOCK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		}
+		break; /* BOARD_EVENT_FE_UNLOCK */
+	case BOARD_EVENT_DEMOD_LOCK:
+		break; /* BOARD_EVENT_DEMOD_LOCK */
+	case BOARD_EVENT_DEMOD_UNLOCK:
+		break; /* BOARD_EVENT_DEMOD_UNLOCK */
+	case BOARD_EVENT_RECEPTION_MAX_4:
+		break; /* BOARD_EVENT_RECEPTION_MAX_4 */
+	case BOARD_EVENT_RECEPTION_3:
+		break; /* BOARD_EVENT_RECEPTION_3 */
+	case BOARD_EVENT_RECEPTION_2:
+		break; /* BOARD_EVENT_RECEPTION_2 */
+	case BOARD_EVENT_RECEPTION_1:
+		break; /* BOARD_EVENT_RECEPTION_1 */
+	case BOARD_EVENT_RECEPTION_LOST_0:
+		break; /* BOARD_EVENT_RECEPTION_LOST_0 */
+	case BOARD_EVENT_MULTIPLEX_OK:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 1);
+			break;
+		}
+		break; /* BOARD_EVENT_MULTIPLEX_OK */
+	case BOARD_EVENT_MULTIPLEX_ERRORS:
+		switch (board_id) {
+		case SMS1XXX_BOARD_HAUPPAUGE_WINDHAM:
+			smscore_gpio_set_level(coredev,
+						board->board_cfg.led1, 0);
+			break;
+		}
+		break; /* BOARD_EVENT_MULTIPLEX_ERRORS */
 
-		smscore_led_state(coredev, led);
+	default:
+		sms_err("Unknown SMS board event");
 		break;
 	}
 	return 0;
diff --git a/drivers/media/dvb/siano/sms-cards.h b/drivers/media/dvb/siano/sms-cards.h
index 8e0fe9f..7a6c82e 100644
--- a/drivers/media/dvb/siano/sms-cards.h
+++ b/drivers/media/dvb/siano/sms-cards.h
@@ -22,6 +22,7 @@
 
 #include <linux/usb.h>
 #include "smscoreapi.h"
+#include "smsir.h"
 
 #define SMS_BOARD_UNKNOWN 0
 #define SMS1XXX_BOARD_SIANO_STELLAR 1
@@ -34,25 +35,76 @@
 #define SMS1XXX_BOARD_HAUPPAUGE_WINDHAM 8
 #define SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD 9
 #define SMS1XXX_BOARD_HAUPPAUGE_TIGER_MINICARD_R2 10
+#define SMS1XXX_BOARD_SIANO_NICE	11
+#define SMS1XXX_BOARD_SIANO_VENICE	12
+
+struct sms_board_gpio_cfg {
+	int lna_vhf_exist;
+	int lna_vhf_ctrl;
+	int lna_uhf_exist;
+	int lna_uhf_ctrl;
+	int lna_uhf_d_ctrl;
+	int lna_sband_exist;
+	int lna_sband_ctrl;
+	int lna_sband_d_ctrl;
+	int foreign_lna0_ctrl;
+	int foreign_lna1_ctrl;
+	int foreign_lna2_ctrl;
+	int rf_switch_vhf;
+	int rf_switch_uhf;
+	int rf_switch_sband;
+	int leds_power;
+	int led0;
+	int led1;
+	int led2;
+	int led3;
+	int led4;
+	int ir;
+	int eeprom_wp;
+	int mrc_sense;
+	int mrc_pdn_resetn;
+	int mrc_gp0; /* mrcs spi int */
+	int mrc_gp1;
+	int mrc_gp2;
+	int mrc_gp3;
+	int mrc_gp4;
+	int host_spi_gsp_ts_int;
+};
 
 struct sms_board {
 	enum sms_device_type_st type;
 	char *name, *fw[DEVICE_MODE_MAX];
-
-	/* gpios */
-	int led_power, led_hi, led_lo, lna_ctrl;
+	struct sms_board_gpio_cfg board_cfg;
+	enum ir_kb_type ir_kb_type;
 };
 
 struct sms_board *sms_get_board(int id);
 
-int sms_board_setup(struct smscore_device_t *coredev);
+extern struct usb_device_id smsusb_id_table[];
+extern struct smscore_device_t *coredev;
 
-#define SMS_LED_OFF 0
-#define SMS_LED_LO  1
-#define SMS_LED_HI  2
-int sms_board_led_feedback(struct smscore_device_t *coredev, int led);
-int sms_board_power(struct smscore_device_t *coredev, int onoff);
+enum SMS_BOARD_EVENTS {
+	BOARD_EVENT_POWER_INIT,
+	BOARD_EVENT_POWER_SUSPEND,
+	BOARD_EVENT_POWER_RESUME,
+	BOARD_EVENT_BIND,
+	BOARD_EVENT_SCAN_PROG,
+	BOARD_EVENT_SCAN_COMP,
+	BOARD_EVENT_EMERGENCY_WARNING_SIGNAL,
+	BOARD_EVENT_FE_LOCK,
+	BOARD_EVENT_FE_UNLOCK,
+	BOARD_EVENT_DEMOD_LOCK,
+	BOARD_EVENT_DEMOD_UNLOCK,
+	BOARD_EVENT_RECEPTION_MAX_4,
+	BOARD_EVENT_RECEPTION_3,
+	BOARD_EVENT_RECEPTION_2,
+	BOARD_EVENT_RECEPTION_1,
+	BOARD_EVENT_RECEPTION_LOST_0,
+	BOARD_EVENT_MULTIPLEX_OK,
+	BOARD_EVENT_MULTIPLEX_ERRORS
+};
 
-extern struct usb_device_id smsusb_id_table[];
+int sms_board_event(struct smscore_device_t *coredev,
+		enum SMS_BOARD_EVENTS gevent);
 
 #endif /* __SMS_CARDS_H__ */
diff --git a/drivers/media/dvb/siano/smschar.c b/drivers/media/dvb/siano/smschar.c
new file mode 100644
index 0000000..80547f0
--- /dev/null
+++ b/drivers/media/dvb/siano/smschar.c
@@ -0,0 +1,683 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>	/* printk() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/types.h>	/* size_t */
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <asm/system.h>		/* cli(), *_flags */
+#include <linux/uaccess.h>	/* copy_*_user */
+
+#include "smscoreapi.h"
+#include "smscharioctl.h"
+
+/* max number of packets allowed to be pending on queue*/
+#define SMS_CHR_MAX_Q_LEN	15
+#define SMSCHAR_NR_DEVS		17
+
+struct smschar_device_t {
+	struct cdev cdev;	/*!< Char device structure */
+	wait_queue_head_t waitq;	/* Processes waiting */
+	int cancel_waitq;
+	spinlock_t lock;	/*!< critical section */
+	int pending_count;
+	struct list_head pending_data;	/*!< list of pending data */
+	struct smscore_buffer_t *currentcb;
+	int device_index;
+	struct smscore_device_t *coredev;
+	struct smscore_client_t *smsclient;
+};
+
+/*!  Holds the major number of the device node. may be changed at load
+time.*/
+int smschar_major = 255;
+
+/*!  Holds the first minor number of the device node.
+may be changed at load time.*/
+int smschar_minor;
+
+/* macros that allow the load time parameters change*/
+module_param(smschar_major, int, S_IRUGO);
+module_param(smschar_minor, int, S_IRUGO);
+
+struct smschar_device_t smschar_devices[SMSCHAR_NR_DEVS];
+static int g_smschar_inuse;
+
+static int g_pnp_status_changed = 1;
+wait_queue_head_t g_pnp_event;
+static struct class *smschar_class;
+
+/**
+ * unregisters sms client and returns all queued buffers
+ *
+ * @param dev pointer to the client context (smschar parameters block)
+ *
+ */
+static void smschar_unregister_client(struct smschar_device_t *dev)
+{
+	unsigned long flags;
+
+	sms_info("entering... smschar_unregister_client....\n");
+	if (dev->coredev && dev->smsclient) {
+		dev->cancel_waitq = 1;
+		wake_up_interruptible(&dev->waitq);
+
+		spin_lock_irqsave(&dev->lock, flags);
+
+		while (!list_empty(&dev->pending_data)) {
+			struct smscore_buffer_t *cb =
+				(struct smscore_buffer_t *)dev->pending_data.next;
+			list_del(&cb->entry);
+
+			smscore_putbuffer(dev->coredev, cb);
+			dev->pending_count--;
+		}
+
+		if (dev->currentcb) {
+			smscore_putbuffer(dev->coredev, dev->currentcb);
+			dev->currentcb = NULL;
+			dev->pending_count--;
+		}
+
+		smscore_unregister_client(dev->smsclient);
+		dev->smsclient = NULL;
+
+		spin_unlock_irqrestore(&dev->lock, flags);
+	}
+}
+
+/**
+ * queues incoming buffers into buffers queue
+ *
+ * @param context pointer to the client context (smschar parameters block)
+ * @param cb pointer to incoming buffer descriptor
+ *
+ * @return 0 on success, <0 on queue overflow.
+ */
+static int smschar_onresponse(void *context, struct smscore_buffer_t *cb)
+{
+	struct smschar_device_t *dev = context;
+	unsigned long flags;
+
+	if (!dev) {
+		sms_err("recieved bad dev pointer\n");
+		return -EFAULT;
+	}
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (dev->pending_count > SMS_CHR_MAX_Q_LEN) {
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return -EBUSY;
+	}
+
+	dev->pending_count++;
+	/* if data channel, remove header */
+	if (dev->device_index) {
+		cb->size -= sizeof(struct SmsMsgHdr_ST);
+		cb->offset += sizeof(struct SmsMsgHdr_ST);
+	}
+
+	list_add_tail(&cb->entry, &dev->pending_data);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (waitqueue_active(&dev->waitq)) {
+		wake_up_interruptible(&dev->waitq);
+  }
+
+	return 0;
+}
+
+/**
+ * handles device removal event
+ *
+ * @param context pointer to the client context (smschar parameters block)
+ *
+ */
+static void smschar_onremove(void *context)
+{
+	struct smschar_device_t *dev = (struct smschar_device_t *)context;
+
+	smschar_unregister_client(dev);
+	dev->coredev = NULL;
+}
+
+/**
+ * registers client associated with the node
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int smschar_open(struct inode *inode, struct file *file)
+{
+	struct smschar_device_t *dev = container_of(inode->i_cdev,
+						    struct smschar_device_t,
+						    cdev);
+	int rc = -ENODEV;
+
+	/*sms_info("entering dev->device_index = %d\n", dev->device_index);*/
+	printk(KERN_INFO "%s: dev->device_index = %d\n", __func__, dev->device_index);
+
+	if (dev->coredev) {
+		struct smsclient_params_t params;
+		params.initial_id = dev->device_index ?
+		    dev->device_index : SMS_HOST_LIB;
+		params.data_type = dev->device_index ? MSG_SMS_DAB_CHANNEL : 0;
+		params.onresponse_handler = smschar_onresponse;
+		params.onremove_handler = smschar_onremove;
+		params.context = dev;
+
+		rc = smscore_register_client(dev->coredev, &params,
+					     &dev->smsclient);
+		if (!rc)
+			file->private_data = dev;
+		dev->cancel_waitq = 0;
+		g_pnp_status_changed = 1;
+	}
+
+	if (rc) {
+		/*sms_err(" exiting, rc %d\n", rc);*/
+		printk(KERN_INFO "%s: [FATAL] smscore_register_client() is failed. rc=%d\n", __func__, rc);
+  }
+	return rc;
+}
+
+/**
+ * unregisters client associated with the node
+ *
+ * @param inode Inode concerned.
+ * @param file File concerned.
+ *
+ */
+static int smschar_release(struct inode *inode, struct file *file)
+{
+	smschar_unregister_client(file->private_data);
+	sms_info("exiting\n");
+	return 0;
+}
+
+/**
+ * copies data from buffers in incoming queue into a user buffer
+ *
+ * @param file File structure.
+ * @param buf Source buffer.
+ * @param count Size of source buffer.
+ * @param f_pos Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t smschar_read(struct file *file, char __user *buf,
+			    size_t count, loff_t *f_pos)
+{
+	struct smschar_device_t *dev = file->private_data;
+	unsigned long flags;
+	int rc, copied = 0;
+
+	if (!buf) {
+		sms_err("Bad pointer recieved from user.\n");
+		return -EFAULT;
+	}
+	if (!dev->coredev || !dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+	rc = wait_event_interruptible(dev->waitq,
+				      !list_empty(&dev->pending_data)
+				      || (dev->cancel_waitq));
+	if (rc < 0) {
+		sms_info("wait_event_interruptible error %d\n", rc);
+		return rc;
+	}
+	if (dev->cancel_waitq)
+		return 0;
+	if (!dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+	spin_lock_irqsave(&dev->lock, flags);
+
+	while (!list_empty(&dev->pending_data) && (copied < count)) {
+		struct smscore_buffer_t *cb =
+		    (struct smscore_buffer_t *)dev->pending_data.next;
+		int actual_size = min(((int)count - copied), cb->size);
+		if (copy_to_user(&buf[copied], &((char *)cb->p)[cb->offset],
+				 actual_size)) {
+			sms_err("copy_to_user failed\n");
+			spin_unlock_irqrestore(&dev->lock, flags);
+			return -EFAULT;
+		}
+		copied += actual_size;
+		cb->offset += actual_size;
+		cb->size -= actual_size;
+
+		if (!cb->size) {
+			list_del(&cb->entry);
+			smscore_putbuffer(dev->coredev, cb);
+			dev->pending_count--;
+		}
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return copied;
+}
+
+/**
+ * sends the buffer to the associated device
+ *
+ * @param file File structure.
+ * @param buf Source buffer.
+ * @param count Size of source buffer.
+ * @param f_pos Position in file (ignored).
+ *
+ * @return Number of bytes read, or <0 on error.
+ */
+static ssize_t smschar_write(struct file *file, const char __user *buf,
+			     size_t count, loff_t *f_pos)
+{
+	struct smschar_device_t *dev;
+	void *buffer;
+
+	if (file == NULL) {
+		sms_err("file is NULL\n");
+		return EINVAL;
+	}
+
+	if (file->private_data == NULL) {
+		sms_err("file->private_data is NULL\n");
+		return -EINVAL;
+	}
+
+	dev = file->private_data;
+	if (!dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+
+	buffer = kmalloc(ALIGN(count, SMS_ALLOC_ALIGNMENT) + SMS_DMA_ALIGNMENT,
+			 GFP_KERNEL | GFP_DMA);
+	if (buffer) {
+		void *msg_buffer = (void *)SMS_ALIGN_ADDRESS(buffer);
+
+		if (!copy_from_user(msg_buffer, buf, count))
+			smsclient_sendrequest(dev->smsclient,
+					      msg_buffer, count);
+		else
+			count = 0;
+
+		kfree(buffer);
+	}
+
+	return count;
+}
+
+static int smschar_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct smschar_device_t *dev = file->private_data;
+	return smscore_map_common_buffer(dev->coredev, vma);
+}
+
+/**
+ * waits until buffer inserted into a queue. when inserted buffer offset
+ * are reportedto the calling process. previously reported buffer is
+ * returned to smscore pool.
+ *
+ * @param dev pointer to smschar parameters block
+ * @param touser pointer to a structure that receives incoming buffer offsets
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int smschar_wait_get_buffer(struct smschar_device_t *dev,
+				   struct smschar_buffer_t *touser)
+{
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (dev->currentcb) {
+		smscore_putbuffer(dev->coredev, dev->currentcb);
+		dev->currentcb = NULL;
+		dev->pending_count--;
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	rc = wait_event_interruptible(dev->waitq,
+				      !list_empty(&dev->pending_data)
+				      || (dev->cancel_waitq));
+	if (rc < 0) {
+		sms_info("wait_event_interruptible error, rc=%d\n", rc);
+		return rc;
+	}
+
+	if (dev->cancel_waitq) {
+		touser->offset = 0;
+		touser->size = 0;
+		return 0;
+	}
+	if (!dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (!list_empty(&dev->pending_data)) {
+		struct smscore_buffer_t *cb =
+		    (struct smscore_buffer_t *)dev->pending_data.next;
+		touser->offset = cb->offset_in_common + cb->offset;
+		touser->size = cb->size;
+
+		list_del(&cb->entry);
+
+		dev->currentcb = cb;
+	} else {
+		touser->offset = 0;
+		touser->size = 0;
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/**
+ * poll for data availability
+ *
+ * @param file File structure.
+ * @param wait kernel polling table.
+ *
+ * @return POLLIN flag if read data is available.
+ */
+static unsigned int smschar_poll(struct file *file,
+				 struct poll_table_struct *wait)
+{
+	struct smschar_device_t *dev;
+	int mask = 0;
+
+	if (file == NULL) {
+		sms_err("file is NULL\n");
+		return EINVAL;
+	}
+
+	if (file->private_data == NULL) {
+		sms_err("file->private_data is NULL\n");
+		return -EINVAL;
+	}
+
+	dev = file->private_data;
+
+	if (list_empty(&dev->pending_data)) {
+		sms_info("No data is ready, waiting for data recieve.\n");
+		poll_wait(file, &dev->waitq, wait);
+	}
+
+	if (!list_empty(&dev->pending_data))
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+static int smschar_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	struct smschar_device_t *dev = file->private_data;
+	void __user *up = (void __user *)arg;
+
+	if (!dev->coredev || !dev->smsclient) {
+		sms_err("no client\n");
+		return -ENODEV;
+	}
+
+	switch (cmd) {
+	case SMSCHAR_SET_DEVICE_MODE:
+		return smscore_set_device_mode(dev->coredev, (int)arg);
+
+	case SMSCHAR_GET_DEVICE_MODE:
+		if (put_user(smscore_get_device_mode(dev->coredev),
+				(int *)up))
+				return -EFAULT;
+		break;
+/*##w21558, Added*/
+	case SMSCHAR_RESET_DEVICE_MODE:
+		return smscore_reset_device_mode(dev->coredev);
+/*}}*/
+
+	case SMSCHAR_IS_DEVICE_PNP_EVENT:
+		{
+			sms_info("Waiting for PnP event.\n");
+			wait_event_interruptible(g_pnp_event,
+						 !g_pnp_status_changed);
+			g_pnp_status_changed = 0;
+			sms_info("PnP Event %d.\n", g_smschar_inuse);
+			if (put_user(g_smschar_inuse, (int *)up))
+				return -EFAULT;
+			break;
+		}
+	case SMSCHAR_GET_BUFFER_SIZE:
+		{
+			if (put_user
+			    (smscore_get_common_buffer_size(dev->coredev),
+			     (int *)up))
+				return -EFAULT;
+
+			break;
+		}
+
+	case SMSCHAR_WAIT_GET_BUFFER:
+		{
+			struct smschar_buffer_t touser;
+			int rc;
+
+			rc = smschar_wait_get_buffer(dev, &touser);
+			if (rc < 0)
+				return rc;
+
+			if (copy_to_user(up, &touser,
+					 sizeof(struct smschar_buffer_t)))
+				return -EFAULT;
+
+			break;
+		}
+	case SMSCHAR_CANCEL_WAIT_BUFFER:
+		{
+			dev->cancel_waitq = 1;
+			wake_up_interruptible(&dev->waitq);
+			break;
+		}
+	case SMSCHAR_GET_FW_FILE_NAME:
+		{
+			if (!up)
+				return -EINVAL;
+			return smscore_get_fw_filename(dev->coredev,
+				       ((struct
+					 smschar_get_fw_filename_ioctl_t
+					 *)up)->mode,
+				       ((struct
+					 smschar_get_fw_filename_ioctl_t
+					 *)up)->filename);
+		}
+	case SMSCHAR_SEND_FW_FILE:
+		{
+			if (!up)
+				return -EINVAL;
+			return smscore_send_fw_file(dev->coredev,
+					((struct
+					smschar_send_fw_file_ioctl_t
+					*)up)->fw_buf,
+					((struct
+					smschar_send_fw_file_ioctl_t
+					*)up)->fw_size);
+		}
+
+  /* ##w21558, Added to tuner power control */
+	case SMSCHAR_SET_POWER_DOWN:
+		return smsmdtv_power_control(0);
+
+	case SMSCHAR_SET_POWER_UP:
+		return smsmdtv_power_control(1);
+	/* End */
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+struct file_operations smschar_fops = {
+	.owner = THIS_MODULE,
+	.read = smschar_read,
+	.write = smschar_write,
+	.open = smschar_open,
+	.release = smschar_release,
+	.mmap = smschar_mmap,
+	.poll = smschar_poll,
+	.ioctl = smschar_ioctl,
+};
+
+static int smschar_setup_cdev(struct smschar_device_t *dev, int index)
+{
+	int rc, devno = MKDEV(smschar_major, smschar_minor + index);
+
+	cdev_init(&dev->cdev, &smschar_fops);
+
+	dev->cdev.owner = THIS_MODULE;
+	dev->cdev.ops = &smschar_fops;
+
+	kobject_set_name(&dev->cdev.kobj, "Siano_sms%d", index);
+	rc = cdev_add(&dev->cdev, devno, 1);
+	sms_info("exiting %p %d, rc %d", dev, index, rc);
+
+	if (index == 0)
+		device_create(smschar_class, \
+			NULL, devno, NULL, "mdtvctrl");
+	else
+		device_create(smschar_class, \
+			NULL, devno, NULL, "mdtv%d", index);
+	return rc;
+}
+
+/**
+ * smschar callback that called when device plugged in/out. the function
+ * register or unregisters char device interface according to plug in/out
+ *
+ * @param coredev pointer to device that is being plugged in/out
+ * @param device pointer to system device object
+ * @param arrival 1 on plug-on, 0 othewise
+ *
+ * @return 0 on success, <0 on error.
+ */
+static int smschar_hotplug(struct smscore_device_t *coredev,
+			   struct device *device, int arrival)
+{
+	int rc = 0, i;
+
+	/*sms_info("entering %d\n", arrival);*/
+
+	g_pnp_status_changed = 1;
+	if (arrival) {
+		/* currently only 1 instance supported */
+		if (!g_smschar_inuse) {
+			/* data notification callbacks assignment */
+			memset(smschar_devices, 0, SMSCHAR_NR_DEVS *
+			       sizeof(struct smschar_device_t));
+
+			/* Initialize each device. */
+			for (i = 0; i < SMSCHAR_NR_DEVS; i++) {
+				/*sms_info("create device %d", i);*/
+				smschar_setup_cdev(&smschar_devices[i], i);
+				INIT_LIST_HEAD(&smschar_devices[i].
+					       pending_data);
+				spin_lock_init(&smschar_devices[i].lock);
+				init_waitqueue_head(&smschar_devices[i].waitq);
+
+				smschar_devices[i].coredev = coredev;
+				smschar_devices[i].device_index = i;
+			}
+			g_smschar_inuse = 1;
+			wake_up_interruptible(&g_pnp_event);
+		}
+	} else {
+		/* currently only 1 instance supported */
+		if (g_smschar_inuse) {
+			/* Get rid of our char dev entries */
+			for (i = 0; i < SMSCHAR_NR_DEVS; i++) {
+				cdev_del(&smschar_devices[i].cdev);
+				/*sms_info("remove device %d\n", i);*/
+			}
+
+			g_smschar_inuse = 0;
+			wake_up_interruptible(&g_pnp_event);
+		}
+	}
+
+	/*sms_info("exiting, rc %d\n", rc);*/
+
+	return rc;/* succeed */
+}
+
+int smschar_register(void)
+{
+	dev_t devno = MKDEV(smschar_major, smschar_minor);
+	int rc = -1;
+
+	sms_info("registering device major=%d minor=%d\n", smschar_major,
+		smschar_minor);
+	if (smschar_major) {
+		rc = register_chrdev_region(devno, SMSCHAR_NR_DEVS, "smschar");
+	} else {
+		rc = alloc_chrdev_region(&devno, smschar_minor,
+					SMSCHAR_NR_DEVS, "smschar");
+		smschar_major = MAJOR(devno);
+	}
+
+	if (rc < 0) {
+		sms_warn("smschar: can't get major %d\n", smschar_major);
+		return rc;
+	}
+	init_waitqueue_head(&g_pnp_event);
+
+	smschar_class = class_create(THIS_MODULE, "SMSMdtv");
+	if (IS_ERR(smschar_class)) {
+		sms_err("smschar:can't create SMSMdtv class");
+		return -1;
+	}
+
+	return smscore_register_hotplug(smschar_hotplug);
+}
+
+void smschar_unregister(void)
+{
+	dev_t devno = MKDEV(smschar_major, smschar_minor);
+	int i = 0;
+
+	for (i = 0; i < SMSCHAR_NR_DEVS; i++)
+		device_destroy(smschar_class, MKDEV(smschar_major, i));
+
+	class_destroy(smschar_class);
+	unregister_chrdev_region(devno, SMSCHAR_NR_DEVS);
+	smscore_unregister_hotplug(smschar_hotplug);
+	sms_info("unregistered\n");
+}
diff --git a/drivers/media/dvb/siano/smscharioctl.h b/drivers/media/dvb/siano/smscharioctl.h
new file mode 100644
index 0000000..c62a126
--- /dev/null
+++ b/drivers/media/dvb/siano/smscharioctl.h
@@ -0,0 +1,58 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#ifndef __SMS_CHAR_IOCTL_H__
+#define __SMS_CHAR_IOCTL_H__
+
+#include <linux/ioctl.h>
+
+struct smschar_buffer_t {
+	unsigned long offset;	/* offset in common buffer (mapped to user) */
+	int size;
+};
+
+struct smschar_get_fw_filename_ioctl_t {
+	int mode;
+	char filename[200];
+};
+
+struct smschar_send_fw_file_ioctl_t {
+	char *fw_buf;
+	int fw_size;
+};
+
+#define SMSCHAR_SET_DEVICE_MODE		_IOW('K', 0, int)
+#define SMSCHAR_GET_DEVICE_MODE		_IOR('K', 1, int)
+#define SMSCHAR_GET_BUFFER_SIZE		_IOR('K', 2, int)
+#define SMSCHAR_WAIT_GET_BUFFER		_IOR('K', 3, struct smschar_buffer_t)
+#define SMSCHAR_IS_DEVICE_PNP_EVENT 	_IOR('K', 4, int)
+#define SMSCHAR_GET_FW_FILE_NAME	\
+	_IOWR('K', 5, struct smschar_get_fw_filename_ioctl_t)
+#define SMSCHAR_SEND_FW_FILE		\
+	_IOW('K', 6, struct smschar_send_fw_file_ioctl_t)
+#define SMSCHAR_CANCEL_WAIT_BUFFER	_IO('K', 7)
+
+/*##w21558, SMS1130 power control*/
+#define SMSCHAR_SET_POWER_UP   _IOW('K', 8, int)
+#define SMSCHAR_SET_POWER_DOWN _IOW('K', 9, int)
+/*##w21558, to reset device mode*/
+#define SMSCHAR_RESET_DEVICE_MODE _IOW('K', 10, int)
+
+#endif /* __SMS_CHAR_IOCTL_H__ */
diff --git a/drivers/media/dvb/siano/smscoreapi.c b/drivers/media/dvb/siano/smscoreapi.c
index cf613f2..6e03a5f 100644
--- a/drivers/media/dvb/siano/smscoreapi.c
+++ b/drivers/media/dvb/siano/smscoreapi.c
@@ -1,25 +1,23 @@
-/*
- *  Siano core API module
- *
- *  This file contains implementation for the interface to sms core component
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+/****************************************************************
+
+ Siano Mobile Silicon, Inc.
+ MDTV receiver kernel modules.
+ Copyright (C) 2006-2008, Uri Shkolnik
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ ****************************************************************/
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -28,16 +26,41 @@
 #include <linux/dma-mapping.h>
 #include <linux/delay.h>
 #include <linux/io.h>
-
+#include <linux/uaccess.h>
 #include <linux/firmware.h>
+#include <linux/wait.h>
+
+#include <asm/byteorder.h>
 
 #include "smscoreapi.h"
+#include "smsendian.h"
 #include "sms-cards.h"
+#include "smsir.h"
+
+#define MAX_GPIO_PIN_NUMBER	31
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10)
+/*#define REQUEST_FIRMWARE_SUPPORTED*/
+#undef REQUEST_FIRMWARE_SUPPORTED
+/*#define DEFAULT_FW_FILE_PATH "/system/mdtv"*/
+#define DEFAULT_FW_FILE_PATH "/system/etc/firmware"
+#else
+/*#define DEFAULT_FW_FILE_PATH "/lib/firmware"*/
+/*#define DEFAULT_FW_FILE_PATH "/system/mdtv"*/
+#define DEFAULT_FW_FILE_PATH "/system/etc/firmware"
+#endif
+
+/* Debug level is low */
+int sms_debug = 7;
 
-int sms_debug;
 module_param_named(debug, sms_debug, int, 0644);
 MODULE_PARM_DESC(debug, "set debug level (info=1, adv=2 (or-able))");
 
+/*##w21558, mode change : 4 --> 2*/
+static int default_mode = DEVICE_MODE_DAB_TDMB;
+module_param(default_mode, int, 0644);
+MODULE_PARM_DESC(default_mode, "default firmware id (device mode)");
+
 struct smscore_device_notifyee_t {
 	struct list_head entry;
 	hotplug_t hotplug;
@@ -45,53 +68,17 @@ struct smscore_device_notifyee_t {
 
 struct smscore_idlist_t {
 	struct list_head entry;
-	int		id;
-	int		data_type;
+	int id;
+	int data_type;
 };
 
 struct smscore_client_t {
 	struct list_head entry;
 	struct smscore_device_t *coredev;
-	void			*context;
-	struct list_head 	idlist;
-	onresponse_t	onresponse_handler;
-	onremove_t		onremove_handler;
-};
-
-struct smscore_device_t {
-	struct list_head entry;
-
-	struct list_head clients;
-	struct list_head subclients;
-	spinlock_t		clientslock;
-
-	struct list_head buffers;
-	spinlock_t		bufferslock;
-	int				num_buffers;
-
-	void			*common_buffer;
-	int				common_buffer_size;
-	dma_addr_t		common_buffer_phys;
-
-	void			*context;
-	struct device	*device;
-
-	char			devpath[32];
-	unsigned long	device_flags;
-
-	setmode_t		setmode_handler;
-	detectmode_t	detectmode_handler;
-	sendrequest_t	sendrequest_handler;
-	preload_t		preload_handler;
-	postload_t		postload_handler;
-
-	int				mode, modes_supported;
-
-	struct completion version_ex_done, data_download_done, trigger_done;
-	struct completion init_device_done, reload_start_done, resume_done;
-
-	int board_id;
-	int led_state;
+	void *context;
+	struct list_head idlist;
+	onresponse_t onresponse_handler;
+	onremove_t onremove_handler;
 };
 
 void smscore_set_board_id(struct smscore_device_t *core, int id)
@@ -99,13 +86,6 @@ void smscore_set_board_id(struct smscore_device_t *core, int id)
 	core->board_id = id;
 }
 
-int smscore_led_state(struct smscore_device_t *core, int led)
-{
-	if (led >= 0)
-		core->led_state = led;
-	return core->led_state;
-}
-
 int smscore_get_board_id(struct smscore_device_t *core)
 {
 	return core->board_id;
@@ -113,9 +93,9 @@ int smscore_get_board_id(struct smscore_device_t *core)
 
 struct smscore_registry_entry_t {
 	struct list_head entry;
-	char			devpath[32];
-	int				mode;
-	enum sms_device_type_st	type;
+	char devpath[32];
+	int mode;
+	enum sms_device_type_st type;
 };
 
 static struct list_head g_smscore_notifyees;
@@ -125,29 +105,22 @@ static struct mutex g_smscore_deviceslock;
 static struct list_head g_smscore_registry;
 static struct mutex g_smscore_registrylock;
 
-static int default_mode = 4;
-
-module_param(default_mode, int, 0644);
-MODULE_PARM_DESC(default_mode, "default firmware id (device mode)");
-
 static struct smscore_registry_entry_t *smscore_find_registry(char *devpath)
 {
 	struct smscore_registry_entry_t *entry;
 	struct list_head *next;
 
 	kmutex_lock(&g_smscore_registrylock);
-	for (next = g_smscore_registry.next;
-	     next != &g_smscore_registry;
-	     next = next->next) {
+	for (next = g_smscore_registry.next; next != &g_smscore_registry; next
+			= next->next) {
 		entry = (struct smscore_registry_entry_t *) next;
 		if (!strcmp(entry->devpath, devpath)) {
 			kmutex_unlock(&g_smscore_registrylock);
 			return entry;
 		}
 	}
-	entry = (struct smscore_registry_entry_t *)
-			kmalloc(sizeof(struct smscore_registry_entry_t),
-				GFP_KERNEL);
+	entry = /* (struct smscore_registry_entry_t *) */kmalloc(
+			sizeof(struct smscore_registry_entry_t), GFP_KERNEL);
 	if (entry) {
 		entry->mode = default_mode;
 		strcpy(entry->devpath, devpath);
@@ -196,8 +169,7 @@ void smscore_registry_setmode(char *devpath, int mode)
 }
 
 static void smscore_registry_settype(char *devpath,
-				     enum sms_device_type_st type)
-{
+		enum sms_device_type_st type) {
 	struct smscore_registry_entry_t *entry;
 
 	entry = smscore_find_registry(devpath);
@@ -207,16 +179,12 @@ static void smscore_registry_settype(char *devpath,
 		sms_err("No registry found.");
 }
 
-
 static void list_add_locked(struct list_head *new, struct list_head *head,
-			    spinlock_t *lock)
-{
+		spinlock_t *lock) {
 	unsigned long flags;
 
 	spin_lock_irqsave(lock, flags);
-
 	list_add(new, head);
-
 	spin_unlock_irqrestore(lock, flags);
 }
 
@@ -234,16 +202,16 @@ int smscore_register_hotplug(hotplug_t hotplug)
 	struct list_head *next, *first;
 	int rc = 0;
 
+	sms_info(" entering... smscore_register_hotplug \n");
 	kmutex_lock(&g_smscore_deviceslock);
 
 	notifyee = kmalloc(sizeof(struct smscore_device_notifyee_t),
-			   GFP_KERNEL);
+		GFP_KERNEL);
 	if (notifyee) {
 		/* now notify callback about existing devices */
 		first = &g_smscore_devices;
-		for (next = first->next;
-		     next != first && !rc;
-		     next = next->next) {
+		for (next = first->next; next != first && !rc;
+			next = next->next) {
 			struct smscore_device_t *coredev =
 				(struct smscore_device_t *) next;
 			rc = hotplug(coredev, coredev->device, 1);
@@ -272,13 +240,15 @@ void smscore_unregister_hotplug(hotplug_t hotplug)
 {
 	struct list_head *next, *first;
 
+	sms_info(" exiting... smscore_register_hotplug \n");
+
 	kmutex_lock(&g_smscore_deviceslock);
 
 	first = &g_smscore_notifyees;
 
 	for (next = first->next; next != first;) {
 		struct smscore_device_notifyee_t *notifyee =
-			(struct smscore_device_notifyee_t *) next;
+				(struct smscore_device_notifyee_t *) next;
 		next = next->next;
 
 		if (notifyee->hotplug == hotplug) {
@@ -302,8 +272,7 @@ static void smscore_notify_clients(struct smscore_device_t *coredev)
 }
 
 static int smscore_notify_callbacks(struct smscore_device_t *coredev,
-				    struct device *device, int arrival)
-{
+		struct device *device, int arrival) {
 	struct list_head *next, *first;
 	int rc = 0;
 
@@ -313,7 +282,7 @@ static int smscore_notify_callbacks(struct smscore_device_t *coredev,
 
 	for (next = first->next; next != first; next = next->next) {
 		rc = ((struct smscore_device_notifyee_t *) next)->
-				hotplug(coredev, device, arrival);
+			 hotplug(coredev, device, arrival);
 		if (rc < 0)
 			break;
 	}
@@ -321,12 +290,10 @@ static int smscore_notify_callbacks(struct smscore_device_t *coredev,
 	return rc;
 }
 
-static struct
-smscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,
-				       dma_addr_t common_buffer_phys)
-{
-	struct smscore_buffer_t *cb =
-		kmalloc(sizeof(struct smscore_buffer_t), GFP_KERNEL);
+static struct smscore_buffer_t *smscore_createbuffer(u8 *buffer,
+		void *common_buffer, dma_addr_t common_buffer_phys) {
+	struct smscore_buffer_t *cb = kmalloc(sizeof(struct smscore_buffer_t),
+			GFP_KERNEL);
 	if (!cb) {
 		sms_info("kmalloc(...) failed");
 		return NULL;
@@ -350,11 +317,11 @@ smscore_buffer_t *smscore_createbuffer(u8 *buffer, void *common_buffer,
  * @return 0 on success, <0 on error.
  */
 int smscore_register_device(struct smsdevice_params_t *params,
-			    struct smscore_device_t **coredev)
-{
+		struct smscore_device_t **coredev) {
 	struct smscore_device_t *dev;
 	u8 *buffer;
 
+	sms_info(" entering....smscore_register_device \n");
 	dev = kzalloc(sizeof(struct smscore_device_t), GFP_KERNEL);
 	if (!dev) {
 		sms_info("kzalloc(...) failed");
@@ -372,31 +339,42 @@ int smscore_register_device(struct smsdevice_params_t *params,
 	spin_lock_init(&dev->clientslock);
 	spin_lock_init(&dev->bufferslock);
 
-	/* init completion events */
+	/* Device protocol completion events */
 	init_completion(&dev->version_ex_done);
 	init_completion(&dev->data_download_done);
 	init_completion(&dev->trigger_done);
 	init_completion(&dev->init_device_done);
 	init_completion(&dev->reload_start_done);
 	init_completion(&dev->resume_done);
+	init_completion(&dev->gpio_configuration_done);
+	init_completion(&dev->gpio_set_level_done);
+	init_completion(&dev->gpio_get_level_done);
+	init_completion(&dev->ir_init_done);
+
+	/* Buffer management */
+	init_waitqueue_head(&dev->buffer_mng_waitq);
 
 	/* alloc common buffer */
+	sms_info(" entering...alloc common buffer \n");
 	dev->common_buffer_size = params->buffer_size * params->num_buffers;
+
+/* w21558 */
+#if defined(MOT_FEAT_OMAP_DMA_USE)
 	dev->common_buffer = dma_alloc_coherent(NULL, dev->common_buffer_size,
-						&dev->common_buffer_phys,
-						GFP_KERNEL | GFP_DMA);
+			&dev->common_buffer_phys, GFP_KERNEL | GFP_DMA);
 	if (!dev->common_buffer) {
 		smscore_unregister_device(dev);
 		return -ENOMEM;
 	}
+#endif
 
 	/* prepare dma buffers */
-	for (buffer = dev->common_buffer;
-	     dev->num_buffers < params->num_buffers;
-	     dev->num_buffers++, buffer += params->buffer_size) {
-		struct smscore_buffer_t *cb =
-			smscore_createbuffer(buffer, dev->common_buffer,
-					     dev->common_buffer_phys);
+	sms_info("entering... prepare dma buffers \n");
+	for (buffer = dev->common_buffer; dev->num_buffers <
+			params->num_buffers; dev->num_buffers++, buffer
+			+= params->buffer_size) {
+		struct smscore_buffer_t *cb = smscore_createbuffer(buffer,
+				dev->common_buffer, dev->common_buffer_phys);
 		if (!cb) {
 			smscore_unregister_device(dev);
 			return -ENOMEM;
@@ -428,7 +406,70 @@ int smscore_register_device(struct smsdevice_params_t *params,
 
 	*coredev = dev;
 
-	sms_info("device %p created", dev);
+	sms_info("device %p created\n", dev);
+
+	return 0;
+}
+
+static int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,
+		void *buffer, size_t size, struct completion *completion) {
+	int rc = coredev->sendrequest_handler(coredev->context, buffer, size);
+	if (rc < 0) {
+		sms_info("sendrequest returned error %d", rc);
+		return rc;
+	}
+
+	return wait_for_completion_timeout(completion,
+			msecs_to_jiffies(SMS_PROTOCOL_MAX_RAOUNDTRIP_MS)) ? 0 : -ETIME;
+}
+
+/**
+ * Starts & enables IR operations
+ *
+ * @return 0 on success, < 0 on error.
+ */
+static int smscore_init_ir(struct smscore_device_t *coredev)
+{
+	int ir_io;
+	int rc;
+	void *buffer;
+
+	coredev->ir.input_dev = NULL;
+	ir_io = sms_get_board(smscore_get_board_id(coredev))->board_cfg.ir;
+	if (ir_io) {/* only if IR port exist we use IR sub-module */
+		sms_info("IR loading");
+		rc = sms_ir_init(coredev);
+
+		if	(rc != 0)
+			sms_err("Error initialization DTV IR sub-module");
+		else {
+			buffer = kmalloc(sizeof(struct SmsMsgData_ST2) +
+						SMS_DMA_ALIGNMENT,
+						GFP_KERNEL | GFP_DMA);
+			if (buffer) {
+				struct SmsMsgData_ST2 *msg =
+				(struct SmsMsgData_ST2 *)
+				SMS_ALIGN_ADDRESS(buffer);
+
+				SMS_INIT_MSG(&msg->xMsgHeader,
+						MSG_SMS_START_IR_REQ,
+						sizeof(struct SmsMsgData_ST2));
+				msg->msgData[0] = coredev->ir.controller;
+				msg->msgData[1] = coredev->ir.timeout;
+
+				smsendian_handle_tx_message(
+					(struct SmsMsgHdr_ST2 *)msg);
+				rc = smscore_sendrequest_and_wait(coredev, msg,
+						msg->xMsgHeader. msgLength,
+						&coredev->ir_init_done);
+
+				kfree(buffer);
+			} else
+				sms_err
+				("Sending IR initialization message failed");
+		}
+	} else
+		sms_info("IR port has not been detected");
 
 	return 0;
 }
@@ -443,16 +484,22 @@ int smscore_register_device(struct smsdevice_params_t *params,
  */
 int smscore_start_device(struct smscore_device_t *coredev)
 {
-	int rc = smscore_set_device_mode(
-			coredev, smscore_registry_getmode(coredev->devpath));
+	int rc;
+
+	sms_info("%p starting......\n", coredev);
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	rc = smscore_set_device_mode(coredev, smscore_registry_getmode(
+			coredev->devpath));
 	if (rc < 0) {
-		sms_info("set device mode faile , rc %d", rc);
+		sms_info("set device mode failed , rc %d", rc);
 		return rc;
 	}
+#endif
 
 	kmutex_lock(&g_smscore_deviceslock);
 
 	rc = smscore_notify_callbacks(coredev, coredev->device, 1);
+	smscore_init_ir(coredev);
 
 	sms_info("device %p started, rc %d", coredev, rc);
 
@@ -461,32 +508,21 @@ int smscore_start_device(struct smscore_device_t *coredev)
 	return rc;
 }
 
-static int smscore_sendrequest_and_wait(struct smscore_device_t *coredev,
-					void *buffer, size_t size,
-					struct completion *completion)
-{
-	int rc = coredev->sendrequest_handler(coredev->context, buffer, size);
-	if (rc < 0) {
-		sms_info("sendrequest returned error %d", rc);
-		return rc;
-	}
-
-	return wait_for_completion_timeout(completion,
-					   msecs_to_jiffies(10000)) ?
-						0 : -ETIME;
-}
-
 static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
-					 void *buffer, size_t size)
-{
+		void *buffer, size_t size) {
 	struct SmsFirmware_ST *firmware = (struct SmsFirmware_ST *) buffer;
 	struct SmsMsgHdr_ST *msg;
-	u32 mem_address = firmware->StartAddress;
+	u32 mem_address;
 	u8 *payload = firmware->Payload;
 	int rc = 0;
 
+	firmware->StartAddress = le32_to_cpu(firmware->StartAddress);
+	firmware->Length = le32_to_cpu(firmware->Length);
+
+	mem_address = firmware->StartAddress;
+
 	sms_info("loading FW to addr 0x%x size %d",
-		 mem_address, firmware->Length);
+			mem_address, firmware->Length);
 	if (coredev->preload_handler) {
 		rc = coredev->preload_handler(coredev->context);
 		if (rc < 0)
@@ -501,35 +537,35 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
 	if (coredev->mode != DEVICE_MODE_NONE) {
 		sms_debug("sending reload command.");
 		SMS_INIT_MSG(msg, MSG_SW_RELOAD_START_REQ,
-			     sizeof(struct SmsMsgHdr_ST));
-		rc = smscore_sendrequest_and_wait(coredev, msg,
-						  msg->msgLength,
-						  &coredev->reload_start_done);
+				sizeof(struct SmsMsgHdr_ST));
+		smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+		rc = smscore_sendrequest_and_wait(coredev, msg, msg->msgLength,
+				&coredev->reload_start_done);
 		mem_address = *(u32 *) &payload[20];
 	}
 
 	while (size && rc >= 0) {
 		struct SmsDataDownload_ST *DataMsg =
-			(struct SmsDataDownload_ST *) msg;
-		int payload_size = min((int) size, SMS_MAX_PAYLOAD_SIZE);
+				(struct SmsDataDownload_ST *) msg;
+		int payload_size = min((int)size, SMS_MAX_PAYLOAD_SIZE);
 
 		SMS_INIT_MSG(msg, MSG_SMS_DATA_DOWNLOAD_REQ,
-			     (u16)(sizeof(struct SmsMsgHdr_ST) +
-				      sizeof(u32) + payload_size));
+				(u16) (sizeof(struct SmsMsgHdr_ST) +
+						sizeof(u32) + payload_size));
 
 		DataMsg->MemAddr = mem_address;
 		memcpy(DataMsg->Payload, payload, payload_size);
 
+		smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 		if ((coredev->device_flags & SMS_ROM_NO_RESPONSE) &&
-		    (coredev->mode == DEVICE_MODE_NONE))
-			rc = coredev->sendrequest_handler(
-				coredev->context, DataMsg,
-				DataMsg->xMsgHeader.msgLength);
+				(coredev->mode	== DEVICE_MODE_NONE)) {
+			rc = coredev->sendrequest_handler(coredev->context, DataMsg,
+					DataMsg->xMsgHeader. msgLength);
+		}
 		else
-			rc = smscore_sendrequest_and_wait(
-				coredev, DataMsg,
-				DataMsg->xMsgHeader.msgLength,
-				&coredev->data_download_done);
+			rc = smscore_sendrequest_and_wait(coredev, DataMsg,
+					DataMsg->xMsgHeader. msgLength,
+					&coredev->data_download_done);
 
 		payload += payload_size;
 		size -= payload_size;
@@ -539,47 +575,48 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
 	if (rc >= 0) {
 		if (coredev->mode == DEVICE_MODE_NONE) {
 			struct SmsMsgData_ST *TriggerMsg =
-				(struct SmsMsgData_ST *) msg;
+					(struct SmsMsgData_ST *) msg;
 
 			SMS_INIT_MSG(msg, MSG_SMS_SWDOWNLOAD_TRIGGER_REQ,
-				     sizeof(struct SmsMsgHdr_ST) +
-				     sizeof(u32) * 5);
+					sizeof(struct SmsMsgHdr_ST) +
+					sizeof(u32) * 5);
 
 			TriggerMsg->msgData[0] = firmware->StartAddress;
-						/* Entry point */
+			/* Entry point */
 			TriggerMsg->msgData[1] = 5; /* Priority */
 			TriggerMsg->msgData[2] = 0x200; /* Stack size */
 			TriggerMsg->msgData[3] = 0; /* Parameter */
 			TriggerMsg->msgData[4] = 4; /* Task ID */
 
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 			if (coredev->device_flags & SMS_ROM_NO_RESPONSE) {
-				rc = coredev->sendrequest_handler(
-					coredev->context, TriggerMsg,
+				rc = coredev->sendrequest_handler(coredev->
+					context, TriggerMsg,
 					TriggerMsg->xMsgHeader.msgLength);
+
 				msleep(100);
 			} else
-				rc = smscore_sendrequest_and_wait(
-					coredev, TriggerMsg,
+				rc = smscore_sendrequest_and_wait(coredev,
+					TriggerMsg,
 					TriggerMsg->xMsgHeader.msgLength,
 					&coredev->trigger_done);
+
 		} else {
 			SMS_INIT_MSG(msg, MSG_SW_RELOAD_EXEC_REQ,
-				     sizeof(struct SmsMsgHdr_ST));
-
-			rc = coredev->sendrequest_handler(coredev->context,
-							  msg, msg->msgLength);
+					sizeof(struct SmsMsgHdr_ST));
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+			rc = coredev->sendrequest_handler(coredev->context, msg,
+					msg->msgLength);
 		}
 		msleep(500);
 	}
 
-	sms_debug("rc=%d, postload=%p ", rc,
-		  coredev->postload_handler);
+	sms_debug("rc=%d, postload=%p ", rc, coredev->postload_handler);
 
 	kfree(msg);
 
 	return ((rc >= 0) && coredev->postload_handler) ?
-		coredev->postload_handler(coredev->context) :
-		rc;
+			coredev->postload_handler(coredev->context) : rc;
 }
 
 /**
@@ -593,15 +630,16 @@ static int smscore_load_firmware_family2(struct smscore_device_t *coredev,
  * @return 0 on success, <0 on error.
  */
 static int smscore_load_firmware_from_file(struct smscore_device_t *coredev,
-					   char *filename,
-					   loadfirmware_t loadfirmware_handler)
-{
+		char *filename, loadfirmware_t loadfirmware_handler) {
 	int rc = -ENOENT;
+	u8 *fw_buf = NULL;
+	u32 fw_buf_size = 0;
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
 	const struct firmware *fw;
-	u8 *fw_buffer;
 
-	if (loadfirmware_handler == NULL && !(coredev->device_flags &
-					      SMS_DEVICE_FAMILY2))
+	if (loadfirmware_handler == NULL && !(coredev->device_flags
+			& SMS_DEVICE_FAMILY2))
 		return -EINVAL;
 
 	rc = request_firmware(&fw, filename, coredev->device);
@@ -610,26 +648,38 @@ static int smscore_load_firmware_from_file(struct smscore_device_t *coredev,
 		return rc;
 	}
 	sms_info("read FW %s, size=%zd", filename, fw->size);
-	fw_buffer = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),
-			    GFP_KERNEL | GFP_DMA);
-	if (fw_buffer) {
-		memcpy(fw_buffer, fw->data, fw->size);
-
-		rc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?
-		      smscore_load_firmware_family2(coredev,
-						    fw_buffer,
-						    fw->size) :
-		      loadfirmware_handler(coredev->context,
-					   fw_buffer, fw->size);
-
-		kfree(fw_buffer);
-	} else {
+	printk(KERN_INFO "read FW %s, size=%zd\n", filename, fw->size);
+	fw_buf = kmalloc(ALIGN(fw->size, SMS_ALLOC_ALIGNMENT),
+				GFP_KERNEL | GFP_DMA);
+	if (!fw_buf) {
 		sms_info("failed to allocate firmware buffer");
-		rc = -ENOMEM;
+		return -ENOMEM;
 	}
+	memcpy(fw_buf, fw->data, fw->size);
+	fw_buf_size = fw->size;
+#else
+	if (!coredev->fw_buf) {
+		sms_info("missing fw file buffer");
+		return -EINVAL;
+	}
+	fw_buf = coredev->fw_buf;
+	fw_buf_size = coredev->fw_buf_size;
+	sms_info("fw_buf_size = %d\n", fw_buf_size);
+#endif
 
-	release_firmware(fw);
+	rc = (coredev->device_flags & SMS_DEVICE_FAMILY2) ?
+		smscore_load_firmware_family2(coredev, fw_buf, fw_buf_size)
+		: loadfirmware_handler(coredev->context, fw_buf,
+		fw_buf_size);
 
+	kfree(fw_buf);
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	release_firmware(fw);
+#else
+	coredev->fw_buf = NULL;
+	coredev->fw_buf_size = 0;
+#endif
 	return rc;
 }
 
@@ -650,6 +700,9 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 
 	kmutex_lock(&g_smscore_deviceslock);
 
+	/* Release input device (IR) resources */
+	sms_ir_exit(coredev);
+
 	smscore_notify_clients(coredev);
 	smscore_notify_callbacks(coredev, NULL, 0);
 
@@ -657,20 +710,23 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 	 * onresponse must no longer be called */
 
 	while (1) {
-		while ((cb = smscore_getbuffer(coredev))) {
+		while (!list_empty(&coredev->buffers)) {
+			cb = (struct smscore_buffer_t *) coredev->buffers.next;
+			list_del(&cb->entry);
 			kfree(cb);
 			num_buffers++;
 		}
 		if (num_buffers == coredev->num_buffers)
 			break;
+
 		if (++retry > 10) {
 			sms_info("exiting although "
-				 "not all buffers released.");
+					"not all buffers released.");
 			break;
 		}
 
 		sms_info("waiting for %d buffer(s)",
-			 coredev->num_buffers - num_buffers);
+				coredev->num_buffers - num_buffers);
 		msleep(100);
 	}
 
@@ -678,8 +734,10 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 
 	if (coredev->common_buffer)
 		dma_free_coherent(NULL, coredev->common_buffer_size,
-				  coredev->common_buffer,
-				  coredev->common_buffer_phys);
+			coredev->common_buffer, coredev->common_buffer_phys);
+
+	if (coredev->fw_buf != NULL)
+		kfree(coredev->fw_buf);
 
 	list_del(&coredev->entry);
 	kfree(coredev);
@@ -689,33 +747,35 @@ void smscore_unregister_device(struct smscore_device_t *coredev)
 	sms_info("device %p destroyed", coredev);
 }
 
+/*##w21558, Removed.*/
+/*
 static int smscore_detect_mode(struct smscore_device_t *coredev)
 {
 	void *buffer = kmalloc(sizeof(struct SmsMsgHdr_ST) + SMS_DMA_ALIGNMENT,
-			       GFP_KERNEL | GFP_DMA);
+			GFP_KERNEL | GFP_DMA);
 	struct SmsMsgHdr_ST *msg =
-		(struct SmsMsgHdr_ST *) SMS_ALIGN_ADDRESS(buffer);
+			(struct SmsMsgHdr_ST *) SMS_ALIGN_ADDRESS(buffer);
 	int rc;
 
 	if (!buffer)
 		return -ENOMEM;
 
 	SMS_INIT_MSG(msg, MSG_SMS_GET_VERSION_EX_REQ,
-		     sizeof(struct SmsMsgHdr_ST));
+			sizeof(struct SmsMsgHdr_ST));
 
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
 	rc = smscore_sendrequest_and_wait(coredev, msg, msg->msgLength,
-					  &coredev->version_ex_done);
+			&coredev->version_ex_done);
 	if (rc == -ETIME) {
 		sms_err("MSG_SMS_GET_VERSION_EX_REQ failed first try");
 
 		if (wait_for_completion_timeout(&coredev->resume_done,
-						msecs_to_jiffies(5000))) {
-			rc = smscore_sendrequest_and_wait(
-				coredev, msg, msg->msgLength,
-				&coredev->version_ex_done);
+				msecs_to_jiffies(5000))) {
+			rc = smscore_sendrequest_and_wait(coredev, msg,
+				msg->msgLength, &coredev->version_ex_done);
 			if (rc < 0)
 				sms_err("MSG_SMS_GET_VERSION_EX_REQ failed "
-					"second try, rc %d", rc);
+						"second try, rc %d", rc);
 		} else
 			rc = -ETIME;
 	}
@@ -724,30 +784,27 @@ static int smscore_detect_mode(struct smscore_device_t *coredev)
 
 	return rc;
 }
+*/
 
 static char *smscore_fw_lkup[][SMS_NUM_OF_DEVICE_TYPES] = {
-	/*Stellar		NOVA A0		Nova B0		VEGA*/
-	/*DVBT*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*DVBH*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*TDMB*/
-	{"none", "tdmb_nova_12mhz.inp", "none", "none"},
-	/*DABIP*/
-	{"none", "none", "none", "none"},
-	/*BDA*/
-	{"none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none"},
-	/*ISDBT*/
-	{"none", "isdbt_nova_12mhz.inp", "dvb_nova_12mhz.inp", "none"},
-	/*ISDBTBDA*/
-	{"none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none"},
-	/*CMMB*/
-	{"none", "none", "none", "cmmb_vega_12mhz.inp"}
-};
-
-static inline char *sms_get_fw_name(struct smscore_device_t *coredev,
-				    int mode, enum sms_device_type_st type)
-{
+/*Stellar               NOVA A0         Nova B0         VEGA */
+/*DVBT*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*DVBH*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*TDMB*/
+{ "none", "tdmb_nova_12mhz.inp", "tdmb_nova_12mhz_b0.inp", "none" },
+/*DABIP*/{ "none", "none", "none", "none" },
+/*BDA*/
+{ "none", "dvb_nova_12mhz.inp", "dvb_nova_12mhz_b0.inp", "none" },
+/*ISDBT*/
+{ "none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none" },
+/*ISDBTBDA*/
+{ "none", "isdbt_nova_12mhz.inp", "isdbt_nova_12mhz_b0.inp", "none" },
+/*CMMB*/{ "none", "none", "none", "cmmb_vega_12mhz.inp" } };
+
+static inline char *sms_get_fw_name(struct smscore_device_t *coredev, int mode,
+		enum sms_device_type_st type) {
 	char **fw = sms_get_board(smscore_get_board_id(coredev))->fw;
 	return (fw && fw[mode]) ? fw[mode] : smscore_fw_lkup[mode][type];
 }
@@ -764,11 +821,15 @@ static inline char *sms_get_fw_name(struct smscore_device_t *coredev,
  */
 int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 {
+/*##w21558, Removed*/
+/*
 	void *buffer;
+*/
 	int rc = 0;
 	enum sms_device_type_st type;
 
 	sms_debug("set device mode to %d", mode);
+	printk(KERN_INFO "%s: set device mode to %d\n", __func__, mode);
 	if (coredev->device_flags & SMS_DEVICE_FAMILY2) {
 		if (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_RAW_TUNER) {
 			sms_err("invalid mode specified %d", mode);
@@ -777,6 +838,8 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 
 		smscore_registry_setmode(coredev->devpath, mode);
 
+/*##w21558, Removed*/
+/*
 		if (!(coredev->device_flags & SMS_DEVICE_NOT_READY)) {
 			rc = smscore_detect_mode(coredev);
 			if (rc < 0) {
@@ -784,9 +847,11 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 				return rc;
 			}
 		}
+*/
 
 		if (coredev->mode == mode) {
 			sms_info("device mode %d already set", mode);
+			printk(KERN_INFO "device mode %d already set", mode);
 			return 0;
 		}
 
@@ -797,50 +862,54 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 			fw_filename = sms_get_fw_name(coredev, mode, type);
 
 			rc = smscore_load_firmware_from_file(coredev,
-							     fw_filename, NULL);
+					fw_filename, NULL);
 			if (rc < 0) {
 				sms_warn("error %d loading firmware: %s, "
-					 "trying again with default firmware",
-					 rc, fw_filename);
+					"trying again with default firmware",
+					rc, fw_filename);
 
 				/* try again with the default firmware */
 				fw_filename = smscore_fw_lkup[mode][type];
 				rc = smscore_load_firmware_from_file(coredev,
-							     fw_filename, NULL);
+						fw_filename, NULL);
 
 				if (rc < 0) {
 					sms_warn("error %d loading "
-						 "firmware: %s", rc,
-						 fw_filename);
+							"firmware: %s", rc,
+							fw_filename);
 					return rc;
 				}
 			}
-			sms_log("firmware download success: %s", fw_filename);
+			sms_info("firmware download success: %s", fw_filename);
 		} else
 			sms_info("mode %d supported by running "
-				 "firmware", mode);
+					"firmware", mode);
 
+/*##w21558, Removed*/
+/*
 		buffer = kmalloc(sizeof(struct SmsMsgData_ST) +
-				 SMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);
+				SMS_DMA_ALIGNMENT, GFP_KERNEL | GFP_DMA);
 		if (buffer) {
 			struct SmsMsgData_ST *msg =
-				(struct SmsMsgData_ST *)
+					(struct SmsMsgData_ST *)
 					SMS_ALIGN_ADDRESS(buffer);
 
 			SMS_INIT_MSG(&msg->xMsgHeader, MSG_SMS_INIT_DEVICE_REQ,
-				     sizeof(struct SmsMsgData_ST));
+					sizeof(struct SmsMsgData_ST));
 			msg->msgData[0] = mode;
 
-			rc = smscore_sendrequest_and_wait(
-				coredev, msg, msg->xMsgHeader.msgLength,
-				&coredev->init_device_done);
+			smsendian_handle_tx_message((struct SmsMsgHdr_ST *)msg);
+			rc = smscore_sendrequest_and_wait(coredev, msg,
+					msg->xMsgHeader. msgLength,
+					&coredev->init_device_done);
 
 			kfree(buffer);
 		} else {
 			sms_err("Could not allocate buffer for "
-				"init device message.");
+					"init device message.");
 			rc = -ENOMEM;
 		}
+*/
 	} else {
 		if (mode < DEVICE_MODE_DVBT || mode > DEVICE_MODE_DVBT_BDA) {
 			sms_err("invalid mode specified %d", mode);
@@ -851,7 +920,7 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 
 		if (coredev->detectmode_handler)
 			coredev->detectmode_handler(coredev->context,
-						    &coredev->mode);
+					&coredev->mode);
 
 		if (coredev->mode != mode && coredev->setmode_handler)
 			rc = coredev->setmode_handler(coredev->context, mode);
@@ -862,12 +931,87 @@ int smscore_set_device_mode(struct smscore_device_t *coredev, int mode)
 		coredev->device_flags &= ~SMS_DEVICE_NOT_READY;
 	}
 
-	if (rc != 0)
+	if (rc < 0)
 		sms_err("return error code %d.", rc);
 	return rc;
 }
 
 /**
+ * calls device handler to get fw file name
+ *
+ * @param coredev pointer to a coredev object returned by
+ *                smscore_register_device
+ * @param filename pointer to user buffer to fill the file name
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_get_fw_filename(struct smscore_device_t *coredev, int mode,
+		char *filename) {
+	int rc = 0;
+	enum sms_device_type_st type;
+	char tmpname[200];
+
+	type = smscore_registry_gettype(coredev->devpath);
+
+#ifdef REQUEST_FIRMWARE_SUPPORTED
+	/* driver not need file system services */
+	tmpname[0] = '\0';
+#else
+	sprintf(tmpname, "%s/%s", DEFAULT_FW_FILE_PATH,
+			smscore_fw_lkup[mode][type]);
+#endif
+	if (copy_to_user(filename, tmpname, strlen(tmpname) + 1)) {
+		sms_err("Failed copy file path to user buffer\n");
+		return -EFAULT;
+	}
+	return rc;
+}
+
+/**
+ * calls device handler to keep fw buff for later use
+ *
+ * @param coredev pointer to a coredev object returned by
+ *                smscore_register_device
+ * @param ufwbuf  pointer to user fw buffer
+ * @param size    size in bytes of buffer
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_send_fw_file(struct smscore_device_t *coredev, u8 *ufwbuf,
+		int size) {
+	int rc = 0;
+
+	/* free old buffer */
+	if (coredev->fw_buf != NULL) {
+		kfree(coredev->fw_buf);
+		coredev->fw_buf = NULL;
+	}
+
+	coredev->fw_buf = kmalloc(ALIGN(size, SMS_ALLOC_ALIGNMENT), GFP_KERNEL
+			| GFP_DMA);
+	if (!coredev->fw_buf) {
+		sms_info("Failed allocate FW buffer memory\n");
+		return -EFAULT;
+	}
+
+	if (copy_from_user(coredev->fw_buf, ufwbuf, size)) {
+		sms_info("Failed copy FW from user buffer\n");
+		kfree(coredev->fw_buf);
+		return -EFAULT;
+	}
+	coredev->fw_buf_size = size;
+
+	return rc;
+}
+
+/* ##w21558, Added */
+int smscore_reset_device_mode(struct smscore_device_t *coredev)
+{
+  coredev->mode = -1;
+  return 0;
+}
+
+/**
  * calls device handler to get current mode of operation
  *
  * @param coredev pointer to a coredev object returned by
@@ -890,28 +1034,26 @@ int smscore_get_device_mode(struct smscore_device_t *coredev)
  * @param id client id (SMS_DONT_CARE for all id)
  *
  */
-static struct
-smscore_client_t *smscore_find_client(struct smscore_device_t *coredev,
-				      int data_type, int id)
-{
+static struct smscore_client_t *smscore_find_client(
+		struct smscore_device_t *coredev, int data_type, int id) {
 	struct smscore_client_t *client = NULL;
 	struct list_head *next, *first;
 	unsigned long flags;
 	struct list_head *firstid, *nextid;
 
-
 	spin_lock_irqsave(&coredev->clientslock, flags);
 	first = &coredev->clients;
-	for (next = first->next;
-	     (next != first) && !client;
-	     next = next->next) {
-		firstid = &((struct smscore_client_t *)next)->idlist;
-		for (nextid = firstid->next;
-		     nextid != firstid;
-		     nextid = nextid->next) {
-			if ((((struct smscore_idlist_t *)nextid)->id == id) &&
-			    (((struct smscore_idlist_t *)nextid)->data_type == data_type ||
-			    (((struct smscore_idlist_t *)nextid)->data_type == 0))) {
+	for (next = first->next; (next != first) && !client;
+			next = next->next) {
+		firstid = &((struct smscore_client_t *) next)->idlist;
+		for (nextid = firstid->next; nextid != firstid;
+				nextid = nextid->next) {
+			if ((((struct smscore_idlist_t *) nextid)->id == id)
+					&& (((struct smscore_idlist_t *)
+						 nextid)->data_type
+						== data_type
+						|| (((struct smscore_idlist_t *)
+						nextid)->data_type == 0))) {
 				client = (struct smscore_client_t *) next;
 				break;
 			}
@@ -931,12 +1073,10 @@ smscore_client_t *smscore_find_client(struct smscore_device_t *coredev,
  *
  */
 void smscore_onresponse(struct smscore_device_t *coredev,
-			struct smscore_buffer_t *cb)
-{
-	struct SmsMsgHdr_ST *phdr =
-		(struct SmsMsgHdr_ST *)((u8 *) cb->p + cb->offset);
-	struct smscore_client_t *client =
-		smscore_find_client(coredev, phdr->msgType, phdr->msgDstId);
+		struct smscore_buffer_t *cb) {
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) ((u8 *) cb->p
+			+ cb->offset);
+	struct smscore_client_t *client;
 	int rc = -EBUSY;
 
 	static unsigned long last_sample_time; /* = 0; */
@@ -947,40 +1087,54 @@ void smscore_onresponse(struct smscore_device_t *coredev,
 		last_sample_time = time_now;
 
 	if (time_now - last_sample_time > 10000) {
-		sms_debug("\ndata rate %d bytes/secs",
-			  (int)((data_total * 1000) /
-				(time_now - last_sample_time)));
+		sms_info("\ndata rate %d bytes/secs",
+				(int)((data_total * 1000) /
+						(time_now - last_sample_time)));
 
 		last_sample_time = time_now;
 		data_total = 0;
 	}
 
 	data_total += cb->size;
+
+	/* Do we need to re-route? */
+	if ((phdr->msgType == MSG_SMS_HO_PER_SLICES_IND) ||
+			(phdr->msgType == MSG_SMS_TRANSMISSION_IND)) {
+		if (coredev->mode == DEVICE_MODE_DVBT_BDA)
+			phdr->msgDstId = DVBT_BDA_CONTROL_MSG_ID;
+	}
+
+
+	client = smscore_find_client(coredev, phdr->msgType, phdr->msgDstId);
+
 	/* If no client registered for type & id,
 	 * check for control client where type is not registered */
-	if (client)
+	if (client) {
 		rc = client->onresponse_handler(client->context, cb);
-
+  }
 	if (rc < 0) {
+		smsendian_handle_rx_message((struct SmsMsgData_ST *)phdr);
+
 		switch (phdr->msgType) {
-		case MSG_SMS_GET_VERSION_EX_RES:
-		{
+		case MSG_SMS_GET_VERSION_EX_RES: {
 			struct SmsVersionRes_ST *ver =
-				(struct SmsVersionRes_ST *) phdr;
-			sms_debug("MSG_SMS_GET_VERSION_EX_RES "
-				  "id %d prots 0x%x ver %d.%d",
-				  ver->FirmwareId, ver->SupportedProtocols,
-				  ver->RomVersionMajor, ver->RomVersionMinor);
+					(struct SmsVersionRes_ST *) phdr;
+			sms_info("MSG_SMS_GET_VERSION_EX_RES "
+					"id %d prots 0x%x ver %d.%d",
+					ver->FirmwareId,
+					ver->SupportedProtocols,
+					ver->RomVersionMajor,
+					ver->RomVersionMinor);
 
 			coredev->mode = ver->FirmwareId == 255 ?
-				DEVICE_MODE_NONE : ver->FirmwareId;
+					DEVICE_MODE_NONE : ver->FirmwareId;
 			coredev->modes_supported = ver->SupportedProtocols;
 
 			complete(&coredev->version_ex_done);
 			break;
 		}
 		case MSG_SMS_INIT_DEVICE_RES:
-			sms_debug("MSG_SMS_INIT_DEVICE_RES");
+			printk(KERN_INFO "%s: MSG_SMS_INIT_DEVICE_RES\n", __func__);
 			complete(&coredev->init_device_done);
 			break;
 		case MSG_SW_RELOAD_START_RES:
@@ -994,13 +1148,50 @@ void smscore_onresponse(struct smscore_device_t *coredev,
 			sms_debug("MSG_SW_RELOAD_EXEC_RES");
 			break;
 		case MSG_SMS_SWDOWNLOAD_TRIGGER_RES:
-			sms_debug("MSG_SMS_SWDOWNLOAD_TRIGGER_RES");
+			sms_info("MSG_SMS_SWDOWNLOAD_TRIGGER_RES");
 			complete(&coredev->trigger_done);
 			break;
 		case MSG_SMS_SLEEP_RESUME_COMP_IND:
 			complete(&coredev->resume_done);
 			break;
+		case MSG_SMS_GPIO_CONFIG_EX_RES:
+			sms_debug("MSG_SMS_GPIO_CONFIG_EX_RES");
+			complete(&coredev->gpio_configuration_done);
+			break;
+		case MSG_SMS_GPIO_SET_LEVEL_RES:
+			sms_debug("MSG_SMS_GPIO_SET_LEVEL_RES");
+			complete(&coredev->gpio_set_level_done);
+			break;
+		case MSG_SMS_GPIO_GET_LEVEL_RES:
+		{
+			u32 *msgdata = (u32 *) phdr;
+			coredev->gpio_get_res = msgdata[1];
+			sms_debug("MSG_SMS_GPIO_GET_LEVEL_RES gpio level %d",
+					coredev->gpio_get_res);
+			complete(&coredev->gpio_get_level_done);
+			break;
+		}
+		case MSG_SMS_START_IR_RES:
+			complete(&coredev->ir_init_done);
+			break;
+		case MSG_SMS_IR_SAMPLES_IND:
+			sms_ir_event(coredev,
+				(const char *)
+				((char *)phdr
+				+ sizeof(struct SmsMsgHdr_ST)),
+				(int)phdr->msgLength
+				- sizeof(struct SmsMsgHdr_ST));
+      break;
+
+    case MSG_SMS_SPI_INT_LINE_SET_RES:
+      sms_info("MSG_SMS_SPI_INT_LINE_SET_RES\n");
+			break;
 		default:
+/*
+			sms_info("no client (%p) or error (%d), "
+					"type:%d dstid:%d", client, rc,
+					phdr->msgType, phdr->msgDstId);
+*/
 			break;
 		}
 		smscore_putbuffer(coredev, cb);
@@ -1020,12 +1211,24 @@ struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)
 	struct smscore_buffer_t *cb = NULL;
 	unsigned long flags;
 
+	DEFINE_WAIT(wait);
+
 	spin_lock_irqsave(&coredev->bufferslock, flags);
 
-	if (!list_empty(&coredev->buffers)) {
+	/* This function must return a valid buffer, since the buffer list is
+	 * finite, we check that there is an available buffer, if not, we wait
+	 * until such buffer become available.
+	 */
+
+	prepare_to_wait(&coredev->buffer_mng_waitq, &wait, TASK_INTERRUPTIBLE);
+
+	if (list_empty(&coredev->buffers))
+		schedule();
+
+	finish_wait(&coredev->buffer_mng_waitq, &wait);
+
 		cb = (struct smscore_buffer_t *) coredev->buffers.next;
 		list_del(&cb->entry);
-	}
 
 	spin_unlock_irqrestore(&coredev->bufferslock, flags);
 
@@ -1041,15 +1244,13 @@ struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev)
  *
  */
 void smscore_putbuffer(struct smscore_device_t *coredev,
-		       struct smscore_buffer_t *cb)
-{
+		struct smscore_buffer_t *cb) {
+	wake_up_interruptible(&coredev->buffer_mng_waitq);
 	list_add_locked(&cb->entry, &coredev->buffers, &coredev->bufferslock);
 }
 
 static int smscore_validate_client(struct smscore_device_t *coredev,
-				   struct smscore_client_t *client,
-				   int data_type, int id)
-{
+		struct smscore_client_t *client, int data_type, int id) {
 	struct smscore_idlist_t *listentry;
 	struct smscore_client_t *registered_client;
 
@@ -1092,11 +1293,13 @@ static int smscore_validate_client(struct smscore_device_t *coredev,
  * @return 0 on success, <0 on error.
  */
 int smscore_register_client(struct smscore_device_t *coredev,
-			    struct smsclient_params_t *params,
-			    struct smscore_client_t **client)
-{
+		struct smsclient_params_t *params,
+				struct smscore_client_t **client) {
 	struct smscore_client_t *newclient;
 	/* check that no other channel with same parameters exists */
+	sms_info("entering....smscore_register_client \n");
+
+
 	if (smscore_find_client(coredev, params->data_type,
 				params->initial_id)) {
 		sms_err("Client already exist.");
@@ -1117,10 +1320,10 @@ int smscore_register_client(struct smscore_device_t *coredev,
 	list_add_locked(&newclient->entry, &coredev->clients,
 			&coredev->clientslock);
 	smscore_validate_client(coredev, newclient, params->data_type,
-				params->initial_id);
+			params->initial_id);
 	*client = newclient;
-	sms_debug("%p %d %d", params->context, params->data_type,
-		  params->initial_id);
+	sms_debug("Register new client %p DT=%d ID=%d",
+		params->context, params->data_type, params->initial_id);
 
 	return 0;
 }
@@ -1139,10 +1342,9 @@ void smscore_unregister_client(struct smscore_client_t *client)
 
 	spin_lock_irqsave(&coredev->clientslock, flags);
 
-
 	while (!list_empty(&client->idlist)) {
 		struct smscore_idlist_t *identry =
-			(struct smscore_idlist_t *) client->idlist.next;
+				(struct smscore_idlist_t *) client->idlist.next;
 		list_del(&identry->entry);
 		kfree(identry);
 	}
@@ -1166,9 +1368,8 @@ void smscore_unregister_client(struct smscore_client_t *client)
  *
  * @return 0 on success, <0 on error.
  */
-int smsclient_sendrequest(struct smscore_client_t *client,
-			  void *buffer, size_t size)
-{
+int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size) {
 	struct smscore_device_t *coredev;
 	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) buffer;
 	int rc;
@@ -1187,88 +1388,300 @@ int smsclient_sendrequest(struct smscore_client_t *client,
 	}
 
 	rc = smscore_validate_client(client->coredev, client, 0,
-				     phdr->msgSrcId);
+			phdr->msgSrcId);
 	if (rc < 0)
 		return rc;
 
 	return coredev->sendrequest_handler(coredev->context, buffer, size);
 }
 
+#ifdef SMS_HOSTLIB_SUBSYS
+/**
+ * return the size of large (common) buffer
+ *
+ * @param coredev pointer to a coredev object from clients hotplug
+ *
+ * @return size (in bytes) of the buffer
+ */
+int smscore_get_common_buffer_size(struct smscore_device_t *coredev)
+{
+	return coredev->common_buffer_size;
+}
 
-int smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,
-			   struct smscore_gpio_config *pinconfig)
+/**
+ * maps common buffer (if supported by platform)
+ *
+ * @param coredev pointer to a coredev object from clients hotplug
+ * @param vma pointer to vma struct from mmap handler
+ *
+ * @return 0 on success, <0 on error.
+ */
+int smscore_map_common_buffer(struct smscore_device_t *coredev,
+		struct vm_area_struct *vma)
 {
-	struct {
-		struct SmsMsgHdr_ST hdr;
-		u32 data[6];
-	} msg;
+	unsigned long end = vma->vm_end,
+	start = vma->vm_start,
+	size = PAGE_ALIGN(coredev->common_buffer_size);
 
-	if (coredev->device_flags & SMS_DEVICE_FAMILY2) {
-		msg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-		msg.hdr.msgDstId = HIF_TASK;
-		msg.hdr.msgFlags = 0;
-		msg.hdr.msgType  = MSG_SMS_GPIO_CONFIG_EX_REQ;
-		msg.hdr.msgLength = sizeof(msg);
+	if (!(vma->vm_flags & (VM_READ | VM_SHARED)) ||
+			(vma->vm_flags & VM_WRITE)) {
+		sms_err("invalid vm flags");
+		return -EINVAL;
+	}
 
-		msg.data[0] = pin;
-		msg.data[1] = pinconfig->pullupdown;
+	if ((end - start) != size) {
+		sms_err("invalid size %d expected %d",
+				(int)(end - start), (int)size);
+		return -EINVAL;
+	}
 
-		/* Convert slew rate for Nova: Fast(0) = 3 / Slow(1) = 0; */
-		msg.data[2] = pinconfig->outputslewrate == 0 ? 3 : 0;
+	if (remap_pfn_range(vma, start,
+			coredev->common_buffer_phys >> PAGE_SHIFT,
+			size, pgprot_noncached(vma->vm_page_prot))) {
+		sms_err("remap_page_range failed");
+		return -EAGAIN;
+	}
 
-		switch (pinconfig->outputdriving) {
-		case SMS_GPIO_OUTPUTDRIVING_16mA:
-			msg.data[3] = 7; /* Nova - 16mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_12mA:
-			msg.data[3] = 5; /* Nova - 11mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_8mA:
-			msg.data[3] = 3; /* Nova - 7mA */
-			break;
-		case SMS_GPIO_OUTPUTDRIVING_4mA:
-		default:
-			msg.data[3] = 2; /* Nova - 4mA */
-			break;
-		}
+	return 0;
+}
+#endif /* SMS_HOSTLIB_SUBSYS */
+
+static int GetGpioPinParams(u32 PinNum, u32 *pTranslatedPinNum,
+		u32 *pGroupNum, u32 *pGroupCfg) {
+
+	*pGroupCfg = 1;
+
+	if (PinNum >= 0 && PinNum <= 1)	{
+		*pTranslatedPinNum = 0;
+		*pGroupNum = 9;
+		*pGroupCfg = 2;
+	} else if (PinNum >= 2 && PinNum <= 6) {
+		*pTranslatedPinNum = 2;
+		*pGroupNum = 0;
+		*pGroupCfg = 2;
+	} else if (PinNum >= 7 && PinNum <= 11) {
+		*pTranslatedPinNum = 7;
+		*pGroupNum = 1;
+	} else if (PinNum >= 12 && PinNum <= 15) {
+		*pTranslatedPinNum = 12;
+		*pGroupNum = 2;
+		*pGroupCfg = 3;
+	} else if (PinNum == 16) {
+		*pTranslatedPinNum = 16;
+		*pGroupNum = 23;
+	} else if (PinNum >= 17 && PinNum <= 24) {
+		*pTranslatedPinNum = 17;
+		*pGroupNum = 3;
+	} else if (PinNum == 25) {
+		*pTranslatedPinNum = 25;
+		*pGroupNum = 6;
+	} else if (PinNum >= 26 && PinNum <= 28) {
+		*pTranslatedPinNum = 26;
+		*pGroupNum = 4;
+	} else if (PinNum == 29) {
+		*pTranslatedPinNum = 29;
+		*pGroupNum = 5;
+		*pGroupCfg = 2;
+	} else if (PinNum == 30) {
+		*pTranslatedPinNum = 30;
+		*pGroupNum = 8;
+	} else if (PinNum == 31) {
+		*pTranslatedPinNum = 31;
+		*pGroupNum = 17;
+	} else
+		return -1;
+
+	*pGroupCfg <<= 24;
+
+	return 0;
+}
+
+int smscore_gpio_configure(struct smscore_device_t *coredev, u8 PinNum,
+		struct smscore_gpio_config *pGpioConfig) {
+
+	u32 totalLen;
+	u32 TranslatedPinNum;
+	u32 GroupNum;
+	u32 ElectricChar;
+	u32 groupCfg;
+	void *buffer;
+	int rc;
+
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[6];
+	} *pMsg;
+
+
+	if (PinNum > MAX_GPIO_PIN_NUMBER)
+		return -EINVAL;
+
+	if (pGpioConfig == NULL)
+		return -EINVAL;
+
+	totalLen = sizeof(struct SmsMsgHdr_ST) + (sizeof(u32) * 6);
+
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+
+	if (!(coredev->device_flags & SMS_DEVICE_FAMILY2)) {
+		pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_REQ;
+		if (GetGpioPinParams(PinNum, &TranslatedPinNum, &GroupNum,
+				&groupCfg) != 0)
+			return -EINVAL;
+
+		pMsg->msgData[1] = TranslatedPinNum;
+		pMsg->msgData[2] = GroupNum;
+		ElectricChar = (pGpioConfig->PullUpDown)
+				| (pGpioConfig->InputCharacteristics << 2)
+				| (pGpioConfig->OutputSlewRate << 3)
+				| (pGpioConfig->OutputDriving << 4);
+		pMsg->msgData[3] = ElectricChar;
+		pMsg->msgData[4] = pGpioConfig->Direction;
+		pMsg->msgData[5] = groupCfg;
+	} else {
+		pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_CONFIG_EX_REQ;
+		pMsg->msgData[1] = pGpioConfig->PullUpDown;
+		pMsg->msgData[2] = pGpioConfig->OutputSlewRate;
+		pMsg->msgData[3] = pGpioConfig->OutputDriving;
+		pMsg->msgData[4] = pGpioConfig->Direction;
+		pMsg->msgData[5] = 0;
+	}
+
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_configuration_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_configure timeout");
+		else
+			sms_err("smscore_gpio_configure error");
+	}
+	kfree(buffer);
+
+	return rc;
+}
+
+int smscore_gpio_set_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 NewLevel) {
+
+	u32 totalLen;
+	int rc;
+	void *buffer;
 
-		msg.data[4] = pinconfig->direction;
-		msg.data[5] = 0;
-	} else /* TODO: SMS_DEVICE_FAMILY1 */
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[3]; /* keep it 3 ! */
+	} *pMsg;
+
+	if ((NewLevel > 1) || (PinNum > MAX_GPIO_PIN_NUMBER) ||
+			(PinNum > MAX_GPIO_PIN_NUMBER))
 		return -EINVAL;
 
-	return coredev->sendrequest_handler(coredev->context,
-					    &msg, sizeof(msg));
+	totalLen = sizeof(struct SmsMsgHdr_ST) +
+			(3 * sizeof(u32)); /* keep it 3 ! */
+
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_SET_LEVEL_REQ;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+	pMsg->msgData[1] = NewLevel;
+
+	/* Send message to SMS */
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_set_level_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_set_level timeout");
+		else
+			sms_err("smscore_gpio_set_level error");
+	}
+	kfree(buffer);
+
+	return rc;
 }
 
-int smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level)
-{
-	struct {
-		struct SmsMsgHdr_ST hdr;
-		u32 data[3];
-	} msg;
+int smscore_gpio_get_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 *level) {
+
+	u32 totalLen;
+	int rc;
+	void *buffer;
+
+	struct SetGpioMsg {
+		struct SmsMsgHdr_ST xMsgHeader;
+		u32 msgData[2];
+	} *pMsg;
+
 
-	if (pin > MAX_GPIO_PIN_NUMBER)
+	if (PinNum > MAX_GPIO_PIN_NUMBER)
 		return -EINVAL;
 
-	msg.hdr.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
-	msg.hdr.msgDstId = HIF_TASK;
-	msg.hdr.msgFlags = 0;
-	msg.hdr.msgType  = MSG_SMS_GPIO_SET_LEVEL_REQ;
-	msg.hdr.msgLength = sizeof(msg);
+	totalLen = sizeof(struct SmsMsgHdr_ST) + (2 * sizeof(u32));
 
-	msg.data[0] = pin;
-	msg.data[1] = level ? 1 : 0;
-	msg.data[2] = 0;
+	buffer = kmalloc(totalLen + SMS_DMA_ALIGNMENT,
+			GFP_KERNEL | GFP_DMA);
+	if (!buffer)
+		return -ENOMEM;
+
+	pMsg = (struct SetGpioMsg *) SMS_ALIGN_ADDRESS(buffer);
+
+	pMsg->xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
+	pMsg->xMsgHeader.msgDstId = HIF_TASK;
+	pMsg->xMsgHeader.msgFlags = 0;
+	pMsg->xMsgHeader.msgType = MSG_SMS_GPIO_GET_LEVEL_REQ;
+	pMsg->xMsgHeader.msgLength = (u16) totalLen;
+	pMsg->msgData[0] = PinNum;
+	pMsg->msgData[1] = 0;
+
+	/* Send message to SMS */
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)pMsg);
+	rc = smscore_sendrequest_and_wait(coredev, pMsg, totalLen,
+			&coredev->gpio_get_level_done);
+
+	if (rc != 0) {
+		if (rc == -ETIME)
+			sms_err("smscore_gpio_get_level timeout");
+		else
+			sms_err("smscore_gpio_get_level error");
+	}
+	kfree(buffer);
+
+	/* Its a race between other gpio_get_level() and the copy of the single
+	 * global 'coredev->gpio_get_res' to  the function's variable 'level'
+	 */
+	*level = coredev->gpio_get_res;
 
-	return coredev->sendrequest_handler(coredev->context,
-					    &msg, sizeof(msg));
+	return rc;
 }
 
 static int __init smscore_module_init(void)
 {
 	int rc = 0;
 
+	sms_info("entering... smscore_module_init....\n");
 	INIT_LIST_HEAD(&g_smscore_notifyees);
 	INIT_LIST_HEAD(&g_smscore_devices);
 	kmutex_init(&g_smscore_deviceslock);
@@ -1276,25 +1689,127 @@ static int __init smscore_module_init(void)
 	INIT_LIST_HEAD(&g_smscore_registry);
 	kmutex_init(&g_smscore_registrylock);
 
+	/* Register sub system adapter objects */
+
+#ifdef SMS_NET_SUBSYS
+	/* NET Register */
+	rc = smsnet_register();
+	if (rc) {
+		sms_err("Error registering Siano's network client.\n");
+		goto smsnet_error;
+	}
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	/* Char interface Register */
+	rc = smschar_register();
+	if (rc) {
+		sms_err("Error registering Siano's char device client.\n");
+		goto smschar_error;
+	}
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+	/* DVB v.3 Register */
+	rc = smsdvb_register();
+	if (rc) {
+		sms_err("Error registering DVB client.\n");
+		goto smsdvb_error;
+	}
+#endif
+
+	/* Register interfaces objects */
+
+#ifdef SMS_USB_DRV
 	/* USB Register */
 	rc = smsusb_register();
+	if (rc) {
+		sms_err("Error registering USB bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
+
+#ifdef SMS_SDIO_DRV
+	/* SDIO Register */
+	rc = smssdio_register();
+	if (rc) {
+		sms_err("Error registering SDIO bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
+
+#ifdef SMS_SPI_DRV
+	/* SPI Register */
+	rc = smsspi_register();
+	if (rc) {
+		sms_err("Error registering Intel PXA310 SPI bus driver.\n");
+		goto sms_bus_drv_error;
+	}
+#endif
 
-	/* DVB Register */
-	rc = smsdvb_register();
+	return rc;
+
+sms_bus_drv_error:
+#ifdef SMS_DVB3_SUBSYS
+	smsdvb_unregister();
+smsdvb_error:
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	smschar_unregister();
+smschar_error:
+#endif
+
+#ifdef SMS_NET_SUBSYS
+	smsnet_unregister();
+smsnet_error:
+#endif
 
-	sms_debug("rc %d", rc);
+	/*sms_err("rc %d", rc);*/
+	printk(KERN_INFO "%s, rc %d\n", __func__, rc);
 
 	return rc;
 }
 
 static void __exit smscore_module_exit(void)
 {
+  printk(KERN_INFO "%s is called.\n", __func__);
+
+#ifdef SMS_NET_SUBSYS
+	/* Net Unregister */
+	smsnet_unregister();
+#endif
+
+#ifdef SMS_HOSTLIB_SUBSYS
+	/* Char interface Unregister */
+	smschar_unregister();
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+	/* DVB v.3 unregister */
+	smsdvb_unregister();
+#endif
+
+	/* Unegister interfaces objects */
+#ifdef SMS_USB_DRV
+	/* USB unregister */
+	smsusb_unregister();
+#endif
+
+#ifdef SMS_SDIO_DRV
+	/* SDIO unegister */
+	smssdio_unregister();
+#endif
+#ifdef SMS_SPI_DRV
+	/* SPI unegister */
+	smsspi_unregister();
+#endif
 
 	kmutex_lock(&g_smscore_deviceslock);
 	while (!list_empty(&g_smscore_notifyees)) {
 		struct smscore_device_notifyee_t *notifyee =
-			(struct smscore_device_notifyee_t *)
-				g_smscore_notifyees.next;
+		(struct smscore_device_notifyee_t *)
+		g_smscore_notifyees.next;
 
 		list_del(&notifyee->entry);
 		kfree(notifyee);
@@ -1304,26 +1819,20 @@ static void __exit smscore_module_exit(void)
 	kmutex_lock(&g_smscore_registrylock);
 	while (!list_empty(&g_smscore_registry)) {
 		struct smscore_registry_entry_t *entry =
-			(struct smscore_registry_entry_t *)
-				g_smscore_registry.next;
+		(struct smscore_registry_entry_t *)
+		g_smscore_registry.next;
 
 		list_del(&entry->entry);
 		kfree(entry);
 	}
 	kmutex_unlock(&g_smscore_registrylock);
 
-	/* DVB UnRegister */
-	smsdvb_unregister();
-
-	/* Unregister USB */
-	smsusb_unregister();
-
-	sms_debug("");
+	sms_debug("end");
 }
 
 module_init(smscore_module_init);
 module_exit(smscore_module_exit);
 
-MODULE_DESCRIPTION("Driver for the Siano SMS1XXX USB dongle");
-MODULE_AUTHOR("Siano Mobile Silicon,,, (doronc@siano-ms.com)");
+MODULE_DESCRIPTION("Siano MDTV Core module - Version 2.0.1");
+MODULE_AUTHOR("Siano Mobile Silicon, Inc. (uris@siano-ms.com)");
 MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/siano/smscoreapi.h b/drivers/media/dvb/siano/smscoreapi.h
index 760e233..30b3cc9 100644
--- a/drivers/media/dvb/siano/smscoreapi.h
+++ b/drivers/media/dvb/siano/smscoreapi.h
@@ -1,26 +1,26 @@
-/*
- *  Driver for the Siano SMS1xxx USB dongle
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef __smscoreapi_h__
-#define __smscoreapi_h__
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_CORE_API_H__
+#define __SMS_CORE_API_H__
 
 #include <linux/version.h>
 #include <linux/device.h>
@@ -28,14 +28,14 @@
 #include <linux/mm.h>
 #include <linux/scatterlist.h>
 #include <linux/types.h>
-#include <asm/page.h>
+#include <linux/mutex.h>
+#include <linux/compat.h>
+#include <linux/wait.h>
+#include <linux/timer.h>
 
-#include "dmxdev.h"
-#include "dvbdev.h"
-#include "dvb_demux.h"
-#include "dvb_frontend.h"
+#include <asm/page.h>
 
-#include <linux/mutex.h>
+#include "smsir.h"
 
 #define kmutex_init(_p_) mutex_init(_p_)
 #define kmutex_lock(_p_) mutex_lock(_p_)
@@ -46,6 +46,7 @@
 #define min(a, b) (((a) < (b)) ? (a) : (b))
 #endif
 
+#define SMS_PROTOCOL_MAX_RAOUNDTRIP_MS			(10000)
 #define SMS_ALLOC_ALIGNMENT					128
 #define SMS_DMA_ALIGNMENT					16
 #define SMS_ALIGN_ADDRESS(addr) \
@@ -53,7 +54,7 @@
 
 #define SMS_DEVICE_FAMILY2					1
 #define SMS_ROM_NO_RESPONSE					2
-#define SMS_DEVICE_NOT_READY				0x8000000
+#define SMS_DEVICE_NOT_READY					0x8000000
 
 enum sms_device_type_st {
 	SMS_STELLAR = 0,
@@ -67,80 +68,134 @@ struct smscore_device_t;
 struct smscore_client_t;
 struct smscore_buffer_t;
 
-typedef int (*hotplug_t)(struct smscore_device_t *coredev,
-			 struct device *device, int arrival);
+typedef int (*hotplug_t) (struct smscore_device_t *coredev,
+			  struct device *device, int arrival);
 
-typedef int (*setmode_t)(void *context, int mode);
-typedef void (*detectmode_t)(void *context, int *mode);
-typedef int (*sendrequest_t)(void *context, void *buffer, size_t size);
-typedef int (*loadfirmware_t)(void *context, void *buffer, size_t size);
-typedef int (*preload_t)(void *context);
-typedef int (*postload_t)(void *context);
+typedef int (*setmode_t) (void *context, int mode);
+typedef void (*detectmode_t) (void *context, int *mode);
+typedef int (*sendrequest_t) (void *context, void *buffer, size_t size);
+typedef int (*loadfirmware_t) (void *context, void *buffer, size_t size);
+typedef int (*preload_t) (void *context);
+typedef int (*postload_t) (void *context);
 
-typedef int (*onresponse_t)(void *context, struct smscore_buffer_t *cb);
-typedef void (*onremove_t)(void *context);
+typedef int (*onresponse_t) (void *context, struct smscore_buffer_t *cb);
+typedef void (*onremove_t) (void *context);
 
 struct smscore_buffer_t {
 	/* public members, once passed to clients can be changed freely */
 	struct list_head entry;
-	int				size;
-	int				offset;
+	int size;
+	int offset;
 
 	/* private members, read-only for clients */
-	void			*p;
-	dma_addr_t		phys;
-	unsigned long	offset_in_common;
+	void *p;
+	dma_addr_t phys;
+	unsigned long offset_in_common;
 };
 
 struct smsdevice_params_t {
-	struct device	*device;
+	struct device *device;
 
-	int				buffer_size;
-	int				num_buffers;
+	int buffer_size;
+	int num_buffers;
 
-	char			devpath[32];
-	unsigned long	flags;
+	char devpath[32];
+	unsigned long flags;
 
-	setmode_t		setmode_handler;
-	detectmode_t	detectmode_handler;
-	sendrequest_t	sendrequest_handler;
-	preload_t		preload_handler;
-	postload_t		postload_handler;
+	setmode_t setmode_handler;
+	detectmode_t detectmode_handler;
+	sendrequest_t sendrequest_handler;
+	preload_t preload_handler;
+	postload_t postload_handler;
 
-	void			*context;
+	void *context;
 	enum sms_device_type_st device_type;
 };
 
 struct smsclient_params_t {
-	int				initial_id;
-	int				data_type;
-	onresponse_t	onresponse_handler;
-	onremove_t		onremove_handler;
+	int initial_id;
+	int data_type;
+	onresponse_t onresponse_handler;
+	onremove_t onremove_handler;
+	void *context;
+};
+
+struct smscore_device_t {
+	struct list_head entry;
+
+	struct list_head clients;
+	struct list_head subclients;
+	spinlock_t clientslock; /* client lock */
+
+	struct list_head buffers;
+	spinlock_t bufferslock; /* buffer lock  */
+	int num_buffers;
+
+	void *common_buffer;
+	int common_buffer_size;
+	dma_addr_t common_buffer_phys;
+
+	void *context;
+	struct device *device;
+
+	char devpath[32];
+	unsigned long device_flags;
+
+	setmode_t setmode_handler;
+	detectmode_t detectmode_handler;
+	sendrequest_t sendrequest_handler;
+	preload_t preload_handler;
+	postload_t postload_handler;
 
-	void			*context;
+	int mode, modes_supported;
+
+	/* host <--> device messages */
+	struct completion version_ex_done, data_download_done, trigger_done;
+	struct completion init_device_done, reload_start_done, resume_done;
+	struct completion gpio_configuration_done, gpio_set_level_done;
+	struct completion gpio_get_level_done, ir_init_done;
+
+	/* Buffer management */
+	wait_queue_head_t buffer_mng_waitq;
+
+	/* GPIO */
+	int gpio_get_res;
+
+	/* Target hardware board */
+	int board_id;
+
+	/* Firmware */
+	u8 *fw_buf;
+	u32 fw_buf_size;
+
+	/* Infrared (IR) */
+	struct ir_t ir;
 };
 
+/* Use DMA channel */
+#define MOT_FEAT_OMAP_DMA_USE             1
+
 /* GPIO definitions for antenna frequency domain control (SMS8021) */
-#define SMS_ANTENNA_GPIO_0					1
-#define SMS_ANTENNA_GPIO_1					0
+#define SMS_ANTENNA_GPIO_0				1
+#define SMS_ANTENNA_GPIO_1				0
 
-#define BW_8_MHZ							0
-#define BW_7_MHZ							1
-#define BW_6_MHZ							2
-#define BW_5_MHZ							3
-#define BW_ISDBT_1SEG						4
-#define BW_ISDBT_3SEG						5
+#define BW_8_MHZ					0
+#define BW_7_MHZ					1
+#define BW_6_MHZ					2
+#define BW_5_MHZ					3
+#define BW_ISDBT_1SEG					4
+#define BW_ISDBT_3SEG					5
 
 #define MSG_HDR_FLAG_SPLIT_MSG				4
 
-#define MAX_GPIO_PIN_NUMBER					31
+#define MAX_GPIO_PIN_NUMBER				31
 
-#define HIF_TASK							11
-#define SMS_HOST_LIB						150
+#define HIF_TASK					11
+#define SMS_HOST_LIB					150
 #define DVBT_BDA_CONTROL_MSG_ID				201
 
 #define SMS_MAX_PAYLOAD_SIZE				240
-#define SMS_TUNE_TIMEOUT					500
+#define SMS_TUNE_TIMEOUT				500
 
 #define MSG_SMS_GPIO_CONFIG_REQ				507
 #define MSG_SMS_GPIO_CONFIG_RES				508
@@ -148,48 +203,53 @@ struct smsclient_params_t {
 #define MSG_SMS_GPIO_SET_LEVEL_RES			510
 #define MSG_SMS_GPIO_GET_LEVEL_REQ			511
 #define MSG_SMS_GPIO_GET_LEVEL_RES			512
-#define MSG_SMS_RF_TUNE_REQ					561
-#define MSG_SMS_RF_TUNE_RES					562
+#define MSG_SMS_RF_TUNE_REQ				561
+#define MSG_SMS_RF_TUNE_RES				562
 #define MSG_SMS_INIT_DEVICE_REQ				578
 #define MSG_SMS_INIT_DEVICE_RES				579
 #define MSG_SMS_ADD_PID_FILTER_REQ			601
 #define MSG_SMS_ADD_PID_FILTER_RES			602
-#define MSG_SMS_REMOVE_PID_FILTER_REQ		603
-#define MSG_SMS_REMOVE_PID_FILTER_RES		604
-#define MSG_SMS_DAB_CHANNEL					607
-#define MSG_SMS_GET_PID_FILTER_LIST_REQ		608
-#define MSG_SMS_GET_PID_FILTER_LIST_RES		609
-#define MSG_SMS_GET_STATISTICS_REQ			615
-#define MSG_SMS_GET_STATISTICS_RES			616
-#define MSG_SMS_SET_ANTENNA_CONFIG_REQ		651
-#define MSG_SMS_SET_ANTENNA_CONFIG_RES		652
-#define MSG_SMS_GET_STATISTICS_EX_REQ		653
-#define MSG_SMS_GET_STATISTICS_EX_RES		654
-#define MSG_SMS_SLEEP_RESUME_COMP_IND		655
+#define MSG_SMS_REMOVE_PID_FILTER_REQ			603
+#define MSG_SMS_REMOVE_PID_FILTER_RES			604
+#define MSG_SMS_DAB_CHANNEL				607
+#define MSG_SMS_GET_PID_FILTER_LIST_REQ			608
+#define MSG_SMS_GET_PID_FILTER_LIST_RES			609
+#define MSG_SMS_HO_PER_SLICES_IND			630
+#define MSG_SMS_SET_ANTENNA_CONFIG_REQ			651
+#define MSG_SMS_SET_ANTENNA_CONFIG_RES			652
+#define MSG_SMS_SLEEP_RESUME_COMP_IND			655
 #define MSG_SMS_DATA_DOWNLOAD_REQ			660
 #define MSG_SMS_DATA_DOWNLOAD_RES			661
-#define MSG_SMS_SWDOWNLOAD_TRIGGER_REQ		664
-#define MSG_SMS_SWDOWNLOAD_TRIGGER_RES		665
-#define MSG_SMS_SWDOWNLOAD_BACKDOOR_REQ		666
-#define MSG_SMS_SWDOWNLOAD_BACKDOOR_RES		667
+#define MSG_SMS_SWDOWNLOAD_TRIGGER_REQ			664
+#define MSG_SMS_SWDOWNLOAD_TRIGGER_RES			665
+#define MSG_SMS_SWDOWNLOAD_BACKDOOR_REQ			666
+#define MSG_SMS_SWDOWNLOAD_BACKDOOR_RES			667
 #define MSG_SMS_GET_VERSION_EX_REQ			668
 #define MSG_SMS_GET_VERSION_EX_RES			669
-#define MSG_SMS_SET_CLOCK_OUTPUT_REQ		670
+#define MSG_SMS_SET_CLOCK_OUTPUT_REQ			670
 #define MSG_SMS_I2C_SET_FREQ_REQ			685
 #define MSG_SMS_GENERIC_I2C_REQ				687
 #define MSG_SMS_GENERIC_I2C_RES				688
 #define MSG_SMS_DVBT_BDA_DATA				693
-#define MSG_SW_RELOAD_REQ					697
-#define MSG_SMS_DATA_MSG					699
+#define MSG_SW_RELOAD_REQ				697
+#define MSG_SMS_DATA_MSG				699
 #define MSG_SW_RELOAD_START_REQ				702
 #define MSG_SW_RELOAD_START_RES				703
 #define MSG_SW_RELOAD_EXEC_REQ				704
 #define MSG_SW_RELOAD_EXEC_RES				705
 #define MSG_SMS_SPI_INT_LINE_SET_REQ		710
+#define MSG_SMS_SPI_INT_LINE_SET_RES	  711
 #define MSG_SMS_GPIO_CONFIG_EX_REQ			712
 #define MSG_SMS_GPIO_CONFIG_EX_RES			713
 #define MSG_SMS_ISDBT_TUNE_REQ				776
 #define MSG_SMS_ISDBT_TUNE_RES				777
+#define MSG_SMS_TRANSMISSION_IND			782
+#define MSG_SMS_START_IR_REQ				800
+#define MSG_SMS_START_IR_RES				801
+#define MSG_SMS_IR_SAMPLES_IND				802
+#define MSG_SMS_SIGNAL_DETECTED_IND			827
+#define MSG_SMS_NO_SIGNAL_IND				828
+
 
 #define SMS_INIT_MSG_EX(ptr, type, src, dst, len) do { \
 	(ptr)->msgType = type; (ptr)->msgSrcId = src; (ptr)->msgDstId = dst; \
@@ -198,6 +258,16 @@ struct smsclient_params_t {
 #define SMS_INIT_MSG(ptr, type, len) \
 	SMS_INIT_MSG_EX(ptr, type, 0, HIF_TASK, len)
 
+enum SMS_DVB3_EVENTS {
+	DVB3_EVENT_INIT = 0,
+	DVB3_EVENT_SLEEP,
+	DVB3_EVENT_HOTPLUG,
+	DVB3_EVENT_FE_LOCK,
+	DVB3_EVENT_FE_UNLOCK,
+	DVB3_EVENT_UNC_OK,
+	DVB3_EVENT_UNC_ERR
+};
+
 enum SMS_DEVICE_MODE {
 	DEVICE_MODE_NONE = -1,
 	DEVICE_MODE_DVBT = 0,
@@ -213,181 +283,267 @@ enum SMS_DEVICE_MODE {
 };
 
 struct SmsMsgHdr_ST {
-	u16	msgType;
-	u8	msgSrcId;
-	u8	msgDstId;
-	u16	msgLength; /* Length of entire message, including header */
-	u16	msgFlags;
+	u16 msgType;
+	u8 msgSrcId;
+	u8 msgDstId;
+	u16 msgLength;		/* Length of entire message, including header */
+	u16 msgFlags;
 };
 
 struct SmsMsgData_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-	u32			msgData[1];
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 msgData[1];
+};
+
+struct SmsMsgData_ST2 {
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 msgData[2];
 };
 
 struct SmsDataDownload_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-	u32			MemAddr;
-	u8			Payload[SMS_MAX_PAYLOAD_SIZE];
+	struct SmsMsgHdr_ST xMsgHeader;
+	u32 MemAddr;
+	u8 Payload[SMS_MAX_PAYLOAD_SIZE];
 };
 
 struct SmsVersionRes_ST {
-	struct SmsMsgHdr_ST	xMsgHeader;
-
-	u16		ChipModel; /* e.g. 0x1102 for SMS-1102 "Nova" */
-	u8		Step; /* 0 - Step A */
-	u8		MetalFix; /* 0 - Metal 0 */
-
-	u8		FirmwareId; /* 0xFF  ROM, otherwise the
-				     * value indicated by
-				     * SMSHOSTLIB_DEVICE_MODES_E */
-	u8		SupportedProtocols; /* Bitwise OR combination of
-					     * supported protocols */
+	struct SmsMsgHdr_ST xMsgHeader;
+
+	u16 ChipModel;		/* e.g. 0x1102 for SMS-1102 "Nova" */
+	u8 Step;		/* 0 - Step A */
+	u8 MetalFix;		/* 0 - Metal 0 */
+
+	/* FirmwareId 0xFF if ROM, otherwise the
+	 * value indicated by SMSHOSTLIB_DEVICE_MODES_E */
+	u8 FirmwareId;
+	/* SupportedProtocols Bitwise OR combination of
+				 * supported protocols */
+	u8 SupportedProtocols;
+
+	u8 VersionMajor;
+	u8 VersionMinor;
+	u8 VersionPatch;
+	u8 VersionFieldPatch;
+
+	u8 RomVersionMajor;
+	u8 RomVersionMinor;
+	u8 RomVersionPatch;
+	u8 RomVersionFieldPatch;
+
+	u8 TextLabel[34];
+};
 
-	u8		VersionMajor;
-	u8		VersionMinor;
-	u8		VersionPatch;
-	u8		VersionFieldPatch;
+struct SmsFirmware_ST {
+	u32 CheckSum;
+	u32 Length;
+	u32 StartAddress;
+	u8 Payload[1];
+};
 
-	u8		RomVersionMajor;
-	u8		RomVersionMinor;
-	u8		RomVersionPatch;
-	u8		RomVersionFieldPatch;
+/* Statistics information returned as response for SmsHostApiGetStatistics_Req*/
+struct SMSHOSTLIB_STATISTICS_S {
+	u32 Reserved;		/*!< Reserved*/
+
+	/* Common parameters*/
+	u32 IsRfLocked;		/*!< 0 - not locked, 1 - locked*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+	u32 IsExternalLNAOn;	/*!< 0 - external LNA off, 1 - external LNA on*/
+
+	/* Reception quality*/
+	s32 SNR;		/*!< dB*/
+	u32 BER;		/*!< Post Viterbi BER [1E-5]*/
+	u32 FIB_CRC;		/*!< CRC errors percentage, valid only for DAB*/
+	u32 TS_PER;		/*!< Transport stream PER, 0xFFFFFFFF indicate N/A, valid only for DVB-T/H*/
+	u32 MFER;		/*!< DVB-H frame error rate in percentage, 0xFFFFFFFF indicate N/A, valid only for DVB-H*/
+	s32 RSSI;		/*!< dBm*/
+	s32 InBandPwr;		/*!< In band power in dBM*/
+	s32 CarrierOffset;	/*!< Carrier Offset in bin/1024*/
+
+	/* Transmission parameters*/
+	u32 Frequency;		/*!< Frequency in Hz*/
+	u32 Bandwidth;		/*!< Bandwidth in MHz, valid only for DVB-T/H*/
+	u32 TransmissionMode;	/*!< Transmission Mode, for DAB modes 1-4, for DVB-T/H FFT mode carriers in Kilos*/
+	u32 ModemState;		/*!< from SMSHOSTLIB_DVB_MODEM_STATE_ET , valid only for DVB-T/H*/
+	u32 GuardInterval;	/*!< Guard Interval from SMSHOSTLIB_GUARD_INTERVALS_ET, valid only for DVB-T/H*/
+	u32 CodeRate;		/*!< Code Rate from SMSHOSTLIB_CODE_RATE_ET, valid only for DVB-T/H*/
+	u32 LPCodeRate;		/*!< Low Priority Code Rate from SMSHOSTLIB_CODE_RATE_ET, valid only for DVB-T/H*/
+	u32 Hierarchy;		/*!< Hierarchy from SMSHOSTLIB_HIERARCHY_ET, valid only for DVB-T/H*/
+	u32 Constellation;	/*!< Constellation from SMSHOSTLIB_CONSTELLATION_ET, valid only for DVB-T/H*/
+
+	/* Burst parameters, valid only for DVB-H*/
+	u32 BurstSize;		/*!< Current burst size in bytes, valid only for DVB-H*/
+	u32 BurstDuration;	/*!< Current burst duration in mSec, valid only for DVB-H*/
+	u32 BurstCycleTime;	/*!< Current burst cycle time in mSec, valid only for DVB-H*/
+	u32 CalculatedBurstCycleTime;/*!< Current burst cycle time in mSec, as calculated by demodulator, valid only for DVB-H*/
+	u32 NumOfRows;		/*!< Number of rows in MPE table, valid only for DVB-H*/
+	u32 NumOfPaddCols;	/*!< Number of padding columns in MPE table, valid only for DVB-H*/
+	u32 NumOfPunctCols;	/*!< Number of puncturing columns in MPE table, valid only for DVB-H*/
+	u32 ErrorTSPackets;	/*!< Number of erroneous transport-stream packets*/
+	u32 TotalTSPackets;	/*!< Total number of transport-stream packets*/
+	u32 NumOfValidMpeTlbs;	/*!< Number of MPE tables which do not include errors after MPE RS decoding*/
+	u32 NumOfInvalidMpeTlbs;/*!< Number of MPE tables which include errors after MPE RS decoding*/
+	u32 NumOfCorrectedMpeTlbs;/*!< Number of MPE tables which were corrected by MPE RS decoding*/
+	/* Common params*/
+	u32 BERErrorCount;	/*!< Number of errornous SYNC bits.*/
+	u32 BERBitCount;	/*!< Total number of SYNC bits.*/
+
+	/* Interface information*/
+	u32 SmsToHostTxErrors;	/*!< Total number of transmission errors.*/
+
+	/* DAB/T-DMB*/
+	u32 PreBER; 		/*!< DAB/T-DMB only: Pre Viterbi BER [1E-5]*/
+
+	/* DVB-H TPS parameters*/
+	u32 CellId;		/*!< TPS Cell ID in bits 15..0, bits 31..16 zero; if set to 0xFFFFFFFF cell_id not yet recovered*/
+	u32 DvbhSrvIndHP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 DvbhSrvIndLP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+
+	u32 NumMPEReceived;	/*!< DVB-H, Num MPE section received*/
+
+	u32 ReservedFields[10];	/*!< Reserved*/
+};
 
-	u8		TextLabel[34];
+struct PID_STATISTICS_DATA_S {
+	struct PID_BURST_S {
+		u32	size;
+		u32	padding_cols;
+		u32	punct_cols;
+		u32	duration;
+		u32	cycle;
+		u32	calc_cycle;
+	} burst;
+
+	u32	tot_tbl_cnt;
+	u32	invalid_tbl_cnt;
+	u32  tot_cor_tbl;
 };
 
-struct SmsFirmware_ST {
-	u32			CheckSum;
-	u32			Length;
-	u32			StartAddress;
-	u8			Payload[1];
+struct PID_DATA_S {
+	u32 pid;
+	u32 num_rows;
+	struct PID_STATISTICS_DATA_S pid_statistics;
 };
 
-struct SMSHOSTLIB_STATISTICS_ST {
-	u32 Reserved; /* Reserved */
-
-	/* Common parameters */
-	u32 IsRfLocked; /* 0 - not locked, 1 - locked */
-	u32 IsDemodLocked; /* 0 - not locked, 1 - locked */
-	u32 IsExternalLNAOn; /* 0 - external LNA off, 1 - external LNA on */
-
-	/* Reception quality */
-	s32  SNR; /* dB */
-	u32 BER; /* Post Viterbi BER [1E-5] */
-	u32 FIB_CRC;	/* CRC errors percentage, valid only for DAB */
-	u32 TS_PER; /* Transport stream PER, 0xFFFFFFFF indicate N/A,
-		     * valid only for DVB-T/H */
-	u32 MFER; /* DVB-H frame error rate in percentage,
-		   * 0xFFFFFFFF indicate N/A, valid only for DVB-H */
-	s32  RSSI; /* dBm */
-	s32  InBandPwr; /* In band power in dBM */
-	s32  CarrierOffset; /* Carrier Offset in bin/1024 */
-
-	/* Transmission parameters, valid only for DVB-T/H */
-	u32 Frequency; /* Frequency in Hz */
-	u32 Bandwidth; /* Bandwidth in MHz */
-	u32 TransmissionMode; /* Transmission Mode, for DAB modes 1-4,
-			       * for DVB-T/H FFT mode carriers in Kilos */
-	u32 ModemState; /* from SMS_DvbModemState_ET */
-	u32 GuardInterval; /* Guard Interval, 1 divided by value */
-	u32 CodeRate; /* Code Rate from SMS_DvbModemState_ET */
-	u32 LPCodeRate; /* Low Priority Code Rate from SMS_DvbModemState_ET */
-	u32 Hierarchy; /* Hierarchy from SMS_Hierarchy_ET */
-	u32 Constellation; /* Constellation from SMS_Constellation_ET */
-
-	/* Burst parameters, valid only for DVB-H */
-	u32 BurstSize; /* Current burst size in bytes */
-	u32 BurstDuration; /* Current burst duration in mSec */
-	u32 BurstCycleTime; /* Current burst cycle time in mSec */
-	u32 CalculatedBurstCycleTime; /* Current burst cycle time in mSec,
-				       * as calculated by demodulator */
-	u32 NumOfRows; /* Number of rows in MPE table */
-	u32 NumOfPaddCols; /* Number of padding columns in MPE table */
-	u32 NumOfPunctCols; /* Number of puncturing columns in MPE table */
-	/* Burst parameters */
-	u32 ErrorTSPackets; /* Number of erroneous transport-stream packets */
-	u32 TotalTSPackets; /* Total number of transport-stream packets */
-	u32 NumOfValidMpeTlbs; /* Number of MPE tables which do not include
-				* errors after MPE RS decoding */
-	u32 NumOfInvalidMpeTlbs; /* Number of MPE tables which include errors
-				  * after MPE RS decoding */
-	u32 NumOfCorrectedMpeTlbs; /* Number of MPE tables which were corrected
-				    * by MPE RS decoding */
-
-	/* Common params */
-	u32 BERErrorCount; /* Number of errornous SYNC bits. */
-	u32 BERBitCount; /* Total number of SYNC bits. */
-
-	/* Interface information */
-	u32 SmsToHostTxErrors; /* Total number of transmission errors. */
-
-	/* DAB/T-DMB */
-	u32 PreBER; /* DAB/T-DMB only: Pre Viterbi BER [1E-5] */
-
-	/* DVB-H TPS parameters */
-	u32 CellId; /* TPS Cell ID in bits 15..0, bits 31..16 zero;
-		     * if set to 0xFFFFFFFF cell_id not yet recovered */
+#define CORRECT_STAT_RSSI(_stat) ((_stat).RSSI *= (-1))
+#define CORRECT_STAT_BANDWIDTH(_stat) _stat.Bandwidth = (8 - (_stat.Bandwidth))
+#define CORRECT_STAT_TRANSMISSON_MODE(_stat) \
+	do { \
+	if (_stat.TransmissionMode == 0) \
+		_stat.TransmissionMode = 2; \
+	else if (_stat.TransmissionMode == 1) \
+		_stat.TransmissionMode = 8; \
+	else \
+		_stat.TransmissionMode = 4; \
+	} while (0);
+
+struct TRANSMISSION_STATISTICS_S {
+	u32 Frequency;		/*!< Frequency in Hz*/
+	u32 Bandwidth;		/*!< Bandwidth in MHz*/
+	u32 TransmissionMode;	/*!< FFT mode carriers in Kilos*/
+	u32 GuardInterval;	/*!< Guard Interval from SMSHOSTLIB_GUARD_INTERVALS_ET*/
+	u32 CodeRate;		/*!< Code Rate from SMSHOSTLIB_CODE_RATE_ET*/
+	u32 LPCodeRate;		/*!< Low Priority Code Rate from SMSHOSTLIB_CODE_RATE_ET*/
+	u32 Hierarchy;		/*!< Hierarchy from SMSHOSTLIB_HIERARCHY_ET*/
+	u32 Constellation;	/*!< Constellation from SMSHOSTLIB_CONSTELLATION_ET*/
+
+	/* DVB-H TPS parameters*/
+	u32 CellId;		/*!< TPS Cell ID in bits 15..0, bits 31..16 zero; if set to 0xFFFFFFFF cell_id not yet recovered*/
+	u32 DvbhSrvIndHP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 DvbhSrvIndLP;	/*!< DVB-H service indication info, bit 1 - Time Slicing indicator, bit 0 - MPE-FEC indicator*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+};
 
+struct RECEPTION_STATISTICS_S {
+	u32 IsRfLocked;		/*!< 0 - not locked, 1 - locked*/
+	u32 IsDemodLocked;	/*!< 0 - not locked, 1 - locked*/
+	u32 IsExternalLNAOn;	/*!< 0 - external LNA off, 1 - external LNA on*/
+
+	u32 ModemState;		/*!< from SMSHOSTLIB_DVB_MODEM_STATE_ET*/
+	s32 SNR;		/*!< dB*/
+	u32 BER;		/*!< Post Viterbi BER [1E-5]*/
+	u32 BERErrorCount;	/*!< Number of erronous SYNC bits.*/
+	u32 BERBitCount;	/*!< Total number of SYNC bits.*/
+	u32 TS_PER;		/*!< Transport stream PER, 0xFFFFFFFF indicate N/A*/
+	u32 MFER;		/*!< DVB-H frame error rate in percentage, 0xFFFFFFFF indicate N/A, valid only for DVB-H*/
+	s32 RSSI;		/*!< dBm*/
+	s32 InBandPwr;		/*!< In band power in dBM*/
+	s32 CarrierOffset;	/*!< Carrier Offset in bin/1024*/
+	u32 ErrorTSPackets;	/*!< Number of erroneous transport-stream packets*/
+	u32 TotalTSPackets;	/*!< Total number of transport-stream packets*/
+
+	s32 MRC_SNR;		/*!< dB*/
+	s32 MRC_RSSI;		/*!< dBm*/
+	s32 MRC_InBandPwr;	/*!< In band power in dBM*/
 };
 
-struct SmsMsgStatisticsInfo_ST {
-	u32 RequestResult;
 
-	struct SMSHOSTLIB_STATISTICS_ST Stat;
+/* Statistics information returned as response for SmsHostApiGetStatisticsEx_Req for DVB applications, SMS1100 and up*/
+struct SMSHOSTLIB_STATISTICS_DVB_S {
+	/* Reception*/
+	struct RECEPTION_STATISTICS_S ReceptionData;
 
-	/* Split the calc of the SNR in DAB */
-	u32 Signal; /* dB */
-	u32 Noise; /* dB */
+	/* Transmission parameters*/
+	struct TRANSMISSION_STATISTICS_S TransmissionData;
 
+	/* Burst parameters, valid only for DVB-H*/
+#define	SRVM_MAX_PID_FILTERS		8
+	struct PID_DATA_S PidData[SRVM_MAX_PID_FILTERS];
 };
 
+struct SRVM_SIGNAL_STATUS_S {
+	u32 result;
+	u32 snr;
+	u32 tsPackets;
+	u32 etsPackets;
+	u32 constellation;
+	u32 hpCode;
+	u32 tpsSrvIndLP;
+	u32 tpsSrvIndHP;
+	u32 cellId;
+	u32 reason;
+
+	s32 inBandPower;
+	u32 requestId;
+};
 
 struct smscore_gpio_config {
 #define SMS_GPIO_DIRECTION_INPUT  0
 #define SMS_GPIO_DIRECTION_OUTPUT 1
-	u8 direction;
+	u8 Direction;
 
 #define SMS_GPIO_PULLUPDOWN_NONE     0
 #define SMS_GPIO_PULLUPDOWN_PULLDOWN 1
 #define SMS_GPIO_PULLUPDOWN_PULLUP   2
 #define SMS_GPIO_PULLUPDOWN_KEEPER   3
-	u8 pullupdown;
+	u8 PullUpDown;
 
 #define SMS_GPIO_INPUTCHARACTERISTICS_NORMAL  0
 #define SMS_GPIO_INPUTCHARACTERISTICS_SCHMITT 1
-	u8 inputcharacteristics;
-
-#define SMS_GPIO_OUTPUTSLEWRATE_FAST 0
-#define SMS_GPIO_OUTPUTSLEWRATE_SLOW 1
-	u8 outputslewrate;
-
-#define SMS_GPIO_OUTPUTDRIVING_4mA  0
-#define SMS_GPIO_OUTPUTDRIVING_8mA  1
-#define SMS_GPIO_OUTPUTDRIVING_12mA 2
-#define SMS_GPIO_OUTPUTDRIVING_16mA 3
-	u8 outputdriving;
-};
-
-struct smsdvb_client_t {
-	struct list_head entry;
-
-	struct smscore_device_t	*coredev;
-	struct smscore_client_t	*smsclient;
-
-	struct dvb_adapter	adapter;
-	struct dvb_demux	demux;
-	struct dmxdev		dmxdev;
-	struct dvb_frontend	frontend;
-
-	fe_status_t		fe_status;
-	int			fe_ber, fe_snr, fe_unc, fe_signal_strength;
-
-	struct completion	tune_done, stat_done;
-
-	/* todo: save freq/band instead whole struct */
-	struct dvb_frontend_parameters fe_params;
-
+	u8 InputCharacteristics;
+
+#define SMS_GPIO_OUTPUTSLEWRATE_SLOW		0 /* 10xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_FAST		1 /* 10xx */
+
+#define SMS_GPIO_OUTPUTSLEWRATE_0_45_V_NS	0 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_0_9_V_NS	1 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_1_7_V_NS	2 /* 11xx */
+#define SMS_GPIO_OUTPUTSLEWRATE_3_3_V_NS	3 /* 11xx */
+	u8 OutputSlewRate;
+
+#define SMS_GPIO_OUTPUTDRIVING_S_4mA		0 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_8mA		1 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_12mA		2 /* 10xx */
+#define SMS_GPIO_OUTPUTDRIVING_S_16mA		3 /* 10xx */
+
+#define SMS_GPIO_OUTPUTDRIVING_1_5mA		0 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_2_8mA		1 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_4mA			2 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_7mA			3 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_10mA			4 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_11mA			5 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_14mA			6 /* 11xx */
+#define SMS_GPIO_OUTPUTDRIVING_16mA			7 /* 11xx */
+	u8 OutputDriving;
 };
 
 extern void smscore_registry_setmode(char *devpath, int mode);
@@ -402,44 +558,99 @@ extern void smscore_unregister_device(struct smscore_device_t *coredev);
 
 extern int smscore_start_device(struct smscore_device_t *coredev);
 extern int smscore_load_firmware(struct smscore_device_t *coredev,
-				 char *filename,
-				 loadfirmware_t loadfirmware_handler);
+		char *filename, loadfirmware_t loadfirmware_handler);
 
 extern int smscore_set_device_mode(struct smscore_device_t *coredev, int mode);
 extern int smscore_get_device_mode(struct smscore_device_t *coredev);
+/*##w21558, Added*/
+extern int smscore_reset_device_mode(struct smscore_device_t *coredev);
+
+extern int smscore_register_client(struct smscore_device_t *coredev,
+		struct smsclient_params_t *params,
+		struct smscore_client_t **client);
+extern void smscore_unregister_client(struct smscore_client_t *client);
+
+extern int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size);
+extern void smscore_onresponse(struct smscore_device_t *coredev,
+		struct smscore_buffer_t *cb);
+
+
+extern int smscore_get_common_buffer_size(struct smscore_device_t *coredev);
+extern int smscore_map_common_buffer(struct smscore_device_t *coredev,
+		struct vm_area_struct *vma);
+extern int smscore_get_fw_filename(struct smscore_device_t *coredev, int mode,
+				   char *filename);
+extern int smscore_send_fw_file(struct smscore_device_t *coredev, u8 *ufwbuf,
+				int size);
 
 extern int smscore_register_client(struct smscore_device_t *coredev,
-				    struct smsclient_params_t *params,
-				    struct smscore_client_t **client);
+				   struct smsclient_params_t *params,
+				   struct smscore_client_t **client);
 extern void smscore_unregister_client(struct smscore_client_t *client);
 
-extern int smsclient_sendrequest(struct smscore_client_t *client,
-				 void *buffer, size_t size);
+extern int smsclient_sendrequest(struct smscore_client_t *client, void *buffer,
+		size_t size);
+
+extern int smscore_register_device(struct smsdevice_params_t *params,
+		struct smscore_device_t **coredev);
+
 extern void smscore_onresponse(struct smscore_device_t *coredev,
 			       struct smscore_buffer_t *cb);
 
+extern int smscore_get_common_buffer_size(struct smscore_device_t *coredev);
+extern int smscore_map_common_buffer(struct smscore_device_t *coredev,
+				     struct vm_area_struct *vma);
 
-extern
-struct smscore_buffer_t *smscore_getbuffer(struct smscore_device_t *coredev);
+extern struct smscore_buffer_t *smscore_getbuffer(
+		struct smscore_device_t *coredev);
 extern void smscore_putbuffer(struct smscore_device_t *coredev,
 			      struct smscore_buffer_t *cb);
 
-int smscore_configure_gpio(struct smscore_device_t *coredev, u32 pin,
-			   struct smscore_gpio_config *pinconfig);
-int smscore_set_gpio(struct smscore_device_t *coredev, u32 pin, int level);
+int smscore_gpio_configure(struct smscore_device_t *coredev, u8 PinNum,
+		struct smscore_gpio_config *pGpioConfig);
+int smscore_gpio_set_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 NewLevel);
+int smscore_gpio_get_level(struct smscore_device_t *coredev, u8 PinNum,
+		u8 *level);
 
 void smscore_set_board_id(struct smscore_device_t *core, int id);
 int smscore_get_board_id(struct smscore_device_t *core);
 
-int smscore_led_state(struct smscore_device_t *core, int led);
+#ifdef SMS_HOSTLIB_SUBSYS
+extern int smschar_register(void);
+extern void smschar_unregister(void);
+#endif
+
+#ifdef SMS_NET_SUBSYS
+extern int smsnet_register(void);
+extern void smsnet_unregister(void);
+#endif
+
+#ifdef SMS_DVB3_SUBSYS
+extern int smsdvb_register(void);
+extern void smsdvb_unregister(void);
+#endif
 
-/* smsdvb.c */
-int smsdvb_register(void);
-void smsdvb_unregister(void);
+#ifdef SMS_USB_DRV
+extern int smsusb_register(void);
+extern void smsusb_unregister(void);
+#endif
+
+#ifdef SMS_SDIO_DRV
+extern int smssdio_register(void);
+extern void smssdio_unregister(void);
+#endif
 
-/* smsusb.c */
-int smsusb_register(void);
-void smsusb_unregister(void);
+/*##w21558, general SPI driver, in sholes, OMAP34XX spi driver*/
+
+#ifdef SMS_SPI_DRV
+extern int smsspi_register(void);
+extern void smsspi_unregister(void);
+#endif
+
+/*##w21558, Added*/
+extern int smsmdtv_power_control(int pwrup_enable);
 
 /* ------------------------------------------------------------------------ */
 
@@ -464,5 +675,9 @@ extern int sms_debug;
 #define sms_debug(fmt, arg...) \
 	dprintk(KERN_DEBUG, DBG_ADV, fmt, ##arg)
 
-
-#endif /* __smscoreapi_h__ */
+/*##w21558*/
+#define DISPLAY_CURR_TIME() do {\
+	struct timeval tv; \
+	do_gettimeofday(&tv); \
+	printk(KERN_INFO "%s: time = %ld\n", __func__, tv.tv_sec * 1000 + tv.tv_usec / 1000); } while (0)
+#endif /* __SMS_CORE_API_H__ */
diff --git a/drivers/media/dvb/siano/smsdbg_prn.h b/drivers/media/dvb/siano/smsdbg_prn.h
new file mode 100644
index 0000000..a91badd
--- /dev/null
+++ b/drivers/media/dvb/siano/smsdbg_prn.h
@@ -0,0 +1,57 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef _SMS_DBG_H_
+#define _SMS_DBG_H_
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+/************************************************************************/
+/* Debug Zones definitions.                                             */
+/************************************************************************/
+#undef PERROR
+#define PERROR(fmt, args...) \
+	printk(KERN_ERR "spibus error: line %d- %s(): " fmt, __LINE__,\
+	  __func__, ## args)
+#undef PWARNING
+#define PWARNING(fmt, args...) \
+	printk(KERN_WARNING "spibus warning: line %d- %s(): " fmt, __LINE__,  \
+	__func__, ## args)
+
+/* the debug macro - conditional compilation from the makefile */
+/*#undef PDEBUG*/			/* undef it, just in case */
+/*#define SPIBUS_DEBUG*/
+#ifdef SPIBUS_DEBUG
+#define PDEBUG(fmt, args...) \
+	printk(KERN_DEBUG "spibus: line %d- %s(): " fmt, __LINE__, \
+	 __func__, ## args)
+#else
+#  define PDEBUG(fmt, args...)	/* not debugging: nothing */
+#endif
+
+/* The following defines are used for printing and
+are mandatory for compilation. */
+#define TXT(str) str
+#define PRN_DBG(str) PDEBUG str
+#define PRN_ERR(str) PERROR str
+
+#endif /*_SMS_DBG_H_*/
diff --git a/drivers/media/dvb/siano/smsdvb.c b/drivers/media/dvb/siano/smsdvb.c
index 2da953a..027d383 100644
--- a/drivers/media/dvb/siano/smsdvb.c
+++ b/drivers/media/dvb/siano/smsdvb.c
@@ -1,88 +1,239 @@
-/*
- *  Driver for the Siano SMS1xxx USB dongle
- *
- *  author: Anatoly Greenblat
- *
- *  Copyright (c), 2005-2008 Siano Mobile Silicon, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation;
- *
- *  Software distributed under the License is distributed on an "AS IS"
- *  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
- *
- *  See the GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <asm/byteorder.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
 
 #include "smscoreapi.h"
+#include "smsendian.h"
 #include "sms-cards.h"
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
+struct smsdvb_client_t {
+	struct list_head entry;
+
+	struct smscore_device_t *coredev;
+	struct smscore_client_t *smsclient;
+
+	struct dvb_adapter adapter;
+	struct dvb_demux demux;
+	struct dmxdev dmxdev;
+	struct dvb_frontend frontend;
+
+	fe_status_t fe_status;
+
+	struct completion tune_done;
+
+	/* todo: save freq/band instead whole struct */
+	struct dvb_frontend_parameters fe_params;
+
+	struct SMSHOSTLIB_STATISTICS_DVB_S sms_stat_dvb;
+	int event_fe_state;
+	int event_unc_state;
+};
+
 static struct list_head g_smsdvb_clients;
 static struct mutex g_smsdvb_clientslock;
 
+
+/* Events that may come from DVB v3 adapter */
+static void sms_board_dvb3_event(struct smsdvb_client_t *client,
+		enum SMS_DVB3_EVENTS event) {
+
+	struct smscore_device_t *coredev = client->coredev;
+	switch (event) {
+	case DVB3_EVENT_INIT:
+		sms_debug("DVB3_EVENT_INIT");
+		sms_board_event(coredev, BOARD_EVENT_BIND);
+		break;
+	case DVB3_EVENT_SLEEP:
+		sms_debug("DVB3_EVENT_SLEEP");
+		sms_board_event(coredev, BOARD_EVENT_POWER_SUSPEND);
+		break;
+	case DVB3_EVENT_HOTPLUG:
+		sms_debug("DVB3_EVENT_HOTPLUG");
+		sms_board_event(coredev, BOARD_EVENT_POWER_INIT);
+		break;
+	case DVB3_EVENT_FE_LOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_LOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_LOCK;
+			sms_debug("DVB3_EVENT_FE_LOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_LOCK);
+		}
+		break;
+	case DVB3_EVENT_FE_UNLOCK:
+		if (client->event_fe_state != DVB3_EVENT_FE_UNLOCK) {
+			client->event_fe_state = DVB3_EVENT_FE_UNLOCK;
+			sms_debug("DVB3_EVENT_FE_UNLOCK");
+			sms_board_event(coredev, BOARD_EVENT_FE_UNLOCK);
+		}
+		break;
+	case DVB3_EVENT_UNC_OK:
+		if (client->event_unc_state != DVB3_EVENT_UNC_OK) {
+			client->event_unc_state = DVB3_EVENT_UNC_OK;
+			sms_debug("DVB3_EVENT_UNC_OK");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_OK);
+		}
+		break;
+	case DVB3_EVENT_UNC_ERR:
+		if (client->event_unc_state != DVB3_EVENT_UNC_ERR) {
+			client->event_unc_state = DVB3_EVENT_UNC_ERR;
+			sms_debug("DVB3_EVENT_UNC_ERR");
+			sms_board_event(coredev, BOARD_EVENT_MULTIPLEX_ERRORS);
+		}
+		break;
+
+	default:
+		sms_err("Unknown dvb3 api event");
+		break;
+	}
+}
+
 static int smsdvb_onresponse(void *context, struct smscore_buffer_t *cb)
 {
 	struct smsdvb_client_t *client = (struct smsdvb_client_t *) context;
-	struct SmsMsgHdr_ST *phdr =
-		(struct SmsMsgHdr_ST *)(((u8 *) cb->p) + cb->offset);
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *) (((u8 *) cb->p)
+			+ cb->offset);
+	u32 *pMsgData = (u32 *) phdr + 1;
+	/*u32 MsgDataLen = phdr->msgLength - sizeof(struct SmsMsgHdr_ST);*/
+	bool is_status_update = false;
+
+	smsendian_handle_rx_message((struct SmsMsgData_ST *) phdr);
 
 	switch (phdr->msgType) {
 	case MSG_SMS_DVBT_BDA_DATA:
-		dvb_dmx_swfilter(&client->demux, (u8 *)(phdr + 1),
-				 cb->size - sizeof(struct SmsMsgHdr_ST));
+		dvb_dmx_swfilter(&client->demux, (u8 *) (phdr + 1), cb->size
+				- sizeof(struct SmsMsgHdr_ST));
 		break;
 
 	case MSG_SMS_RF_TUNE_RES:
 		complete(&client->tune_done);
 		break;
 
-	case MSG_SMS_GET_STATISTICS_RES:
-	{
-		struct SmsMsgStatisticsInfo_ST *p =
-			(struct SmsMsgStatisticsInfo_ST *)(phdr + 1);
-
-		if (p->Stat.IsDemodLocked) {
-			client->fe_status = FE_HAS_SIGNAL |
-					    FE_HAS_CARRIER |
-					    FE_HAS_VITERBI |
-					    FE_HAS_SYNC |
-					    FE_HAS_LOCK;
-
-			client->fe_snr = p->Stat.SNR;
-			client->fe_ber = p->Stat.BER;
-			client->fe_unc = p->Stat.BERErrorCount;
-
-			if (p->Stat.InBandPwr < -95)
-				client->fe_signal_strength = 0;
-			else if (p->Stat.InBandPwr > -29)
-				client->fe_signal_strength = 100;
-			else
-				client->fe_signal_strength =
-					(p->Stat.InBandPwr + 95) * 3 / 2;
+	case MSG_SMS_SIGNAL_DETECTED_IND:
+		sms_info("MSG_SMS_SIGNAL_DETECTED_IND");
+		client->sms_stat_dvb.TransmissionData.IsDemodLocked = true;
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_NO_SIGNAL_IND:
+		sms_info("MSG_SMS_NO_SIGNAL_IND");
+		client->sms_stat_dvb.TransmissionData.IsDemodLocked = false;
+		is_status_update = true;
+		break;
+
+	case MSG_SMS_TRANSMISSION_IND: {
+		sms_info("MSG_SMS_TRANSMISSION_IND");
+
+		pMsgData++;
+		memcpy(&client->sms_stat_dvb.TransmissionData, pMsgData,
+				sizeof(struct TRANSMISSION_STATISTICS_S));
+
+		/* Mo need to correct guard interval
+		 * (as opposed to old statistics message).
+		 */
+		CORRECT_STAT_BANDWIDTH(client->sms_stat_dvb.TransmissionData);
+		CORRECT_STAT_TRANSMISSON_MODE(
+				client->sms_stat_dvb.TransmissionData);
+		is_status_update = true;
+		break;
+	}
+	case MSG_SMS_HO_PER_SLICES_IND: {
+		struct RECEPTION_STATISTICS_S *pReceptionData =
+				&client->sms_stat_dvb.ReceptionData;
+		struct SRVM_SIGNAL_STATUS_S SignalStatusData;
+
+		/*sms_info("MSG_SMS_HO_PER_SLICES_IND");*/
+		pMsgData++;
+		SignalStatusData.result = pMsgData[0];
+		SignalStatusData.snr = pMsgData[1];
+		SignalStatusData.inBandPower = (s32) pMsgData[2];
+		SignalStatusData.tsPackets = pMsgData[3];
+		SignalStatusData.etsPackets = pMsgData[4];
+		SignalStatusData.constellation = pMsgData[5];
+		SignalStatusData.hpCode = pMsgData[6];
+		SignalStatusData.tpsSrvIndLP = pMsgData[7] & 0x03;
+		SignalStatusData.tpsSrvIndHP = pMsgData[8] & 0x03;
+		SignalStatusData.cellId = pMsgData[9] & 0xFFFF;
+		SignalStatusData.reason = pMsgData[10];
+		SignalStatusData.requestId = pMsgData[11];
+		pReceptionData->IsRfLocked = pMsgData[16];
+		pReceptionData->IsDemodLocked = pMsgData[17];
+		pReceptionData->ModemState = pMsgData[12];
+		pReceptionData->SNR = pMsgData[1];
+		pReceptionData->BER = pMsgData[13];
+		pReceptionData->RSSI = pMsgData[14];
+		CORRECT_STAT_RSSI(client->sms_stat_dvb.ReceptionData);
+
+		pReceptionData->InBandPwr = (s32) pMsgData[2];
+		pReceptionData->CarrierOffset = (s32) pMsgData[15];
+		pReceptionData->TotalTSPackets = pMsgData[3];
+		pReceptionData->ErrorTSPackets = pMsgData[4];
+
+		/* TS PER */
+		if ((SignalStatusData.tsPackets + SignalStatusData.etsPackets)
+				> 0) {
+			pReceptionData->TS_PER = (SignalStatusData.etsPackets
+					* 100) / (SignalStatusData.tsPackets
+					+ SignalStatusData.etsPackets);
 		} else {
-			client->fe_status = 0;
-			client->fe_snr =
-			client->fe_ber =
-			client->fe_unc =
-			client->fe_signal_strength = 0;
+			pReceptionData->TS_PER = 0;
 		}
 
-		complete(&client->stat_done);
-		break;
-	} }
+		pReceptionData->BERBitCount = pMsgData[18];
+		pReceptionData->BERErrorCount = pMsgData[19];
+
+		pReceptionData->MRC_SNR = pMsgData[20];
+		pReceptionData->MRC_InBandPwr = pMsgData[21];
+		pReceptionData->MRC_RSSI = pMsgData[22];
 
+		is_status_update = true;
+		break;
+	}
+	}
 	smscore_putbuffer(client->coredev, cb);
 
+	if (is_status_update) {
+	if (client->sms_stat_dvb.ReceptionData.IsDemodLocked) {
+		client->fe_status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+			| FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		sms_board_dvb3_event(client, DVB3_EVENT_FE_LOCK);
+		if (client->sms_stat_dvb.ReceptionData.ErrorTSPackets == 0)
+			sms_board_dvb3_event(client, DVB3_EVENT_UNC_OK);
+		else
+			sms_board_dvb3_event(client, DVB3_EVENT_UNC_ERR);
+
+		} else {
+			client->fe_status = 0;
+			sms_board_dvb3_event(client, DVB3_EVENT_FE_UNLOCK);
+		}
+	}
+
 	return 0;
 }
 
@@ -115,8 +266,7 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct SmsMsgData_ST PidMsg;
 
-	sms_debug("add pid %d(%x)",
-		  feed->pid, feed->pid);
+	sms_debug("add pid %d(%x)", feed->pid, feed->pid);
 
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
@@ -125,8 +275,9 @@ static int smsdvb_start_feed(struct dvb_demux_feed *feed)
 	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
-	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)&PidMsg);
+	return smsclient_sendrequest(client->smsclient, &PidMsg,
+			sizeof(PidMsg));
 }
 
 static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
@@ -135,8 +286,7 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 		container_of(feed->demux, struct smsdvb_client_t, demux);
 	struct SmsMsgData_ST PidMsg;
 
-	sms_debug("remove pid %d(%x)",
-		  feed->pid, feed->pid);
+	sms_debug("remove pid %d(%x)", feed->pid, feed->pid);
 
 	PidMsg.xMsgHeader.msgSrcId = DVBT_BDA_CONTROL_MSG_ID;
 	PidMsg.xMsgHeader.msgDstId = HIF_TASK;
@@ -145,100 +295,81 @@ static int smsdvb_stop_feed(struct dvb_demux_feed *feed)
 	PidMsg.xMsgHeader.msgLength = sizeof(PidMsg);
 	PidMsg.msgData[0] = feed->pid;
 
-	return smsclient_sendrequest(client->smsclient,
-				     &PidMsg, sizeof(PidMsg));
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)&PidMsg);
+	return smsclient_sendrequest(client->smsclient, &PidMsg,
+			sizeof(PidMsg));
 }
 
 static int smsdvb_sendrequest_and_wait(struct smsdvb_client_t *client,
 					void *buffer, size_t size,
 					struct completion *completion)
 {
-	int rc = smsclient_sendrequest(client->smsclient, buffer, size);
+	int rc;
+
+	smsendian_handle_tx_message((struct SmsMsgHdr_ST *)buffer);
+	rc = smsclient_sendrequest(client->smsclient, buffer, size);
 	if (rc < 0)
 		return rc;
 
-	return wait_for_completion_timeout(completion,
-					   msecs_to_jiffies(2000)) ?
-						0 : -ETIME;
-}
-
-static int smsdvb_send_statistics_request(struct smsdvb_client_t *client)
-{
-	struct SmsMsgHdr_ST Msg = { MSG_SMS_GET_STATISTICS_REQ,
-			     DVBT_BDA_CONTROL_MSG_ID,
-			     HIF_TASK, sizeof(struct SmsMsgHdr_ST), 0 };
-	int ret = smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
-					      &client->stat_done);
-	if (ret < 0)
-		return ret;
-
-	if (client->fe_status & FE_HAS_LOCK)
-		sms_board_led_feedback(client->coredev,
-				       (client->fe_unc == 0) ?
-				       SMS_LED_HI : SMS_LED_LO);
-	else
-		sms_board_led_feedback(client->coredev, SMS_LED_OFF);
-	return ret;
+	return wait_for_completion_timeout(completion, msecs_to_jiffies(2000))
+			? 0 : -ETIME;
 }
 
 static int smsdvb_read_status(struct dvb_frontend *fe, fe_status_t *stat)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
 		*stat = client->fe_status;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_ber(struct dvb_frontend *fe, u32 *ber)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*ber = client->fe_ber;
+	*ber = client->sms_stat_dvb.ReceptionData.BER;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*strength = client->fe_signal_strength;
+	if (client->sms_stat_dvb.ReceptionData.InBandPwr < -95)
+		*strength = 0;
+		else if (client->sms_stat_dvb.ReceptionData.InBandPwr > -29)
+			*strength = 100;
+		else
+			*strength =
+				(client->sms_stat_dvb.ReceptionData.InBandPwr
+				+ 95) * 3 / 2;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_snr(struct dvb_frontend *fe, u16 *snr)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*snr = client->fe_snr;
+	*snr = client->sms_stat_dvb.ReceptionData.SNR;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
 {
-	struct smsdvb_client_t *client =
-		container_of(fe, struct smsdvb_client_t, frontend);
-	int rc = smsdvb_send_statistics_request(client);
+	struct smsdvb_client_t *client;
+	client = container_of(fe, struct smsdvb_client_t, frontend);
 
-	if (!rc)
-		*ucblocks = client->fe_unc;
+	*ucblocks = client->sms_stat_dvb.ReceptionData.ErrorTSPackets;
 
-	return rc;
+	return 0;
 }
 
 static int smsdvb_get_tune_settings(struct dvb_frontend *fe,
@@ -263,6 +394,10 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe,
 		u32		Data[3];
 	} Msg;
 
+	client->fe_status = FE_HAS_SIGNAL;
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+
 	Msg.Msg.msgSrcId  = DVBT_BDA_CONTROL_MSG_ID;
 	Msg.Msg.msgDstId  = HIF_TASK;
 	Msg.Msg.msgFlags  = 0;
@@ -275,11 +410,19 @@ static int smsdvb_set_frontend(struct dvb_frontend *fe,
 		  fep->frequency, fep->u.ofdm.bandwidth);
 
 	switch (fep->u.ofdm.bandwidth) {
-	case BANDWIDTH_8_MHZ: Msg.Data[1] = BW_8_MHZ; break;
-	case BANDWIDTH_7_MHZ: Msg.Data[1] = BW_7_MHZ; break;
-	case BANDWIDTH_6_MHZ: Msg.Data[1] = BW_6_MHZ; break;
-	case BANDWIDTH_AUTO: return -EOPNOTSUPP;
-	default: return -EINVAL;
+	case BANDWIDTH_8_MHZ:
+		Msg.Data[1] = BW_8_MHZ;
+		break;
+	case BANDWIDTH_7_MHZ:
+		Msg.Data[1] = BW_7_MHZ;
+		break;
+	case BANDWIDTH_6_MHZ:
+		Msg.Data[1] = BW_6_MHZ;
+		break;
+	case BANDWIDTH_AUTO:
+		return -EOPNOTSUPP;
+	default:
+		return -EINVAL;
 	}
 
 	return smsdvb_sendrequest_and_wait(client, &Msg, sizeof(Msg),
@@ -306,8 +449,7 @@ static int smsdvb_init(struct dvb_frontend *fe)
 	struct smsdvb_client_t *client =
 		container_of(fe, struct smsdvb_client_t, frontend);
 
-	sms_board_power(client->coredev, 1);
-
+	sms_board_dvb3_event(client, DVB3_EVENT_INIT);
 	return 0;
 }
 
@@ -316,8 +458,7 @@ static int smsdvb_sleep(struct dvb_frontend *fe)
 	struct smsdvb_client_t *client =
 		container_of(fe, struct smsdvb_client_t, frontend);
 
-	sms_board_led_feedback(client->coredev, SMS_LED_OFF);
-	sms_board_power(client->coredev, 0);
+	sms_board_dvb3_event(client, DVB3_EVENT_SLEEP);
 
 	return 0;
 }
@@ -329,7 +470,7 @@ static void smsdvb_release(struct dvb_frontend *fe)
 
 static struct dvb_frontend_ops smsdvb_fe_ops = {
 	.info = {
-		.name			= "Siano Mobile Digital SMS1xxx",
+		 .name = "Siano Mobile Digital MDTV Receiver",
 		.type			= FE_OFDM,
 		.frequency_min		= 44250000,
 		.frequency_max		= 867250000,
@@ -340,8 +481,7 @@ static struct dvb_frontend_ops smsdvb_fe_ops = {
 			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 |
 			FE_CAN_QAM_AUTO | FE_CAN_TRANSMISSION_MODE_AUTO |
 			FE_CAN_GUARD_INTERVAL_AUTO |
-			FE_CAN_RECOVER |
-			FE_CAN_HIERARCHY_AUTO,
+		 FE_CAN_RECOVER | FE_CAN_HIERARCHY_AUTO,
 	},
 
 	.release = smsdvb_release,
@@ -371,7 +511,7 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	if (!arrival)
 		return 0;
 
-	if (smscore_get_device_mode(coredev) != 4) {
+	if (smscore_get_device_mode(coredev) != DEVICE_MODE_DVBT_BDA) {
 		sms_err("SMS Device mode is not set for "
 			"DVB operation.");
 		return 0;
@@ -384,10 +524,15 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	}
 
 	/* register dvb adapter */
+#ifdef SMS_DVB_OLD_DVB_REGISTER_ADAPTER
 	rc = dvb_register_adapter(&client->adapter,
-				  sms_get_board(
-					smscore_get_board_id(coredev))->name,
-				  THIS_MODULE, device, adapter_nr);
+				  sms_get_board(smscore_get_board_id(coredev))->
+				  name, THIS_MODULE, device);
+#else
+	rc = dvb_register_adapter(&client->adapter,
+				  sms_get_board(smscore_get_board_id(coredev))->
+				  name, THIS_MODULE, device, adapter_nr);
+#endif
 	if (rc < 0) {
 		sms_err("dvb_register_adapter() failed %d", rc);
 		goto adapter_error;
@@ -442,7 +587,6 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 	client->coredev = coredev;
 
 	init_completion(&client->tune_done);
-	init_completion(&client->stat_done);
 
 	kmutex_lock(&g_smsdvb_clientslock);
 
@@ -450,10 +594,11 @@ static int smsdvb_hotplug(struct smscore_device_t *coredev,
 
 	kmutex_unlock(&g_smsdvb_clientslock);
 
-	sms_info("success");
-
-	sms_board_setup(coredev);
+	client->event_fe_state = -1;
+	client->event_unc_state = -1;
+	sms_board_dvb3_event(client, DVB3_EVENT_HOTPLUG);
 
+	sms_info("success");
 	return 0;
 
 client_error:
@@ -494,8 +639,12 @@ void smsdvb_unregister(void)
 	kmutex_lock(&g_smsdvb_clientslock);
 
 	while (!list_empty(&g_smsdvb_clients))
-	       smsdvb_unregister_client(
-			(struct smsdvb_client_t *) g_smsdvb_clients.next);
+		smsdvb_unregister_client((struct smsdvb_client_t *)
+					 g_smsdvb_clients.next);
 
 	kmutex_unlock(&g_smsdvb_clientslock);
 }
+
+MODULE_DESCRIPTION("SMS DVB subsystem adaptation module");
+MODULE_AUTHOR("Siano Mobile Silicon, Inc. (uris@siano-ms.com)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/dvb/siano/smsendian.c b/drivers/media/dvb/siano/smsendian.c
new file mode 100644
index 0000000..d79aa05
--- /dev/null
+++ b/drivers/media/dvb/siano/smsendian.c
@@ -0,0 +1,100 @@
+/****************************************************************
+
+ Siano Mobile Silicon, Inc.
+ MDTV receiver kernel modules.
+ Copyright (C) 2006-2009, Uri Shkolnik
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ ****************************************************************/
+
+#include <asm/byteorder.h>
+
+#include "smsendian.h"
+#include "smscoreapi.h"
+
+void smsendian_handle_tx_message(void *buffer)
+{
+#ifdef __BIG_ENDIAN
+	struct SmsMsgData_ST *msg = (struct SmsMsgData_ST *)buffer;
+	int i;
+	int msgWords;
+
+	switch (msg->xMsgHeader.msgType) {
+	case MSG_SMS_DATA_DOWNLOAD_REQ:
+	{
+		msg->msgData[0] = le32_to_cpu(msg->msgData[0]);
+		break;
+	}
+
+	default:
+		msgWords = (msg->xMsgHeader.msgLength -
+				sizeof(struct SmsMsgHdr_ST))/4;
+
+		for (i = 0; i < msgWords; i++)
+			msg->msgData[i] = le32_to_cpu(msg->msgData[i]);
+
+		break;
+	}
+#endif /* __BIG_ENDIAN */
+}
+
+void smsendian_handle_rx_message(void *buffer)
+{
+#ifdef __BIG_ENDIAN
+	struct SmsMsgData_ST *msg = (struct SmsMsgData_ST *)buffer;
+	int i;
+	int msgWords;
+
+	switch (msg->xMsgHeader.msgType) {
+	case MSG_SMS_GET_VERSION_EX_RES:
+	{
+		struct SmsVersionRes_ST *ver =
+			(struct SmsVersionRes_ST *) msg;
+		ver->ChipModel = le16_to_cpu(ver->ChipModel);
+		break;
+	}
+
+	case MSG_SMS_DVBT_BDA_DATA:
+	case MSG_SMS_DAB_CHANNEL:
+	case MSG_SMS_DATA_MSG:
+	{
+		break;
+	}
+
+	default:
+	{
+		msgWords = (msg->xMsgHeader.msgLength -
+				sizeof(struct SmsMsgHdr_ST))/4;
+
+		for (i = 0; i < msgWords; i++)
+			msg->msgData[i] = le32_to_cpu(msg->msgData[i]);
+
+		break;
+	}
+	}
+#endif /* __BIG_ENDIAN */
+}
+
+void smsendian_handle_message_header(void *msg)
+{
+#ifdef __BIG_ENDIAN
+	struct SmsMsgHdr_ST *phdr = (struct SmsMsgHdr_ST *)msg;
+
+	phdr->msgType = le16_to_cpu(phdr->msgType);
+	phdr->msgLength = le16_to_cpu(phdr->msgLength);
+	phdr->msgFlags = le16_to_cpu(phdr->msgFlags);
+#endif /* __BIG_ENDIAN */
+}
+
diff --git a/drivers/media/dvb/siano/smsendian.h b/drivers/media/dvb/siano/smsendian.h
new file mode 100644
index 0000000..7fbedc6
--- /dev/null
+++ b/drivers/media/dvb/siano/smsendian.h
@@ -0,0 +1,32 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2009, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_ENDIAN_H__
+#define __SMS_ENDIAN_H__
+
+#include <asm/byteorder.h>
+
+void smsendian_handle_tx_message(void *buffer);
+void smsendian_handle_rx_message(void *buffer);
+void smsendian_handle_message_header(void *msg);
+
+#endif /* __SMS_ENDIAN_H__ */
+
diff --git a/drivers/media/dvb/siano/smsir.c b/drivers/media/dvb/siano/smsir.c
new file mode 100644
index 0000000..a5f302c
--- /dev/null
+++ b/drivers/media/dvb/siano/smsir.c
@@ -0,0 +1,301 @@
+/****************************************************************
+
+ Siano Mobile Silicon, Inc.
+ MDTV receiver kernel modules.
+ Copyright (C) 2006-2009, Uri Shkolnik
+
+ This program is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ ****************************************************************/
+
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "smscoreapi.h"
+#include "smsir.h"
+#include "sms-cards.h"
+
+/* In order to add new IR remote control -
+ * 1) Add it to the <enum ir_kb_type> @ smsir,h,
+ * 2) Add its map to keyboard_layout_maps below
+ * 3) Set your board (sms-cards sub-module) to use it
+ */
+
+static struct keyboard_layout_map_t keyboard_layout_maps[] = {
+		[SMS_IR_KB_DEFAULT_TV] = {
+			.ir_protocol = IR_RC5,
+			.rc5_kbd_address = KEYBOARD_ADDRESS_TV1,
+			.keyboard_layout_map = {
+					KEY_0, KEY_1, KEY_2,
+					KEY_3, KEY_4, KEY_5,
+					KEY_6, KEY_7, KEY_8,
+					KEY_9, 0, 0, KEY_POWER,
+					KEY_MUTE, 0, 0,
+					KEY_VOLUMEUP, KEY_VOLUMEDOWN,
+					KEY_BRIGHTNESSUP,
+					KEY_BRIGHTNESSDOWN, KEY_CHANNELUP,
+					KEY_CHANNELDOWN,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0,
+					0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+			}
+		},
+		[SMS_IR_KB_HCW_SILVER] = {
+			.ir_protocol = IR_RC5,
+			.rc5_kbd_address = KEYBOARD_ADDRESS_LIGHTING1,
+			.keyboard_layout_map = {
+					KEY_0, KEY_1, KEY_2,
+					KEY_3, KEY_4, KEY_5,
+					KEY_6, KEY_7, KEY_8,
+					KEY_9, KEY_TEXT, KEY_RED,
+					KEY_RADIO, KEY_MENU,
+					KEY_SUBTITLE,
+					KEY_MUTE, KEY_VOLUMEUP,
+					KEY_VOLUMEDOWN, KEY_PREVIOUS, 0,
+					KEY_UP, KEY_DOWN, KEY_LEFT,
+					KEY_RIGHT, KEY_VIDEO, KEY_AUDIO,
+					KEY_MHP, KEY_EPG, KEY_TV,
+					0, KEY_NEXTSONG, KEY_EXIT,
+					KEY_CHANNELUP, 	KEY_CHANNELDOWN,
+					KEY_CHANNEL, 0,
+					KEY_PREVIOUSSONG, KEY_ENTER,
+					KEY_SLEEP, 0, 0, KEY_BLUE,
+					0, 0, 0, 0, KEY_GREEN, 0,
+					KEY_PAUSE, 0, KEY_REWIND,
+					0, KEY_FASTFORWARD, KEY_PLAY,
+					KEY_STOP, KEY_RECORD,
+					KEY_YELLOW, 0, 0, KEY_SELECT,
+					KEY_ZOOM, KEY_POWER, 0, 0
+			}
+		},
+		{ } /* Terminating entry */
+};
+
+u32 ir_pos;
+u32	ir_word;
+u32 ir_toggle;
+
+#define RC5_PUSH_BIT(dst, bit, pos)	\
+	{ dst <<= 1; dst |= bit; pos++; }
+
+
+static void sms_ir_rc5_event(struct smscore_device_t *coredev,
+				u32 toggle, u32 addr, u32 cmd)
+{
+	bool toggle_changed;
+	u16 keycode;
+
+	sms_info("IR RC5 word: address %d, command %d, toggle %d",
+				addr, cmd, toggle);
+
+	toggle_changed = ir_toggle != toggle;
+	/* keep toggle */
+	ir_toggle = toggle;
+
+	if (addr !=
+		keyboard_layout_maps[coredev->ir.ir_kb_type].rc5_kbd_address)
+		return; /* Check for valid address */
+
+	keycode =
+		keyboard_layout_maps
+		[coredev->ir.ir_kb_type].keyboard_layout_map[cmd];
+
+	if (!toggle_changed &&
+			(keycode != KEY_VOLUMEUP && keycode != KEY_VOLUMEDOWN))
+		return; /* accept only repeated volume, reject other keys */
+
+	sms_info("kernel input keycode (from ir) %d", keycode);
+	input_report_key(coredev->ir.input_dev, keycode, 1);
+	input_sync(coredev->ir.input_dev);
+
+}
+
+/* decode raw bit pattern to RC5 code */
+/* taken from ir-functions.c */
+static u32 ir_rc5_decode(unsigned int code)
+{
+/*	unsigned int org_code = code;*/
+	unsigned int pair;
+	unsigned int rc5 = 0;
+	int i;
+
+	for (i = 0; i < 14; ++i) {
+		pair = code & 0x3;
+		code >>= 2;
+
+		rc5 <<= 1;
+		switch (pair) {
+		case 0:
+		case 2:
+			break;
+		case 1:
+			rc5 |= 1;
+			break;
+		case 3:
+/*	dprintk(1, "ir-common: ir_rc5_decode(%x) bad code\n", org_code);*/
+			sms_info("bad code");
+			return 0;
+		}
+	}
+/*
+	dprintk(1, "ir-common: code=%x, rc5=%x, start=%x,
+		toggle=%x, address=%x, "
+		"instr=%x\n", rc5, org_code, RC5_START(rc5),
+		RC5_TOGGLE(rc5), RC5_ADDR(rc5), RC5_INSTR(rc5));
+*/
+	return rc5;
+}
+
+static void sms_rc5_parse_word(struct smscore_device_t *coredev)
+{
+	#define RC5_START(x)    (((x)>>12)&3)
+	#define RC5_TOGGLE(x)   (((x)>>11)&1)
+	#define RC5_ADDR(x)     (((x)>>6)&0x1F)
+	#define RC5_INSTR(x)    ((x)&0x3F)
+
+	int i, j;
+	u32 rc5_word = 0;
+
+	/* Reverse the IR word direction */
+	for (i = 0 ; i < 28 ; i++)
+		RC5_PUSH_BIT(rc5_word, (ir_word>>i)&1, j)
+
+	rc5_word = ir_rc5_decode(rc5_word);
+	/* sms_info("temp = 0x%x, rc5_code = 0x%x", ir_word, rc5_word); */
+
+	sms_ir_rc5_event(coredev,
+				RC5_TOGGLE(rc5_word),
+				RC5_ADDR(rc5_word),
+				RC5_INSTR(rc5_word));
+}
+
+
+static void sms_rc5_accumulate_bits(struct smscore_device_t *coredev,
+		s32 ir_sample)
+{
+	#define RC5_TIME_GRANULARITY	200
+	#define RC5_DEF_BIT_TIME		889
+	#define RC5_MAX_SAME_BIT_CONT	4
+	#define RC5_WORD_LEN			27 /* 28 bit */
+
+	u32 i, j;
+	s32 delta_time;
+	u32 time = (ir_sample > 0) ? ir_sample : (0-ir_sample);
+	u32 level = (ir_sample < 0) ? 0 : 1;
+
+	for (i = RC5_MAX_SAME_BIT_CONT; i > 0; i--) {
+		delta_time = time - (i*RC5_DEF_BIT_TIME) + RC5_TIME_GRANULARITY;
+		if (delta_time < 0)
+			continue; /* not so many consecutive bits */
+		if (delta_time > (2 * RC5_TIME_GRANULARITY)) {
+			/* timeout */
+			if (ir_pos == (RC5_WORD_LEN-1))
+				/* complete last bit */
+				RC5_PUSH_BIT(ir_word, level, ir_pos)
+
+			if (ir_pos == RC5_WORD_LEN)
+				sms_rc5_parse_word(coredev);
+			else if (ir_pos) /* timeout within a word */
+				sms_info("IR error parsing a word");
+
+			ir_pos = 0;
+			ir_word = 0;
+			/* sms_info("timeout %d", time); */
+			break;
+		}
+		/* The time is within the range of this number of bits */
+		for (j = 0 ; j < i ; j++)
+			RC5_PUSH_BIT(ir_word, level, ir_pos)
+
+		break;
+	}
+}
+
+void sms_ir_event(struct smscore_device_t *coredev, const char *buf, int len)
+{
+	#define IR_DATA_RECEIVE_MAX_LEN	520 /* 128*4 + 4 + 4 */
+	u32 i;
+	enum ir_protocol ir_protocol =
+			keyboard_layout_maps[coredev->ir.ir_kb_type]
+					     .ir_protocol;
+	s32 *samples;
+	int count = len>>2;
+
+	samples = (s32 *)buf;
+/*	sms_info("IR buffer received, length = %d", count);*/
+
+	for (i = 0; i < count; i++)
+		if (ir_protocol == IR_RC5)
+			sms_rc5_accumulate_bits(coredev, samples[i]);
+	/*  IR_RCMM not implemented */
+}
+
+int sms_ir_init(struct smscore_device_t *coredev)
+{
+	struct input_dev *input_dev;
+
+	sms_info("Allocating input device");
+	input_dev = input_allocate_device();
+	if (!input_dev)	{
+		sms_err("Not enough memory");
+		return -ENOMEM;
+	}
+
+	coredev->ir.input_dev = input_dev;
+	coredev->ir.ir_kb_type =
+		sms_get_board(smscore_get_board_id(coredev))->ir_kb_type;
+	coredev->ir.keyboard_layout_map =
+		keyboard_layout_maps[coredev->ir.ir_kb_type].
+				keyboard_layout_map;
+	sms_info("IR remote keyboard type is %d", coredev->ir.ir_kb_type);
+
+	coredev->ir.controller = 0;	/* Todo: vega/nova SPI number */
+	coredev->ir.timeout = IR_DEFAULT_TIMEOUT;
+	sms_info("IR port %d, timeout %d ms",
+			coredev->ir.controller, coredev->ir.timeout);
+
+	snprintf(coredev->ir.name,
+				IR_DEV_NAME_MAX_LEN,
+				"SMS IR w/kbd type %d",
+				coredev->ir.ir_kb_type);
+	input_dev->name = coredev->ir.name;
+	input_dev->phys = coredev->ir.name;
+	input_dev->dev.parent = coredev->device;
+
+	/* Key press events only */
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	input_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
+
+	sms_info("Input device (IR) %s is set for key events", input_dev->name);
+
+	if (input_register_device(input_dev)) {
+		sms_err("Failed to register device");
+		input_free_device(input_dev);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+void sms_ir_exit(struct smscore_device_t *coredev)
+{
+	if (coredev->ir.input_dev)
+		input_unregister_device(coredev->ir.input_dev);
+
+	sms_info("");
+}
+
diff --git a/drivers/media/dvb/siano/smsir.h b/drivers/media/dvb/siano/smsir.h
new file mode 100644
index 0000000..b7d703e
--- /dev/null
+++ b/drivers/media/dvb/siano/smsir.h
@@ -0,0 +1,93 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2009, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_IR_H__
+#define __SMS_IR_H__
+
+#include <linux/input.h>
+
+#define IR_DEV_NAME_MAX_LEN		23 /* "SMS IR kbd type nn\0" */
+#define IR_KEYBOARD_LAYOUT_SIZE	64
+#define IR_DEFAULT_TIMEOUT		100
+
+enum ir_kb_type {
+	SMS_IR_KB_DEFAULT_TV,
+	SMS_IR_KB_HCW_SILVER
+};
+
+enum rc5_keyboard_address {
+	KEYBOARD_ADDRESS_TV1 = 0,
+	KEYBOARD_ADDRESS_TV2 = 1,
+	KEYBOARD_ADDRESS_TELETEXT = 2,
+	KEYBOARD_ADDRESS_VIDEO = 3,
+	KEYBOARD_ADDRESS_LV1 = 4,
+	KEYBOARD_ADDRESS_VCR1 = 5,
+	KEYBOARD_ADDRESS_VCR2 = 6,
+	KEYBOARD_ADDRESS_EXPERIMENTAL = 7,
+	KEYBOARD_ADDRESS_SAT1 = 8,
+	KEYBOARD_ADDRESS_CAMERA = 9,
+	KEYBOARD_ADDRESS_SAT2 = 10,
+	KEYBOARD_ADDRESS_CDV = 12,
+	KEYBOARD_ADDRESS_CAMCORDER = 13,
+	KEYBOARD_ADDRESS_PRE_AMP = 16,
+	KEYBOARD_ADDRESS_TUNER = 17,
+	KEYBOARD_ADDRESS_RECORDER1 = 18,
+	KEYBOARD_ADDRESS_PRE_AMP1 = 19,
+	KEYBOARD_ADDRESS_CD_PLAYER = 20,
+	KEYBOARD_ADDRESS_PHONO = 21,
+	KEYBOARD_ADDRESS_SATA = 22,
+	KEYBOARD_ADDRESS_RECORDER2 = 23,
+	KEYBOARD_ADDRESS_CDR = 26,
+	KEYBOARD_ADDRESS_LIGHTING = 29,
+	KEYBOARD_ADDRESS_LIGHTING1 = 30, /* KEYBOARD_ADDRESS_HCW_SILVER */
+	KEYBOARD_ADDRESS_PHONE = 31,
+	KEYBOARD_ADDRESS_NOT_RC5 = 0xFFFF
+};
+
+enum ir_protocol {
+	IR_RC5,
+	IR_RCMM
+};
+
+struct keyboard_layout_map_t {
+	enum ir_protocol ir_protocol;
+	enum rc5_keyboard_address rc5_kbd_address;
+	u16 keyboard_layout_map[IR_KEYBOARD_LAYOUT_SIZE];
+};
+
+struct smscore_device_t;
+
+struct ir_t {
+	struct input_dev *input_dev;
+	enum ir_kb_type ir_kb_type;
+	char name[IR_DEV_NAME_MAX_LEN+1];
+	u16 *keyboard_layout_map;
+	u32 timeout;
+	u32 controller;
+};
+
+int sms_ir_init(struct smscore_device_t *coredev);
+void sms_ir_exit(struct smscore_device_t *coredev);
+void sms_ir_event(struct smscore_device_t *coredev,
+			const char *buf, int len);
+
+#endif /* __SMS_IR_H__ */
+
diff --git a/drivers/media/dvb/siano/smsspicommon.c b/drivers/media/dvb/siano/smsspicommon.c
new file mode 100644
index 0000000..4c714f3
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspicommon.c
@@ -0,0 +1,384 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#include "smsspicommon.h"
+#include "smsdbg_prn.h"
+
+static struct _rx_buffer_st *smsspi_handle_unused_bytes_buf(
+		struct _spi_dev *dev,
+		struct _rx_buffer_st *buf, int offset, int len,
+		int unused_bytes)
+{
+	struct _rx_buffer_st *tmp_buf;
+	tmp_buf = dev->cb.allocate_rx_buf(dev->context,
+		RX_PACKET_SIZE);
+	if (!tmp_buf) {
+		PRN_ERR((TXT
+			("Failed to allocate RX buffer.\n")));
+		return NULL;
+	}
+	if (unused_bytes > 0) {
+		/* Copy the remaining bytes to the end of
+		alignment block (256 bytes) so next read
+		will be aligned. */
+		int align_block =
+			(((unused_bytes + SPI_PACKET_SIZE -
+			1) >> SPI_PACKET_SIZE_BITS) <<
+			SPI_PACKET_SIZE_BITS);
+		memset(tmp_buf->ptr, 0,
+			align_block - unused_bytes);
+		memcpy((char *)tmp_buf->ptr +
+			(align_block - unused_bytes),
+			(char *)buf->ptr + offset + len -
+			unused_bytes, unused_bytes);
+	}
+	return tmp_buf;
+}
+
+static struct _rx_buffer_st *smsspi_common_find_msg(struct _spi_dev *dev,
+		struct _rx_buffer_st *buf, int offset, int len,
+		int *unused_bytes, int *missing_bytes)
+{
+	int i;
+	int recieved_bytes, padded_msg_len;
+	int align_fix;
+	int msg_offset;
+	char *ptr = (char *)buf->ptr + offset;
+	if (unused_bytes == NULL || missing_bytes == NULL)
+		return NULL;
+
+	*missing_bytes = 0;
+	*unused_bytes = 0;
+
+	PRN_DBG((TXT("entering with %d bytes.\n"), len));
+	for (i = 0; i < len; i++, ptr++) {
+		switch (dev->rxState) {
+		case RxsWait_a5:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0xa5) ? RxsWait_5a : RxsWait_a5;
+			dev->rxPacket.msg_offset =
+			    (unsigned long)ptr - (unsigned long)buf->ptr + 4;
+			break;
+		case RxsWait_5a:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0x5a) ? RxsWait_e7 : RxsWait_a5;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsWait_e7:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0xe7) ? RxsWait_7e : RxsWait_a5;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsWait_7e:
+			dev->rxState =
+			    ((*ptr & 0xff) == 0x7e) ? RxsTypeH : RxsWait_a5;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsTypeH:
+			dev->rxPacket.msg_buf = buf;
+			dev->rxPacket.msg_offset =
+			    (unsigned long)ptr - (unsigned long)buf->ptr;
+			dev->rxState = RxsTypeL;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsTypeL:
+			dev->rxState = RxsGetSrcId;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetSrcId:
+			dev->rxState = RxsGetDstId;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetDstId:
+			dev->rxState = RxsGetLenL;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetLenL:
+			dev->rxState = RxsGetLenH;
+			dev->rxPacket.msg_len = (*ptr & 0xff);
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsGetLenH:
+			dev->rxState = RxsFlagsL;
+			dev->rxPacket.msg_len += (*ptr & 0xff) << 8;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsFlagsL:
+			dev->rxState = RxsFlagsH;
+			dev->rxPacket.msg_flags = (*ptr & 0xff);
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsFlagsH:
+			dev->rxState = RxsData;
+			dev->rxPacket.msg_flags += (*ptr & 0xff) << 8;
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		case RxsData:
+			recieved_bytes =
+			    len + offset - dev->rxPacket.msg_offset;
+			padded_msg_len =
+			    ((dev->rxPacket.msg_len + 4 + SPI_PACKET_SIZE -
+			      1) >> SPI_PACKET_SIZE_BITS) <<
+			    SPI_PACKET_SIZE_BITS;
+			if (recieved_bytes < padded_msg_len) {
+				*unused_bytes = 0;
+				*missing_bytes = padded_msg_len -
+						recieved_bytes;
+				return buf;
+			}
+			dev->rxState = RxsWait_a5;
+			if (dev->cb.msg_found_cb) {
+				align_fix = 0;
+				if (dev->rxPacket.
+				    msg_flags & MSG_HDR_FLAG_SPLIT_MSG_HDR) {
+					align_fix =
+					    (dev->rxPacket.
+					     msg_flags >> 8) & 0x3;
+					/* The FW aligned the message data
+					therefore - alignment bytes should be
+					thrown away. Throw the alignment bytes
+					by moving the header ahead over the
+					alignment bytes. */
+					if (align_fix) {
+						int length;
+						ptr =
+						    (char *)dev->rxPacket.
+						    msg_buf->ptr +
+						    dev->rxPacket.msg_offset;
+
+						/* Restore header to original
+						state before alignment changes
+						*/
+						length =
+						    (ptr[5] << 8) | ptr[4];
+						length -= align_fix;
+						ptr[5] = length >> 8;
+						ptr[4] = length & 0xff;
+						/* Zero alignment flags */
+						ptr[7] &= 0xfc;
+
+						for (i = MSG_HDR_LEN - 1;
+						     i >= 0; i--) {
+							ptr[i + align_fix] =
+							    ptr[i];
+						}
+						dev->rxPacket.msg_offset +=
+						    align_fix;
+					}
+				}
+
+
+				/* force all messages to start on
+				 * 4-byte boundary */
+				msg_offset = dev->rxPacket.msg_offset;
+				if (msg_offset & 0x3)	{
+					msg_offset &= (~0x3);
+					memmove((unsigned char *)
+						(dev->rxPacket.msg_buf->ptr)
+						+ msg_offset,
+						(unsigned char *)
+						(dev->rxPacket.msg_buf->ptr)
+						+ dev->rxPacket.msg_offset,
+						dev->rxPacket.msg_len -
+						align_fix);
+				}
+
+				*unused_bytes =
+				    len + offset - dev->rxPacket.msg_offset -
+				    dev->rxPacket.msg_len;
+
+				/* In any case we got here - unused_bytes
+				 * should not be 0 Because we want to force
+				 * reading at least 256 after the end
+				 * of any found message */
+				if (*unused_bytes == 0)
+					*unused_bytes = -1;
+
+				buf = smsspi_handle_unused_bytes_buf(dev, buf,
+						offset, len, *unused_bytes);
+
+				dev->cb.msg_found_cb(dev->context,
+							 dev->rxPacket.msg_buf,
+							 msg_offset,
+							 dev->rxPacket.msg_len -
+							 align_fix);
+				*missing_bytes = 0;
+				return buf;
+			} else {
+				PRN_DBG((TXT
+		 ("Msg found but no callback. therefore - thrown away.\n")));
+			}
+			/*PRN_DBG((TXT("state %d.\n"), dev->rxState));*/
+			break;
+		}
+	}
+
+	if (dev->rxState == RxsWait_a5) {
+		*unused_bytes = 0;
+		*missing_bytes = 0;
+		return buf;
+	} else {
+		/* Workaround to corner case: if the last byte of the buffer
+		is "a5" (first byte of the preamble), the host thinks it should
+		send another 256 bytes.  In case the a5 is the firmware
+		underflow byte, this will cause an infinite loop, so we check
+		for this case explicity. */
+		if ((dev->rxState == RxsWait_5a) && (*(ptr - 2) == 0xa5)) {
+			dev->rxState = RxsWait_a5;
+			*unused_bytes = 0;
+			*missing_bytes = 0;
+			return buf;
+		}
+
+		if (dev->rxPacket.msg_offset >= (SPI_PACKET_SIZE + 4))
+			/* adding 4 for the preamble. */
+		{		/*The packet will be copied to a new buffer
+				   and rescaned by the state machine */
+			struct _rx_buffer_st *tmp_buf = buf;
+			*unused_bytes = dev->rxState - RxsWait_a5;
+			tmp_buf = smsspi_handle_unused_bytes_buf(dev, buf,
+					offset, len, *unused_bytes);
+			dev->rxState = RxsWait_a5;
+			dev->cb.free_rx_buf(dev->context, buf);
+			*missing_bytes = 0;
+			return tmp_buf;
+		} else {
+			/* report missing bytes and continue
+			   with message scan. */
+			*unused_bytes = 0;
+			*missing_bytes = SPI_PACKET_SIZE;
+			return buf;
+		}
+	}
+}
+
+void smsspi_common_transfer_msg(struct _spi_dev *dev, struct _spi_msg *txmsg,
+				int padding_allowed)
+{
+	int len, bytes_to_transfer;
+	unsigned long tx_phy_addr;
+	int missing_bytes, tx_bytes;
+	int offset, unused_bytes;
+	int align_block;
+	char *txbuf;
+	struct _rx_buffer_st *buf, *tmp_buf;
+
+	len = 0;
+	if (!dev->cb.transfer_data_cb) {
+		PRN_ERR((TXT
+		("function called while module is not initialized.\n")));
+		return;
+	}
+	if (txmsg == 0) {
+		bytes_to_transfer = SPI_PACKET_SIZE;
+		txbuf = 0;
+		tx_phy_addr = 0;
+		tx_bytes = 0;
+	} else {
+		tx_bytes = txmsg->len;
+		if (padding_allowed)
+			bytes_to_transfer =
+			    (((tx_bytes + SPI_PACKET_SIZE -
+			       1) >> SPI_PACKET_SIZE_BITS) <<
+			     SPI_PACKET_SIZE_BITS);
+		else
+			bytes_to_transfer = (((tx_bytes + 3) >> 2) << 2);
+		txbuf = txmsg->buf;
+		tx_phy_addr = txmsg->buf_phy_addr;
+	}
+	offset = 0;
+	unused_bytes = 0;
+	buf =
+	    dev->cb.allocate_rx_buf(dev->context,
+				    RX_PACKET_SIZE + SPI_PACKET_SIZE);
+	if (!buf) {
+		PRN_ERR((TXT("Failed to allocate RX buffer.\n")));
+		return;
+	}
+	while (bytes_to_transfer || unused_bytes) {
+		if ((unused_bytes <= 0) && (bytes_to_transfer > 0)) {
+			len = min(bytes_to_transfer, RX_PACKET_SIZE);
+			dev->cb.transfer_data_cb(dev->phy_context,
+				(unsigned char *)txbuf,
+				tx_phy_addr,
+				(unsigned char *)buf->ptr + offset,
+				buf->phy_addr + offset, len);
+		}
+
+		tmp_buf =
+		    smsspi_common_find_msg(dev, buf, offset, len,
+					   &unused_bytes, &missing_bytes);
+		if (bytes_to_transfer)
+			bytes_to_transfer -= len;
+
+		if (tx_bytes)
+			tx_bytes -= len;
+
+		if (missing_bytes)
+			offset += len;
+
+		if (unused_bytes) {
+			/* In this case tmp_buf is a new buffer allocated
+			 * in smsspi_common_find_msg
+			 * and it already contains the unused bytes */
+			if (unused_bytes > 0) {
+				align_block =
+				    (((unused_bytes + SPI_PACKET_SIZE -
+				       1) >> SPI_PACKET_SIZE_BITS) <<
+				     SPI_PACKET_SIZE_BITS);
+				len = align_block;
+			}
+			offset = 0;
+			buf = tmp_buf;
+		}
+		if (tx_bytes <= 0) {
+			txbuf = 0;
+			tx_bytes = 0;
+		}
+		if (bytes_to_transfer < missing_bytes) {
+			bytes_to_transfer =
+			    (((missing_bytes + SPI_PACKET_SIZE -
+			       1) >> SPI_PACKET_SIZE_BITS) <<
+			     SPI_PACKET_SIZE_BITS);
+			/*PRN_DBG((TXT
+	("a message was found, adding bytes to transfer, txmsg %d, total %d\n")
+			, tx_bytes, bytes_to_transfer));*/
+		}
+	}
+	dev->cb.free_rx_buf(dev->context, buf);
+}
+
+int smsspicommon_init(struct _spi_dev *dev, void *context, void *phy_context,
+		      struct _spi_dev_cb_st *cb)
+{
+	PRN_DBG((TXT("entering.\n")));
+	if (cb->transfer_data_cb == 0 ||
+	    cb->msg_found_cb == 0 ||
+	    cb->allocate_rx_buf == 0 || cb->free_rx_buf == 0) {
+		PRN_ERR((TXT("Invalid input parameters of init routine.\n")));
+		return -1;
+	}
+	dev->context = context;
+	dev->phy_context = phy_context;
+	memcpy(&dev->cb, cb, sizeof(struct _spi_dev_cb_st));
+	dev->rxState = RxsWait_a5;
+	PRN_DBG((TXT("exiting.\n")));
+	return 0;
+}
diff --git a/drivers/media/dvb/siano/smsspicommon.h b/drivers/media/dvb/siano/smsspicommon.h
new file mode 100644
index 0000000..cfcc6b1
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspicommon.h
@@ -0,0 +1,96 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+#ifndef _SMS_SPI_COMMON_H_
+#define _SMS_SPI_COMMON_H_
+
+#define RX_PACKET_SIZE  		0x1000
+#define SPI_PACKET_SIZE_BITS		8
+#define SPI_PACKET_SIZE 		(1<<SPI_PACKET_SIZE_BITS)
+#define SPI_MAX_CTRL_MSG_SIZE		0x100
+
+#define MSG_HDR_FLAG_SPLIT_MSG_HDR	0x0004
+#define MSG_HDR_LEN			8
+
+enum _spi_rx_state {
+	RxsWait_a5 = 0,
+	RxsWait_5a,
+	RxsWait_e7,
+	RxsWait_7e,
+	RxsTypeH,
+	RxsTypeL,
+	RxsGetSrcId,
+	RxsGetDstId,
+	RxsGetLenL,
+	RxsGetLenH,
+	RxsFlagsL,
+	RxsFlagsH,
+	RxsData
+};
+
+struct _rx_buffer_st {
+	void *ptr;
+	unsigned long phy_addr;
+};
+
+struct _rx_packet_request {
+	struct _rx_buffer_st *msg_buf;
+	int msg_offset;
+	int msg_len;
+	int msg_flags;
+};
+
+struct _spi_dev_cb_st{
+	void (*transfer_data_cb) (void *context, unsigned char *, unsigned long,
+				  unsigned char *, unsigned long, int);
+	void (*msg_found_cb) (void *, void *, int, int);
+	struct _rx_buffer_st *(*allocate_rx_buf) (void *, int);
+	void (*free_rx_buf) (void *, struct _rx_buffer_st *);
+};
+
+struct _spi_dev {
+	void *context;
+	void *phy_context;
+	struct _spi_dev_cb_st cb;
+	char *rxbuf;
+	enum _spi_rx_state rxState;
+	struct _rx_packet_request rxPacket;
+	char *internal_tx_buf;
+};
+
+struct _spi_msg {
+	char *buf;
+	unsigned long buf_phy_addr;
+	int len;
+};
+
+void smsspi_common_transfer_msg(struct _spi_dev *dev, struct _spi_msg *txmsg,
+				int padding_allowed);
+int smsspicommon_init(struct _spi_dev *dev, void *contex, void *phy_context,
+		      struct _spi_dev_cb_st *cb);
+
+#if defined HEXDUMP_DEBUG && defined SPIBUS_DEBUG
+/*! dump a human readable print of a binary buffer */
+void smsspi_khexdump(char *buf, int len);
+#else
+#define smsspi_khexdump(buf, len)
+#endif
+
+#endif /*_SMS_SPI_COMMON_H_*/
diff --git a/drivers/media/dvb/siano/smsspilog.c b/drivers/media/dvb/siano/smsspilog.c
new file mode 100644
index 0000000..d728cb6
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspilog.c
@@ -0,0 +1,506 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+/*!
+	\file	spibusdrv.c
+
+	\brief	spi bus driver module
+
+	This file contains implementation of the spi bus driver.
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <linux/spi/spi.h>
+#include <linux/time.h>
+
+#include "smscoreapi.h"
+#include "smsdbg_prn.h"
+#include "smsspicommon.h"
+#include "smsspiphy.h"
+
+#define ANDROID_2_6_25
+#ifdef ANDROID_2_6_25
+#include <linux/workqueue.h>
+#endif
+
+
+#define SMS_INTR_PIN			16  /* 0 for nova sip, 26 for vega */
+#define TX_BUFFER_SIZE			0x200
+#define RX_BUFFER_SIZE			(0x1000 + SPI_PACKET_SIZE + 0x100)
+#define NUM_RX_BUFFERS			72
+
+struct _spi_device_st {
+	struct _spi_dev dev;
+	void *phy_dev;
+
+	struct completion write_operation;
+	struct list_head tx_queue;
+	int allocatedPackets;
+	int padding_allowed;
+	char *rxbuf;
+	dma_addr_t rxbuf_phy_addr;
+
+	struct smscore_device_t *coredev;
+	struct list_head txqueue;
+	char *txbuf;
+	dma_addr_t txbuf_phy_addr;
+
+#if defined(MOT_FEAT_OMAP_DMA_USE)
+  int dma_tx_channel;
+  int dma_rx_channel;
+#endif
+};
+
+struct _smsspi_txmsg {
+	struct list_head node;	/*! internal management */
+	void *buffer;
+	size_t size;
+	int alignment;
+	int add_preamble;
+	struct completion completion;
+	void (*prewrite) (void *);
+	void (*postwrite) (void *);
+};
+
+struct _spi_device_st *spi_dev;
+
+static void spi_worker_thread(void *arg);
+static DECLARE_WORK(spi_work_queue, (void *)spi_worker_thread);
+static u8 smsspi_preamble[] = { 0xa5, 0x5a, 0xe7, 0x7e };
+static u8 smsspi_startup[] = { 0, 0, 0xde, 0xc1, 0xa5, 0x51, 0xf1, 0xed };
+static u32 default_type = SMS_NOVA_B0; /*SMS_NOVA_A0;*/
+static u32 intr_pin = SMS_INTR_PIN;
+
+module_param(default_type, int, 0644);
+MODULE_PARM_DESC(default_type, "default board type.");
+
+module_param(intr_pin, int, 0644);
+MODULE_PARM_DESC(intr_pin, "interrupt pin number.");
+
+/******************************************/
+static void spi_worker_thread(void *arg)
+{
+	struct _spi_device_st *spi_device = spi_dev;
+	struct _smsspi_txmsg *msg = NULL;
+	struct _spi_msg txmsg;
+
+	/*PDEBUG("worker start\n");*/
+	do {
+		/* do we have a msg to write ? */
+		if (!msg && !list_empty(&spi_device->txqueue))
+			msg = (struct _smsspi_txmsg *)
+					list_entry(spi_device->txqueue.
+					next, struct _smsspi_txmsg, node);
+
+		if (msg) {
+			if (msg->add_preamble) {
+				txmsg.len =
+				    min(msg->size + sizeof(smsspi_preamble),
+					(size_t) TX_BUFFER_SIZE);
+				txmsg.buf = spi_device->txbuf;
+				txmsg.buf_phy_addr = spi_device->txbuf_phy_addr;
+				memcpy(txmsg.buf, smsspi_preamble,
+				       sizeof(smsspi_preamble));
+				memcpy(&txmsg.buf[sizeof(smsspi_preamble)],
+				       msg->buffer,
+				       txmsg.len - sizeof(smsspi_preamble));
+				msg->add_preamble = 0;
+				msg->buffer +=
+				    txmsg.len - sizeof(smsspi_preamble);
+				msg->size -=
+				    txmsg.len - sizeof(smsspi_preamble);
+				/* zero out the rest of aligned buffer */
+				memset(&txmsg.buf[txmsg.len], 0,
+				       TX_BUFFER_SIZE - txmsg.len);
+				smsspi_common_transfer_msg(&spi_device->dev,
+							   &txmsg, 1);
+			} else {
+				txmsg.len =
+				    min(msg->size, (size_t) TX_BUFFER_SIZE);
+				txmsg.buf = spi_device->txbuf;
+				txmsg.buf_phy_addr = spi_device->txbuf_phy_addr;
+				memcpy(txmsg.buf, msg->buffer, txmsg.len);
+
+				msg->buffer += txmsg.len;
+				msg->size -= txmsg.len;
+				/* zero out the rest of aligned buffer */
+				memset(&txmsg.buf[txmsg.len], 0,
+				       TX_BUFFER_SIZE - txmsg.len);
+				smsspi_common_transfer_msg(&spi_device->dev,
+							   &txmsg, 0);
+			}
+
+		} else {
+			smsspi_common_transfer_msg(&spi_device->dev, NULL, 1);
+		}
+
+		/* if there was write, have we finished ? */
+		if (msg && !msg->size) {
+			/* call postwrite call back */
+			if (msg->postwrite)
+				msg->postwrite(spi_device);
+
+			list_del(&msg->node);
+			complete(&msg->completion);
+			msg = NULL;
+		}
+		/* if there was read, did we read anything ? */
+
+	} while (!list_empty(&spi_device->txqueue) || msg);
+
+	/*PDEBUG("worker end\n");*/
+
+}
+
+static void msg_found(void *context, void *buf, int offset, int len)
+{
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	struct smscore_buffer_t *cb =
+	    (struct smscore_buffer_t
+	     *)(container_of(buf, struct smscore_buffer_t, p));
+
+	/*PDEBUG("entering\n");*/
+	cb->offset = offset;
+	cb->size = len;
+	/* PERROR ("buffer %p is sent back to core databuf=%p,
+		offset=%d.\n", cb, cb->p, cb->offset); */
+	smscore_onresponse(spi_device->coredev, cb);
+
+	/*PDEBUG("exiting\n");*/
+
+}
+
+static void smsspi_int_handler(void *context)
+{
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+
+	PREPARE_WORK(&spi_work_queue, (void *)spi_worker_thread);
+	spi_device->padding_allowed = 1;
+	schedule_work(&spi_work_queue);
+}
+
+static int smsspi_queue_message_and_wait(struct _spi_device_st *spi_device,
+					 struct _smsspi_txmsg *msg)
+{
+	init_completion(&msg->completion);
+	list_add_tail(&msg->node, &spi_device->txqueue);
+	schedule_work(&spi_work_queue);
+	wait_for_completion(&msg->completion);
+
+	return 0;
+}
+
+/*##w21558*/
+#ifdef __SMS_DUMMY_INT__
+static int smsspi_SetIntLine(void *context)
+{
+	struct _Msg {
+		struct SmsMsgHdr_ST hdr;
+		u32 data[3];
+	} Msg = {
+		{
+		MSG_SMS_SPI_INT_LINE_SET_REQ, 0, HIF_TASK,
+			    sizeof(struct _Msg), 0}, {
+		0, intr_pin, 100}
+	};
+	struct _smsspi_txmsg msg;
+
+	PDEBUG("Sending SPI Set Interrupt command sequence\n");
+/*	fwDnlComplete(spi_device->phy_dev, 0);*/
+	msg.buffer = &Msg;
+	msg.size = sizeof(Msg);
+	msg.alignment = SPI_PACKET_SIZE;
+	msg.add_preamble = 1;
+	msg.prewrite = NULL;
+	msg.postwrite = NULL;	/* smsspiphy_restore_clock; */
+
+	return smsspi_queue_message_and_wait(context, &msg);
+/*	return 0;*/
+}
+#endif
+
+static int smsspi_preload(void *context)
+{
+	struct _smsspi_txmsg msg;
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+
+	prepareForFWDnl(spi_device->phy_dev);
+	PDEBUG("Sending SPI init sequence\n");
+	msg.buffer = smsspi_startup;
+	msg.size = sizeof(smsspi_startup);
+	msg.alignment = 4;
+	msg.add_preamble = 0;
+	msg.prewrite = NULL;	/* smsspiphy_reduce_clock; */
+	msg.postwrite = NULL;
+
+	smsspi_queue_message_and_wait(context, &msg);
+	/*smsspi_SetIntLine(context);*/
+
+	return 0;
+}
+
+/*#if 0
+//ROCK 0331
+//Move INT_LINE_SET_REQ to the preload, enable the INT before FW download
+//Add MSG_SMS_SET_PERIODIC_STATS_REQ, enable the Period Statistics*/
+static int smsspi_postload(void *context)
+{
+	struct _Msg {
+		struct SmsMsgHdr_ST hdr;
+		u32 data[3];
+	} Msg = {
+		{
+		MSG_SMS_SPI_INT_LINE_SET_REQ, 0, HIF_TASK,
+			    sizeof(struct _Msg), 0}, {
+		0, intr_pin, 0}
+	};
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	struct _smsspi_txmsg msg;
+
+	PDEBUG("Sending SPI Set Interrupt command sequence\n");
+	fwDnlComplete(spi_device->phy_dev, 0);
+	msg.buffer = &Msg;
+	msg.size = sizeof(Msg);
+	msg.alignment = SPI_PACKET_SIZE;
+	msg.add_preamble = 1;
+	msg.prewrite = NULL;
+	msg.postwrite = NULL;	/* smsspiphy_restore_clock; */
+
+	return smsspi_queue_message_and_wait(context, &msg);
+}
+/*#endif*/
+
+
+static int smsspi_write(void *context, void *txbuf, size_t len)
+{
+	struct _smsspi_txmsg msg;
+
+	msg.buffer = txbuf;
+	msg.size = len;
+	msg.prewrite = NULL;
+	msg.postwrite = NULL;
+
+	if (len > 0x1000) {
+		/* The FW is the only long message. Do not add preamble,
+		and do not padd it */
+		msg.alignment = 4;
+		msg.add_preamble = 0;
+		msg.prewrite = smschipreset;
+	} else {
+		msg.alignment = SPI_PACKET_SIZE;
+		msg.add_preamble = 1;
+	}
+
+/*
+	PDEBUG("Writing message to  SPI.\n");
+	PDEBUG("msg hdr: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\n",
+	       ((u8 *) txbuf)[0], ((u8 *) txbuf)[1], ((u8 *) txbuf)[2],
+	       ((u8 *) txbuf)[3], ((u8 *) txbuf)[4], ((u8 *) txbuf)[5],
+	       ((u8 *) txbuf)[6], ((u8 *) txbuf)[7]);
+	PDEBUG("0x%x, 0x%x,\n",    ((u8 *) txbuf)[0], ((u8 *) txbuf)[1]);
+*/
+
+	return smsspi_queue_message_and_wait(context, &msg);
+}
+
+struct _rx_buffer_st *allocate_rx_buf(void *context, int size)
+{
+	struct smscore_buffer_t *buf;
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	if (size > RX_BUFFER_SIZE) {
+		PERROR("Requested size is bigger than max buffer size.\n");
+		return NULL;
+	}
+	buf = smscore_getbuffer(spi_device->coredev);
+/*	PDEBUG("Recieved Rx buf %p physical 0x%x (contained in %p)\n", buf->p,
+		buf->phys, buf);*/
+
+	/* note: this is not mistake! the rx_buffer_st is identical to part of
+	   smscore_buffer_t and we return the address of the start of the
+	   identical part */
+	return (struct _rx_buffer_st *) &buf->p;
+}
+
+static void free_rx_buf(void *context, struct _rx_buffer_st *buf)
+{
+	struct _spi_device_st *spi_device = (struct _spi_device_st *) context;
+	struct smscore_buffer_t *cb =
+	    (struct smscore_buffer_t
+	     *)(container_of(((void *)buf), struct smscore_buffer_t, p));
+/*	PDEBUG("buffer %p is released.\n", cb);*/
+	smscore_putbuffer(spi_device->coredev, cb);
+}
+
+/*! Release device STUB
+
+\param[in]	dev:		device control block
+\return		void
+*/
+static void smsspi_release(struct device *dev)
+{
+	PDEBUG("nothing to do\n");
+	/* Nothing to release */
+}
+
+static struct platform_device smsspi_device = {
+	.name = "smsspi",
+	.id = 1,
+	.dev = {
+		.release = smsspi_release,
+		},
+};
+
+int smsspi_register(void)
+{
+	struct smsdevice_params_t params;
+	int ret;
+	struct _spi_device_st *spi_device;
+	struct _spi_dev_cb_st common_cb;
+
+	PDEBUG("entering \n");
+
+	spi_device =
+	    kmalloc(sizeof(struct _spi_device_st), GFP_KERNEL);
+	spi_dev = spi_device;
+
+	INIT_LIST_HEAD(&spi_device->txqueue);
+
+	ret = platform_device_register(&smsspi_device);
+	if (ret < 0) {
+		PERROR("platform_device_register failed\n");
+		return ret;
+	}
+
+/* w21558 */
+#if defined(MOT_FEAT_OMAP_DMA_USE)
+	spi_device->txbuf =
+	    dma_alloc_coherent(NULL, TX_BUFFER_SIZE,
+			       &spi_device->txbuf_phy_addr,
+			       GFP_KERNEL | GFP_DMA);
+	if (!spi_device->txbuf) {
+		printk(KERN_INFO "%s dma_alloc_coherent(...) failed\n",
+		       __func__);
+		ret = -ENOMEM;
+		goto txbuf_error;
+	}
+#endif
+
+	spi_device->phy_dev =
+	    smsspiphy_init(NULL, smsspi_int_handler, &spi_device);
+	if (spi_device->phy_dev == 0) {
+		printk(KERN_INFO "%s smsspiphy_init(...) failed\n", __func__);
+		goto phy_error;
+	}
+
+	common_cb.allocate_rx_buf = allocate_rx_buf;
+	common_cb.free_rx_buf = free_rx_buf;
+	common_cb.msg_found_cb = msg_found;
+	common_cb.transfer_data_cb = smsspibus_xfer;
+
+	ret =
+	    smsspicommon_init(&spi_device->dev, spi_device, spi_device->phy_dev,
+			      &common_cb);
+	if (ret) {
+		printk(KERN_INFO "%s smsspiphy_init(...) failed\n", __func__);
+		goto common_error;
+	}
+
+	/* register in smscore */
+	memset(&params, 0, sizeof(params));
+	params.context = spi_device;
+	params.device = &smsspi_device.dev;
+	params.buffer_size = RX_BUFFER_SIZE;
+	params.num_buffers = NUM_RX_BUFFERS;
+	params.flags = SMS_DEVICE_NOT_READY;
+	params.sendrequest_handler = smsspi_write;
+	strcpy(params.devpath, "spi");
+	params.device_type = default_type;
+
+	if (0) {
+		/* device family */
+		/* params.setmode_handler = smsspi_setmode; */
+	} else {
+		params.flags =
+		    SMS_DEVICE_FAMILY2 | SMS_DEVICE_NOT_READY |
+		    SMS_ROM_NO_RESPONSE;
+		params.preload_handler = smsspi_preload;
+		params.postload_handler = smsspi_postload;
+	}
+
+	ret = smscore_register_device(&params, &spi_device->coredev);
+	if (ret < 0) {
+		printk(KERN_INFO "%s smscore_register_device(...) failed\n",
+		       __func__);
+		goto reg_device_error;
+	}
+
+	ret = smscore_start_device(spi_device->coredev);
+	if (ret < 0) {
+		printk(KERN_INFO "%s smscore_start_device(...) failed\n",
+		       __func__);
+		goto start_device_error;
+	}
+
+	PDEBUG("exiting\n");
+	return 0;
+
+start_device_error:
+	smscore_unregister_device(spi_device->coredev);
+
+reg_device_error:
+
+common_error:
+	smsspiphy_deinit(spi_device->phy_dev);
+
+phy_error:
+	dma_free_coherent(NULL, TX_BUFFER_SIZE, spi_device->txbuf,
+			  spi_device->txbuf_phy_addr);
+
+txbuf_error:
+	platform_device_unregister(&smsspi_device);
+
+	PDEBUG("exiting error %d\n", ret);
+
+	return ret;
+}
+
+void smsspi_unregister(void)
+{
+	struct _spi_device_st *spi_device = spi_dev;
+	PDEBUG("entering\n");
+
+	/* stop interrupts */
+	smsspiphy_deinit(spi_device->phy_dev);
+	smscore_unregister_device(spi_device->coredev);
+
+	dma_free_coherent(NULL, TX_BUFFER_SIZE, spi_device->txbuf,
+			spi_device->txbuf_phy_addr);
+
+	platform_device_unregister(&smsspi_device);
+	PDEBUG("exiting\n");
+}
diff --git a/drivers/media/dvb/siano/smsspiphy.h b/drivers/media/dvb/siano/smsspiphy.h
new file mode 100644
index 0000000..de7da4f
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspiphy.h
@@ -0,0 +1,39 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#ifndef __SMS_SPI_PHY_H__
+#define __SMS_SPI_PHY_H__
+
+void smsspibus_xfer(void *context, unsigned char *txbuf,
+		    unsigned long txbuf_phy_addr, unsigned char *rxbuf,
+		    unsigned long rxbuf_phy_addr, int len);
+void *smsspiphy_init(void *context, void (*smsspi_interruptHandler) (void *),
+		     void *intr_context);
+void smsspiphy_deinit(void *context);
+void smschipreset(void *context);
+void WriteFWtoStellar(void *pSpiPhy, unsigned char *pFW, unsigned long Len);
+void prepareForFWDnl(void *pSpiPhy);
+void fwDnlComplete(void *context, int App);
+
+/*##w21558*/
+int smsspiphy_interrupt_control(int enable);
+
+#endif /* __SMS_SPI_PHY_H__ */
diff --git a/drivers/media/dvb/siano/smsspiphy_omap34xx.c b/drivers/media/dvb/siano/smsspiphy_omap34xx.c
new file mode 100644
index 0000000..3cd7cc0
--- /dev/null
+++ b/drivers/media/dvb/siano/smsspiphy_omap34xx.c
@@ -0,0 +1,374 @@
+/****************************************************************
+
+Siano Mobile Silicon, Inc.
+MDTV receiver kernel modules.
+Copyright (C) 2006-2008, Uri Shkolnik
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 2 of the License, or
+(at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+****************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/irq.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <asm/dma.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/vmalloc.h>
+#include <linux/i2c.h>
+
+#include "smsdbg_prn.h"
+#include "smscoreapi.h"
+
+#include <linux/time.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/clock.h>
+
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/system.h>
+#include <mach/dma.h>
+
+#include <linux/gpio_mapping.h>
+
+/* debug macro */
+#define tdmblog(fmt, arg...) printk(KERN_DEBUG "TDMB_SEQ: "fmt, ##arg)
+
+#define SPI_PACKET_SIZE 256
+
+/*
+#define MDTV_INT_N_GPIO         38
+#define MDTV_PWDN_GPIO          53
+#define MDTV_RESET_N_GPIO       54
+*/
+
+#define MDTV_INT_N_GPIO         get_gpio_by_name("mtv_int")
+#define MDTV_PWDN_GPIO          get_gpio_by_name("mtv_pwdn")
+#define MDTV_RESET_N_GPIO       get_gpio_by_name("mtv_reset_n")
+
+/* MTV_INT */
+#define SMS_IRQ_GPIO          MDTV_INT_N_GPIO
+
+#define TX_BUFFER_SIZE			0x200
+
+/* physical layer variables */
+/*! global bus data */
+struct spiphy_dev_s {
+	struct completion transfer_in_process;
+	void (*interruptHandler) (void *);
+	void *intr_context;
+	struct spi_device *dev;	/*!< device model stuff */
+	int irq;
+
+	char *txpad;
+	dma_addr_t txpad_phy_addr;
+};
+
+struct omap2_mcspi_cs {
+	void __iomem		*base;
+	unsigned long		phys;
+	int			word_len;
+};
+
+
+#define MOT_LP3907_DEV      1
+
+#define INTERRUPT_DISABLE     0
+#define INTERRUPT_ENABLE      1
+
+static struct spi_device *smsmdtv_dev;
+
+static int smsmdtv_int_enable_flag = INTERRUPT_ENABLE;
+
+/* SPI interrupt handler */
+static irqreturn_t spibus_interrupt(int irq, void *context)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+
+	if (spiphy_dev->interruptHandler)
+		spiphy_dev->interruptHandler(spiphy_dev->intr_context);
+
+	printk(KERN_INFO "spibus_interrupt.\n");
+	return IRQ_HANDLED;
+
+}
+
+#define SPI_MIN_BYTES (4)
+#define SMS_MAX_BUF_SIZE (0x1000)
+
+#if defined(MOT_FEAT_OMAP_DMA_USE)
+void smsspibus_xfer(void *context, unsigned char *txbuf,
+		    unsigned long txbuf_phy_addr, unsigned char *rxbuf,
+		    unsigned long rxbuf_phy_addr, int len)
+{
+  struct spi_transfer t;
+  struct spi_message  m;
+  struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+  unsigned long txdma;
+
+  int status = -1;
+
+  if (txbuf == 0) {
+    txbuf = (unsigned char *)spiphy_dev->txpad;
+    txdma  = spiphy_dev->txpad_phy_addr;
+  } else {
+    txdma = txbuf_phy_addr;
+  }
+
+  spi_message_init(&m);
+
+  m.is_dma_mapped = 1;
+  memset(&t, 0, sizeof(struct spi_transfer));
+
+  t.tx_buf    = txbuf;
+  t.tx_dma    = txdma;
+  t.len       = len;
+  t.rx_buf    = rxbuf;
+  t.rx_dma    = rxbuf_phy_addr;
+  t.delay_usecs = 1;
+
+  spi_message_add_tail(&t, &m);
+
+  status = spi_sync(spiphy_dev->dev, &m);
+}
+
+#else
+void smsspibus_xfer(void *context, unsigned char *txbuf,
+		    unsigned long txbuf_phy_addr, unsigned char *rxbuf,
+		    unsigned long rxbuf_phy_addr, int len)
+{
+	struct spi_transfer	*t = 0;
+	struct spi_message	 m;
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+	int i = 0;
+	int status = -1;
+
+	t = spiphy_dev->spi_xfer;
+
+	spi_message_init(&m);
+
+	for (i = 0; i < len/SPI_MIN_BYTES; i++) {
+		memset(&t[i], 0, sizeof(struct spi_transfer));
+		t[i].tx_buf	 = txbuf;
+		t[i].len		 = SPI_MIN_BYTES;
+		t[i].rx_buf	 = rxbuf;
+
+		spi_message_add_tail(&t[i], &m);
+
+		if (txbuf)
+			txbuf += SPI_MIN_BYTES;
+		rxbuf += SPI_MIN_BYTES;
+	}
+
+	status = spi_sync(spiphy_dev->dev, &m);
+
+}
+#endif
+
+void smschipreset(void *context)
+{
+  return;
+}
+
+int smsmdtv_power_control(int pwrup_enable)
+{
+  int ret = 0, line = 0;
+
+  tdmblog("power control = %d\n", pwrup_enable);
+
+  if (pwrup_enable == 1) {
+
+#ifdef CONFIG_MOT_FEAT_TDMB_SUPPORT
+	tdmb_config_gpio_on();
+#endif
+	/* PWDN High */
+	gpio_set_value(MDTV_PWDN_GPIO, 1);
+	udelay(20);  /* at least, T = 10usec */
+
+	/* Reset High */
+	gpio_set_value(MDTV_RESET_N_GPIO, 1);
+	udelay(20);  /* at least, T = 10usec */
+
+	/* SMSMDTV interrupt enable */
+	if (smsmdtv_int_enable_flag == INTERRUPT_DISABLE) {
+	enable_irq(OMAP_GPIO_IRQ(SMS_IRQ_GPIO));
+	smsmdtv_int_enable_flag = INTERRUPT_ENABLE;
+	printk(KERN_INFO "enable_irq().\n");
+	}
+  } else {
+
+    /* SMSMDTV interrupt disable */
+    if (smsmdtv_int_enable_flag == INTERRUPT_ENABLE) {
+      disable_irq(OMAP_GPIO_IRQ(SMS_IRQ_GPIO));
+      smsmdtv_int_enable_flag = INTERRUPT_DISABLE;
+      printk(KERN_INFO "disable_irq().\n");
+    }
+
+	/* Reset Low */
+	gpio_set_value(MDTV_RESET_N_GPIO, 0);
+	udelay(20);  /* at least, T = 10usec */
+
+	/* PWDN Low */
+	gpio_set_value(MDTV_PWDN_GPIO, 0);
+	msleep(1);
+
+#ifdef CONFIG_MOT_FEAT_TDMB_SUPPORT
+	tdmb_config_gpio_off();
+#endif
+	}
+
+  if (ret < 0)
+    tdmblog("Power control sequence is failed.\n");
+
+	return ret;
+}
+
+static int __devinit smsmdtv_probe(struct spi_device *spi)
+{
+/*
+	struct spi_device *slave = spi;
+	struct omap2_mcspi_cs *cs = \
+		(struct omap2_mcspi_cs *)slave->controller_state;
+*/
+	int ret;
+
+	/* SPI setup is needed */
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		dev_err(&spi->dev, "[SMS] SPI setup failed\n");
+		goto err;
+	}
+
+	smsmdtv_dev = spi;
+    return ret;
+err:
+	return -1;
+}
+
+static struct spi_driver smsmdtv_driver = {
+  .driver = {
+    .name = "smsmdtv",
+    .bus  = &spi_bus_type,
+    .owner = THIS_MODULE,
+  },
+  .probe = smsmdtv_probe,
+};
+
+void *smsspiphy_init(void *context,
+	void (*smsspi_interruptHandler) (void *), void *intr_context)
+{
+  struct spiphy_dev_s *spiphy_dev;
+  int ret;
+
+  smsmdtv_dev = 0;
+
+	spiphy_dev = kmalloc(sizeof(struct spiphy_dev_s), GFP_KERNEL);
+	if (spiphy_dev == 0) {
+		sms_err("malloc for spi_dev failed");
+		goto err_malloc;
+	}
+	spiphy_dev->interruptHandler = smsspi_interruptHandler;
+	spiphy_dev->intr_context     = intr_context;
+
+  ret = spi_register_driver(&smsmdtv_driver);
+
+	if (ret < 0 || smsmdtv_dev == 0) {
+		sms_info("Cann't get SPI device\n");
+		goto err_register;
+  }
+
+	spiphy_dev->dev      = smsmdtv_dev;
+
+
+  /*spi_loop_test(slave);*/
+
+  spiphy_dev->irq = OMAP_GPIO_IRQ(SMS_IRQ_GPIO);
+
+  set_irq_type(spiphy_dev->irq, IRQ_TYPE_EDGE_RISING);
+	ret = request_irq(spiphy_dev->irq, spibus_interrupt, \
+		IRQF_TRIGGER_RISING|IRQF_DISABLED, "smsmdtv", spiphy_dev);
+
+	if (ret < 0) {
+		sms_err("Unable to request irq %d", ret);
+		goto err_irq;
+	}
+
+	spiphy_dev->txpad = dma_alloc_coherent(NULL, TX_BUFFER_SIZE,
+			&spiphy_dev->txpad_phy_addr,
+			GFP_KERNEL|GFP_DMA);
+	if (!spiphy_dev->txpad) {
+    ret = -ENOMEM;
+    goto err_txpad;
+	}
+  memset(spiphy_dev->txpad, 0xFF, TX_BUFFER_SIZE);
+
+
+	PDEBUG("exiting\n");
+	return spiphy_dev;
+
+err_txpad:
+  free_irq(spiphy_dev->irq, spiphy_dev);
+err_irq:
+  gpio_free(SMS_IRQ_GPIO);
+  spi_unregister_driver(&smsmdtv_driver);
+err_register:
+  kfree(spiphy_dev);
+err_malloc:
+	return 0;
+}
+
+int smsspiphy_deinit(void *context)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+
+	gpio_free(SMS_IRQ_GPIO);
+  spi_unregister_driver(&smsmdtv_driver);
+	free_irq(spiphy_dev->irq, spiphy_dev);
+  dma_free_coherent(NULL, TX_BUFFER_SIZE, \
+	spiphy_dev->txpad, spiphy_dev->txpad_phy_addr);
+	kfree(spiphy_dev);
+
+	return 0;
+}
+
+void smsspiphy_set_config(struct spiphy_dev_s *spiphy_dev, int clock_divider)
+{
+	/*Omap_SPI_Enable(&(spiphy_dev->sspdev));*/
+}
+
+void prepareForFWDnl(void *context)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+	smsspiphy_set_config(spiphy_dev, 2);
+	msleep(100);
+}
+
+void fwDnlComplete(void *context, int App)
+{
+	struct spiphy_dev_s *spiphy_dev = (struct spiphy_dev_s *) context;
+	smsspiphy_set_config(spiphy_dev, 1);
+	msleep(100);
+}
+
diff --git a/drivers/media/dvb/siano/smsusb.c b/drivers/media/dvb/siano/smsusb.c
index 5d7ca34..87a3c24 100644
--- a/drivers/media/dvb/siano/smsusb.c
+++ b/drivers/media/dvb/siano/smsusb.c
@@ -432,56 +432,11 @@ static void smsusb_disconnect(struct usb_interface *intf)
 	smsusb_term_device(intf);
 }
 
-static int smsusb_suspend(struct usb_interface *intf, pm_message_t msg)
-{
-	struct smsusb_device_t *dev =
-		(struct smsusb_device_t *)usb_get_intfdata(intf);
-	printk(KERN_INFO "%s  Entering status %d.\n", __func__, msg.event);
-	smsusb_stop_streaming(dev);
-	return 0;
-}
-
-static int smsusb_resume(struct usb_interface *intf)
-{
-	int rc, i;
-	struct smsusb_device_t *dev =
-		(struct smsusb_device_t *)usb_get_intfdata(intf);
-	struct usb_device *udev = interface_to_usbdev(intf);
-
-	printk(KERN_INFO "%s  Entering.\n", __func__);
-	usb_clear_halt(udev, usb_rcvbulkpipe(udev, 0x81));
-	usb_clear_halt(udev, usb_rcvbulkpipe(udev, 0x02));
-
-	for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++)
-		printk(KERN_INFO "endpoint %d %02x %02x %d\n", i,
-		       intf->cur_altsetting->endpoint[i].desc.bEndpointAddress,
-		       intf->cur_altsetting->endpoint[i].desc.bmAttributes,
-		       intf->cur_altsetting->endpoint[i].desc.wMaxPacketSize);
-
-	if (intf->num_altsetting > 0) {
-		rc = usb_set_interface(udev,
-				       intf->cur_altsetting->desc.
-				       bInterfaceNumber, 0);
-		if (rc < 0) {
-			printk(KERN_INFO
-			       "%s usb_set_interface failed, rc %d\n",
-			       __func__, rc);
-			return rc;
-		}
-	}
-
-	smsusb_start_streaming(dev);
-	return 0;
-}
-
 static struct usb_driver smsusb_driver = {
 	.name			= "sms1xxx",
 	.probe			= smsusb_probe,
 	.disconnect		= smsusb_disconnect,
 	.id_table		= smsusb_id_table,
-
-	.suspend		= smsusb_suspend,
-	.resume			= smsusb_resume,
 };
 
 int smsusb_register(void)
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 9e4c2ca..6669856 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -316,6 +316,26 @@ config VIDEO_MT9P012
 	  MT9P012 camera.  It is currently working with the TI OMAP3
 	  camera controller.
 
+config VIDEO_MIPI_INTERFACE
+	tristate "MIPI INTERFACE functionality"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is for MIPI INTERFACE functiionality
+
+config VIDEO_MIPI_DLI_TEST
+	tristate "MIPI DLI TEST functionality"
+	depends on VIDEO_MIPI_INTERFACE && VIDEO_V4L2
+	---help---
+	  This is for MIPI INTERFACE functiionality
+
+config VIDEO_OV8810
+	tristate "OV8810 raw sensor driver (8MP)"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Omni-Vision
+	  OV8810 camera.  It is currently working with the TI OMAP3
+	  camera controller.
+
 config VIDEO_OMAP3_HPLENS
 	tristate "HP generic lens driver"
 	depends on I2C && VIDEO_V4L2
@@ -990,3 +1010,13 @@ config USB_S2255
 endif # V4L_USB_DRIVERS
 
 endif # VIDEO_CAPTURE_DRIVERS
+
+#
+# NXP HDMI TDA19989 configuration
+#
+config HDMI_TDA19989
+	tristate "NXP HDMI 1.3 Transmitter driver"
+	depends on I2C
+	help
+	  to support HDMI1.3 transmitter
+	  with 3*8bit video inputs and CEC.
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index c6d953a..a987332 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -112,6 +112,8 @@ obj-$(CONFIG_VIDEO_OMAP3) += omap34xxcam.o
 
 obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
 obj-$(CONFIG_VIDEO_MT9P012)     += mt9p012.o
+obj-$(CONFIG_VIDEO_OV8810)     += ov8810.o
+obj-$(CONFIG_VIDEO_MIPI_DLI_TEST) += mipi_dli.o
 obj-$(CONFIG_VIDEO_OMAP3_HP3A) += hp3a/
 obj-$(CONFIG_VIDEO_OMAP3_HPLENS) += hplens.o
 
@@ -146,6 +148,7 @@ obj-$(CONFIG_VIDEO_CX23885) += cx23885/
 obj-$(CONFIG_VIDEO_PXA27x)	+= pxa_camera.o
 obj-$(CONFIG_VIDEO_SH_MOBILE_CEU)	+= sh_mobile_ceu_camera.o
 obj-$(CONFIG_VIDEO_OMAP2)		+= omap2cam.o
+obj-$(CONFIG_VIDEO_OMAP_MOT_VIDEOOUT) += omap_mot/
 obj-$(CONFIG_VIDEO_OLDOMAP3) += oldomap34xxcam.o oldisp/
 obj-$(CONFIG_VIDEO_OMAP_VIDEOOUT) += omap-vout/
 obj-$(CONFIG_SOC_CAMERA)	+= soc_camera.o
@@ -161,6 +164,7 @@ obj-$(CONFIG_VIDEO_AU0828) += au0828/
 
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
 
+obj-$(CONFIG_HDMI_TDA19989) += tda19989.o
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 EXTRA_CFLAGS += -Idrivers/media/dvb/frontends
 EXTRA_CFLAGS += -Idrivers/media/common/tuners
diff --git a/drivers/media/video/hp3a/hp3a.h b/drivers/media/video/hp3a/hp3a.h
index eb3b9c8..760d224 100644
--- a/drivers/media/video/hp3a/hp3a.h
+++ b/drivers/media/video/hp3a/hp3a.h
@@ -31,6 +31,7 @@ void hp3a_frame_done(void);
 void hp3a_stream_on(void);
 void hp3a_stream_off(void);
 void hp3a_ccdc_start(void);
+void hp3a_update_wb(void);
 int hp3a_hist_busy(void);
 int hp3a_af_busy(void);
 void hp3a_set_sensor_sync(unsigned char exposure, unsigned char gain);
diff --git a/drivers/media/video/hp3a/hp3a_af.c b/drivers/media/video/hp3a/hp3a_af.c
index bb08632..d90a9dc 100644
--- a/drivers/media/video/hp3a/hp3a_af.c
+++ b/drivers/media/video/hp3a/hp3a_af.c
@@ -123,9 +123,8 @@ void hp3a_disable_af(void)
 static void hp3a_af_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 			void *arg2)
 {
-	if (unlikely((H3A_AF_DONE & status) != H3A_AF_DONE)) {
+	if (unlikely((H3A_AF_DONE & status) != H3A_AF_DONE))
 		return;
-	}
 
 	/* clear IRQ status bit.*/
 	/*
@@ -158,9 +157,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		/* Install AF callback. */
 		ret = isp_set_callback(CBK_H3A_AF_DONE, hp3a_af_isr,
 					(void *)NULL, (void *)NULL);
-		if (ret) {
+		if (ret)
 			return ret;
-		}
 
 		if (hp3a_af_busy()) {
 			dev_info(device->dev, "Error: AF engine is busy!\n");
@@ -206,7 +204,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 
 		/* Validate paxel dimessions. */
 		if (config->paxel.width < 16 || config->paxel.width > 256 ||
-			config->paxel.height < 2 ||  config->paxel.height > 256) {
+			config->paxel.height < 2 ||
+			config->paxel.height > 256) {
 			dev_info(device->dev,
 				"Error: Invalid paxel dimention %d-%d\n",
 				config->paxel.width, config->paxel.height);
@@ -222,12 +221,13 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		/* IIR filter hz start setup. */
 		WRITE_REG(isp_af_regs[4].val, config->iir.hz_start_pos);
 
-		/* Setup paxel start position after IIR filter hz start setup. */
+		/* Setup paxel start position after */
+		/* IIR filter hz start setup. */
 		if (config->paxel.hz_start < (config->iir.hz_start_pos + 1) ||
 			config->paxel.hz_start > 4095 ||
 			config->paxel.vt_start > 4095) {
 			dev_info(device->dev,
-				"Error : Invalid paxel start position. (hz=%d vt=%d)\n",
+				"Error : Invalid paxel start. (hz=%d vt=%d)\n",
 				config->paxel.hz_start, config->paxel.vt_start);
 			goto func_exit;
 		}
@@ -250,7 +250,8 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 			goto func_exit;
 		}
 
-		if (config->paxel.line_incr > 8 || config->paxel.line_incr < 2) {
+		if (config->paxel.line_incr > 8 ||
+			config->paxel.line_incr < 2) {
 			dev_info(device->dev,
 				"Error: Invalid paxel line increment %d\n",
 				config->paxel.line_incr);
@@ -262,18 +263,23 @@ int hp3a_config_af(struct hp3a_af_config *config, struct hp3a_fh *fh)
 		OR_REG(isp_af_regs[2].val,
 			(config->paxel.vt_cnt - 1) << AF_VT_COUNT_SHIFT);
 		OR_REG(isp_af_regs[2].val,
-			((config->paxel.line_incr >> 1) - 1) << AF_LINE_INCR_SHIFT);
+			((config->paxel.line_incr >> 1) - 1) <<
+			AF_LINE_INCR_SHIFT);
 
 		/* Validate IIR filter coefficients. */
 		for (index = 0; index < AF_NUMBER_OF_COEF; ++index) {
 			if ((config->iir.coeff_set0[index]) > AF_COEF_MAX) {
 				dev_info(device->dev,
-					"Error : Coefficient(%d) for set 0 is incorrect\n", index);
+					"Err : Coefficient %d for set 0 "
+					" is incorrect\n",
+					index);
 				goto func_exit;
 			}
 			if ((config->iir.coeff_set1[index]) > AF_COEF_MAX) {
 				dev_info(device->dev,
-					"Error : Coefficient for(%d) set 1 is incorrect\n", index);
+					"Err : Coefficient %d for set 1 "
+					"wrong\n",
+					index);
 				goto func_exit;
 			}
 		}
diff --git a/drivers/media/video/hp3a/hp3a_common.h b/drivers/media/video/hp3a/hp3a_common.h
index 700733f..54141b5 100644
--- a/drivers/media/video/hp3a/hp3a_common.h
+++ b/drivers/media/video/hp3a/hp3a_common.h
@@ -43,7 +43,7 @@
 #define  AND_REG(x, v)		(x &= (u32)v)
 
 /* hp3a specific default values. */
-#define  MIN_RAW_CAPTURE_INTERVAL	2
+#define  MIN_RAW_CAPTURE_INTERVAL	1
 #define  MAX_STAT_BUFFERS_PER_FRAME	3
 
 enum {
@@ -127,6 +127,7 @@ struct hp3a_3x3with_offset {
 struct hp3a_sensor_param {
 	u32 exposure;
 	u16 gain;
+	u16 fps;
 };
 
 /**
@@ -140,6 +141,7 @@ struct hp3a_sensor_param_internal {
 	u32 frame_id;
 	u32 exposure;
 	u16 gain;
+	u16 fps;
 };
 
 /**
@@ -167,9 +169,9 @@ struct hp3a_histogram_config {
    u32 enable;
 	u8 hist_source;		/* CCDC or Memory */
 	u8 input_bit_width;	/* Needed o know the size per pixel */
-	u8 hist_frames;		/* Numbers of frames to be processed and accumulated */
-	u8 hist_h_v_info;	/* frame-input width and height if source is memory */
-	u8 hist_packed_pxl;	/* If data is packed packed 8-bit into 16 bits */
+	u8 hist_frames;	/* Num frames to be processed, accumulated */
+	u8 hist_h_v_info;	/* input width and height if source is memory */
+	u8 hist_packed_pxl;	/* If data is packed packed 8 into 16 bits */
 	u16 hist_radd;		/* frame-input address in memory */
 	u16 hist_radd_off;	/* line-offset for frame-input */
 	u16 hist_bins;		/* number of bins: 32, 64, 128, or 256 */
@@ -245,6 +247,7 @@ struct hp3a_statistics {
  **/
 struct hp3a_context {
 	int initialized;
+	int default_v4l2_dev;
 	int v4l2_streaming;
 	int update_hardpipe;
 	int hist_done;
@@ -259,10 +262,9 @@ struct hp3a_context {
 	u8 exposure_sync;
 	u8 gain_sync;
 	u32 hist_bin_size;
-	u32 current_exposure;
-	u32 current_gain;
-	u32 exposure;
-	u16 gain;
+	struct hp3a_sensor_param sensor_current;
+	struct hp3a_sensor_param sensor_requested;
+	struct hp3a_sensor_param sensor_stats;
 	u32 frame_count;
 	u32 req_af_buffer_size;
 	u32 req_raw_buffer_size;
diff --git a/drivers/media/video/hp3a/hp3a_ext.c b/drivers/media/video/hp3a/hp3a_ext.c
index b0f82c2..49faf20 100644
--- a/drivers/media/video/hp3a/hp3a_ext.c
+++ b/drivers/media/video/hp3a/hp3a_ext.c
@@ -33,7 +33,6 @@
  **/
 void hp3a_ccdc_done(void)
 {
-	++g_tc.frame_count;
 	hp3a_update_stats_readout_done();
 }
 EXPORT_SYMBOL(hp3a_ccdc_done);
@@ -45,6 +44,7 @@ EXPORT_SYMBOL(hp3a_ccdc_done);
  **/
 void hp3a_ccdc_start(void)
 {
+	++g_tc.frame_count;
 	hp3a_schedule_task();
 }
 EXPORT_SYMBOL(hp3a_ccdc_start);
@@ -57,11 +57,21 @@ EXPORT_SYMBOL(hp3a_ccdc_start);
 void hp3a_frame_done(void)
 {
 	hp3a_update_stats_pipe_done();
-	hp3a_update_hardpipe();
 }
 EXPORT_SYMBOL(hp3a_frame_done);
 
 /**
+ * hp3a_update_wb - Update WB related hw settings.
+ *
+ * No return value.
+ **/
+void hp3a_update_wb(void)
+{
+	hp3a_update_hardpipe();
+}
+EXPORT_SYMBOL(hp3a_update_wb);
+
+/**
  * hp3a_stream_on - Perform stream on specific tasks.
  *
  * No return value.
@@ -69,6 +79,11 @@ EXPORT_SYMBOL(hp3a_frame_done);
 void hp3a_stream_on(void)
 {
 	g_tc.frame_count = 0;
+
+	memset(&g_tc.sensor_current, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_requested, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_stats, 0, sizeof(struct hp3a_sensor_param));
+
 	g_tc.v4l2_streaming = 1;
 	g_tc.raw_cap_sched_count = 0;
 
diff --git a/drivers/media/video/hp3a/hp3a_hardpipe.c b/drivers/media/video/hp3a/hp3a_hardpipe.c
index eb5efcd..f83ace3 100644
--- a/drivers/media/video/hp3a/hp3a_hardpipe.c
+++ b/drivers/media/video/hp3a/hp3a_hardpipe.c
@@ -28,8 +28,8 @@
  **/
 void hp3a_update_hardpipe(void)
 {
-	if (!(omap_readl(ISPPRV_PCR) & ISPPRV_PCR_BUSY) &&
-		g_tc.update_hardpipe == 1) {
+	if (g_tc.update_hardpipe == 1 &&
+		!(omap_readl(ISPPRV_PCR) & ISPPRV_PCR_BUSY)) {
 		omap_writel(g_tc.hpipe_param.dgain, ISPPRV_WB_DGAIN);
 
 		omap_writel(g_tc.hpipe_param.r_gain |
diff --git a/drivers/media/video/hp3a/hp3a_histogram.c b/drivers/media/video/hp3a/hp3a_histogram.c
index 755834e..25919ea 100644
--- a/drivers/media/video/hp3a/hp3a_histogram.c
+++ b/drivers/media/video/hp3a/hp3a_histogram.c
@@ -106,19 +106,18 @@ static void hp3a_histogram_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 	u32 i;
 	struct hp3a_internal_buffer *ibuffer = NULL;
 
-	if (unlikely((HIST_DONE & status) != HIST_DONE)) {
+	if (unlikely((HIST_DONE & status) != HIST_DONE))
 		return;
-	}
 
 	omap_writel(omap_readl(ISPHIST_PCR) & ~(ISPHIST_PCR_EN), ISPHIST_PCR);
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (unlikely(g_tc.v4l2_streaming == 0))
 		return;
-	}
 
 	if (hp3a_dequeue(&g_tc.hist_hw_queue,  &ibuffer) == 0) {
 		/* If there is a buffer available then fill it. */
-		hist_buffer = (u32 *)phys_to_virt(page_to_phys(ibuffer->pages[0]));
+		hist_buffer = (u32 *)phys_to_virt(
+			page_to_phys(ibuffer->pages[0]));
 
 		omap_writel((omap_readl(ISPHIST_CNT)) | \
 			ISPHIST_CNT_CLR_EN, ISPHIST_CNT);
@@ -129,10 +128,10 @@ static void hp3a_histogram_isr(unsigned long status, isp_vbq_callback_ptr arg1,
 		omap_writel((omap_readl(ISPHIST_CNT)) & ~ISPHIST_CNT_CLR_EN,
 			ISPHIST_CNT);
 	} else {
-		/* There are no buffers availavle so just clear internal histogram memory. */
-		for (i = g_tc.hist_bin_size; i--;) {
+		/* There are no buffers availavle so just */
+		/* clear internal histogram memory. */
+		for (i = g_tc.hist_bin_size; i--;)
 			omap_writel(0, ISPHIST_DATA);
-		}
 	}
 
 	/* Set memory HW memory address and enable. */
@@ -169,12 +168,12 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		/* Install HIST_IRQ callback. */
 		ret = isp_set_callback(CBK_HIST_DONE, hp3a_histogram_isr,
 					(void *)NULL, (void *)NULL);
-		if (ret) {
+		if (ret)
 			return ret;
-		}
 
 		if (hp3a_hist_busy()) {
-			dev_info(device->dev, "Error: Histogram engine is busy!\n");
+			dev_info(device->dev, \
+				"Error: Histogram engine is busy\n");
 			return -EINVAL;
 		}
 
@@ -190,27 +189,35 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 
 		if (config->hist_source) {
 			/* source is memory. */
-			WRITE_HV_INFO(isp_hist_regs[14].val, config->hist_h_v_info);
+			WRITE_HV_INFO(isp_hist_regs[14].val,
+				config->hist_h_v_info);
 
-			if ((config->hist_radd & ISP_32B_BOUNDARY_BUF) == config->hist_radd) {
-				WRITE_RADD(isp_hist_regs[12].val, config->hist_radd);
+			if ((config->hist_radd & ISP_32B_BOUNDARY_BUF) ==
+				config->hist_radd) {
+				WRITE_RADD(isp_hist_regs[12].val,
+					config->hist_radd);
 			} else {
-				dev_info(device->dev, "Error: Address should be in 32 byte boundary\n");
+				dev_info(device->dev,
+					"Err: Addr needs 32 byte boundary\n");
 				goto func_exit;
 			}
 
-			if ((config->hist_radd_off & ISP_32B_BOUNDARY_OFFSET) == config->hist_radd_off) {
-				WRITE_RADD_OFF(isp_hist_regs[13].val, config->hist_radd_off);
+			if ((config->hist_radd_off &
+				ISP_32B_BOUNDARY_OFFSET) ==
+				config->hist_radd_off) {
+				WRITE_RADD_OFF(isp_hist_regs[13].val, \
+					config->hist_radd_off);
 			} else {
-				dev_info(device->dev, "Error: Offset should be in 32 byte boundary\n");
+				dev_info(device->dev,
+					"Err: Offset needs 32 byte boundary\n");
 				goto func_exit;
 			}
 		}
 
-		/* set data size bit if the pixel data is 8-bit wide and 2 pixels are packed in to 16-bits. */
-		if (config->hist_packed_pxl) {
+		/* set data size bit if the pixel data is 8-bit wide and */
+		/* 2 pixels are packed in to 16-bits. */
+		if (config->hist_packed_pxl)
 			WRITE_DATA_SIZE(isp_hist_regs[1].val, 1);
-		}
 
 		/* White Balance Field-to-Pattern Assignments */
 		if (unlikely((config->wb_gain_R > MAX_WB_GAIN)
@@ -227,9 +234,8 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		}
 
 		/* Regions size and position */
-		if (config->num_regions > MAX_REGIONS) {
+		if (config->num_regions > MAX_REGIONS)
 			goto func_exit;
-		}
 
 		/* Region 0. */
 		WRITE_REG_HORIZ(isp_hist_regs[3].val, config->reg0_hor);
@@ -251,8 +257,10 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 		/* Number of Bins. */
 		if (unlikely(((config->hist_bins > BINS_256) &&
 			(config->hist_bins != BINS_32)) ||
-			((config->hist_bins == BINS_256) && config->num_regions != 0) ||
-			((config->hist_bins == BINS_128) && config->num_regions >= 2))) {
+			((config->hist_bins == BINS_256) &&
+			config->num_regions != 0) ||
+			((config->hist_bins == BINS_128) &&
+			config->num_regions >= 2))) {
 			dev_info(device->dev,
 				"Error: Invalid Bins Number: %d\n",
 				config->hist_bins);
@@ -273,13 +281,16 @@ int hp3a_config_histogram(struct hp3a_histogram_config *config,
 				g_tc.hist_bin_size = HIST_MEM_SIZE;
 			} else if (config->hist_bins == BINS_128) {
 				bit_shift = config->input_bit_width - 7;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(1-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(1-config->num_regions));
 			} else if (config->hist_bins == BINS_64) {
 				bit_shift = config->input_bit_width - 6;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(2-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(2-config->num_regions));
 			} else if (config->hist_bins == BINS_32) {
 				bit_shift = config->input_bit_width - 5;
-				g_tc.hist_bin_size = (HIST_MEM_SIZE>>(3-config->num_regions));
+				g_tc.hist_bin_size = (HIST_MEM_SIZE>>
+					(3-config->num_regions));
 			} else {
 				goto func_exit;
 			}
diff --git a/drivers/media/video/hp3a/hp3a_ioctl.c b/drivers/media/video/hp3a/hp3a_ioctl.c
index ffc3ad3..32be4f0 100644
--- a/drivers/media/video/hp3a/hp3a_ioctl.c
+++ b/drivers/media/video/hp3a/hp3a_ioctl.c
@@ -60,9 +60,9 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		ret = hp3a_collect_statistics(&statistics);
 		if (SUCCEEDED(ret)) {
 			if (copy_to_user((struct hp3a_statistics *)arg,
-				&statistics, sizeof(struct hp3a_statistics)) != 0) {
+				&statistics,
+				sizeof(struct hp3a_statistics)) != 0)
 				ret = -EFAULT;
-			}
 		}
 		break;
 	}
@@ -107,7 +107,8 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
-			ret = hp3a_enqueue_irqsave(&g_tc.hist_stat_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.hist_stat_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -122,16 +123,19 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
 			if (ibuffer->isp_addr == 0) {
-				ibuffer->isp_addr = ispmmu_map_pages(ibuffer->pages,
+				ibuffer->isp_addr =
+					ispmmu_map_pages(ibuffer->pages,
 					NR_PAGES((unsigned long)ibuffer->user_addr,
 					ibuffer->buffer_size));
 				if (ibuffer->isp_addr == 0) {
-					dev_err(device->dev , "isp mmu failed to map memory!\n");
+					dev_err(device->dev , \
+						"isp mmu fail to map memory\n");
 					return -EFAULT;
 				}
 			}
 			flush_dcache_ibuffer(ibuffer);
-			ret = hp3a_enqueue_irqsave(&g_tc.af_stat_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.af_stat_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -146,15 +150,18 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 		if (index < fh->buffer_count && index > -1) {
 			ibuffer = &(fh->buffers[index]);
 			if (ibuffer->isp_addr == 0) {
-				ibuffer->isp_addr = ispmmu_map_pages(ibuffer->pages,
+				ibuffer->isp_addr =
+					ispmmu_map_pages(ibuffer->pages,
 					NR_PAGES((unsigned long)ibuffer->user_addr,
 					ibuffer->buffer_size));
 				if (ibuffer->isp_addr == 0) {
-					dev_err(device->dev , "isp mmu failed to map memory!\n");
+					dev_err(device->dev , \
+						"isp mmu fail to map memory\n");
 					return -EFAULT;
 				}
 			}
-			ret = hp3a_enqueue_irqsave(&g_tc.raw_frame_queue, &ibuffer);
+			ret = hp3a_enqueue_irqsave(&g_tc.raw_frame_queue,
+				&ibuffer);
 		}
 
 		break;
@@ -172,13 +179,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 			ret = -1;
 			if (req_buf.count > 0) {
 				fh->buffers = kzalloc(req_buf.count * \
-						sizeof(struct hp3a_internal_buffer),
-						GFP_KERNEL);
+					sizeof(struct hp3a_internal_buffer),
+					GFP_KERNEL);
 				if (fh->buffers) {
 					fh->buffer_count = req_buf.count;
-					for (i = 0; i < fh->buffer_count; ++i) {
+					for (i = 0; i < fh->buffer_count; ++i)
 						fh->buffers[i].index = i;
-					}
 					ret = 0;
 				}
 			}
@@ -198,10 +204,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 				(struct hp3a_buffer *)arg,
 				sizeof(struct hp3a_buffer)) == 0) {
 			ret = -1;
-			if (buffer.index >= 0 && buffer.index < fh->buffer_count) {
-				if (fh->buffers[buffer.index].buffer_size == 0) {
+			if (buffer.index >= 0 && buffer.index <
+				fh->buffer_count) {
+				if (fh->buffers[buffer.index].buffer_size
+					==	0) {
 					ret = map_user_to_kernel(&buffer,
-							&(fh->buffers[buffer.index]));
+						&(fh->buffers[buffer.index]));
 				}
 			}
 		} else {
@@ -220,10 +228,12 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 				(struct hp3a_buffer *)arg,
 				sizeof(struct hp3a_buffer)) == 0) {
 			ret = -1;
-			if (buffer.index >= 0 && buffer.index < fh->buffer_count) {
+			if (buffer.index >= 0 && buffer.index <
+				fh->buffer_count) {
 				if (fh->buffers[buffer.index].buffer_size &&
-						fh->buffers[buffer.index].pages) {
-					unmap_buffer_from_kernel(&(fh->buffers[buffer.index]));
+					fh->buffers[buffer.index].pages) {
+					unmap_buffer_from_kernel(
+						&(fh->buffers[buffer.index]));
 					ret = 0;
 				}
 			}
@@ -278,10 +288,9 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 			ret = hp3a_configure_raw(&config);
 			if (SUCCEEDED(ret)) {
 				if (copy_to_user((struct hp3a_raw_config *)arg,
-						&config,
-						sizeof(struct hp3a_raw_config)) != 0) {
+					&config,
+					sizeof(struct hp3a_raw_config)) != 0)
 					ret = -EFAULT;
-				}
 			}
 		} else {
 			ret = -EFAULT;
@@ -318,6 +327,7 @@ long hp3a_unlocked_ioctl(struct file *file, unsigned int cmd,
 	 */
 	case HP3A_S_V4L2_DEV_INDEX: {
 		fh->v4l2_dev = (int)arg;
+		g_tc.default_v4l2_dev = fh->v4l2_dev;
 		ret = 0;
 		break;
 	}
diff --git a/drivers/media/video/hp3a/hp3a_queue.c b/drivers/media/video/hp3a/hp3a_queue.c
index 9d7e553..0f374a0 100644
--- a/drivers/media/video/hp3a/hp3a_queue.c
+++ b/drivers/media/video/hp3a/hp3a_queue.c
@@ -29,7 +29,8 @@
  *
  * No return value.
  **/
-int hp3a_initialize_queue(struct hp3a_queue *queue, int queue_size, unsigned int element_size)
+int hp3a_initialize_queue(struct hp3a_queue *queue,
+		int queue_size, unsigned int element_size)
 {
 	if (queue_size > 0 && element_size > 0) {
 		queue->data = kmalloc(queue_size * element_size,  GFP_KERNEL);
@@ -161,7 +162,6 @@ int hp3a_dequeue(struct hp3a_queue *queue, void *element)
 
 		/* copy data from queue to element. */
 		memcpy(element, item, queue->element_size);
-
 		ret = 0;
 	}
 
@@ -195,7 +195,6 @@ int hp3a_dequeue_irqsave(struct hp3a_queue *queue, void *element)
 
 		/* copy data from queue to element. */
 		memcpy(element, item, queue->element_size);
-
 		ret = 0;
 	}
 
diff --git a/drivers/media/video/hp3a/hp3a_raw.c b/drivers/media/video/hp3a/hp3a_raw.c
index dc92e2e..2e81c0a 100644
--- a/drivers/media/video/hp3a/hp3a_raw.c
+++ b/drivers/media/video/hp3a/hp3a_raw.c
@@ -24,11 +24,7 @@
 
 static struct hp3a_reg isp_raw_regs[] = {
 	{HP3A_REG_32BIT, ISPCCDC_SYN_MODE, 0},
-	{HP3A_REG_32BIT, ISPCCDC_HORZ_INFO, 0},
-	{HP3A_REG_32BIT, ISPCCDC_VERT_START, 0},
-	{HP3A_REG_32BIT, ISPCCDC_VERT_LINES, 0},
 	{HP3A_REG_32BIT, ISPCCDC_HSIZE_OFF, 0},
-	{HP3A_REG_32BIT, ISPCCDC_SDOFST, 0},
 	{HP3A_REG_32BIT, ISPCCDC_SDR_ADDR, 0},
 	{HP3A_REG_32BIT, ISPCCDC_CFG, 0},
 	{HP3A_REG_TOK_TERM, 0, 0}
@@ -42,7 +38,7 @@ static struct hp3a_reg isp_raw_regs[] = {
 void hp3a_enable_raw(unsigned long buffer_addr)
 {
 	if (likely(buffer_addr != 0)) {
-		if (likely(g_tc.isp_ctx_saved == 0)) {
+		if (g_tc.isp_ctx_saved == 0) {
 			/* Save ISP registers. */
 			hp3a_read_ispregs(isp_raw_regs);
 			g_tc.isp_ctx_saved = 1;
@@ -60,19 +56,22 @@ void hp3a_enable_raw(unsigned long buffer_addr)
 		omap_writel(buffer_addr, ISPCCDC_SDR_ADDR);
 
 		/* Set register for line memory offset*/
-		omap_writel(ALIGN_TO((g_tc.raw_width << 1), 32), ISPCCDC_HSIZE_OFF);
+		omap_writel(ALIGN_TO((g_tc.raw_width << 1), 32),
+					ISPCCDC_HSIZE_OFF);
 
-		/*0 - By default Donot inverse the field identification */
-		omap_writel((omap_readl(ISPCCDC_SDOFST) & (~ISPCCDC_SDOFST_FINV)),
-								ISPCCDC_SDOFST);
-
-		/*0 - By default one line offset*/
-		omap_writel(omap_readl(ISPCCDC_SDOFST) & ISPCCDC_SDOFST_FOFST_1L,
-				ISPCCDC_SDOFST);
+		/*
+			The following registers must be set during CCDC config.
+			CCDC_HORZ_INFO
+			CCDC_VERT_START
+			CCDC_VERT_LINES
+			CCDC_SDOFST
+		*/
 
 		/* ISPCCDC_SYN_MODE must be set last. */
-		omap_writel((omap_readl(ISPCCDC_SYN_MODE) | ISPCCDC_SYN_MODE_WEN |
-				ISPCCDC_SYN_MODE_EXWEN | ISPCCDC_SYN_MODE_VP2SDR),
+		omap_writel((omap_readl(ISPCCDC_SYN_MODE) |
+				ISPCCDC_SYN_MODE_WEN |
+				ISPCCDC_SYN_MODE_EXWEN |
+				ISPCCDC_SYN_MODE_VP2SDR),
 				ISPCCDC_SYN_MODE);
 	}
 }
@@ -84,7 +83,7 @@ void hp3a_enable_raw(unsigned long buffer_addr)
  **/
 void hp3a_disable_raw(void)
 {
-	if (likely(g_tc.isp_ctx_saved == 1)) {
+	if (g_tc.isp_ctx_saved == 1) {
 		/* Restore ISP registers. */
 		hp3a_write_ispregs(isp_raw_regs);
 		g_tc.isp_ctx_saved = 0;
@@ -123,7 +122,8 @@ int hp3a_configure_raw(struct hp3a_raw_config *raw)
 		if (likely(g_tc.raw_width != 0 && g_tc.raw_height != 0)) {
 			g_tc.raw_hw_configured = 1;
 			g_tc.req_raw_buffer_size = (u32)ALIGN_TO(((ALIGN_TO( \
-				g_tc.raw_width, 16)*g_tc.raw_height)<<1), 0x1000);
+				g_tc.raw_width, 16)*g_tc.raw_height)<<1), \
+				0x1000);
 		} else {
 			g_tc.raw_hw_configured = 0;
 			g_tc.req_raw_buffer_size = -1;
diff --git a/drivers/media/video/hp3a/hp3a_stats.c b/drivers/media/video/hp3a/hp3a_stats.c
index f74b237..094b7ed 100644
--- a/drivers/media/video/hp3a/hp3a_stats.c
+++ b/drivers/media/video/hp3a/hp3a_stats.c
@@ -24,6 +24,7 @@
 
 #include "hp3a_common.h"
 #include "hp3a_queue.h"
+#include "hp3a_ispreg.h"
 #include "../oldomap34xxcam.h"
 #include "ispccdc.h"
 
@@ -62,10 +63,11 @@ void initialize_hp3a_framework(struct hp3a_dev *device)
 		g_tc.raw_width = 0;
 		g_tc.raw_height = 0;
 		g_tc.histogram_buffer = NULL;
-		g_tc.af_buffer  = NULL;
-		g_tc.raw_buffer  = NULL;
+		g_tc.af_buffer = NULL;
+		g_tc.raw_buffer = NULL;
 		g_tc.exposure_sync = 2;
 		g_tc.gain_sync = 1;
+		g_tc.default_v4l2_dev = 0;
 
 		/* Initialize task queues. */
 		hp3a_initialize_queue(&g_tc.hist_stat_queue, 8,
@@ -117,15 +119,14 @@ void hp3a_framework_start(struct hp3a_fh *fh)
 	fh->buffer_count = 0;
 	fh->buffers = NULL;
 	g_tc.frame_done.done = 0;
-	g_tc.current_exposure = 0;
-	g_tc.current_gain = 0;
-	g_tc.exposure = 0;
-	g_tc.gain = 0;
 	g_tc.hist_done = 0;
 	g_tc.hist_hw_enable = 0;
 	g_tc.af_hw_enable = 0;
-	g_tc.raw_hw_configured = 0;
 	g_tc.isp_ctx_saved = 0;
+
+	memset(&g_tc.sensor_current, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_requested, 0, sizeof(struct hp3a_sensor_param));
+	memset(&g_tc.sensor_stats, 0, sizeof(struct hp3a_sensor_param));
 }
 
 /**
@@ -140,22 +141,17 @@ void hp3a_framework_stop(struct hp3a_fh *fh)
 
 	spin_lock_irqsave(&g_tc.stats_lock, irqflags);
 
-	/* Reset flags. */
-	g_tc.v4l2_streaming = 0;
-
 	/* Need to flush queue. */
 	hp3a_flush_queue(&g_tc.sensor_write_queue);
 	hp3a_flush_queue(&g_tc.sensor_read_queue);
 	hp3a_flush_queue(&g_tc.raw_frame_queue);
 	hp3a_flush_queue(&g_tc.af_stat_queue);
 	hp3a_flush_queue(&g_tc.hist_stat_queue);
-	hp3a_flush_queue(&g_tc.hist_hw_queue);
-	hp3a_flush_queue(&g_tc.ready_stats_queue);
 
 	/* Internal buffer clean up. */
-	for (i = 0; i < fh->buffer_count; ++i) {
+	for (i = 0; i < fh->buffer_count; ++i)
 		unmap_buffer_from_kernel(&(fh->buffers[i]));
-	}
+
 	kfree(fh->buffers);
 	fh->buffers = NULL;
 
@@ -186,40 +182,63 @@ void hp3a_framework_stop(struct hp3a_fh *fh)
 int hp3a_set_sensor_param(struct hp3a_sensor_param *param, struct hp3a_fh *fh)
 {
 	int ret = -1;
-	struct hp3a_sensor_param_internal sensor_param;
+	struct hp3a_sensor_param_internal sensor_param = {
+		.exposure = 0,
+		.gain = 0,
+		.fps = 0};
 
 	if (likely(fh->v4l2_dev > -1)) {
 		if (likely(g_tc.v4l2_streaming == 1)) {
 			sensor_param.v4l2_dev = fh->v4l2_dev;
 			ret = 0;
 
-			if (g_tc.current_exposure != param->exposure) {
+			/* queue fps & exposure together */
+			if (param->fps && g_tc.sensor_requested.fps != \
+					param->fps) {
+				g_tc.sensor_requested.fps = param->fps;
+				sensor_param.fps = param->fps;
+			}
+
+			if (param->exposure &&
+					abs(g_tc.sensor_requested.exposure - \
+					param->exposure) > 2) {
+				g_tc.sensor_requested.exposure = \
+					param->exposure;
 				sensor_param.exposure = param->exposure;
-				sensor_param.gain = 0;
+			}
 
-				ret = hp3a_enqueue(&g_tc.sensor_write_queue,
-							&sensor_param);
+			if (sensor_param.fps || sensor_param.exposure) {
+				ret = hp3a_enqueue(
+				&g_tc.sensor_write_queue,
+				&sensor_param);
 			}
 
-			if (g_tc.current_gain != param->gain) {
-				sensor_param.exposure = 0;
+			if (param->gain &&
+				abs(g_tc.sensor_requested.gain - \
+					param->gain) > 2) {
+				g_tc.sensor_requested.gain = param->gain;
 				sensor_param.gain = param->gain;
-
-				ret = hp3a_enqueue(&g_tc.sensor_write_queue,
-						&sensor_param);
+				sensor_param.exposure = 0;
+				sensor_param.fps = 0;
+				ret = hp3a_enqueue(
+					&g_tc.sensor_write_queue,
+					&sensor_param);
 			}
 		} else {
 			struct cam_sensor_settings sensor_settings = {
 			.flags = 0,
 			.exposure = 0,
 			.gain = 0,
+			.fps = 0,
 			.regs = 0,
 			.reg_data = 0};
 
 			sensor_settings.exposure = param->exposure;
 			sensor_settings.gain = param->gain;
+			sensor_settings.fps = param->fps;
 			sensor_settings.flags = (OMAP34XXCAM_SET_GAIN | \
-						OMAP34XXCAM_SET_EXPOSURE);
+						OMAP34XXCAM_SET_EXPOSURE | \
+						OMAP34XXCAM_SET_FPS);
 
 			/**
 			* Write and read sensor settings.
@@ -228,7 +247,9 @@ int hp3a_set_sensor_param(struct hp3a_sensor_param *param, struct hp3a_fh *fh)
 							&sensor_settings);
 		}
 	} else {
-		dev_err(fh->device->dev, "hp3a: Invalid sensor id(%d)\n", fh->v4l2_dev);
+		dev_err(fh->device->dev,
+			"hp3a: Invalid sensor id(%d)\n",
+			fh->v4l2_dev);
 	}
 
 	return ret;
@@ -251,9 +272,8 @@ int hp3a_set_hardpipe_param(struct hp3a_hardpipe_param *param,
 	g_tc.update_hardpipe = 1;
 	spin_unlock_irqrestore(&g_tc.hardpipe_lock, irqflags);
 
-	if (g_tc.v4l2_streaming == 0) {
+	if (g_tc.v4l2_streaming == 0)
 		hp3a_update_hardpipe();
-	}
 
 	return 0;
 }
@@ -268,9 +288,8 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 {
 	unsigned long irqflags = 0;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (unlikely(g_tc.v4l2_streaming == 0))
 		return -1;
-	}
 
 	/* Initialize buffer indexes. */
 	stat->hist_stat_index = -1;
@@ -293,8 +312,8 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 
 		/* Frame meta data. */
 		stat->frame_id = g_tc.frame_count;
-		stat->exposure = g_tc.exposure;
-		stat->gain = g_tc.gain;
+		stat->exposure = g_tc.sensor_stats.exposure;
+		stat->gain = g_tc.sensor_stats.gain;
 
 		/* Raw bayer frame. */
 		if (g_tc.raw_buffer != NULL) {
@@ -313,15 +332,16 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 		/* Histogram. */
 		if (g_tc.histogram_buffer != NULL) {
 			if (g_tc.hist_done  == 1) {
-				stat->hist_stat_index = g_tc.histogram_buffer->index;
+				stat->hist_stat_index = \
+					g_tc.histogram_buffer->index;
 			} else {
-				hp3a_enqueue(&g_tc.hist_stat_queue, &g_tc.histogram_buffer);
+				hp3a_enqueue(&g_tc.hist_stat_queue,
+					&g_tc.histogram_buffer);
 			}
 			g_tc.histogram_buffer = NULL;
 		}
 
 		g_tc.hist_done = 0;
-
 		spin_unlock_irqrestore(&g_tc.stats_lock, irqflags);
 	}
 
@@ -336,10 +356,12 @@ int hp3a_collect_statistics(struct hp3a_statistics *stat)
 void hp3a_update_stats_readout_done(void)
 {
 	int i;
+	bool allow_exp_update = true;
+	bool allow_gain_update = true;
 	struct hp3a_internal_buffer *ibuffer;
 	struct hp3a_sensor_param_internal sensor_param;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
+	if (g_tc.v4l2_streaming == 0) {
 		hp3a_disable_histogram();
 		hp3a_disable_af();
 		return;
@@ -369,15 +391,18 @@ void hp3a_update_stats_readout_done(void)
 	for (i = MAX_STAT_BUFFERS_PER_FRAME; i--;) {
 		ibuffer = NULL;
 		if (hp3a_dequeue(&g_tc.ready_stats_queue, &ibuffer) == 0) {
-			if (ibuffer->type == HISTOGRAM && g_tc.histogram_buffer == NULL)
+			if (ibuffer->type == HISTOGRAM &&
+					g_tc.histogram_buffer == NULL)
 				g_tc.histogram_buffer = ibuffer;
-			else if (ibuffer->type == PAXEL && g_tc.af_buffer == NULL)
+			else if (ibuffer->type == PAXEL &&
+						g_tc.af_buffer == NULL)
 				g_tc.af_buffer = ibuffer;
-			else if (ibuffer->type == BAYER && g_tc.raw_buffer == NULL)
+			else if (ibuffer->type == BAYER &&
+						g_tc.raw_buffer == NULL)
 				g_tc.raw_buffer = ibuffer;
 			else {
-				printk(KERN_ERR "hp3a: Error unknown buffer type(%d) in"
-							" ready queue\n", ibuffer->type);
+				printk(KERN_ERR "hp3a: Error unknown "
+				"buffer type(%d)\n", ibuffer->type);
 			}
 		} else {
 			break;
@@ -387,12 +412,25 @@ void hp3a_update_stats_readout_done(void)
 	for (i = QUEUE_COUNT(g_tc.sensor_read_queue); i--;) {
 		if (hp3a_dequeue(&g_tc.sensor_read_queue, &sensor_param) == 0) {
 			if (sensor_param.frame_id == g_tc.frame_count) {
-				if (sensor_param.exposure)
-					g_tc.exposure = sensor_param.exposure;
-				if (sensor_param.gain)
-					g_tc.gain = sensor_param.gain;
+				if (sensor_param.exposure == -1) {
+					g_tc.sensor_stats.exposure = 0;
+					allow_exp_update = false;
+				} else if (sensor_param.exposure && \
+						allow_exp_update) {
+					g_tc.sensor_stats.exposure = \
+						sensor_param.exposure;
+				}
+				if (sensor_param.gain == -1) {
+					g_tc.sensor_stats.gain = 0;
+					allow_gain_update = false;
+				} else if (sensor_param.gain && \
+						allow_gain_update) {
+					g_tc.sensor_stats.gain = \
+						sensor_param.gain;
+				}
 			} else if (sensor_param.frame_id > g_tc.frame_count) {
-				hp3a_enqueue(&g_tc.sensor_read_queue, &sensor_param);
+				hp3a_enqueue(&g_tc.sensor_read_queue,
+								&sensor_param);
 			}
 		} else {
 			break;
@@ -417,25 +455,30 @@ void hp3a_update_stats_pipe_done(void)
 {
 	struct hp3a_internal_buffer *ibuffer;
 
-	if (unlikely(g_tc.v4l2_streaming == 0)) {
-		hp3a_disable_raw();
+	hp3a_disable_raw();
+
+	if (g_tc.v4l2_streaming == 0)
 		return;
-	}
 
 	/* RAW stat buffer processing. */
 	if (g_tc.raw_hw_configured == 1) {
 		if ((++g_tc.raw_cap_sched_count) == g_tc.raw_frequency) {
+			if (omap_readl(ISPCCDC_PCR) & ISPCCDC_PCR_BUSY) {
+				--g_tc.raw_cap_sched_count;
+				return;
+			}
 			g_tc.raw_cap_sched_count = 0;
 			ibuffer = NULL;
-			if (hp3a_dequeue(&g_tc.raw_frame_queue, &ibuffer) == 0) {
-				if (ibuffer->buffer_size >= g_tc.req_raw_buffer_size) {
+			if (hp3a_dequeue(&g_tc.raw_frame_queue, &ibuffer)
+				== 0) {
+				if (ibuffer->buffer_size >=
+					g_tc.req_raw_buffer_size) {
 					hp3a_enable_raw(ibuffer->isp_addr);
 					ibuffer->type = BAYER;
-					hp3a_enqueue(&g_tc.ready_stats_queue, &ibuffer);
+					hp3a_enqueue(&g_tc.ready_stats_queue,
+						&ibuffer);
 				}
 			}
-		} else if (g_tc.raw_cap_sched_count == 1) {
-			hp3a_disable_raw();
 		}
 	}
 }
@@ -463,49 +506,84 @@ static void hp3a_task(struct work_struct *work)
 {
 	/* Place holder for deferred tasks. */
 	struct hp3a_sensor_param_internal sensor_param;
+	struct hp3a_sensor_param_internal empty_param = {
+		.exposure = 0,
+		.gain = 0,
+		.fps = 0};
 	struct cam_sensor_settings sensor_settings = {
 		.flags = 0,
 		.exposure = 0,
 		.gain = 0,
 		.regs = 0,
+		.fps = 0,
 		.reg_data = 0};
-	u32 frame_index = (g_tc.frame_count+1);
+	u32 cur_frame = g_tc.frame_count;
 
 	/**
 	 * Setup exposure and gain for next frame.
 	 */
-	if (hp3a_dequeue(&g_tc.sensor_write_queue, &sensor_param) == 0) {
+	if (hp3a_dequeue(&g_tc.sensor_write_queue,
+							&sensor_param) == 0) {
 		sensor_settings.exposure = sensor_param.exposure;
 		sensor_settings.gain = sensor_param.gain;
+		sensor_settings.fps = sensor_param.fps;
+
+		if (sensor_param.fps)
+			sensor_settings.flags |= OMAP34XXCAM_SET_FPS;
 
 		if (sensor_param.exposure)
 			sensor_settings.flags |= OMAP34XXCAM_SET_EXPOSURE;
+
 		if (sensor_param.gain)
 			sensor_settings.flags |= OMAP34XXCAM_SET_GAIN;
 
 		/**
-		* Write and read sensor settings.
-		*/
-		omap34xxcam_sensor_settings(sensor_param.v4l2_dev, &sensor_settings);
-
-		if (g_tc.current_gain != sensor_settings.gain) {
-			sensor_param.frame_id = (frame_index + g_tc.gain_sync);
+		 * Write and read sensor settings.
+		 */
+		omap34xxcam_sensor_settings(sensor_param.v4l2_dev,
+			&sensor_settings);
+
+		if (g_tc.sensor_current.gain != sensor_settings.gain) {
+			if (g_tc.gain_sync > 1) {
+				empty_param.frame_id = cur_frame + 1;
+				empty_param.gain = -1;
+				hp3a_enqueue_irqsave(
+					&g_tc.sensor_read_queue,
+					&empty_param);
+			}
+			sensor_param.frame_id = \
+				(cur_frame + g_tc.gain_sync);
+			sensor_param.fps = sensor_settings.fps;
 			sensor_param.exposure = 0;
 			sensor_param.gain = sensor_settings.gain;
 			/* Queue new value for stats collecton. */
-			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue, &sensor_param);
+			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue,
+				&sensor_param);
 			/* Save new programmed in gain value. */
-			g_tc.current_gain = sensor_settings.gain;
+			g_tc.sensor_current.gain = sensor_settings.gain;
 		}
 
-		if (g_tc.current_exposure != sensor_settings.exposure) {
-			sensor_param.frame_id = (frame_index + g_tc.exposure_sync);
+		if (g_tc.sensor_current.exposure != sensor_settings.exposure) {
+			if (g_tc.exposure_sync > 1) {
+				empty_param.frame_id = cur_frame + 1;
+				empty_param.gain = 0;
+				empty_param.exposure = -1;
+				hp3a_enqueue_irqsave(
+					&g_tc.sensor_read_queue,
+					&empty_param);
+			}
+			sensor_param.frame_id = \
+				(cur_frame + g_tc.exposure_sync);
+			sensor_param.fps = sensor_settings.fps;
 			sensor_param.exposure = sensor_settings.exposure;
 			sensor_param.gain = 0;
 			/* Queue new value for stats collecton. */
-			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue, &sensor_param);
+			hp3a_enqueue_irqsave(&g_tc.sensor_read_queue,
+				&sensor_param);
 			/* Save new programmed in exposure value. */
-			g_tc.current_exposure = sensor_settings.exposure;
+			g_tc.sensor_current.exposure = sensor_settings.exposure;
 		}
+
+		g_tc.sensor_current.fps = sensor_settings.fps;
 	}
 }
diff --git a/drivers/media/video/hplens.c b/drivers/media/video/hplens.c
index ad29e04..d687519 100644
--- a/drivers/media/video/hplens.c
+++ b/drivers/media/video/hplens.c
@@ -258,7 +258,8 @@ static int hplens_ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power on)
  * from the video_control[] array.  Otherwise, returns -EINVAL if the
  * control is not supported.
  */
-static int hplens_ioctl_queryctrl(struct v4l2_int_device *s, struct v4l2_queryctrl *qc)
+static int hplens_ioctl_queryctrl(struct v4l2_int_device *s,
+			struct v4l2_queryctrl *qc)
 {
 	int i;
 
@@ -298,36 +299,42 @@ static int hplens_ioctl_s_ctrl(struct v4l2_int_device *s,
 
 	switch (vc->id) {
 	case V4L2_CID_HPLENS_CMD_READ: {
-		ret = copy_from_user(&reg, (void *)vc->value,  sizeof(struct hplens_reg));
+		ret = copy_from_user(&reg, (void *)vc->value,  \
+			sizeof(struct hplens_reg));
 		if (ret == 0) {
-			if (reg.addr[0] != 0xff) {   /* valid register address */
+			if (reg.addr[0] != 0xff) {
+				/* valid register address */
 				/* write the register address to read */
-				ret = hplens_reg_write(reg.dev_addr, reg.addr, reg.len_addr);
+				ret = hplens_reg_write(reg.dev_addr, \
+					reg.addr, reg.len_addr);
 			}
 			/* Read the register */
-			ret = hplens_reg_read(reg.dev_addr, reg.data, reg.len_data);
+			ret = hplens_reg_read(reg.dev_addr, \
+				reg.data, reg.len_data);
 			if (ret == 0) {
-				ret = copy_to_user((void *)vc->value, &reg, sizeof(struct hplens_reg));
+				ret = copy_to_user((void *)vc->value, &reg, \
+					sizeof(struct hplens_reg));
 			}
 		}
 	}
 	break;
 	case V4L2_CID_HPLENS_CMD_WRITE: {
-		ret = copy_from_user(&reg, (void *)vc->value,  sizeof(struct hplens_reg));
+		ret = copy_from_user(&reg, (void *)vc->value,  \
+			sizeof(struct hplens_reg));
 		if (ret == 0) {
 			if (reg.addr[0] != 0xff) { /* valid register address */
 				while (fdb < reg.len_addr) {
-					/* put the register address to write in the buffer first */
+					/* write register address in buffer */
 					write_buffer[fdb] = reg.addr[fdb];
 					fdb++;
 				}
 			}
 
-			for (idx = fdb; idx <= reg.len_data; idx++) {
+			for (idx = fdb; idx <= reg.len_data; idx++)
 				write_buffer[idx] = reg.data[idx-fdb];
-			}
 
-			ret = hplens_reg_write(reg.dev_addr, write_buffer, reg.len_data + fdb);
+			ret = hplens_reg_write(reg.dev_addr, \
+				write_buffer, reg.len_data + fdb);
 		}
 	}
 	break;
@@ -335,22 +342,25 @@ static int hplens_ioctl_s_ctrl(struct v4l2_int_device *s,
 
 		/* Using dynamic memory. */
 		eeprom = kmalloc(sizeof(struct hplens_eeprom), GFP_KERNEL);
-		if(eeprom == NULL){
+		if (eeprom == NULL)
 			return -EINVAL;
-		}
 
-		ret = copy_from_user(eeprom, (void *)vc->value,  sizeof(struct hplens_eeprom));
+		ret = copy_from_user(eeprom, (void *)vc->value,  \
+			sizeof(struct hplens_eeprom));
 		if (ret == 0) {
-			if (eeprom->addr[0] != 0xff) {   /* valid register address */
+			if (eeprom->addr[0] != 0xff) {
+				/* valid register address */
 				/* write the register address to read */
-				ret = hplens_reg_write(eeprom->dev_addr, eeprom->addr, eeprom->len_addr);
+				ret = hplens_reg_write(eeprom->dev_addr, \
+					eeprom->addr, eeprom->len_addr);
 			}
 
 			/* Read the register */
-			ret = hplens_reg_read(eeprom->dev_addr, eeprom->data, eeprom->len_data);
-			if (ret == 0) {
-				ret = copy_to_user((void *)vc->value, eeprom, sizeof(struct hplens_eeprom));
-			}
+			ret = hplens_reg_read(eeprom->dev_addr, \
+				eeprom->data, eeprom->len_data);
+			if (ret == 0)
+				ret = copy_to_user((void *)vc->value, eeprom, \
+					sizeof(struct hplens_eeprom));
 		}
 
 		/* clean up. */
@@ -401,7 +411,8 @@ static struct v4l2_int_device hplens_int_device = {
  *
  * Returns 0 if successful, or -EBUSY if unable to get client attached data.
  **/
-static int hplens_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static int hplens_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
 {
 	struct hplens_device *lens = &hplens;
 	int err;
@@ -427,7 +438,8 @@ static int hplens_probe(struct i2c_client *client, const struct i2c_device_id *i
 
 	err = v4l2_int_device_register(lens->v4l2_int_device);
 	if (err) {
-		printk(KERN_ERR "Failed to Register " DRIVER_NAME " as V4L2 device.\n");
+		printk(KERN_ERR "Failed to Register " \
+			DRIVER_NAME " as V4L2 device.\n");
 		i2c_set_clientdata(client, NULL);
 	} else {
 		printk(KERN_ERR "Registered " DRIVER_NAME " as V4L2 device.\n");
diff --git a/drivers/media/video/mipi_dli.c b/drivers/media/video/mipi_dli.c
new file mode 100644
index 0000000..4ee87ba
--- /dev/null
+++ b/drivers/media/video/mipi_dli.c
@@ -0,0 +1,185 @@
+/*
+ * driver/media/video/mipi_dli.c
+ *
+ * Copyright 2009 Motorola Corporation.
+ *
+ * Authors: DongSun Yang. <mbr863@motorola.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>		/* everything... */
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+#include "oldisp/ispreg.h"
+#include <linux/uaccess.h>
+
+#include <linux/mipi_dli.h>
+
+struct mipi_dli_platform_data {
+	struct mutex lock;		    /* Mutex lock */
+	unsigned long FrameCount;    /* total frames after last reset */
+	unsigned long ECCErrors;       /* ECC errors after last reset */
+	unsigned long CRCErrors;       /* CRC errors after last reset */
+};
+
+/*Counters for MIPI DLI.*/
+unsigned long frame_counter;
+unsigned long ecc_counter;
+unsigned long crc_counter;
+
+static int mipi_dli_open(struct inode *inode, struct file *file)
+{
+  printk(KERN_ERR "%s is called.\n", __func__);
+  return nonseekable_open(inode, file);
+}
+
+static int mipi_dli_release(struct inode *inode, struct file *file)
+{
+  printk(KERN_ERR "%s is called.\n", __func__);
+  return 0;
+}
+
+static int mipi_dli_ioctl(struct inode *inode, struct file *file,\
+				unsigned int cmd, unsigned long arg)
+{
+	unsigned long mipi_counter;
+	void __user *argp = (void __user *)arg;
+
+	int ret = 0;
+
+	printk(KERN_ERR "mipi_dli_ioctl function start.\n");
+
+	if (copy_from_user(&mipi_counter, argp, sizeof(mipi_counter)))
+		return -EFAULT;
+
+	printk(KERN_ERR "mipi_dli_ioctl operation start.\n");
+
+	if (mipi_counter == 0) {
+		/*Reset counter.*/
+		switch (cmd) {
+		case MIPI_DLI_IOCTL_FRAME_COUNT:
+			mipi_counter = omap_readl(ISPCSI2_CTX_CTRL2(0));
+			mipi_counter = (mipi_counter & 0xFFFF0000) >> 16;
+			frame_counter = mipi_counter;
+			break;
+
+		case MIPI_DLI_IOCTL_ECC_COUNT:
+			ecc_counter = 0;
+			break;
+
+		case MIPI_DLI_IOCTL_CRC_COUNT:
+			crc_counter = 0;
+			break;
+
+		default:
+			printk(KERN_ERR "Unexpected parameter.\n");
+			ret = -EINVAL;
+			break;
+		}
+	} else {
+		/*Get counter.*/
+		switch (cmd)	{
+		case MIPI_DLI_IOCTL_FRAME_COUNT:
+			mipi_counter = omap_readl(ISPCSI2_CTX_CTRL2(0));
+			mipi_counter = (mipi_counter & 0xFFFF0000) >> 16;
+			mipi_counter -= frame_counter;
+			break;
+
+		case MIPI_DLI_IOCTL_ECC_COUNT:
+			mipi_counter = ecc_counter;
+			break;
+
+		case MIPI_DLI_IOCTL_CRC_COUNT:
+			mipi_counter = crc_counter;
+			break;
+
+		default:
+			printk(KERN_ERR "Unexpected parameter.\n");
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret != 0) {
+			printk(KERN_ERR "mipi_dli cmd fail %d.\n", cmd);
+			return -EFAULT;
+		} else
+			printk(KERN_ERR "mipi_counter = %ld.\n",\
+				mipi_counter);
+
+		if (copy_to_user(argp, &mipi_counter, sizeof(mipi_counter)))
+			ret = -EFAULT;
+	}
+
+	return ret;
+}
+
+static const struct file_operations mipi_dli_fops = {
+	.owner   = THIS_MODULE,
+	.open    = mipi_dli_open,
+	.release = mipi_dli_release,
+	.ioctl   = mipi_dli_ioctl,
+};
+
+static struct miscdevice mipi_dli_device = {
+  .minor = MISC_DYNAMIC_MINOR,
+  .name = MIPI_DLI_DEVICE_NAME,
+  .fops = &mipi_dli_fops,
+};
+
+
+static int __init mipi_dli_probe(struct platform_device *pdev)
+{
+	struct mipi_dli_platform_data *mipi_dli;
+	int ret = 0;
+
+	mipi_dli = kzalloc(sizeof(struct mipi_dli_platform_data), GFP_KERNEL);
+	if (!mipi_dli)
+		return -ENOMEM;
+
+	ret = misc_register(&mipi_dli_device);
+
+	if (ret != 0)
+		printk(KERN_ERR "misc_register failed\n");
+
+	mutex_init(&mipi_dli->lock);
+
+	printk(KERN_ERR "MIPI DLI tester probe is finished.\n");
+
+	return ret;
+}
+
+static int mipi_dli_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static void mipi_dli_shutdown(struct platform_device *pdev)
+{
+}
+
+static struct platform_driver mipi_dli_driver = {
+	.driver		= {
+		.name	= "mipi_dli_tester",
+	},
+	.remove		= __devexit_p(mipi_dli_remove),
+	.shutdown	= mipi_dli_shutdown,
+};
+
+static int __init mipi_dli_init(void)
+{
+	int retval = 0;
+	retval = platform_driver_probe(&mipi_dli_driver, mipi_dli_probe);
+	if (retval != 0) {
+		printk(KERN_ERR "failed mipi dli register/probe %d\n", retval);
+		return -ENODEV;
+	}
+	return retval;
+}
+
+subsys_initcall(mipi_dli_init);
+
+MODULE_AUTHOR("Motorola Corporation");
+MODULE_DESCRIPTION("MIPI DLI test Module");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/mt9p012.c b/drivers/media/video/mt9p012.c
index 231e67f..93d52f7 100644
--- a/drivers/media/video/mt9p012.c
+++ b/drivers/media/video/mt9p012.c
@@ -723,6 +723,8 @@ static int mt9p012_read_reg(struct i2c_client *client, u16 data_length,
 	data[0] = (u8) (reg >> 8);;
 	data[1] = (u8) (reg & 0xff);
 	err = i2c_transfer(client->adapter, msg, 1);
+	udelay(50);
+
 	if (err >= 0) {
 		msg->len = data_length;
 		msg->flags = I2C_M_RD;
@@ -774,7 +776,7 @@ static int mt9p012_write_reg(struct i2c_client *client, u16 data_length,
 again:
 	msg->addr = client->addr;
 	msg->flags = 0;
-	msg->len = 2 + data_length;
+	msg->len = data_length + 2;
 	msg->buf = data;
 
 	/* high byte goes out first */
@@ -797,12 +799,12 @@ again:
 	if (err >= 0)
 		return 0;
 
-	v4l_dbg(1, debug, client, "wrote 0x%x to offset 0x%x error %d", val,
-							reg, err);
 	if (retry <= MT9P012_I2C_RETRY_COUNT) {
-		v4l_warn(client, "retry ... %d", retry);
+		dev_dbg(&client->dev, "0x%x=0x%x retry ... %d\n",
+			reg, val, retry);
 		retry++;
-		mdelay(20);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(msecs_to_jiffies(20));
 		goto again;
 	}
 
@@ -885,7 +887,8 @@ static enum mt9p012_image_size mt9p012_find_isize(unsigned int width)
 	return isize;
 }
 
-static enum mt9p012_frame_type mt9p012_find_iframe(enum mt9p012_image_size isize)
+static enum mt9p012_frame_type mt9p012_find_iframe(
+		enum mt9p012_image_size isize)
 {
 	enum mt9p012_frame_type iframe = 0;
 
@@ -1275,7 +1278,7 @@ static int mt9p012_set_framerate(struct v4l2_int_device *s,
 	sensor->abs_max_exposure_time = (line_time_q8 *
 				     (MT9P012_MAX_FRAME_LENGTH_LINES - 1)) >> 8;
 	sensor->fps_max_exposure_time = (line_time_q8 *
-				     (frame_length_lines - 1)) >> 8;
+				(frame_length_lines - 1)) >> 8;
 
 	/* Update Exposure Time */
 	i = find_vctrl(sensor, V4L2_CID_EXPOSURE);
@@ -1290,10 +1293,10 @@ static int mt9p012_set_framerate(struct v4l2_int_device *s,
 	}
 
 	v4l_info(client, "MT9P012 Set Framerate: fper=%d/%d, "
-		 "frame_len_lines=%d, fps_max_expT=%dus, "
-		 "abs_max_expT=%dus\n",
-		 fper->numerator, fper->denominator, frame_length_lines,
-		 sensor->fps_max_exposure_time, sensor->abs_max_exposure_time);
+		"frame_len_lines=%d, fps_max_expT=%dus, "
+		"abs_max_expT=%dus\n",
+		fper->numerator, fper->denominator, frame_length_lines,
+		sensor->fps_max_exposure_time, sensor->abs_max_exposure_time);
 
 	return err;
 }
@@ -1415,6 +1418,7 @@ int mt9p012_configure_frame(struct v4l2_int_device *s,
 
 	err |= mt9p012_write_reg(client, MT9P012_16BIT, REG_FINE_CORRECTION,
 				 sensor_settings[iframe].exposure.fine_correction);
+
 	/* update */
 	err |= mt9p012_write_reg(client, MT9P012_8BIT, REG_GROUPED_PAR_HOLD, 0x00);
 
@@ -2113,8 +2117,23 @@ err_on:
 		sensor->pdata->set_xclk(0);
 		break;
 	case V4L2_POWER_STANDBY:
-		if (sensor->detected)
+		if (sensor->detected) {
 			mt9p012_write_regs(c, stream_off_list);
+			/*
+			 * Work around, black image is captured on HW with 39pf
+			 * capacitor in camera pclk line (for RF desense).
+			 *
+			 * Resetting the sensor here eliminates the issue.
+			 * Remove this workaround after root cause determined.
+			 *
+			 * Workaround allows HW with cap to function properly.
+			 * The capacitor has been removed for production.
+			 * This has no other effect on operation, since the
+			 * sensor is always reset on V4L2_POWER_ON
+			 * (i.e. out of standby) in mt9p012_configure.
+			 */
+			mt9p012_write_regs(c, mt9p012_common_pre);
+		}
 		sensor->power_on = false;
 		rval = sensor->pdata->power_set(sensor->dev, V4L2_POWER_STANDBY);
 		sensor->pdata->set_xclk(0);
diff --git a/drivers/media/video/oldisp/isp.c b/drivers/media/video/oldisp/isp.c
index c407905..7566b0f 100644
--- a/drivers/media/video/oldisp/isp.c
+++ b/drivers/media/video/oldisp/isp.c
@@ -66,13 +66,11 @@
 #endif
 
 
-#if ISP_WORKAROUND
 void *buff_addr;
 dma_addr_t buff_addr_mapped;
 struct scatterlist *sglist_alloc;
 static int alloc_done, num_sc;
 unsigned long offset_value;
-#endif
 
 struct completion isp_wfc;
 
@@ -218,6 +216,7 @@ struct isp_sgdma ispsg;
 struct ispmodule {
 	unsigned int isp_pipeline;
 	int isp_temp_state;
+	int isp_lsc_workaround;
 	int applyCrop;
 	struct v4l2_pix_format pix;
 	unsigned int ccdc_input_width;
@@ -237,6 +236,7 @@ struct ispmodule {
 static struct ispmodule ispmodule_obj = {
 	.isp_pipeline = OMAP_ISP_CCDC,
 	.isp_temp_state = ISP_BUF_INIT,
+	.isp_lsc_workaround = ISP_WORKAROUND,
 	.applyCrop = 0,
 	.pix = {
 		.width = ISP_OUTPUT_WIDTH_DEFAULT,
@@ -278,6 +278,11 @@ static struct isp_reg isp_reg_list[] = {
 	{ISP_TOK_TERM, 0}
 };
 
+int isp_lsc_workaround_enabled(void)
+{
+	return ispmodule_obj.isp_lsc_workaround;
+}
+
 /*
  *
  * V4L2 Handling
@@ -347,30 +352,6 @@ void isp_release_resources(void)
 /* Flag to check first time of isp_get */
 static int off_mode;
 
-static void isp_lsc_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			void *arg2)
-{
-	(void) arg1;
-	(void) arg2;
-
-	if (status & LSC_PRE_ERR) {
-		/* printk(KERN_ERR "isp_sr: LSC_PRE_ERR \n"); */
-		ispccdc_enable_lsc(0);
-		ispccdc_enable_lsc(1);
-	}
-}
-
-static void isp_csia_isr(unsigned long status, isp_vbq_callback_ptr arg1,
-			void *arg2)
-{
-	(void) arg1;
-	(void) arg2;
-
-	if (status & CSIA) {
-		isp_csi2_isr();
-	}
-}
-
 /**
  * isp_set_sgdma_callback - Set Scatter-Gather DMA Callback.
  * @sgdma_state: Pointer to structure with the SGDMA state for each videobuffer
@@ -396,7 +377,8 @@ static int isp_set_sgdma_callback(struct isp_sgdma_state *sgdma_state,
 							sgdma_state->arg);
 		isp_set_callback(CBK_CCDC_VD1, sgdma_state->callback, func_ptr,
 							sgdma_state->arg);
-		isp_set_callback(CBK_LSC_ISR, isp_lsc_isr, NULL, NULL);
+		isp_set_callback(CBK_LSC_ISR, (isp_callback_t)isp_lsc_isr,
+		NULL, NULL);
 	}
 
 	/* isp_set_callback(CBK_SBL_OVF, NULL, NULL, NULL); */
@@ -588,7 +570,7 @@ int isp_unset_callback(enum isp_callback_type type)
 		break;
 	case CBK_SBL_OVF:
 		omap_writel((omap_readl(ISP_IRQ0ENABLE)) &
-						~IRQ0ENABLE_OVF_IRQ, ISP_IRQ0ENABLE);
+			~IRQ0ENABLE_OVF_IRQ, ISP_IRQ0ENABLE);
 		break;
 	default:
 		break;
@@ -960,9 +942,6 @@ int isp_configure_interface(struct isp_interface_config *config)
 		ispctrl_val &= ~ISPCTRL_PAR_BRIDGE_BENDIAN;
 		ispctrl_val |= (0x03 << ISPCTRL_PAR_BRIDGE_SHIFT);
 
-		isp_csi2_ctx_config_format(0, config->u.csi.format);
-		isp_csi2_ctx_update(0, false);
-
 		if (config->u.csi.crc)
 			isp_csi2_ctrl_config_ecc_enable(true);
 
@@ -971,7 +950,11 @@ int isp_configure_interface(struct isp_interface_config *config)
 		isp_csi2_ctrl_config_vp_clk_enable(true);
 		isp_csi2_ctrl_update(false);
 
-		isp_set_callback(CBK_CSIA, isp_csia_isr, NULL, NULL);
+		isp_csi2_ctx_config_format(0, config->u.csi.format);
+		isp_csi2_ctx_update(0, false);
+
+		isp_set_callback(CBK_CSIA, (isp_callback_t)isp_csia_isr,
+		NULL, NULL);
 
 		isp_csi2_irq_complexio1_set(1);
 		isp_csi2_irq_status_set(1);
@@ -996,12 +979,15 @@ int isp_configure_interface(struct isp_interface_config *config)
 	omap_writel(ispctrl_val, ISP_CTRL);
 	spin_unlock(&isp_obj.isp_temp_buf_lock);
 	ispccdc_vdint_val = omap_readl(ISPCCDC_VDINT);
+
 	ispccdc_vdint_val &= ~(ISPCCDC_VDINT_0_MASK << ISPCCDC_VDINT_0_SHIFT);
 	ispccdc_vdint_val &= ~(ISPCCDC_VDINT_1_MASK << ISPCCDC_VDINT_1_SHIFT);
+/* - disabled, causing VDINT to be reset to 0 at start_streaming
 	omap_writel((config->vdint0_timing << ISPCCDC_VDINT_0_SHIFT) |
 						(config->vdint1_timing <<
 						ISPCCDC_VDINT_1_SHIFT),
 						ISPCCDC_VDINT);
+*/
 
 	/* Set sensor specific fields in CCDC and Previewer module.*/
 	ispccdc_set_wenlog(config->wenlog);
@@ -1038,11 +1024,15 @@ EXPORT_SYMBOL(isp_configure_interface_bridge);
  **/
 void isp_CCDC_VD01_enable(void)
 {
-	omap_writel(IRQ0STATUS_CCDC_VD0_IRQ | IRQ0STATUS_CCDC_VD1_IRQ,
-							ISP_IRQ0STATUS);
-	omap_writel(omap_readl(ISP_IRQ0ENABLE) | IRQ0ENABLE_CCDC_VD0_IRQ |
-						IRQ0ENABLE_CCDC_VD1_IRQ,
-						ISP_IRQ0ENABLE);
+	u32 irq_enable = omap_readl(ISP_IRQ0ENABLE);
+
+	if (!(irq_enable & (IRQ0ENABLE_CCDC_VD0_IRQ | \
+		IRQ0ENABLE_CCDC_VD1_IRQ))) {
+		omap_writel(IRQ0STATUS_CCDC_VD0_IRQ | \
+			IRQ0STATUS_CCDC_VD1_IRQ, ISP_IRQ0STATUS);
+		omap_writel(irq_enable | (IRQ0ENABLE_CCDC_VD0_IRQ | \
+			IRQ0ENABLE_CCDC_VD1_IRQ), ISP_IRQ0ENABLE);
+	}
 }
 
 /**
@@ -1074,14 +1064,18 @@ static irqreturn_t omap34xx_isp_isr(int irq, void *ispirq_disp)
 	int i;
 	struct ispirq *irqdis = (struct ispirq *)ispirq_disp;
 	u32 irqstatus;
+	unsigned long irqflags = 0;
 
+	spin_lock_irqsave(&isp_obj.lock, irqflags);
 	irqstatus = omap_readl(ISP_IRQ0STATUS);
 	omap_writel(irqstatus, ISP_IRQ0STATUS);
 	/* The following register read is for write sync. */
 	omap_readl(ISP_IRQ0STATUS);
+	spin_unlock_irqrestore(&isp_obj.lock, irqflags);
 
 	for (i = 0; i < CBK_END; ++i) {
-		if ((irqstatus & irqdis->irq_events[i]) == irqdis->irq_events[i]) {
+		if ((irqstatus & irqdis->irq_events[i]) == \
+				irqdis->irq_events[i]) {
 			if (irqdis->isp_callbk[i]) {
 				irqdis->isp_callbk[i](irqdis->irq_events[i],
 				irqdis->isp_callbk_arg1[i],
@@ -1124,35 +1118,41 @@ void omapisp_unset_callback()
 		/* isp_unset_callback(CBK_SBL_OVF); */
 	}
 
-	if (isp_obj.if_status & ISP_CSIA) {
+	if (isp_obj.if_status & ISP_CSIA)
 		isp_unset_callback(CBK_CSIA);
-	}
 
 	omap_writel(omap_readl(ISP_IRQ0STATUS) | ISP_INT_CLR, ISP_IRQ0STATUS);
 }
 EXPORT_SYMBOL(omapisp_unset_callback);
 
-#if ISP_WORKAROUND
 /**
- *  isp_buf_allocation - To allocate a 10MB memory
+ *  isp_buf_allocation - To allocate isp workaround buffer
  *
  **/
 u32 isp_buf_allocation(void)
 {
-	buff_addr = (void *) vmalloc(ISP_BUFFER_MAX_SIZE);
+	if (alloc_done == 0) {
+		buff_addr = (void *) vmalloc(ISP_BUFFER_MAX_SIZE);
 
-	if (!buff_addr) {
-		printk(KERN_ERR "ISP_ERR: Cannot allocate "
-			"ISP_WORKAROUND memory\n");
-		return -ENOMEM;
-	}
+		if (!buff_addr) {
+			printk(KERN_ERR "ISP_ERR: Cannot allocate "
+				"ISP_WORKAROUND memory\n");
+			return -ENOMEM;
+		}
 
-	sglist_alloc = videobuf_vmalloc_to_sg(buff_addr, ISP_BUFFER_MAX_PAGES);
-	if (!sglist_alloc) {
-		printk(KERN_ERR "ISP_ERR: videobuf_vmalloc_to_sg failed\n");
-		return -ENOMEM;
+		sglist_alloc = videobuf_vmalloc_to_sg(buff_addr,
+		ISP_BUFFER_MAX_PAGES);
+		if (!sglist_alloc) {
+			printk(KERN_ERR "ISP_ERR: videobuf_vmalloc_to_sg failed\n");
+			vfree(buff_addr);
+			buff_addr = NULL;
+			return -ENOMEM;
+		}
+		num_sc = dma_map_sg(NULL, sglist_alloc,
+		ISP_BUFFER_MAX_PAGES, 1);
+		alloc_done = 1;
 	}
-	num_sc = dma_map_sg(NULL, sglist_alloc, ISP_BUFFER_MAX_PAGES, 1);
+
 	return 0;
 }
 
@@ -1162,16 +1162,34 @@ u32 isp_buf_allocation(void)
  **/
 u32 isp_buf_mmap(void)
 {
-	buff_addr_mapped = ispmmu_map_sg(sglist_alloc, ISP_BUFFER_MAX_PAGES);
-	if (!buff_addr_mapped) {
-		printk(KERN_ERR "ISP_ERR: ispmmu_map_sg mapping failed\n");
+	if (alloc_done == 0)
+		isp_buf_allocation();
+
+	if (alloc_done == 1) {
+		if (buff_addr_mapped == 0) {
+			buff_addr_mapped = ispmmu_map_sg(sglist_alloc,
+			ISP_BUFFER_MAX_PAGES);
+			if (!buff_addr_mapped) {
+				printk(KERN_ERR "ISP_ERR: ispmmu_map_sg mapping failed\n");
+				return -ENOMEM;
+			}
+		}
+	} else {
+		printk(KERN_ERR "ISP_ERR: no buffer allocated for mapping!\n");
 		return -ENOMEM;
 	}
-	isppreview_set_outaddr(buff_addr_mapped);
-	alloc_done = 1;
+
 	return 0;
 }
 
+void isp_buf_unmmap(void)
+{
+	if (buff_addr_mapped) {
+		ispmmu_unmap(buff_addr_mapped);
+		buff_addr_mapped = 0;
+	}
+}
+
 /**
  *  isp_buf_get - Get the buffer pointer address
  **/
@@ -1179,28 +1197,29 @@ dma_addr_t isp_buf_get(void)
 {
 	dma_addr_t retaddr;
 
-	if (alloc_done == 1)
+	if (ispmodule_obj.isp_lsc_workaround == 1 && buff_addr_mapped)
 		retaddr = buff_addr_mapped + offset_value;
 	else
 		retaddr = 0;
+
 	return retaddr;
 }
 
 /**
- *  isp_buf_free - To free allocated 10MB memory
+ *  isp_buf_free - To free allocated ISP workaround buffer
  *
  **/
 void isp_buf_free(void)
 {
 	if (alloc_done == 1) {
-		ispmmu_unmap(buff_addr_mapped);
+		isp_buf_unmmap();
 		dma_unmap_sg(NULL, sglist_alloc, ISP_BUFFER_MAX_PAGES, 1);
 		kfree(sglist_alloc);
 		vfree(buff_addr);
+		buff_addr = NULL;
 		alloc_done = 0;
 	}
 }
-#endif
 
 /**
  * isp_start - Starts ISP submodule
@@ -1236,23 +1255,23 @@ void isp_stop()
 	omapisp_unset_callback();
 	ispccdc_enable_lsc(0);
 	ispccdc_enable(0);
-	while (ispccdc_busy() && (timeout < 100)) {
+	while (ispccdc_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
 	isppreview_enable(0);
-	while (isppreview_busy() && (timeout < 100)) {
+	while (isppreview_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
 	ispresizer_enable(0);
-	while (ispresizer_busy() && (timeout < 100)) {
+	while (ispresizer_busy() && (timeout < 1000)) {
 		timeout++;
-		mdelay(10);
+		msleep(1);
 	}
 
 	timeout = 0;
@@ -1270,7 +1289,8 @@ void isp_stop()
 		msleep(1);
 	}
 
-	/* omap_writel(omap_readl(ISP_IRQ0STATUS) | ISP_INT_CLR, ISP_IRQ0STATUS); */
+	/* omap_writel(omap_readl(ISP_IRQ0STATUS) | */
+	/* 	ISP_INT_CLR, ISP_IRQ0STATUS); */
 
 	isp_restore_ctx();
 }
@@ -1282,16 +1302,15 @@ void isp_stop()
 void isp_set_buf(struct isp_sgdma_state *sgdma_state)
 {
 	if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) &&
-						is_ispresizer_enabled())
+						is_ispresizer_enabled()) {
 		ispresizer_set_outaddr(sgdma_state->isp_addr);
-#if (ISP_WORKAROUND == 0)
-	else if ((ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW) &&
-						is_isppreview_enabled())
-		isppreview_set_outaddr(sgdma_state->isp_addr);
-#endif
-	else if (ispmodule_obj.isp_pipeline & OMAP_ISP_CCDC)
+	} else if ((ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW) &&
+						is_isppreview_enabled()) {
+		if (ispmodule_obj.isp_lsc_workaround == 0)
+			isppreview_set_outaddr(sgdma_state->isp_addr);
+	} else if (ispmodule_obj.isp_pipeline & OMAP_ISP_CCDC) {
 		ispccdc_set_outaddr(sgdma_state->isp_addr);
-
+	}
 }
 
 /**
@@ -1302,9 +1321,7 @@ void isp_set_buf(struct isp_sgdma_state *sgdma_state)
 u32 isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 					struct v4l2_pix_format *pix_output)
 {
-#if ISP_WORKAROUND
 	int rval;
-#endif
 
 	isp_release_resources();
 	if ((pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10) &&
@@ -1316,23 +1333,27 @@ u32 isp_calc_pipeline(struct v4l2_pix_format *pix_input,
 			isppreview_request();
 			ispresizer_request();
 		ispccdc_config_datapath(CCDC_RAW, CCDC_OTHERS_VP);
-#if ISP_WORKAROUND
-		isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_MEM);
-		ispresizer_config_datapath(RSZ_MEM_YUV);
-		if (alloc_done == 0) {
-#if !defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-			rval = isp_buf_allocation();
-			if (rval)
-				return -EINVAL;
-#endif
+
+		if (ispmodule_obj.isp_lsc_workaround == 1) {
+			DPRINTK_ISPCTRL("Using ISP workaround!\n");
+			isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_MEM);
+			ispresizer_config_datapath(RSZ_MEM_YUV);
+
 			rval = isp_buf_mmap();
-			if (rval)
+			if (rval) {
+				printk(KERN_ERR "ISP_ERR:  isp_buf_mmap() failed!\n");
 				return -EINVAL;
+			}
+
+			isppreview_set_outaddr(buff_addr_mapped);
+		} else {
+			DPRINTK_ISPCTRL("NOT using ISP workaround!\n");
+
+			isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_RSZ);
+			ispresizer_config_datapath(RSZ_OTFLY_YUV);
+			isppreview_set_outaddr(0);
+			ispccdc_enable_lsc(0);
 		}
-#else
-		isppreview_config_datapath(PRV_RAW_CCDC, PREVIEW_RSZ);
-		ispresizer_config_datapath(RSZ_OTFLY_YUV);
-#endif
 	} else if (pix_input->pixelformat == pix_output->pixelformat) {
 		ispmodule_obj.isp_pipeline = OMAP_ISP_CCDC;
 		ispccdc_request();
@@ -1405,95 +1426,122 @@ void isp_config_pipeline(struct v4l2_pix_format *pix_input,
  **/
 void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 {
+	unsigned long flags = 0;
 	struct videobuf_buffer *vb = (struct videobuf_buffer *) arg2;
 	int notify = 0;
 	int rval = 0;
-	unsigned long flags;
 
 	switch (status) {
 	case CCDC_VD0:
-   #ifdef CONFIG_VIDEO_OMAP3_HP3A
-      hp3a_ccdc_done();
-   #else
-	  ispccdc_config_shadow_registers();
-   #endif
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		hp3a_ccdc_done();
+#else
+		ispccdc_config_shadow_registers();
+#endif
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
-			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW)) {
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
+			return;
+		} else if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
 			return;
-		else {
-			spin_lock(&isp_obj.isp_temp_buf_lock);
-			if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				return;
-
-			} else {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				break;
-			}
 		}
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+		flags);
 		break;
 	case CCDC_VD1:
 		if ((ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) ||
-			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW))
-			return;
-		spin_lock(&isp_obj.isp_temp_buf_lock);
-		if (ispmodule_obj.isp_temp_state == ISP_BUF_INIT) {
-			spin_unlock(&isp_obj.isp_temp_buf_lock);
-			ispccdc_enable(0);
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_PREVIEW)) {
 			return;
 		}
-		spin_unlock(&isp_obj.isp_temp_buf_lock);
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+		if (ispmodule_obj.isp_temp_state == ISP_BUF_INIT)
+			ispccdc_enable(0);
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock, flags);
 		return;
-		break;
 	case PREV_DONE:
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		hp3a_frame_done();
+#endif
 		if (is_isppreview_enabled()) {
-			if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) {
-				spin_lock(&isp_obj.isp_temp_buf_lock);
+			spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+			if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER &&
+				!ispresizer_busy()) {
 				if (!ispmodule_obj.applyCrop &&
+				    ispmodule_obj.isp_lsc_workaround &&
 					(ispmodule_obj.isp_temp_state ==
-					 ISP_BUF_INIT))
+					 ISP_BUF_INIT)) {
 					ispresizer_enable(1);
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
-				if (ispmodule_obj.applyCrop &&
-						!ispresizer_busy()) {
+				} else if (ispmodule_obj.applyCrop) {
 					ispresizer_enable(0);
 					ispresizer_applycrop();
 					ispmodule_obj.applyCrop = 0;
 				}
 			}
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+				flags);
 
+#ifdef CONFIG_VIDEO_OMAP3_HP3A
+			if (!isppreview_busy())
+				isppreview_config_shadow_registers();
+			hp3a_update_wb();
+		}
+#else
 			if (!isppreview_busy()) {
 				isppreview_config_shadow_registers();
-#ifdef CONFIG_VIDEO_OMAP3_HP3A
+				isph3a_update_wb();
 			}
-			hp3a_frame_done();
-#else
-			isph3a_update_wb();
 		}
 #endif
-
 		if (ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER)
 			return;
-		}
+
 		break;
 	case RESZ_DONE:
 		if (is_ispresizer_enabled()) {
-			ispresizer_config_shadow_registers();
-			spin_lock(&isp_obj.isp_temp_buf_lock);
+			spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
+			if (!ispresizer_busy() && !ispccdc_busy())
+				ispresizer_config_shadow_registers();
+
+
 			if (ispmodule_obj.isp_temp_state != ISP_BUF_INIT) {
-				spin_unlock(&isp_obj.isp_temp_buf_lock);
+				spin_unlock_irqrestore
+				(&isp_obj.isp_temp_buf_lock, flags);
 				return;
 			}
-			spin_unlock(&isp_obj.isp_temp_buf_lock);
+			spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock,
+			flags);
 		}
 		break;
 	case HS_VS:
-		spin_lock(&isp_obj.isp_temp_buf_lock);
+		spin_lock_irqsave(&isp_obj.isp_temp_buf_lock, flags);
 		if (ispmodule_obj.isp_temp_state == ISP_BUF_TRAN) {
 			isp_CCDC_VD01_enable();
 			ispmodule_obj.isp_temp_state = ISP_BUF_INIT;
 		}
-		spin_unlock(&isp_obj.isp_temp_buf_lock);
+
+		if (!ispmodule_obj.isp_lsc_workaround &&
+			(ispmodule_obj.isp_pipeline & OMAP_ISP_RESIZER) &&
+			 !ispresizer_busy() &&
+			 !isppreview_busy()) {
+			if (!ispmodule_obj.applyCrop &&
+				 (ispmodule_obj.isp_temp_state ==
+				 ISP_BUF_INIT)) {
+				ispresizer_enable(1);
+			} else if (ispmodule_obj.applyCrop) {
+				ispresizer_enable(0);
+				ispresizer_applycrop();
+				ispmodule_obj.applyCrop = 0;
+			}
+		}
+
+		spin_unlock_irqrestore(&isp_obj.isp_temp_buf_lock, flags);
+
+		ktime_get_ts((struct timespec *)&vb->ts);
+
 #ifdef CONFIG_VIDEO_OMAP3_HP3A
 		hp3a_ccdc_start();
 #endif
@@ -1510,9 +1558,8 @@ void isp_vbq_done(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
 
 	rval = arg1(vb);
 
-	if (rval) {
+	if (rval)
 		isp_sgdma_process(&ispsg, 1, &notify, arg1);
-	}
 
 	return;
 }
@@ -1540,10 +1587,11 @@ EXPORT_SYMBOL(isp_stop);
 void isp_sgdma_cancel()
 {
 	int sg;
-	unsigned long flags;
 	struct videobuf_buffer *vb;
+	unsigned long flags = 0;
 
 	spin_lock_irqsave(&ispsg.lock, flags);
+
 	for (sg = 0; sg < NUM_SG_DMA; sg++) {
 		if (ispsg.sg_state[sg].arg) {
 			vb = ispsg.sg_state[sg].arg;
@@ -1552,6 +1600,7 @@ void isp_sgdma_cancel()
 			ispsg.sg_state[sg].arg = NULL;
 		}
 	}
+
 	spin_unlock_irqrestore(&ispsg.lock, flags);
 }
 EXPORT_SYMBOL(isp_sgdma_cancel);
@@ -1933,6 +1982,20 @@ int isp_handle_private(int cmd, void *arg)
       ispresizer_config_filter_coef(resizer_coef);
       }
    break;
+   case VIDIOC_PRIVATE_ISP_CCDC_BAYER_CFG:
+	   {
+		   struct ispccdc_color_offset *offset;
+		   offset = (struct ispccdc_color_offset *)arg;
+		   ispccdc_set_crop_offset_dynamic(*offset);
+	   }
+	   break;
+	case VIDIOC_PRIVATE_ISP_LSC_WORKAROUND_CFG:
+	  {
+		 ispmodule_obj.isp_lsc_workaround = (*(int *)arg ? 1 : 0);
+		if (ispmodule_obj.isp_lsc_workaround == 0)
+			isp_buf_free();
+	  }
+	  break;
 	default:
 		rval = -EINVAL;
 		break;
@@ -2043,50 +2106,55 @@ EXPORT_SYMBOL(isp_s_fmt_cap);
  **/
 void isp_config_crop(struct v4l2_pix_format *croppix)
 {
-	u8 crop_scaling_w;
-	u8 crop_scaling_h;
-#if ISP_WORKAROUND
 	unsigned long org_left, num_pix, new_top, new_height;
-#endif
-
 	struct v4l2_pix_format *pix = croppix;
 
-	crop_scaling_w = (ispmodule_obj.preview_output_width * 10) /
-								pix->width;
-	crop_scaling_h = (ispmodule_obj.preview_output_height * 10) /
-								pix->height;
-
-	cur_rect.left = (ispcroprect.left * crop_scaling_w) / 10;
-	cur_rect.top = (ispcroprect.top * crop_scaling_h) / 10;
-	cur_rect.width = (ispcroprect.width * crop_scaling_w) / 10;
-	cur_rect.height = (ispcroprect.height * crop_scaling_h) / 10;
-
-#if ISP_WORKAROUND
-	org_left = cur_rect.left;
-	cur_rect.left = ALIGN_NEAR(cur_rect.left, 16);
-
-	num_pix = org_left - cur_rect.left;
-	new_top = (int)(num_pix * 3) / 4;
-	cur_rect.top = (cur_rect.top - new_top);
-	if ((int)cur_rect.top < 0)
-			cur_rect.top = 0;
-
-	new_height = (2 * new_top) + cur_rect.height;
-	if (new_height < cur_rect.height)
-		cur_rect.height = new_height;
-
-	cur_rect.width = cur_rect.width + (2 * num_pix);
-	cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
-
-	offset_value = ((cur_rect.left * 2) + \
-		((ispmodule_obj.preview_output_width) * 2 * cur_rect.top));
-#endif
+	cur_rect.left = (u32)(ispcroprect.left *
+		ispmodule_obj.preview_output_width)/(u32)pix->width;
+	cur_rect.top = (u32)(ispcroprect.top
+		* ispmodule_obj.preview_output_height)/(u32)pix->height;
+	cur_rect.width = (u32)(ispcroprect.width *
+		ispmodule_obj.preview_output_width)/(u32)pix->width;
+	cur_rect.height = (u32)(ispcroprect.height *
+		ispmodule_obj.preview_output_height)/(u32)pix->height;
+
+	if (ispmodule_obj.isp_lsc_workaround == 1) {
+		org_left = cur_rect.left;
+		cur_rect.left = ALIGN_NEAR(cur_rect.left, 16);
+
+		num_pix = org_left - cur_rect.left;
+		new_top = (int)(num_pix * 3) / 4;
+		cur_rect.top = (cur_rect.top - new_top);
+		if ((int)cur_rect.top < 0)
+				cur_rect.top = 0;
+
+		new_height = (2 * new_top) + cur_rect.height;
+		if (new_height < cur_rect.height)
+			cur_rect.height = new_height;
+
+		cur_rect.width = cur_rect.width + (2 * num_pix);
+		cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
+
+		offset_value = ((cur_rect.left * 2) + \
+			((ispmodule_obj.preview_output_width) * 2
+			* cur_rect.top));
+	} else {
+		offset_value = 0;
+		cur_rect.width = ALIGN_NEAR(cur_rect.width, 16);
+		cur_rect.height = ALIGN_NEAR(cur_rect.height, 8);
+	}
 
-	ispresizer_trycrop(cur_rect.left, cur_rect.top, cur_rect.width,
+	ispresizer_trycrop(cur_rect.left, cur_rect.top,
+					cur_rect.width,
 					cur_rect.height,
 					ispmodule_obj.resizer_output_width,
 					ispmodule_obj.resizer_output_height);
 
+	ispmodule_obj.applyCrop = 1;
+
+	DPRINTK_ISPCTRL("ISP: resizer crop (%d-%d-%d-%d) \n",
+		cur_rect.left, cur_rect.top, cur_rect.width, cur_rect.height);
+
 	return;
 }
 EXPORT_SYMBOL(isp_config_crop);
@@ -2120,26 +2188,32 @@ int isp_s_crop(struct v4l2_crop *a, struct v4l2_pix_format *pix)
 
 	if ((crop->c.left + crop->c.width) > pix->width) {
 		rval = -EINVAL;
-		DPRINTK_ISPCTRL("isp_s_crop(): crop->left=%d crop->width=%d pix->width=%d\n",
+		DPRINTK_ISPCTRL("isp_s_crop() crop->left = %d " \
+			"crop->width = %d pix->width = %d\n",
 			crop->c.left, crop->c.width, pix->width);
 		goto out;
 	}
 
 	if ((crop->c.top + crop->c.height) > pix->height) {
 		rval = -EINVAL;
-		DPRINTK_ISPCTRL("isp_s_crop(): crop->top=%d crop->height=%d pix->height=%d\n",
+		DPRINTK_ISPCTRL("isp_s_crop() crop->top = %d " \
+			"crop->height = %d pix->height = %d\n",
 			crop->c.top, crop->c.height, pix->height);
 		goto out;
 	}
 
+
 	ispcroprect.left = crop->c.left;
 	ispcroprect.top = crop->c.top;
 	ispcroprect.width = crop->c.width;
 	ispcroprect.height = crop->c.height;
 
+	DPRINTK_ISPCTRL("ISP: isp_s_crop -> crop (%d-%d-%d-%d)\n",
+		ispcroprect.left, ispcroprect.top,
+		ispcroprect.width, ispcroprect.height);
+
 	isp_config_crop(pix);
 
-	ispmodule_obj.applyCrop = 1;
 out:
 	return rval;
 }
@@ -2166,14 +2240,16 @@ int isp_try_fmt_cap(struct v4l2_pix_format *pix_input,
 		out_aspect_ratio = (pix_output->width * 256)/pix_output->height;
 	}
 
-	if ((out_aspect_ratio - in_aspect_ratio) > 25 &&  (out_aspect_ratio - in_aspect_ratio) < 180) {
+	if ((out_aspect_ratio - in_aspect_ratio) > 25 &&
+		(out_aspect_ratio - in_aspect_ratio) < 180) {
 		/* Adjusted for output aspect ratio. */
-		adjusted_height = ALIGN_TO(((pix_input->width*256)/out_aspect_ratio), 2);
+		adjusted_height = ALIGN_TO(
+			((pix_input->width*256)/out_aspect_ratio), 2);
 
 		ispccdc_config_crop(0,
-			((pix_input->height-adjusted_height)/2),
-			(adjusted_height + (pix_input->height-adjusted_height)/2),
-			pix_input->width);
+		(pix_input->height-adjusted_height)/2,
+		adjusted_height + (pix_input->height-adjusted_height)/2,
+		pix_input->width);
 	} else {
 		ispccdc_config_crop(0, 0, 0, 0);
 	}
@@ -2377,44 +2453,44 @@ EXPORT_SYMBOL(isp_restore_ctx);
 int isp_get(void)
 {
 	int ret_err = 0;
-	DPRINTK_ISPCTRL("isp_get: old %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_get() old %d\n", isp_obj.ref_count);
 	mutex_lock(&(isp_obj.isp_mutex));
 	if (isp_obj.ref_count == 0) {
 		isp_obj.cam_ick = clk_get(&camera_dev, "cam_ick");
 		if (IS_ERR(isp_obj.cam_ick)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for "
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for "
 							"cam_ick failed\n");
 			ret_err = PTR_ERR(isp_obj.cam_ick);
 			goto out_clk_get_ick;
 		}
 		isp_obj.cam_mclk = clk_get(&camera_dev, "cam_mclk");
 		if (IS_ERR(isp_obj.cam_mclk)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for "
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for "
 							"cam_mclk failed\n");
 			ret_err = PTR_ERR(isp_obj.cam_mclk);
 			goto out_clk_get_mclk;
 		}
 		isp_obj.csi2_fck = clk_get(&camera_dev, "csi2_96m_fck");
 		if (IS_ERR(isp_obj.csi2_fck)) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_get for csi2_fclk"
+			DPRINTK_ISPCTRL("ISP_ERR : clk_get for csi2_fclk"
 								" failed\n");
 			ret_err = PTR_ERR(isp_obj.csi2_fck);
 			goto out_clk_get_csi2_fclk;
 		}
 		ret_err = clk_enable(isp_obj.cam_ick);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for ick failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : clk_en for ick failed\n");
 			goto out_clk_enable_ick;
 		}
 		ret_err = clk_enable(isp_obj.cam_mclk);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for mclk failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : clk_en for mclk failed\n");
 			goto out_clk_enable_mclk;
 		}
 		ret_err = clk_enable(isp_obj.csi2_fck);
 		if (ret_err) {
-			DPRINTK_ISPCTRL("ISP_ERR: clk_en for csi2_fclk"
-								" failed\n");
+			DPRINTK_ISPCTRL("ISP_ERR : "
+				"clk_en for csi2_fclk failed\n");
 			goto out_clk_enable_csi2_fclk;
 		}
 		if (off_mode == 1)
@@ -2423,8 +2499,7 @@ int isp_get(void)
 	isp_obj.ref_count++;
 	mutex_unlock(&(isp_obj.isp_mutex));
 
-
-	DPRINTK_ISPCTRL("isp_get: new %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_get : new %d\n", isp_obj.ref_count);
 	return isp_obj.ref_count;
 
 out_clk_enable_csi2_fclk:
@@ -2452,17 +2527,16 @@ EXPORT_SYMBOL(isp_get);
  **/
 int isp_put(void)
 {
-	DPRINTK_ISPCTRL("isp_put: old %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_put old %d \n", isp_obj.ref_count);
 	mutex_lock(&(isp_obj.isp_mutex));
 	if (isp_obj.ref_count)
 		if (--isp_obj.ref_count == 0) {
 			isp_save_ctx();
 			off_mode = 1;
-#if ISP_WORKAROUND && !defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-			isp_buf_free();
-#endif
+
 			isp_release_resources();
 			ispmodule_obj.isp_pipeline = 0;
+			ispmodule_obj.isp_lsc_workaround = ISP_WORKAROUND;
 			clk_disable(isp_obj.cam_ick);
 			clk_disable(isp_obj.cam_mclk);
 			clk_disable(isp_obj.csi2_fck);
@@ -2473,7 +2547,7 @@ int isp_put(void)
 			memset(&cur_rect, 0, sizeof(cur_rect));
 		}
 	mutex_unlock(&(isp_obj.isp_mutex));
-	DPRINTK_ISPCTRL("isp_put: new %d\n", isp_obj.ref_count);
+	DPRINTK_ISPCTRL("isp_put new %d \n", isp_obj.ref_count);
 	return isp_obj.ref_count;
 }
 EXPORT_SYMBOL(isp_put);
@@ -2511,9 +2585,7 @@ EXPORT_SYMBOL(isp_restore_context);
  **/
 static int __init isp_init(void)
 {
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
 	int rval;
-#endif
 	int i;
 
 	DPRINTK_ISPCTRL("+isp_init for Omap 3430 Camera ISP\n");
@@ -2527,13 +2599,13 @@ static int __init isp_init(void)
 	init_completion(&isp_wfc);
 	isp_wfc.done = 0;
 
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
-	if (alloc_done == 0) {
-		rval = isp_buf_allocation();
-		if (rval)
-			return -EINVAL;
-	}
-#endif
+	buff_addr = NULL;
+	buff_addr_mapped = 0;
+	alloc_done = 0;
+	offset_value = 0;
+	rval = isp_buf_allocation();
+	if (rval)
+		return -EINVAL;
 
 	for (i = 0; i < CBK_END; ++i) {
 		ispirq_obj.irq_events[i] = 0;
@@ -2597,9 +2669,7 @@ static void __exit isp_cleanup(void)
 #endif
 	isp_ccdc_cleanup();
 	free_irq(INT_34XX_CAM_IRQ, &ispirq_obj);
-#if ISP_WORKAROUND && defined(CONFIG_VIDEO_OLDOMAP3_BUFFALLOC)
 	isp_buf_free();
-#endif
 }
 
 /**
@@ -2624,7 +2694,10 @@ static void rsz_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
  *
  * Interrupt Service Routine for Preview wrapper
  **/
-static void preview_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
+static void preview_isr(
+		unsigned long status,
+		isp_vbq_callback_ptr arg1,
+		void *arg2)
 {
 	isppreview_enable(0);
 	ispresizer_enable(1);
@@ -2638,7 +2711,10 @@ static void preview_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *a
  *
  * Return a pointer to a page array.
  **/
-struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pages_mapped)
+struct page **map_user_memory_to_kernel(
+			unsigned long addr,
+			u32 size,
+			u32 *nr_pages_mapped)
 {
 	struct page **ppages = NULL;
 	int nr_pages;
@@ -2663,15 +2739,13 @@ struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pa
 			if (unlikely(ret != nr_pages)) {
 				kfree(ppages);
 				ppages = NULL;
-				printk(KERN_ERR "isp: Mapping user pages"
-						" to kernel failed!\n");
+				printk(KERN_ERR "isp : Mapping user pages"
+						" to kernel failed\n");
 			}
-			if (nr_pages_mapped) {
+			if (nr_pages_mapped)
 				*nr_pages_mapped = nr_pages;
-			}
-		} else {
-			printk(KERN_ERR "isp: Error allocating kernel memory!\n");
-		}
+		} else
+			printk(KERN_ERR "isp : Error allocating kernel memory\n");
 	}
 
 	return ppages;
@@ -2687,15 +2761,14 @@ void unmap_user_memory_from_kernel(struct page **pages, int nr_pages)
 	u32 i;
 
 	if (pages != NULL) {
-		for (i = 0; i < nr_pages; ++i) {
+		for (i = 0; i < nr_pages; ++i)
 			page_cache_release(pages[i]);
-		}
 	}
 }
 
 /**
  * isp_run_resizer - Run the resizer on memory based input
- *									and output.
+ * and output.
  * @userdata: address to the passed in data structure.
  *
  * Returns 0 on success, < 0 otherwise.
@@ -2705,7 +2778,7 @@ int isp_run_resizer(void *userdata)
 	int i;
 	int ret = -1;
 	struct ispprv_run_resizer *presizer_user = \
-							(struct ispprv_run_resizer *)userdata;
+		(struct ispprv_run_resizer *)userdata;
 	u32 input_buffer_size, output_buffer_size;
 	u32 input_nr_pages, output_nr_pages;
 	struct page **input_pages = NULL;
@@ -2715,23 +2788,24 @@ int isp_run_resizer(void *userdata)
 	struct ispprv_run_resizer resizer_param;
 
 	if (presizer_user == NULL) {
-		printk(KERN_ERR "isp_run_resizer: Invalid user data!\n");
+		printk(KERN_ERR "isp_run_resizer : Invalid user data\n");
 		return -EINVAL;
 	}
 
-	memcpy(&resizer_param, presizer_user, sizeof(struct ispprv_run_resizer));
+	memcpy(&resizer_param, presizer_user, \
+		sizeof(struct ispprv_run_resizer));
 
-	DPRINTK_ISPCTRL("\nisp_run_resizer: input(%d-%d) - output(%d-%d)\n",
-										resizer_param.input_width,
-										resizer_param.input_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+	DPRINTK_ISPCTRL("\nisp_run_resizer : input(%d-%d) - output(%d-%d)\n",
+		resizer_param.input_width,
+		resizer_param.input_height,
+		resizer_param.output_width,
+		resizer_param.output_height);
 
-	DPRINTK_ISPCTRL("isp_run_resizer: start(%d-%d) - end(%d-%d)\n",
-										resizer_param.left,
-										resizer_param.top,
-										resizer_param.crop_width,
-										resizer_param.crop_height);
+	DPRINTK_ISPCTRL("isp_run_resizer : start(%d-%d) - end(%d-%d)\n",
+		resizer_param.left,
+		resizer_param.top,
+		resizer_param.crop_width,
+		resizer_param.crop_height);
 
 	if (presizer_user->datain == 0 || presizer_user->dataout == 0)
 		return -EINVAL;
@@ -2739,60 +2813,59 @@ int isp_run_resizer(void *userdata)
 	ispresizer_save_context();
 
 	input_buffer_size = ALIGN_TO(presizer_user->input_width* \
-										presizer_user->input_height*2 , 0x100);
+		presizer_user->input_height*2 , 0x100);
 	input_pages = map_user_memory_to_kernel(presizer_user->datain,
-									input_buffer_size, &input_nr_pages);
+		input_buffer_size, &input_nr_pages);
 	if (input_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_resizer : memory allocation failed\n");
 		goto exit_cleanup;
 	}
 
 	output_buffer_size = ALIGN_TO(presizer_user->output_width* \
-											presizer_user->output_height*2, 0x1000);
+		presizer_user->output_height*2, 0x1000);
 	output_pages = map_user_memory_to_kernel(presizer_user->dataout,
-									output_buffer_size, &output_nr_pages);
+		output_buffer_size, &output_nr_pages);
 	if (output_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_resizer() memory allocation failed\n");
 		goto exit_cleanup;
 	}
-	for (i = 0; i < output_nr_pages; ++i) {
+	for (i = 0; i < output_nr_pages; ++i)
 		flush_dcache_page(output_pages[i]);
-	}
 
 	isp_addr_in = ispmmu_map_pages(input_pages, input_nr_pages);
 	if (isp_addr_in == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_resizer() isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 	isp_addr_out = ispmmu_map_pages(output_pages, output_nr_pages);
 	if (isp_addr_out == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_resizer: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_resizer()  isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 
 	if ((resizer_param.left == 0) && (resizer_param.top == 0)) {
-		ret = ispresizer_try_size(&resizer_param.input_width,
-												&resizer_param.input_height,
-												&resizer_param.output_width,
-												&resizer_param.output_height);
+			ret = ispresizer_try_size(&resizer_param.input_width,
+			&resizer_param.input_height,
+			&resizer_param.output_width,
+			&resizer_param.output_height);
 
-		ret = ispresizer_config_size(resizer_param.input_width,
-													resizer_param.input_height,
-													resizer_param.output_width,
-													resizer_param.output_height);
+			ret = ispresizer_config_size(resizer_param.input_width,
+			resizer_param.input_height,
+			resizer_param.output_width,
+			resizer_param.output_height);
 
 		ispresizer_set_inaddr(isp_addr_in);
 	} else {
 		ispresizer_trycrop(resizer_param.left,
-										resizer_param.top,
-										resizer_param.crop_width,
-										resizer_param.crop_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+			resizer_param.top,
+			resizer_param.crop_width,
+			resizer_param.crop_height,
+			resizer_param.output_width,
+			resizer_param.output_height);
 
 		ispresizer_applycrop();
 
@@ -2828,12 +2901,10 @@ int isp_run_resizer(void *userdata)
 exit_cleanup:
 	ispresizer_restore_context();
 
-	if (isp_addr_in != 0) {
+	if (isp_addr_in != 0)
 		ispmmu_unmap(isp_addr_in);
-	}
-	if (isp_addr_out != 0) {
+	if (isp_addr_out != 0)
 		ispmmu_unmap(isp_addr_out);
-	}
 	if (input_pages != NULL) {
 		unmap_user_memory_from_kernel(input_pages, input_nr_pages);
 		kfree(input_pages);
@@ -2843,14 +2914,14 @@ exit_cleanup:
 		kfree(output_pages);
 	}
 
-	DPRINTK_ISPCTRL("isp_run_resizer: exit.\n");
+	DPRINTK_ISPCTRL("isp_run_resizer : exit.\n");
 	return ret;
 }
 EXPORT_SYMBOL(isp_run_resizer);
 
 /**
  * isp_run_preview - Run the preview on memory based input
- *									and output.
+ * and output.
  * @userdata: address to the passed in data structure.
  *
  * Returns 0 on success, < 0 otherwise.
@@ -2859,7 +2930,8 @@ int isp_run_preview(void *userdata)
 {
 	int i;
 	int ret = -1;
-	struct ispprv_run_hardpipe *ppreview_user = (struct ispprv_run_hardpipe *)userdata;
+	struct ispprv_run_hardpipe *ppreview_user = \
+		(struct ispprv_run_hardpipe *)userdata;
 	struct ispprv_run_hardpipe preview_param;
 	u32 input_buffer_size, output_buffer_size;
 	u32 input_nr_pages, output_nr_pages;
@@ -2869,25 +2941,27 @@ int isp_run_preview(void *userdata)
 	unsigned long  isp_addr_out = 0;
 	u32 isppreview_pcr;
 	struct ispprv_run_resizer resizer_param;
+	u16 cropadjust = 0;
 
 	if (ppreview_user == NULL) {
-		printk(KERN_ERR "isp_run_preview: Invalid user data!\n");
+		printk(KERN_ERR "isp_run_preview() Invalid user data\n");
 		return -EINVAL;
 	}
 
-	memcpy(&preview_param, ppreview_user, sizeof(struct ispprv_run_hardpipe));
+	memcpy(&preview_param, ppreview_user, \
+		sizeof(struct ispprv_run_hardpipe));
 
-	DPRINTK_ISPCTRL("\nnisp_run_preview: input(%d-%d) - output(%d-%d)\n",
-										preview_param.input_width,
-										preview_param.input_height,
-										preview_param.output_width,
-										preview_param.output_height);
+	DPRINTK_ISPCTRL("\nnisp_run_preview() input(%d-%d) - output(%d-%d)\n",
+		preview_param.input_width,
+		preview_param.input_height,
+		preview_param.output_width,
+		preview_param.output_height);
 
-	DPRINTK_ISPCTRL("isp_run_preview: start(%d-%d) - end(%d-%d)\n",
-										preview_param.left,
-										preview_param.top,
-										preview_param.crop_width,
-										preview_param.crop_height);
+	DPRINTK_ISPCTRL("isp_run_preview() start(%d-%d) - end(%d-%d)\n",
+		preview_param.left,
+		preview_param.top,
+		preview_param.crop_width,
+		preview_param.crop_height);
 
 	if (ppreview_user->datain == 0 || ppreview_user->dataout == 0)
 		return -EINVAL;
@@ -2898,53 +2972,50 @@ int isp_run_preview(void *userdata)
 	ispccdc_config_crop(0, 0, 0, 0);
 
 	ret = isppreview_try_size(preview_param.input_width,
-											preview_param.input_height,
-											&preview_param.output_width,
-											&preview_param.output_height);
-	if (ret < 0) {
+		preview_param.input_height,
+		&preview_param.output_width,
+		&preview_param.output_height);
+	if (ret < 0)
 		goto exit_cleanup;
-	}
 	ret = isppreview_config_size(preview_param.input_width,
-													preview_param.input_height,
-													preview_param.output_width,
-													preview_param.output_height);
-	if (ret < 0) {
+		preview_param.input_height,
+		preview_param.output_width,
+		preview_param.output_height);
+	if (ret < 0)
 		goto exit_cleanup;
-	}
 
 	input_buffer_size = ALIGN_TO(ppreview_user->input_width* \
-										ppreview_user->input_height*2 , 0x100);
+		ppreview_user->input_height*2 , 0x100);
 	input_pages = map_user_memory_to_kernel(preview_param.datain,
-									input_buffer_size, &input_nr_pages);
+		input_buffer_size, &input_nr_pages);
 	if (input_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_preview : memory allocation failed\n");
 		goto exit_cleanup;
 	}
 
 	output_buffer_size = ALIGN_TO(ppreview_user->output_width* \
-											ppreview_user->output_height*2, 0x1000);
+		ppreview_user->output_height*2, 0x1000);
 	output_pages = map_user_memory_to_kernel(preview_param.dataout,
-									output_buffer_size, &output_nr_pages);
+		output_buffer_size, &output_nr_pages);
 	if (output_pages == NULL) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: memory allocation failed!\n");
+		printk(KERN_ERR "isp_run_preview memory allocation failed\n");
 		goto exit_cleanup;
 	}
-	for (i = 0; i < output_nr_pages; ++i) {
+	for (i = 0; i < output_nr_pages; ++i)
 		flush_dcache_page(output_pages[i]);
-	}
 
 	isp_addr_in = ispmmu_map_pages(input_pages, input_nr_pages);
 	if (isp_addr_in == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_preview : isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 	isp_addr_out = ispmmu_map_pages(output_pages, output_nr_pages);
 	if (isp_addr_out == 0) {
 		ret = -EINVAL;
-		printk(KERN_ERR "isp_run_preview: isp mmu map failed!\n");
+		printk(KERN_ERR "isp_run_preview isp mmu map failed\n");
 		goto exit_cleanup;
 	}
 
@@ -2974,47 +3045,56 @@ int isp_run_preview(void *userdata)
 
 	if ((preview_param.left == 0) && (preview_param.top == 0)) {
 		ret = ispresizer_try_size(&resizer_param.input_width,
-												&resizer_param.input_height,
-												&resizer_param.output_width,
-												&resizer_param.output_height);
-		if (ret < 0) {
+				&resizer_param.input_height,
+				&resizer_param.output_width,
+				&resizer_param.output_height);
+		if (ret < 0)
 			goto exit_cleanup;
-		}
 		ret = ispresizer_config_size(resizer_param.input_width,
-													resizer_param.input_height,
-													resizer_param.output_width,
-													resizer_param.output_height);
-		if (ret < 0) {
+				resizer_param.input_height,
+				resizer_param.output_width,
+				resizer_param.output_height);
+		if (ret < 0)
 			goto exit_cleanup;
-		}
 		ispresizer_set_inaddr(buff_addr_mapped);
 	} else {
 		ispresizer_trycrop(preview_param.left,
-										preview_param.top,
-										preview_param.crop_width,
-										preview_param.crop_height,
-										resizer_param.output_width,
-										resizer_param.output_height);
+				preview_param.top,
+				preview_param.crop_width,
+				preview_param.crop_height,
+				resizer_param.output_width,
+				resizer_param.output_height);
 
 		ispresizer_applycrop();
 
+      /*account for pixel loss when using crop*/
+		if ((preview_param.input_height > preview_param.output_height)
+				&& (preview_param.top > 16))
+			cropadjust = 8;
+		else
+			cropadjust = 0;
+
+
 		/*pixel alignment in 32bit space, vertical must be 0 per TRM */
 		omap_writel(((preview_param.left%16) <<
-							ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-							(0 <<
-							ISPRSZ_IN_START_VERT_ST_SHIFT),
-							ISPRSZ_IN_START);
+					ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+					(0 <<
+					ISPRSZ_IN_START_VERT_ST_SHIFT),
+					ISPRSZ_IN_START);
 
 		/* Align input address for cropping, per TRM  */
-		ispresizer_set_inaddr(buff_addr_mapped +
-							(preview_param.top*resizer_param.input_width*2)
-							+ ((preview_param.left/16)*32));
+		ispresizer_set_inaddr(buff_addr_mapped -
+				(resizer_param.input_width*2*cropadjust) +
+				(preview_param.top*resizer_param.input_width*2)
+				+ ((preview_param.left/16)*32));
 	}
 
 	ispresizer_set_outaddr(isp_addr_out);
 	ispresizer_config_inlineoffset(resizer_param.input_width*2);
-	isp_set_callback(CBK_PREV_DONE, preview_isr, (void *) NULL, (void *)NULL);
-	isp_set_callback(CBK_RESZ_DONE, rsz_isr, (void *) NULL, (void *)NULL);
+	isp_set_callback(CBK_PREV_DONE, preview_isr,
+			(void *) NULL, (void *)NULL);
+	isp_set_callback(CBK_RESZ_DONE, rsz_isr,
+			(void *) NULL, (void *)NULL);
 
 	omap_writel(RESZ_DONE|PREV_DONE, ISP_IRQ0STATUS);
 	isp_wfc.done = 0;
@@ -3031,12 +3111,10 @@ exit_cleanup:
 	isppreview_restore_context();
 	ispresizer_restore_context();
 
-	if (isp_addr_in != 0) {
+	if (isp_addr_in != 0)
 		ispmmu_unmap(isp_addr_in);
-	}
-	if (isp_addr_out != 0) {
+	if (isp_addr_out != 0)
 		ispmmu_unmap(isp_addr_out);
-	}
 	if (input_pages != NULL) {
 		unmap_user_memory_from_kernel(input_pages, input_nr_pages);
 		kfree(input_pages);
@@ -3046,7 +3124,7 @@ exit_cleanup:
 		kfree(output_pages);
 	}
 
-	DPRINTK_ISPCTRL("isp_run_preview: exit.\n");
+	DPRINTK_ISPCTRL("isp_run_preview : exit.\n");
 	return ret;
 }
 EXPORT_SYMBOL(isp_run_preview);
@@ -3061,33 +3139,34 @@ void isp_print_status(void)
 	if (!is_ispctrl_debug_enabled())
 		return;
 
-	DPRINTK_ISPCTRL("###CM_FCLKEN_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_FCLKEN_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_FCLKEN_CAM));
-	DPRINTK_ISPCTRL("###CM_ICLKEN_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_ICLKEN_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_ICLKEN_CAM));
-	DPRINTK_ISPCTRL("###CM_CLKSEL_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKSEL_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_CLKSEL_CAM));
-	DPRINTK_ISPCTRL("###CM_AUTOIDLE_CAM=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_AUTOIDLE_CAM = 0x%x\n",
 					omap_readl(OMAP3_CM_AUTOIDLE_CAM));
-	DPRINTK_ISPCTRL("###CM_CLKEN_PLL[18:16] should be 0x7, = 0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKEN_PLL[18 : 16] should be 0x7, = 0x%x\n",
 					omap_readl(OMAP3_CM_CLKEN_PLL));
-	DPRINTK_ISPCTRL("###CM_CLKSEL2_PLL[18:8] should be 0x2D, [6:0] should "
-			"be 1 = 0x%x\n", omap_readl(OMAP3_CM_CLKSEL2_PLL));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_HS=0x%x\n",
+	DPRINTK_ISPCTRL("###CM_CLKSEL2_PLL[18 : 8] should be 0x2D, "
+			"[6 : 0] should be 1 = 0x%x\n",
+			omap_readl(OMAP3_CM_CLKSEL2_PLL));
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_HS = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_HS));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_XCLKA=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_XCLKA = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_XCLKA));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D1=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D1 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D1));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D3=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D3 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D3));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D5=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D5 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D5));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D7=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D7 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D7));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D9=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D9 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D9));
-	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D11=0x%x\n",
+	DPRINTK_ISPCTRL("###CTRL_PADCONF_CAM_D11 = 0x%x\n",
 					omap_readl(CTRL_PADCONF_CAM_D11));
 }
 EXPORT_SYMBOL(isp_print_status);
diff --git a/drivers/media/video/oldisp/isp.h b/drivers/media/video/oldisp/isp.h
index 8d6cd17..895fd73 100644
--- a/drivers/media/video/oldisp/isp.h
+++ b/drivers/media/video/oldisp/isp.h
@@ -74,7 +74,7 @@
 #define NUM_ISP_CAPTURE_FORMATS 	(sizeof(isp_formats) /\
 							sizeof(isp_formats[0]))
 #define ISP_WORKAROUND 1
-#define ISP_BUFFER_MAX_SIZE (1024 * 1024 * 10)
+#define ISP_BUFFER_MAX_SIZE (1024 * 1024 * 16)
 #define ISP_BUFFER_MAX_PAGES (ISP_BUFFER_MAX_SIZE / ISPMMU_PAGE_SIZE)
 
 #define NR_PAGES(x, y)		((((y + x - 1) & PAGE_MASK) >> PAGE_SHIFT) - \
@@ -364,10 +364,13 @@ void __exit isp_hist_cleanup(void);
 void __exit isp_resizer_cleanup(void);
 void __exit isp_af_exit(void);
 
-struct page **map_user_memory_to_kernel(unsigned long addr, u32 size, u32 *nr_pages_mapped);
+struct page **map_user_memory_to_kernel(unsigned long addr, u32 size,
+		u32 *nr_pages_mapped);
 void unmap_user_memory_from_kernel(struct page **pages, int nr_pages);
 
 int isp_run_resizer(void *userdata);
 int isp_run_preview(void *userdata);
 
+int isp_lsc_workaround_enabled(void);
+
 #endif	/* OMAP_ISP_TOP_H */
diff --git a/drivers/media/video/oldisp/ispccdc.c b/drivers/media/video/oldisp/ispccdc.c
index 044e247..d8c8654 100644
--- a/drivers/media/video/oldisp/ispccdc.c
+++ b/drivers/media/video/oldisp/ispccdc.c
@@ -47,6 +47,8 @@ static unsigned long fpc_table_add_m;
  * @ccdcout_h: CCDC output height.
  * @ccdcin_w: CCDC input width.
  * @ccdcin_h: CCDC input height.
+ * @ccdcin_wstart: CCDC input horizontal offset due to color order.
+ * @ccdcin_hstart: CCDC input vertical offset due to color order.
  * @ccdcin_woffset: CCDC input horizontal offset.
  * @ccdcin_hoffset: CCDC input vertical offset.
  * @crop_w: Crop width.
@@ -68,6 +70,8 @@ static struct isp_ccdc {
 	u32 ccdcout_h;
 	u32 ccdcin_w;
 	u32 ccdcin_h;
+	u8 ccdcin_wstart;
+	u8 ccdcin_hstart;
 	u32 ccdcin_woffset;
 	u32 ccdcin_hoffset;
 	u32 crop_w;
@@ -142,6 +146,22 @@ static struct isp_reg ispccdc_reg_list[] = {
 };
 
 /**
+ * isp_lsc_isr - LSC prefetch error interrupt handling.
+ **/
+void isp_lsc_isr(unsigned long status, void  *arg1, void *arg2)
+{
+	unsigned long irqflags = 0;
+
+	if (status & LSC_PRE_ERR) {
+		spin_lock_irqsave(&ispccdc_obj.ispccdc_lock, irqflags);
+		ispccdc_enable_lsc(0);
+		ispccdc_enable_lsc(1);
+		spin_unlock_irqrestore(&ispccdc_obj.ispccdc_lock, irqflags);
+		/* printk(KERN_ERR "isp_sr: LSC_PRE_ERR \n"); */
+	}
+}
+
+/**
  * omap34xx_isp_ccdc_config - Sets CCDC configuration from userspace
  * @userspace_add: Structure containing CCDC configuration sent from userspace.
  *
@@ -282,8 +302,8 @@ int omap34xx_isp_ccdc_config(void *userspace_add)
 			ispccdc_enable_lsc(1);
 		} else if ((ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) ==
 						ISP_ABS_CCDC_CONFIG_LSC) {
-				ispccdc_enable_lsc(0);
-				ccdc_use_lsc = 0;
+			ispccdc_enable_lsc(0);
+			ccdc_use_lsc = 0;
 		}
 		mutex_lock(&ispccdc_obj.ispccdc_mutex);
 		if ((ISP_ABS_TBL_LSC & ccdc_struct->update)
@@ -299,18 +319,22 @@ int omap34xx_isp_ccdc_config(void *userspace_add)
 						"Cannot allocate\
 						memory for \
 						gain tables \n");
-					mutex_unlock(&ispccdc_obj.ispccdc_mutex);
+					mutex_unlock(
+						&ispccdc_obj.ispccdc_mutex);
 					return -ENOMEM;
 				}
 				lsc_ispmmu_addr = ispmmu_map(
-					virt_to_phys((u8 *)ALIGN_TO(lsc_gain_table, 0x1000)),
+					virt_to_phys((u8 *)ALIGN_TO(
+						lsc_gain_table,
+						0x1000)),
 					lsc_config.size);
 				omap_writel(lsc_ispmmu_addr,
 					ISPCCDC_LSC_TABLE_BASE);
 				lsc_initialized = 1;
 				size_mismatch = 0;
 			}
-			if (copy_from_user((u8 *)ALIGN_TO(lsc_gain_table, 0x1000),
+			if (copy_from_user((u8 *)ALIGN_TO(lsc_gain_table,
+				0x1000),
 				(ccdc_struct->lsc), lsc_config.size)) {
 				mutex_unlock(&ispccdc_obj.ispccdc_mutex);
 				goto copy_from_user_err;
@@ -371,7 +395,7 @@ int ispccdc_request(void)
 							ISPCTRL_CCDC_CLK_EN |
 							ISPCTRL_SBL_WR1_RAM_EN,
 							ISP_CTRL);
-	omap_writel((omap_readl(ISPCCDC_CFG)) | ISPCCDC_CFG_VDLC, ISPCCDC_CFG);
+	omap_writel((omap_readl(ISPCCDC_CFG) | ISPCCDC_CFG_VDLC), ISPCCDC_CFG);
 	spin_unlock(&ispccdc_obj.ispccdc_lock);
 	return 0;
 }
@@ -479,20 +503,40 @@ void ispccdc_enable_lsc(u8 enable)
 		return;
 
 	if (enable) {
-		omap_writel(omap_readl(ISP_CTRL) | ISPCTRL_SBL_SHARED_RPORTB |
-					ISPCTRL_SBL_RD_RAM_EN, ISP_CTRL);
-		omap_writel(omap_readl(ISPCCDC_LSC_CONFIG) | 0x1,
-							ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISP_CTRL) | (ISPCTRL_SBL_SHARED_RPORTB |
+					ISPCTRL_SBL_RD_RAM_EN)), ISP_CTRL);
+		omap_writel((omap_readl(ISPCCDC_LSC_CONFIG) | 0x1),
+			ISPCCDC_LSC_CONFIG);
 		ispccdc_obj.lsc_en = 1;
 	} else {
-		omap_writel(omap_readl(ISPCCDC_LSC_CONFIG) & 0xFFFE,
-							ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISPCCDC_LSC_CONFIG) & ~0x1),
+			ISPCCDC_LSC_CONFIG);
+		omap_writel((omap_readl(ISP_CTRL) &
+					~(ISPCTRL_SBL_SHARED_RPORTB |
+					ISPCTRL_SBL_RD_RAM_EN)), ISP_CTRL);
 		ispccdc_obj.lsc_en = 0;
 	}
 }
 EXPORT_SYMBOL(ispccdc_enable_lsc);
 
 /**
+ * ispccdc_set_crop_offset_dynamic - Store the component order as component offset.
+ * @raw_fmt: Input data component order.
+ *
+ * Turns the component order into a horizontal & vertical offset and store
+ * offsets to be used later.
+ **/
+void ispccdc_set_crop_offset_dynamic(struct ispccdc_color_offset offset)
+{
+	printk(KERN_INFO "ipsccdc crop offset dyn(%d)\n", offset.offsetcode);
+	if (offset.offsetcode > ISPCCDC_INPUT_FMT_GB_RG)
+		offset.offsetcode = 0;
+	ispccdc_set_crop_offset(offset.offsetcode);
+
+}
+EXPORT_SYMBOL(ispccdc_set_crop_offset_dynamic);
+
+/**
  * ispccdc_set_crop_offset - Store the component order as component offset.
  * @raw_fmt: Input data component order.
  *
@@ -503,22 +547,26 @@ void ispccdc_set_crop_offset(enum ispccdc_raw_fmt raw_fmt)
 {
 	switch (raw_fmt) {
 	case ISPCCDC_INPUT_FMT_GR_BG:
-		ispccdc_obj.ccdcin_woffset = 1;
-		ispccdc_obj.ccdcin_hoffset = 0;
+		ispccdc_obj.ccdcin_wstart = 1;
+		ispccdc_obj.ccdcin_hstart = 0;
 		break;
 	case ISPCCDC_INPUT_FMT_BG_GR:
-		ispccdc_obj.ccdcin_woffset = 1;
-		ispccdc_obj.ccdcin_hoffset = 1;
+		ispccdc_obj.ccdcin_wstart = 1;
+		ispccdc_obj.ccdcin_hstart = 1;
 		break;
 	case ISPCCDC_INPUT_FMT_RG_GB:
-		ispccdc_obj.ccdcin_woffset = 0;
-		ispccdc_obj.ccdcin_hoffset = 0;
+		ispccdc_obj.ccdcin_wstart = 0;
+		ispccdc_obj.ccdcin_hstart = 0;
 		break;
 	case ISPCCDC_INPUT_FMT_GB_RG:
-		ispccdc_obj.ccdcin_woffset = 0;
-		ispccdc_obj.ccdcin_hoffset = 1;
+		ispccdc_obj.ccdcin_wstart = 0;
+		ispccdc_obj.ccdcin_hstart = 1;
 		break;
 	}
+	DPRINTK_ISPCCDC("ispccdc_crop_offset(%d)\n", raw_fmt);
+
+	ispccdc_obj.ccdcin_woffset = ispccdc_obj.ccdcin_wstart;
+	ispccdc_obj.ccdcin_hoffset = ispccdc_obj.ccdcin_hstart;
 }
 EXPORT_SYMBOL(ispccdc_set_crop_offset);
 
@@ -540,8 +588,10 @@ EXPORT_SYMBOL(ispccdc_set_crop_offset);
  **/
 void ispccdc_config_crop(u32 left, u32 top, u32 height, u32 width)
 {
-	ispccdc_obj.ccdcin_woffset = left + ((left + 1) % 2);
-	ispccdc_obj.ccdcin_hoffset = top + (top % 2);
+	ispccdc_obj.ccdcin_woffset = left +
+		((left + ispccdc_obj.ccdcin_wstart) % 2);
+	ispccdc_obj.ccdcin_hoffset = top +
+		((top + ispccdc_obj.ccdcin_hstart) % 2);
 
 	ispccdc_obj.crop_w = width - (width % 16);
 	ispccdc_obj.crop_h = height + (height % 2);
@@ -576,7 +626,7 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 	struct ispccdc_syncif syncif;
 	struct ispccdc_bclamp blkcfg;
 
-	u32 colptn = (ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT) |
+   u32 colptn = (ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT) |
 		(ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC1_SHIFT) |
 		(ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC2_SHIFT) |
 		(ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC3_SHIFT) |
@@ -630,7 +680,7 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
 		spin_lock(&ispccdc_obj.ispccdc_lock);
-		omap_writel((omap_readl(ISPCCDC_CFG)) & ~ISPCCDC_CFG_WENLOG,
+		omap_writel((omap_readl(ISPCCDC_CFG) & ~ISPCCDC_CFG_WENLOG),
 								ISPCCDC_CFG);
 		spin_unlock(&ispccdc_obj.ispccdc_lock);
 		vpcfg.bitshift_sel = BIT11_2;
@@ -658,8 +708,8 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 		syn_mode |= ISPCCDC_SYN_MODE_WEN;
 		/* Generally cam_wen is used with cam_hs, vs signals */
 		syn_mode |= ISPCCDC_SYN_MODE_EXWEN;
-		omap_writel((omap_readl(ISPCCDC_CFG))
-			| ISPCCDC_CFG_WENLOG, ISPCCDC_CFG);
+		omap_writel((omap_readl(ISPCCDC_CFG) |
+			ISPCCDC_CFG_WENLOG), ISPCCDC_CFG);
 		/* Video Port Configuration */
 		vpcfg.bitshift_sel = BIT9_0;
 		vpcfg.freq_sel = PIXCLKBY2;
@@ -775,8 +825,10 @@ int ispccdc_config_datapath(enum ccdc_input input, enum ccdc_output output)
 
 	ispccdc_obj.ccdc_inpfmt = input;
 	ispccdc_obj.ccdc_outfmt = output;
-		ispccdc_print_status();
-		isp_print_status();
+
+	ispccdc_print_status();
+	isp_print_status();
+
 	return 0;
 }
 EXPORT_SYMBOL(ispccdc_config_datapath);
@@ -1283,6 +1335,7 @@ int ispccdc_try_size(u32 input_w, u32 input_h, u32 *output_w, u32 *output_h)
 			*output_w -= (*output_w % 16);
 			*output_w += 16;
 		}
+      *output_h -= ispccdc_obj.ccdcin_hstart;
 	}
 
 	ispccdc_obj.ccdcout_w = *output_w;
@@ -1339,12 +1392,32 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 			((ispccdc_obj.ccdcin_h-ispccdc_obj.ccdcin_hoffset) <<
 					ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 					ISPCCDC_FMT_VERT);
+
+	#ifdef CONFIG_VIDEO_OMAP3_HP3A
+		omap_writel(ispccdc_obj.ccdcin_woffset
+						<< ISPCCDC_HORZ_INFO_SPH_SHIFT
+						| ((ispccdc_obj.ccdcout_w - 1)
+						<< ISPCCDC_HORZ_INFO_NPH_SHIFT),
+						ISPCCDC_HORZ_INFO);
+		omap_writel(ispccdc_obj.ccdcin_hoffset
+				<< ISPCCDC_VERT_START_SLV0_SHIFT,
+				ISPCCDC_VERT_START);
+		omap_writel((ispccdc_obj.ccdcout_h - 1) <<
+						ISPCCDC_VERT_LINES_NLV_SHIFT,
+						ISPCCDC_VERT_LINES);
+		ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2, 0, 0);
+	#else
+		omap_writel(ISPCCDC_HORZ_INFO_RESET, ISPCCDC_HORZ_INFO);
+		omap_writel(0, ISPCCDC_VERT_START);
+		omap_writel(0, ISPCCDC_VERT_LINES);
+	#endif
+
 		omap_writel((ispccdc_obj.ccdcout_w <<
 					ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
 					(ispccdc_obj.ccdcout_h <<
 					ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
 					ISPCCDC_VP_OUT);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25) &
+		omap_writel((((ispccdc_obj.ccdcout_h - 1) &
 					ISPCCDC_VDINT_0_MASK) <<
 					ISPCCDC_VDINT_0_SHIFT) |
 					((50 & ISPCCDC_VDINT_1_MASK) <<
@@ -1385,16 +1458,18 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 					((50 & ISPCCDC_VDINT_1_MASK) <<
 					ISPCCDC_VDINT_1_SHIFT), ISPCCDC_VDINT);
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_VP_MEM) {
-		omap_writel((1 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcin_woffset <<
+					ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
 					(ispccdc_obj.ccdcin_w <<
 					ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
 					ISPCCDC_FMT_HORZ);
-		omap_writel((0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcin_hoffset <<
+					ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
 					((ispccdc_obj.ccdcin_h) <<
 					ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 					ISPCCDC_FMT_VERT);
-		omap_writel((ispccdc_obj.ccdcout_w
-					<< ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
+		omap_writel((ispccdc_obj.ccdcout_w <<
+					ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
 					(ispccdc_obj.ccdcout_h <<
 					ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
 					ISPCCDC_VP_OUT);
@@ -1405,17 +1480,19 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 					ISPCCDC_HORZ_INFO_NPH_SHIFT),
 					ISPCCDC_HORZ_INFO);
 */
-		omap_writel(1 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+		omap_writel(ispccdc_obj.ccdcin_woffset <<
+					ISPCCDC_HORZ_INFO_SPH_SHIFT |
 					((ispccdc_obj.ccdcout_w - 1) <<
 					ISPCCDC_HORZ_INFO_NPH_SHIFT),
 					ISPCCDC_HORZ_INFO);
-		omap_writel(0 << ISPCCDC_VERT_START_SLV0_SHIFT,
+		omap_writel(ispccdc_obj.ccdcin_hoffset <<
+					ISPCCDC_VERT_START_SLV0_SHIFT,
 					ISPCCDC_VERT_START);
 		omap_writel((ispccdc_obj.ccdcout_h - 1) <<
 					ISPCCDC_VERT_LINES_NLV_SHIFT,
 					ISPCCDC_VERT_LINES);
 		ispccdc_config_outlineoffset(ispccdc_obj.ccdcout_w * 2, 0, 0);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25) &
+		omap_writel((((ispccdc_obj.ccdcout_h - 1) &
 					ISPCCDC_VDINT_0_MASK) <<
 					ISPCCDC_VDINT_0_SHIFT) |
 					((50 & ISPCCDC_VDINT_1_MASK) <<
@@ -1423,12 +1500,14 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 	} else if (ispccdc_obj.ccdc_outfmt == CCDC_OTHERS_LSC_MEM) {
 		/* Added by MMS */
 		/* Start with 1 pixel apart */
-		omap_writel((1 << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT)
+		omap_writel((ispccdc_obj.ccdcin_woffset <<
+				ISPCCDC_FMT_HORZ_FMTSPH_SHIFT)
 				| (ispccdc_obj.ccdcin_w
 				<< ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
 				ISPCCDC_FMT_HORZ);
 
-		omap_writel((0 << ISPCCDC_FMT_VERT_FMTSLV_SHIFT)
+		omap_writel((ispccdc_obj.ccdcin_hoffset <<
+				ISPCCDC_FMT_VERT_FMTSLV_SHIFT)
 				| ((ispccdc_obj.ccdcin_h)
 				<< ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
 				ISPCCDC_FMT_VERT);
@@ -1450,7 +1529,7 @@ int ispccdc_config_size(u32 input_w, u32 input_h, u32 output_w, u32 output_h)
 		/*Configure the HSIZE_OFF with output buffer width*/
 
 		ispccdc_config_outlineoffset((ispccdc_obj.ccdcout_w * 2), 0, 0);
-		omap_writel((((ispccdc_obj.ccdcout_h - 25)
+		omap_writel((((ispccdc_obj.ccdcout_h - 1)
 				& ISPCCDC_VDINT_0_MASK)
 				<< ISPCCDC_VDINT_0_SHIFT)
 				| (((50) &  ISPCCDC_VDINT_1_MASK)
@@ -1564,15 +1643,18 @@ void ispccdc_enable(u8 enable)
 	if (enable) {
 		if (ccdc_use_lsc && !ispccdc_obj.lsc_en &&
 			((ispccdc_obj.ccdc_inpfmt == CCDC_RAW) ||
-			(ispccdc_obj.ccdc_inpfmt == CCDC_RAW_PATTERN)))
+			(ispccdc_obj.ccdc_inpfmt == CCDC_RAW_PATTERN))) {
 			ispccdc_enable_lsc(1);
-			omap_writel(omap_readl(ISPCCDC_PCR) | (ISPCCDC_PCR_EN),
+		}
+		omap_writel(CCDC_VD0|CCDC_VD1, ISP_IRQ0STATUS);
+		omap_writel(omap_readl(ISPCCDC_PCR) | (ISPCCDC_PCR_EN),
 								ISPCCDC_PCR);
 	} else {
 		omap_writel(omap_readl(ISPCCDC_PCR) & ~(ISPCCDC_PCR_EN),
 								ISPCCDC_PCR);
 	}
-
+	/* write sync */
+	omap_readl(ISPCCDC_PCR);
 }
 EXPORT_SYMBOL(ispccdc_enable);
 
diff --git a/drivers/media/video/oldisp/ispccdc.h b/drivers/media/video/oldisp/ispccdc.h
index a7d1aa5..b0a9068 100644
--- a/drivers/media/video/oldisp/ispccdc.h
+++ b/drivers/media/video/oldisp/ispccdc.h
@@ -215,6 +215,9 @@ void ispccdc_set_wenlog(u32 wenlog);
 
 void ispccdc_set_dcsub(u32 dcsub);
 
+void ispccdc_set_crop_offset_dynamic(struct ispccdc_color_offset offset);
+
 void ispccdc_set_crop_offset(enum ispccdc_raw_fmt);
 
+void isp_lsc_isr(unsigned long status, void *arg1, void *arg2);
 #endif		/* OMAP_ISP_CCDC_H */
diff --git a/drivers/media/video/oldisp/ispcsi2.c b/drivers/media/video/oldisp/ispcsi2.c
index 2e25858..b7218eb 100644
--- a/drivers/media/video/oldisp/ispcsi2.c
+++ b/drivers/media/video/oldisp/ispcsi2.c
@@ -47,6 +47,15 @@ static bool update_ctrl;
 static bool uses_videoport;
 
 /**
+ * isp_csia_isr - CSIA interrupt handling.
+ **/
+void isp_csia_isr(unsigned long status, void *arg1, void *arg2)
+{
+	if (status & CSIA)
+		isp_csi2_isr();
+}
+
+/**
  * isp_csi2_complexio_lanes_config - Configuration of CSI2 ComplexIO lanes.
  * @reqcfg: Pointer to structure containing desired lane configuration
  *
@@ -1808,8 +1817,15 @@ void isp_csi2_isr(void)
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ)
 		printk(KERN_DEBUG "CSI2: ECC correction done\n");
 
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ) {
+		printk(KERN_ERR "CSI2: ECC correction failed\n");
+		ecc_counter++;
+	}
+#else
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ)
 		printk(KERN_ERR "CSI2: ECC correction failed\n");
+#endif
 
 	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ)
 		printk(KERN_ERR "CSI2: ComplexIO #2 failed\n");
diff --git a/drivers/media/video/oldisp/ispcsi2.h b/drivers/media/video/oldisp/ispcsi2.h
index 3cd366a..853a32e 100644
--- a/drivers/media/video/oldisp/ispcsi2.h
+++ b/drivers/media/video/oldisp/ispcsi2.h
@@ -177,6 +177,11 @@ struct isp_csi2_cfg_update {
 	struct isp_csi2_ctrl_cfg_update ctrl;
 };
 
+#if defined(CONFIG_VIDEO_MIPI_DLI_TEST)
+/*Counters for MIPI DLI.*/
+extern unsigned long ecc_counter;
+#endif
+
 int isp_csi2_complexio_lanes_config(struct isp_csi2_lanes_cfg *reqcfg);
 int isp_csi2_complexio_lanes_update(bool force_update);
 int isp_csi2_complexio_lanes_count(int cnt);
@@ -232,6 +237,7 @@ void isp_csi2_isr(void);
 int isp_csi2_reset(void);
 void isp_csi2_enable(int enable);
 void isp_csi2_regdump(void);
+void isp_csia_isr(unsigned long status, void *arg1, void *arg2);
 
 #endif	/* OMAP_ISP_CSI2_H */
 
diff --git a/drivers/media/video/oldisp/ispmmu.c b/drivers/media/video/oldisp/ispmmu.c
index c937bba..56ceef4 100644
--- a/drivers/media/video/oldisp/ispmmu.c
+++ b/drivers/media/video/oldisp/ispmmu.c
@@ -478,6 +478,7 @@ dma_addr_t ispmmu_map_pages(struct page **pages, int page_nr)
 	u32 pd, p_addr;
 	u32 *l2_table;
 	u32 page_index = 0;
+	dma_addr_t ret_addr;
 
 	DPRINTK_ISPMMU("map_pages: page_nr (number of pages) = %d\n", page_nr);
 
@@ -529,8 +530,11 @@ dma_addr_t ispmmu_map_pages(struct page **pages, int page_nr)
 	DPRINTK_ISPMMU("mapped to ISP virtual address 0x%x\n",
 		(u32)((idx << 20) + (p_addr & (PAGE_SIZE - 1))));
 
+	down(&ispmmu_mutex);
 	omap_writel(1, ISPMMU_GFLUSH);
-	return (dma_addr_t)((idx<<20) + (p_addr & (PAGE_SIZE - 1)));
+	up(&ispmmu_mutex);
+	ret_addr = (dma_addr_t)((idx<<20) + (p_addr & (PAGE_SIZE - 1)));
+	return ret_addr;
 
 release_mem:
 	for (; i >= 0; i--) {
@@ -576,6 +580,7 @@ int ispmmu_unmap(dma_addr_t v_addr)
 		return -EINVAL;
 	}
 
+	down(&ispmmu_mutex);
 	while (((*(ttb + idx)) & (ISPMMU_L1D_TYPE_MASK <<
 						ISPMMU_L1D_TYPE_SHIFT)) ==
 						(ISPMMU_L1D_TYPE_PAGE <<
@@ -583,13 +588,12 @@ int ispmmu_unmap(dma_addr_t v_addr)
 		*(ttb + idx) = (ISPMMU_L1D_TYPE_FAULT <<
 						ISPMMU_L1D_TYPE_SHIFT);
 		free_l2_page_table(l2p_table_addr[idx]);
-		l2p_table_addr[idx++] = 0;
-		if (!(idx % ISPMMU_REGION_ENTRIES_NR)) {
+		l2p_table_addr[idx] = 0;
+		if (!((++idx) % ISPMMU_REGION_ENTRIES_NR)) {
 			DPRINTK_ISPMMU("Do not exceed this 32M region\n");
 			break;
 		}
 	}
-	down(&ispmmu_mutex);
 	omap_writel(1, ISPMMU_GFLUSH);
 	up(&ispmmu_mutex);
 
diff --git a/drivers/media/video/oldisp/ispmmu.h b/drivers/media/video/oldisp/ispmmu.h
index 265ebb9..6560249 100644
--- a/drivers/media/video/oldisp/ispmmu.h
+++ b/drivers/media/video/oldisp/ispmmu.h
@@ -68,7 +68,7 @@
  * to keep track of these 16 L2 page table's status.
  */
 #define L2P_TABLE_SIZE			1024
-#define L2P_TABLE_NR 			62 /* Currently supports 4*5MP shots */
+#define L2P_TABLE_NR 			80
 #define L2P_TABLES_SIZE 		(L2P_TABLE_SIZE * L2P_TABLE_NR)
 
 /* Extra memory allocated to get ttb aligned on 16KB */
diff --git a/drivers/media/video/oldisp/isppreview.c b/drivers/media/video/oldisp/isppreview.c
index ac47153..716d294 100644
--- a/drivers/media/video/oldisp/isppreview.c
+++ b/drivers/media/video/oldisp/isppreview.c
@@ -460,30 +460,29 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 {
 	int ctr;
 
+	mutex_lock(&ispprev_obj.ispprev_mutex);
 	if ((ISP_ABS_TBL_NF & isptables_struct->flag) == ISP_ABS_TBL_NF) {
 		NF_enable = 1;
 		params->features |= (PREV_NOISE_FILTER);
 		if ((ISP_ABS_TBL_NF & isptables_struct->update) ==
 							ISP_ABS_TBL_NF) {
-			mutex_lock(&ispprev_obj.ispprev_mutex);
+			spin_lock(&ispprev_obj.ispprev_lock);
+
 			if (copy_from_user(&prev_nf_t, (struct ispprev_nf *)
 						(isptables_struct->prev_nf),
 						sizeof(struct ispprev_nf))) {
-				mutex_unlock(&ispprev_obj.ispprev_mutex);
+				spin_unlock(&ispprev_obj.ispprev_lock);
 				goto err_copy_from_user;
 			}
 
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 
-			spin_lock(&ispprev_obj.ispprev_lock);
 			if (ispprev_obj.stream_on == 0) {
 				NF_update = 0;
 				isppreview_config_noisefilter(prev_nf_t);
 				isppreview_enable_noisefilter(NF_enable);
 			} else
 				NF_update = 1;
-
-			spin_unlock(&ispprev_obj.ispprev_lock);
 		} else
 			NF_update = 0;
 	} else {
@@ -498,15 +497,16 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 
 	if ((ISP_ABS_TBL_REDGAMMA & isptables_struct->update) ==
 							ISP_ABS_TBL_REDGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
-		if (copy_from_user(redgamma_table, isptables_struct->red_gamma,
+		spin_lock(&ispprev_obj.ispprev_lock);
+
+		if (copy_from_user(redgamma_table,
+						isptables_struct->red_gamma,
 						sizeof(redgamma_table))) {
 			RG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_RED_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -517,24 +517,20 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			RG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		RG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
 	if ((ISP_ABS_TBL_GREENGAMMA & isptables_struct->update) ==
 						ISP_ABS_TBL_GREENGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
+		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (copy_from_user(greengamma_table,
 						isptables_struct->green_gamma,
 						sizeof(greengamma_table))) {
 			GG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_GREEN_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -545,24 +541,20 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			GG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		GG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
 	if ((ISP_ABS_TBL_BLUEGAMMA & isptables_struct->update) ==
 					ISP_ABS_TBL_BLUEGAMMA) {
-		mutex_lock(&ispprev_obj.ispprev_mutex);
-		if (copy_from_user(bluegamma_table, (isptables_struct->
-						blue_gamma),
+		spin_lock(&ispprev_obj.ispprev_lock);
+
+		if (copy_from_user(bluegamma_table,
+						(isptables_struct->blue_gamma),
 						sizeof(bluegamma_table))) {
 			BG_update = 0;
-			mutex_unlock(&ispprev_obj.ispprev_mutex);
+			spin_unlock(&ispprev_obj.ispprev_lock);
 			goto err_copy_from_user;
 		}
-		mutex_unlock(&ispprev_obj.ispprev_mutex);
-		spin_lock(&ispprev_obj.ispprev_lock);
+
 		if (ispprev_obj.stream_on == 0) {
 			omap_writel(ISPPRV_TBL_ADDR_BLUE_G_START,
 							ISPPRV_SET_TBL_ADDR);
@@ -573,15 +565,14 @@ int omap34xx_isp_tables_update(struct isptables_update *isptables_struct)
 			BG_update = 1;
 
 		spin_unlock(&ispprev_obj.ispprev_lock);
-	} else {
-		spin_lock(&ispprev_obj.ispprev_lock);
-		BG_update = 0;
-		spin_unlock(&ispprev_obj.ispprev_lock);
 	}
 
+	mutex_unlock(&ispprev_obj.ispprev_mutex);
 	return 0;
 
 err_copy_from_user:
+	mutex_unlock(&ispprev_obj.ispprev_mutex);
+
 	printk(KERN_ERR "Preview Tables:Copy From User Error");
 	return -EINVAL;
 }
@@ -632,29 +623,29 @@ void isppreview_config_shadow_registers()
 	}
 
 	if (GG_update) {
+		GG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_GREEN_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
 			omap_writel(greengamma_table[ctr],
 							ISPPRV_SET_TBL_DATA);
 		}
-		GG_update = 0;
 	}
 
 	if (RG_update) {
+		RG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_RED_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++)
 			omap_writel(redgamma_table[ctr], ISPPRV_SET_TBL_DATA);
-		RG_update = 0;
 	}
 
 	if (BG_update) {
+		BG_update = 0;
 		omap_writel(ISPPRV_TBL_ADDR_BLUE_G_START, ISPPRV_SET_TBL_ADDR);
 
 		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++)
 			omap_writel(bluegamma_table[ctr], ISPPRV_SET_TBL_DATA);
-		BG_update = 0;
 	}
 
 	if (NF_update && NF_enable) {
@@ -756,6 +747,8 @@ int isppreview_config_datapath(enum preview_input input,
 		pcr &= ~(ISPPRV_PCR_SOURCE);
 		pcr &= ~(ISPPRV_PCR_ONESHOT);
 		ispprev_obj.prev_inpfmt = PRV_RAW_CCDC;
+		isppreview_set_inaddr(0);
+		isppreview_config_inlineoffset(0);
 		break;
 	case PRV_RAW_MEM:
 		pcr |= ISPPRV_PCR_SOURCE;
@@ -1001,14 +994,10 @@ void isppreview_config_hmed(struct ispprev_hmed prev_hmed)
 	u32 odddist = 0;
 	u32 evendist = 0;
 
-	if (prev_hmed.odddist == 1)
-		odddist = ~ISPPRV_HMED_ODDDIST;
-	else
+	if (prev_hmed.odddist == 2)
 		odddist = ISPPRV_HMED_ODDDIST;
 
-	if (prev_hmed.evendist == 1)
-		evendist = ~ISPPRV_HMED_EVENDIST;
-	else
+	if (prev_hmed.evendist == 2)
 		evendist = ISPPRV_HMED_EVENDIST;
 
 	spin_lock(&ispprev_obj.ispprev_lock);
diff --git a/drivers/media/video/oldisp/ispreg.h b/drivers/media/video/oldisp/ispreg.h
index f7622d8..1b973a6 100644
--- a/drivers/media/video/oldisp/ispreg.h
+++ b/drivers/media/video/oldisp/ispreg.h
@@ -125,7 +125,7 @@
 #define CM_ICLKEN_CAM_EN		0x1
 #define CM_FCLKEN_CAM_EN		0x1
 
-#define CM_CAM_MCLK_HZ			432000000
+#define CM_CAM_MCLK_HZ		(OMAP_MCAM_SRC_CLK/OMAP_MCAM_SRC_DIV)
 
 /* ISP Submodules offset */
 
@@ -304,6 +304,8 @@
 #define ISPCCDC_PRGODD1			0x480BC690
 #define ISPCCDC_VP_OUT			0x480BC694
 
+#define ISPCCDC_HORZ_INFO_RESET		0x00000100
+
 #define ISPCCDC_LSC_CONFIG		0x480BC698
 #define ISPCCDC_LSC_INITIAL		0x480BC69C
 #define ISPCCDC_LSC_TABLE_BASE		0x480BC6A0
@@ -933,8 +935,9 @@
 #define ISPRSZ_PID_CID_SHIFT			8
 #define ISPRSZ_PID_TID_SHIFT			16
 
-#define ISPRSZ_PCR_ENABLE			0x5
+#define ISPRSZ_PCR_ENABLE			1
 #define ISPRSZ_PCR_BUSY				(1 << 1)
+#define ISPRSZ_PCR_ONESHOT			(1 << 2)
 
 #define ISPRSZ_CNT_HRSZ_SHIFT			0
 #define ISPRSZ_CNT_HRSZ_MASK			0x3FF
diff --git a/drivers/media/video/oldisp/ispresizer.c b/drivers/media/video/oldisp/ispresizer.c
index 221a21c..a8b3428 100644
--- a/drivers/media/video/oldisp/ispresizer.c
+++ b/drivers/media/video/oldisp/ispresizer.c
@@ -29,9 +29,7 @@
 #include "ispreg.h"
 #include "ispresizer.h"
 
-#if ISP_WORKAROUND
 dma_addr_t buff_addr_lsc_wa;
-#endif
 
 static u8 need_to_write_filter_coefs = {0};
 
@@ -262,6 +260,9 @@ int ispresizer_config_datapath(enum ispresizer_input input)
 	u32 cnt = 0;
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()+\n");
 	ispres_obj.resinput = input;
+
+	mutex_lock(&ispres_obj.ispres_mutex);
+	cnt = omap_readl(ISPRSZ_CNT);
 	switch (input) {
 	case RSZ_OTFLY_YUV:
 		cnt &= ~ISPRSZ_CNT_INPTYP;
@@ -282,13 +283,17 @@ int ispresizer_config_datapath(enum ispresizer_input input)
 		return -EINVAL;
 	}
 
-	mutex_lock(&ispres_obj.ispres_mutex);
-	omap_writel(omap_readl(ISPRSZ_CNT) | cnt, ISPRSZ_CNT);
+	omap_writel(cnt, ISPRSZ_CNT);
 	mutex_unlock(&ispres_obj.ispres_mutex);
 
+	/* Use bilinear interpolation for upsampling per TRM */
+	if (ispres_obj.outputwidth > ispres_obj.inputwidth)
+		ispresizer_enable_cbilin(1);
+	else
+		ispresizer_enable_cbilin(0);
+
 	ispresizer_config_ycpos(0);
 	ispresizer_config_filter_coef(&ispreszdefcoef);
-	ispresizer_enable_cbilin(0);
 	ispresizer_config_luma_enhance(&ispreszdefaultyenh);
 	DPRINTK_ISPRESZ("ispresizer_config_datapath()-\n");
 	return 0;
@@ -341,7 +346,7 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 	input_h = *input_height;
 
 	if (input_w < 32 || input_h < 32) {
-		DPRINTK_ISPCCDC("ISP_ERR: RESIZER cannot handle input width"
+		DPRINTK_ISPRESZ("ISP_ERR: RESIZER cannot handle input width"
 				" less than 32 pixels or height less than"
 				" 32\n");
 		return -EINVAL;
@@ -387,8 +392,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 		if (rsz < MINIMUM_RESIZE_VALUE) {
 			rsz = MINIMUM_RESIZE_VALUE;
 			*output_h = (((input_h - 4) * 256) / rsz) + 1;
-			printk(KERN_INFO "%s: using output_h %d instead\n",
-			       __func__, *output_h);
 		}
 	} else {
 		rsz = rsz_7;
@@ -397,8 +400,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 		if (rsz > MAXIMUM_RESIZE_VALUE) {
 			rsz = MAXIMUM_RESIZE_VALUE;
 			*output_h = (((input_h - 7) * 256) / rsz) + 1;
-			printk(KERN_INFO "%s: using output_h %d instead\n",
-			       __func__, *output_h);
 		}
 	}
 
@@ -428,8 +429,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 			rsz = MAXIMUM_RESIZE_VALUE;
 			*output_w = (((input_w - 7) * 256) / rsz) + 1;
 			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			printk(KERN_INFO "%s: using output_w %d instead\n",
-			       __func__, *output_w);
 		}
 	} else {
 		rsz = rsz_4;
@@ -437,8 +436,6 @@ int ispresizer_try_size(u32 *input_width, u32 *input_height, u32 *output_w,
 			rsz = MINIMUM_RESIZE_VALUE;
 			*output_w = (((input_w - 4) * 256) / rsz) + 1;
 			*output_w = (*output_w + 0xf) & 0xfffffff0;
-			printk(KERN_INFO "%s: using output_w %d instead\n",
-			       __func__, *output_w);
 		}
 	}
 
@@ -504,14 +501,15 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 		return -EINVAL;
 	}
 
-#if ISP_WORKAROUND
-	buff_addr_lsc_wa = isp_buf_get();
-	if (buff_addr_lsc_wa) {
-		/* Set Resizer input address and offset adderss */
-		ispresizer_set_inaddr(buff_addr_lsc_wa);
-		ispresizer_config_inlineoffset(omap_readl(ISPPRV_WADD_OFFSET));
+	if (isp_lsc_workaround_enabled()) {
+		buff_addr_lsc_wa = isp_buf_get();
+		if (buff_addr_lsc_wa) {
+			/* Set Resizer input address and offset adderss */
+			ispresizer_set_inaddr(buff_addr_lsc_wa);
+			ispresizer_config_inlineoffset
+				(omap_readl(ISPPRV_WADD_OFFSET));
+		}
 	}
-#endif
 
 	/* mutex_lock(&ispres_obj.ispres_mutex); */
 
@@ -522,19 +520,18 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 						ISPRSZ_CNT_VSTPH_SHIFT),
 						ISPRSZ_CNT);
 
-#if ISP_WORKAROUND
-	omap_writel((0x00 <<	ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-					(0x00 <<
-					ISPRSZ_IN_START_VERT_ST_SHIFT),
-					ISPRSZ_IN_START);
-
-#else
-	omap_writel(((ispres_obj.ipwd_crop * 2) <<
-					ISPRSZ_IN_START_HORZ_ST_SHIFT) |
-					(ispres_obj.ipht_crop <<
-					ISPRSZ_IN_START_VERT_ST_SHIFT),
-					ISPRSZ_IN_START);
-#endif
+	if (isp_lsc_workaround_enabled()) {
+		omap_writel((0x00 <<	ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+						(0x00 <<
+						ISPRSZ_IN_START_VERT_ST_SHIFT),
+						ISPRSZ_IN_START);
+	} else {
+		omap_writel(((ispres_obj.ipwd_crop * 2) <<
+						ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+						(ispres_obj.ipht_crop <<
+						ISPRSZ_IN_START_VERT_ST_SHIFT),
+						ISPRSZ_IN_START);
+	}
 
 	omap_writel((ispres_obj.inputwidth << ISPRSZ_IN_SIZE_HORZ_SHIFT) |
 						(ispres_obj.inputheight <<
@@ -560,8 +557,8 @@ int ispresizer_config_size(u32 input_w, u32 input_h, u32 output_w,
 						ISPRSZ_CNT);
 
 	/* mutex_unlock(&ispres_obj.ispres_mutex); */
-
-    ispresizer_write_filter_coef();
+	if (!ispresizer_busy())
+		ispresizer_write_filter_coef();
 
     ispresizer_config_outlineoffset(output_w*2);
     DPRINTK_ISPRESZ("ispresizer_config_size()-\n");
@@ -577,13 +574,22 @@ EXPORT_SYMBOL(ispresizer_config_size);
  **/
 void ispresizer_enable(u8 enable)
 {
-	int val;
+	u32 val;
 	DPRINTK_ISPRESZ("+ispresizer_enable()+\n");
-	if (enable)
-		val = (((omap_readl(ISPRSZ_PCR)) & 0x2) | ISPRSZ_PCR_ENABLE);
-	else
-		val = (omap_readl(ISPRSZ_PCR) & ~ISPRSZ_PCR_ENABLE);
-	omap_writel(val, ISPRSZ_PCR);
+	val = omap_readl(ISPRSZ_PCR);
+	if (enable) {
+		if (!(val & ISPRSZ_PCR_ENABLE)) {
+			omap_writel(RESZ_DONE, ISP_IRQ0STATUS);
+			omap_writel((val | ISPRSZ_PCR_ONESHOT |
+				ISPRSZ_PCR_ENABLE), ISPRSZ_PCR);
+			/* write sync */
+			omap_readl(ISPRSZ_PCR);
+		}
+	} else if (val & ISPRSZ_PCR_ENABLE) {
+		omap_writel((val & ~ISPRSZ_PCR_ENABLE), ISPRSZ_PCR);
+		/* write sync */
+		omap_readl(ISPRSZ_PCR);
+	}
 	DPRINTK_ISPRESZ("+ispresizer_enable()-\n");
 }
 EXPORT_SYMBOL(ispresizer_enable);
@@ -727,78 +733,74 @@ void ispresizer_write_filter_coef(void)
 	int i, j;
 	DPRINTK_ISPRESZ("ispresizer_write_filter_coef\n");
 
-	if (ispresizer_busy() == 0) {
-		if (ispres_obj.h_resz <= MID_RESIZE_VALUE) {
-			j = 0;
-			for (i = 0; i < 16; i++) {
+	if (ispres_obj.h_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			omap_writel((ispres_obj.coeflist.
+					h_filter_coef_4tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					h_filter_coef_4tap[j + 1] <<
+					ISPRSZ_HFILT10_COEF1_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
 				omap_writel((ispres_obj.coeflist.
-						h_filter_coef_4tap[j] <<
-						ISPRSZ_HFILT10_COEF0_SHIFT) |
-						(ispres_obj.coeflist.
-						h_filter_coef_4tap[j + 1] <<
-						ISPRSZ_HFILT10_COEF1_SHIFT),
-						ISPRSZ_HFILT10 + (i * 0x04));
+					h_filter_coef_7tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
+				j += 1;
+			} else {
+				omap_writel((ispres_obj.coeflist.
+					h_filter_coef_7tap[j] <<
+					ISPRSZ_HFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					h_filter_coef_7tap[j+1] <<
+					ISPRSZ_HFILT10_COEF1_SHIFT),
+					ISPRSZ_HFILT10 + (i * 0x04));
 				j += 2;
 			}
-		} else {
-			j = 0;
-			for (i = 0; i < 16; i++) {
-				if ((i + 1) % 4 == 0) {
-					omap_writel((ispres_obj.coeflist.
-							h_filter_coef_7tap[j] <<
-							ISPRSZ_HFILT10_COEF0_SHIFT),
-							ISPRSZ_HFILT10 + (i * 0x04));
-					j += 1;
-				} else {
-					omap_writel((ispres_obj.coeflist.
-							h_filter_coef_7tap[j] <<
-							ISPRSZ_HFILT10_COEF0_SHIFT) |
-							(ispres_obj.coeflist.
-							h_filter_coef_7tap[j+1] <<
-							ISPRSZ_HFILT10_COEF1_SHIFT),
-							ISPRSZ_HFILT10 + (i * 0x04));
-					j += 2;
-				}
-			}
 		}
-		if (ispres_obj.v_resz <= MID_RESIZE_VALUE) {
-			j = 0;
-			for (i = 0; i < 16; i++) {
+	}
+	if (ispres_obj.v_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			omap_writel((ispres_obj.coeflist.
+					v_filter_coef_4tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					v_filter_coef_4tap[j + 1] <<
+					ISPRSZ_VFILT10_COEF1_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
+				omap_writel((ispres_obj.coeflist.
+					v_filter_coef_7tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
+				j += 1;
+			} else {
 				omap_writel((ispres_obj.coeflist.
-						v_filter_coef_4tap[j] <<
-						ISPRSZ_VFILT10_COEF0_SHIFT) |
-						(ispres_obj.coeflist.
-						v_filter_coef_4tap[j + 1] <<
-						ISPRSZ_VFILT10_COEF1_SHIFT),
-						ISPRSZ_VFILT10 + (i * 0x04));
+					v_filter_coef_7tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT) |
+					(ispres_obj.coeflist.
+					v_filter_coef_7tap[j+1] <<
+					ISPRSZ_VFILT10_COEF1_SHIFT),
+					ISPRSZ_VFILT10 + (i * 0x04));
 				j += 2;
 			}
-		} else {
-			j = 0;
-			for (i = 0; i < 16; i++) {
-				if ((i + 1) % 4 == 0) {
-					omap_writel((ispres_obj.coeflist.
-							v_filter_coef_7tap[j] <<
-							ISPRSZ_VFILT10_COEF0_SHIFT),
-							ISPRSZ_VFILT10 + (i * 0x04));
-					j += 1;
-				} else {
-					omap_writel((ispres_obj.coeflist.
-							v_filter_coef_7tap[j] <<
-							ISPRSZ_VFILT10_COEF0_SHIFT) |
-							(ispres_obj.coeflist.
-							v_filter_coef_7tap[j+1] <<
-							ISPRSZ_VFILT10_COEF1_SHIFT),
-							ISPRSZ_VFILT10 + (i * 0x04));
-					j += 2;
-				}
-			}
 		}
-
-		need_to_write_filter_coefs = 0;
-	} else {
-		DPRINTK_ISPRESZ("Resizer busy when programming filter coefs\n");
 	}
+
+	need_to_write_filter_coefs = 0;
 }
 EXPORT_SYMBOL(ispresizer_write_filter_coef);
 
@@ -813,6 +815,7 @@ int ispresizer_config_inlineoffset(u32 offset)
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()+\n");
 	if (offset%32)
 		return -EINVAL;
+
 	omap_writel(offset << ISPRSZ_SDR_INOFF_OFFSET_SHIFT, ISPRSZ_SDR_INOFF);
 	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()-\n");
 	return 0;
@@ -830,6 +833,7 @@ int ispresizer_set_inaddr(u32 addr)
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()+\n");
 	if (addr%32)
 		return -EINVAL;
+
 	omap_writel(addr << ISPRSZ_SDR_INADD_ADDR_SHIFT, ISPRSZ_SDR_INADD);
 	DPRINTK_ISPRESZ("ispresizer_set_inaddr()-\n");
 	return 0;
diff --git a/drivers/media/video/oldomap34xxcam.c b/drivers/media/video/oldomap34xxcam.c
index 39d26db..3bb2e36 100644
--- a/drivers/media/video/oldomap34xxcam.c
+++ b/drivers/media/video/oldomap34xxcam.c
@@ -147,7 +147,10 @@ int omap34xxcam_update_vbq(struct videobuf_buffer *vb)
 	struct isp_af_xtrastats af_xtrastats;
 #endif
 
+#if !defined(CONFIG_VIDEO_OMAP3_HP3A)
 	do_gettimeofday(&vb->ts);
+#endif
+
 	vb->field_count = atomic_add_return(2, &fh->field_count);
 	vb->state = VIDEOBUF_DONE;
 #ifndef CONFIG_VIDEO_OMAP3_HP3A
@@ -376,9 +379,17 @@ static int vidioc_g_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct omap34xxcam_fh *ofh = fh;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
+	struct v4l2_format sensor_format;
 
+	/* Get size_out */
 	mutex_lock(&vdev->mutex);
 	f->fmt.pix = ofh->pix;
+
+	/* Get size_in (sensor pixel format) & save in user defined raw_data
+	   after f->fmt.pix */
+	vidioc_int_g_fmt_cap(vdev->vdev_sensor, &sensor_format);
+	memcpy(f->fmt.raw_data + sizeof(sensor_format.fmt.pix),
+		&sensor_format.fmt.pix, sizeof(sensor_format.fmt.pix));
 	mutex_unlock(&vdev->mutex);
 
 	return 0;
@@ -496,7 +507,8 @@ static int try_pix_parm(struct omap34xxcam_videodev *vdev,
 			 * Select bigger resolution if it's available
 			 * at same fps.
 			 */
-			if (frmi.width > best_pix_in->width
+			if ((frmi.width > best_pix_in->width ||
+				frmi.height > best_pix_in->height)
 			    && FPS_ABS_DIFF(fps, frmi.discrete)
 			    <= FPS_ABS_DIFF(fps, *best_ival))
 				goto do_it_now;
@@ -515,7 +527,7 @@ do_it_now:
 	if (best_pix_in->width == 0)
 		return -EINVAL;
 
-	dev_info(vdev->cam->dev, "w %d, h %d -> w %d, h %d\n",
+	dev_dbg(vdev->cam->dev, "w %d, h %d -> w %d, h %d\n",
 		 best_pix_in->width, best_pix_in->height,
 		 best_pix_out.width, best_pix_out.height);
 
@@ -1040,6 +1052,12 @@ static int vidioc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 
 	mutex_lock(&vdev->mutex);
 
+	/* If streaming, just change fps, don't try to change resolution */
+	if (vdev->streaming) {
+		rval = vidioc_int_s_parm(vdev->vdev_sensor, a);
+		goto out;
+	}
+
 	vdev->want_timeperframe = a->parm.capture.timeperframe;
 
 	pix_tmp = vdev->want_pix;
@@ -1047,6 +1065,7 @@ static int vidioc_s_parm(struct file *file, void *fh, struct v4l2_streamparm *a)
 	rval = s_pix_parm(vdev, &pix_tmp_sensor, &pix_tmp,
 			  &a->parm.capture.timeperframe);
 
+out:
 	mutex_unlock(&vdev->mutex);
 
 	return rval;
@@ -1196,7 +1215,7 @@ static int vidioc_enum_frameintervals(struct file *file, void *fh,
  * feedback. The request is then passed on to the ISP private IOCTL handler,
  * isp_handle_private()
  */
-static int vidioc_default(struct file *file, void *fh, int cmd, void *arg)
+static long vidioc_default(struct file *file, void *fh, int cmd, void *arg)
 {
 	struct omap34xxcam_fh *ofh = file->private_data;
 	struct omap34xxcam_videodev *vdev = ofh->vdev;
@@ -1287,9 +1306,9 @@ out:
  * @dev: numeric device identifier.
  * @settings: ptr to a sensor settings structure.
  *
- * This request is passed to the sensor driver based on the bit masked flags field of the
- * settings structure. If the sensor does not support the requested operation, an error is
- * returned.
+ * This request is passed to the sensor driver based on the bit masked flags
+ * field of the settings structure. If the sensor does not support the
+ * requested operation, an error is returned.
  *
  * If the requested device id is not valid, -ENODEV is returned.
  */
@@ -1298,6 +1317,7 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 	int err = -1;
 	struct omap34xxcam_videodev *vdev = NULL;
 	struct omap34xxcam_device *cam = omap34xxcam;
+	struct v4l2_streamparm a;
 	struct v4l2_control vc;
 	int i;
 
@@ -1313,6 +1333,14 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 
 	mutex_lock(&vdev->mutex);
 
+	if ((settings->flags & OMAP34XXCAM_SET_FPS) &&
+		  settings->fps != 0) {
+		a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		a.parm.capture.timeperframe.numerator = 1;
+		a.parm.capture.timeperframe.denominator = settings->fps;
+		err = vidioc_int_s_parm(vdev->vdev_sensor, &a);
+	}
+
 	if (settings->flags & OMAP34XXCAM_SET_EXPOSURE) {
 		vc.id = V4L2_CID_EXPOSURE;
 		vc.value = settings->exposure;
@@ -1328,7 +1356,13 @@ int omap34xxcam_sensor_settings(int dev, struct cam_sensor_settings *settings)
 	}
 
 update_sensor_exit:
-   vc.id = V4L2_CID_EXPOSURE;
+	a.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (vidioc_int_g_parm(vdev->vdev_sensor, &a) == 0) {
+		settings->fps = a.parm.capture.timeperframe.denominator /
+			a.parm.capture.timeperframe.numerator;
+	}
+
+	vc.id = V4L2_CID_EXPOSURE;
 	vc.value = 0;
 	if (vidioc_int_g_ctrl(vdev->vdev_sensor, &vc) == 0)
 		settings->exposure = (u32)vc.value;
diff --git a/drivers/media/video/oldomap34xxcam.h b/drivers/media/video/oldomap34xxcam.h
index 1c9c2fc..de6f16e 100644
--- a/drivers/media/video/oldomap34xxcam.h
+++ b/drivers/media/video/oldomap34xxcam.h
@@ -243,12 +243,14 @@ struct cam_sensor_settings{
 	u16 gain;
 	u16 regs;
 	void *reg_data;
+	u16 fps;
 };
 
 #define	OMAP34XXCAM_SET_EXPOSURE		0x1
 #define	OMAP34XXCAM_SET_GAIN			         0x2
 #define	OMAP34XXCAM_READ_REGS			   0x4
 #define	OMAP34XXCAM_WRITE_REGS			   0x8
+#define	OMAP34XXCAM_SET_FPS			   0x10
 
 #define	OMAP34XXCAM_REG_8BIT			         0x1
 #define	OMAP34XXCAM_REG_16BIT			      0x2
diff --git a/drivers/media/video/omap-vout/omapvout-dss.c b/drivers/media/video/omap-vout/omapvout-dss.c
index 0d08f96..25ecc8a 100644
--- a/drivers/media/video/omap-vout/omapvout-dss.c
+++ b/drivers/media/video/omap-vout/omapvout-dss.c
@@ -27,6 +27,9 @@
 
 #define VRFB_TX_TIMEOUT		1000
 
+#define DSS_MANUAL_MODE_THRESHOLD 307200 // 640*480
+static bool toggleUpdateMode = false;
+
 /*=== Local Functions ==================================================*/
 
 static int omapvout_dss_format_bytespp(u32 pixelformat)
@@ -465,19 +468,46 @@ static int omapvout_dss_perform_vrfb_dma(struct omapvout_device *vout,
 
 		w = vout->crop.width;
 		h = vout->crop.height;
+		if (vrfb->decimate_src) {
+			w = w / 2;
+			h = h / 2;
+		}
 
 		dss_fmt = omapvout_dss_color_mode(vout->pix.pixelformat);
+		bytespp = omapvout_dss_format_bytespp(vout->pix.pixelformat);
+
 		omap_vrfb_setup(&vrfb->ctx[0], vrfb->phy_addr[0],
 				w, h, dss_fmt, rot);
 		omap_vrfb_setup(&vrfb->ctx[1], vrfb->phy_addr[1],
 				w, h, dss_fmt, rot);
-
 		omapvout_dss_calc_offset(vout, vrfb->ctx[0].bytespp,
 				vrfb->ctx[0].xoffset, vrfb->ctx[0].yoffset);
 
-		bytespp = omapvout_dss_format_bytespp(vout->pix.pixelformat);
 		vrfb->en = (w * bytespp) / 4; /* 32 bit ES */
 		vrfb->fn = h;
+
+		if (!vrfb->decimate_src) {
+			/* Maintain the previous settings to reduce risk */
+			vrfb->src_mode = OMAP_DMA_AMODE_POST_INC;
+			vrfb->src_ei = 0;
+			vrfb->src_fi = 0;
+		} else {
+			/* Decimate source frame by 2 */
+
+			/* Need to use double indexed DMA */
+			vrfb->src_mode = OMAP_DMA_AMODE_DOUBLE_IDX;
+			/* Skip every other word */
+			vrfb->src_ei = 4 + 1;
+			/* Skip every other line.
+			 * - Mult width by 2 to get real input frame line
+			 *   width for the skip.
+			 * - Add 4 to account for the trailing word  of the
+			 *   previous line that needs still needs to be
+			 *   skipped.
+			 */
+			vrfb->src_fi = (w * bytespp * 2) + 4 + 1;
+		}
+
 		vrfb->dst_ei = 1;
 		if (fmt == V4L2_PIX_FMT_YUYV || fmt == V4L2_PIX_FMT_UYVY) {
 			vrfb->dst_fi = (OMAP_VRFB_LINE_LEN * bytespp * 2)
@@ -493,9 +523,9 @@ static int omapvout_dss_perform_vrfb_dma(struct omapvout_device *vout,
 
 	omap_set_dma_transfer_params(vrfb->dma_ch, OMAP_DMA_DATA_TYPE_S32,
 				vrfb->en, vrfb->fn, OMAP_DMA_SYNC_ELEMENT,
-				vrfb->dma_id, 0x0);
-	omap_set_dma_src_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
-				src_paddr, 0, 0);
+				vrfb->dma_id, 0);
+	omap_set_dma_src_params(vrfb->dma_ch, 0, vrfb->src_mode,
+				src_paddr, vrfb->src_ei, vrfb->src_fi);
 	omap_set_dma_src_burst_mode(vrfb->dma_ch, OMAP_DMA_DATA_BURST_16);
 	omap_set_dma_dest_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_DOUBLE_IDX,
 				dst_paddr, vrfb->dst_ei, vrfb->dst_fi);
@@ -546,13 +576,18 @@ static int omapvout_dss_update_overlay(struct omapvout_device *vout,
 		o_info.height = vout->crop.height;
 	}
 
+	if (vrfb->decimate_src) { /* Decimate source frame by 2 */
+		o_info.width = o_info.width / 2;
+		o_info.height = o_info.height / 2;
+	}
+
 	o_info.pos_x = vout->win.w.left & ~1;
 	o_info.pos_y = vout->win.w.top & ~1;
 	o_info.out_width = vout->win.w.width;
 	o_info.out_height = vout->win.w.height;
 	o_info.color_mode = omapvout_dss_color_mode(vout->pix.pixelformat);
 	o_info.rotation_type = OMAP_DSS_ROT_VRFB;
-	o_info.rotation = vout->rotation; // Rotation value, not buffer index
+	o_info.rotation = vout->rotation; /* Rotation value, not buffer index */
 	o_info.mirror = false;
 
 	rc = ovly->set_overlay_info(ovly, &o_info);
@@ -567,10 +602,12 @@ static int omapvout_dss_update_overlay(struct omapvout_device *vout,
 		return rc;
 	}
 
+	if (ovly->manager->device->update) {
 	rc = ovly->manager->device->update(ovly->manager->device, 0, 0,
 					vout->disp_width, vout->disp_height);
 	if (rc)
 		DBG("Overlay update failed %d\n", rc);
+	}
 
 	return rc;
 }
@@ -653,7 +690,7 @@ static void omapvout_dss_perform_update(struct work_struct *work)
 		 * is unlocked since the sync may take some time.
 		 */
 		dev = dss->overlay->manager->device;
-		if (dev->sync)
+		if (dev && dev->sync)
 			dev->sync(dev);
 
 		/* Since the mutex was unlocked, it is possible that the DSS
@@ -779,6 +816,7 @@ int omapvout_dss_open(struct omapvout_device *vout, u16 *disp_w, u16 *disp_h)
 	INIT_WORK(&vout->dss->work, omapvout_dss_perform_update);
 
 	vout->dss->enabled = false;
+	vout->dss->vrfb.decimate_src = false;
 
 failed:
 	return rc;
@@ -804,6 +842,16 @@ int omapvout_dss_enable(struct omapvout_device *vout)
 {
 	/* It is assumed that the caller has locked the vout mutex */
 
+	if (vout->win.w.height*vout->win.w.width > DSS_MANUAL_MODE_THRESHOLD) {
+		struct omap_dss_device *dev;
+		dev = vout->dss->overlay->manager->device;
+
+		if (dev && dev->set_update_mode) {
+			if (!dev->set_update_mode(dev, OMAP_DSS_UPDATE_AUTO))
+				toggleUpdateMode = true;
+		}
+	}
+
 	/* Reset the current frame idx */
 	vout->dss->cur_q_idx = -1;
 
@@ -822,7 +870,6 @@ void omapvout_dss_disable(struct omapvout_device *vout)
 	struct omap_overlay *ovly;
 	struct omap_dss_device *dev;
 	struct videobuf_buffer *buf, *tmp;
-
 	/* It is assumed that the caller has locked the vout mutex */
 
 	memset(&o_info, 0, sizeof(o_info));
@@ -831,6 +878,15 @@ void omapvout_dss_disable(struct omapvout_device *vout)
 	vout->dss->enabled = false;
 
 	dev = vout->dss->overlay->manager->device;
+
+	if (toggleUpdateMode) {
+		rc = dev->set_update_mode(dev, OMAP_DSS_UPDATE_MANUAL);
+	if (rc)
+		DBG("Setting DSS update mode failed %d\n", rc);
+	else
+		toggleUpdateMode = false;
+	}
+
 	if (vout->dss->working && dev->sync) {
 		/* Allow the current frame to finish */
 		mutex_unlock(&vout->mtx);
@@ -856,10 +912,12 @@ void omapvout_dss_disable(struct omapvout_device *vout)
 	if (rc)
 		DBG("Overlay manager apply failed %d\n", rc);
 
+	if (ovly->manager->device->update) {
 	rc = ovly->manager->device->update(ovly->manager->device,
 				0, 0, vout->disp_width, vout->disp_height);
 	if (rc)
 		DBG("Display update failed %d\n", rc);
+	}
 }
 
 int omapvout_dss_update(struct omapvout_device *vout)
@@ -885,3 +943,13 @@ int omapvout_dss_update(struct omapvout_device *vout)
 	return 0;
 }
 
+bool omapvout_dss_get_decimate(struct omapvout_device *vout)
+{
+	return vout->dss->vrfb.decimate_src;
+}
+
+void omapvout_dss_set_decimate(struct omapvout_device *vout, bool enable)
+{
+	vout->dss->vrfb.decimate_src = enable;
+}
+
diff --git a/drivers/media/video/omap-vout/omapvout-dss.h b/drivers/media/video/omap-vout/omapvout-dss.h
index dde8eff..b9345d5 100644
--- a/drivers/media/video/omap-vout/omapvout-dss.h
+++ b/drivers/media/video/omap-vout/omapvout-dss.h
@@ -26,8 +26,12 @@ struct omapvout_dss_vrfb {
 	/* VRFB dma config data */
 	u32 en;
 	u32 fn;
+	u32 src_mode;
+	u32 src_ei;
+	u32 src_fi;
 	u32 dst_ei;
 	u32 dst_fi;
+	bool decimate_src;
 
 	/* VRFB dma channel data */
 	int dma_id;
@@ -75,6 +79,8 @@ extern bool omapvout_dss_is_rotation_supported(struct omapvout_device *vout);
 extern int  omapvout_dss_enable(struct omapvout_device *vout);
 extern void omapvout_dss_disable(struct omapvout_device *vout);
 extern int  omapvout_dss_update(struct omapvout_device *vout);
+extern bool omapvout_dss_get_decimate(struct omapvout_device *vout);
+extern void omapvout_dss_set_decimate(struct omapvout_device *vout, bool en);
 
 #endif /* __OMAPVOUT_DSS_H__ */
 
diff --git a/drivers/media/video/omap-vout/omapvout.c b/drivers/media/video/omap-vout/omapvout.c
index a56718f..1b74b7d 100644
--- a/drivers/media/video/omap-vout/omapvout.c
+++ b/drivers/media/video/omap-vout/omapvout.c
@@ -35,6 +35,7 @@
 #include "omapvout-vbq.h"
 #include "omapvout-bp.h"
 
+#define V4L2_CID_PRIVATE_DECIMATE_BY_2		(V4L2_CID_PRIVATE_BASE + 0x921)
 #define MODULE_NAME "omapvout"
 
 /* list of image formats supported by OMAP2 video pipelines */
@@ -70,8 +71,81 @@ const static struct v4l2_fmtdesc omap2_formats[] = {
 
 #define NUM_OUTPUT_FORMATS (sizeof(omap2_formats)/sizeof(omap2_formats[0]))
 
+/* This is a way to allow other components to force a desired rotation.
+ * This will take effect when streaming is next enabled.
+ */
+struct omapvout_override {
+	int dirty;
+	int force_rotation_dirty;
+	int force_rotation_enable;
+	int forced_rotation;
+	int client_rotation;
+};
+
+#define NUM_PLANES (3)
+static struct omapvout_override gOverride[NUM_PLANES];
+
+
+int omapvout_force_rotation(int plane, int enable, int rotation)
+{
+	struct omapvout_override *ovr;
+	int en;
+
+	if (plane < 0 || plane >= NUM_PLANES) {
+		DBG("Invalid plane (%d)\n", plane);
+		return -1;
+	}
+
+	ovr = &gOverride[plane];
+	if (ovr->force_rotation_enable == enable &&
+	    ovr->forced_rotation == rotation)
+		return 0;
+
+	en = (enable) ? 1 : 0;
+	if (en) {
+		if (rotation < 0 || rotation > 3) {
+			DBG("Invalid rotation (%d)\n", rotation);
+			return -1;
+		}
+
+		ovr->forced_rotation = rotation;
+	}
+
+	ovr->force_rotation_dirty = 1;
+	ovr->force_rotation_enable = en;
+	ovr->dirty = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL(omapvout_force_rotation);
+
 /*=== Local Functions ==================================================*/
 
+static void omapvout_chk_overrides(struct omapvout_device *vout)
+{
+	struct omapvout_override *ovr;
+
+	ovr = &gOverride[vout->id];
+
+	if (!ovr->dirty)
+		return;
+
+	if (ovr->force_rotation_dirty) {
+		ovr->force_rotation_dirty = 0;
+		if (ovr->force_rotation_enable) {
+			ovr->client_rotation = vout->rotation;
+			vout->rotation = ovr->forced_rotation;
+		} else {
+			vout->rotation = ovr->client_rotation;
+		}
+		printk("omapvout_chk_overrides/%d/%d/%d\n", \
+			ovr->force_rotation_enable, \
+			ovr->forced_rotation, ovr->client_rotation);
+	}
+
+	ovr->dirty = 0;
+}
+
 static int omapvout_crop_to_size(struct v4l2_rect *rect, int w, int h)
 {
 	struct v4l2_rect try;
@@ -227,6 +301,17 @@ static void omapvout_free_resources(struct omapvout_device *vout)
 	kfree(vout);
 }
 
+#ifdef CONFIG_TVOUT_SHOLEST
+static int video_status;
+void set_video_status(int onoff)
+{
+  video_status = onoff;
+}
+int get_video_status(void)
+{
+  return video_status;
+}
+#endif
 /*=== V4L2 Interface Functions =========================================*/
 
 static int omapvout_open(struct file *file)
@@ -237,6 +322,9 @@ static int omapvout_open(struct file *file)
 
 	DBG("omapvout_open\n");
 
+#ifdef CONFIG_TVOUT_SHOLEST
+  set_video_status(1);
+#endif
 	vout = video_drvdata(file);
 
 	if (vout == NULL) {
@@ -298,6 +386,8 @@ static int omapvout_open(struct file *file)
 
 	vout->mmap_cnt = 0;
 
+	omapvout_chk_overrides(vout);
+
 	mutex_unlock(&vout->mtx);
 
 	file->private_data = vout;
@@ -314,7 +404,9 @@ static int omapvout_release(struct file *file)
 	struct omapvout_device *vout;
 
 	DBG("omapvout_release\n");
-
+#ifdef CONFIG_TVOUT_SHOLEST
+  set_video_status(0);
+#endif
 	vout = video_drvdata(file);
 
 	if (vout == NULL) {
@@ -564,6 +656,8 @@ static int omapvout_vidioc_s_fmt_vid_overlay(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_window(vout, win);
 	if (rc != 0)
 		goto failed;
@@ -602,6 +696,8 @@ static int omapvout_vidioc_s_fmt_vid_out(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_pixel_format(vout, pix);
 	if (rc != 0)
 		goto failed;
@@ -700,6 +796,8 @@ static int omapvout_vidioc_s_crop(struct file *file, void *priv,
 		goto failed;
 	}
 
+	omapvout_chk_overrides(vout);
+
 	rc = omapvout_try_crop(vout, &rect);
 	if (rc != 0)
 		goto failed;
@@ -785,7 +883,8 @@ static int omapvout_vidioc_qbuf(struct file *file, void *priv,
 	DBG("Q'ing Frame %d\n", b->index);
 
 	mutex_lock(&vout->mtx);
-        rc = videobuf_qbuf(&vout->queue, b);
+	omapvout_chk_overrides(vout);
+	rc = videobuf_qbuf(&vout->queue, b);
 	mutex_unlock(&vout->mtx);
 
 	return rc;
@@ -821,6 +920,8 @@ static int omapvout_vidioc_streamon(struct file *file, void *priv,
 
 	mutex_lock(&vout->mtx);
 
+	omapvout_chk_overrides(vout);
+
 	/* Not sure how else to do this.  We can't truly validate the
 	 * configuration until all of the pieces have been provided, like
 	 * input, output, crop sizes and rotation.  This is the only point
@@ -909,6 +1010,10 @@ static int omapvout_vidioc_g_ctrl(struct file *file, void *priv,
 	case V4L2_CID_BG_COLOR:
 		ctrl->value = vout->bg_color;
 		break;
+	case V4L2_CID_PRIVATE_DECIMATE_BY_2:
+		ctrl->value = (int) omapvout_dss_get_decimate(vout);
+		break;
+
 	default:
 		rc = -EINVAL;
 		break;
@@ -948,6 +1053,11 @@ static int omapvout_vidioc_s_ctrl(struct file *file, void *priv,
 			DBG("Invalid rotation %d\n", v);
 			rc = -ERANGE;
 		}
+		if (rc == 0 && gOverride[vout->id].force_rotation_enable) {
+			gOverride[vout->id].client_rotation = vout->rotation;
+			vout->rotation = gOverride[vout->id].forced_rotation;
+			gOverride[vout->id].force_rotation_dirty = 0;
+		}
 		break;
 	case V4L2_CID_BG_COLOR:
 		if (v < 0 || v > 0xFFFFFF) {
@@ -957,6 +1067,10 @@ static int omapvout_vidioc_s_ctrl(struct file *file, void *priv,
 			vout->bg_color = v;
 		}
 		break;
+	case V4L2_CID_PRIVATE_DECIMATE_BY_2:
+		omapvout_dss_set_decimate(vout, ((v) ? true : false));
+		break;
+
 	default:
 		rc = -EINVAL;
 		break;
@@ -1121,6 +1235,8 @@ static int __init omapvout_probe_device(struct omap_vout_config *cfg,
 
 	vout->id = plane;
 
+	memset(gOverride, 0, sizeof(gOverride));
+
 	return 0;
 
 cleanup:
diff --git a/drivers/media/video/omap_mot/Kconfig b/drivers/media/video/omap_mot/Kconfig
new file mode 100644
index 0000000..f15b5c8
--- /dev/null
+++ b/drivers/media/video/omap_mot/Kconfig
@@ -0,0 +1,8 @@
+config VIDEO_OMAP_MOT_VIDEOOUT
+	tristate "Video out driver"
+	depends on VIDEO_DEV && VIDEO_V4L2 && OMAP2_DSS
+
+config VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+	tristate "Video out driver buffer pool"
+	depends on VIDEO_OMAP_MOT_VIDEOOUT
+
diff --git a/drivers/media/video/omap_mot/Makefile b/drivers/media/video/omap_mot/Makefile
new file mode 100644
index 0000000..b3585ac
--- /dev/null
+++ b/drivers/media/video/omap_mot/Makefile
@@ -0,0 +1,7 @@
+
+vout-objs := omapvout.o omapvout-dss.o omapvout-mem.o
+
+obj-$(CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL) += omapvout-bp.o
+
+obj-$(CONFIG_VIDEO_OMAP_MOT_VIDEOOUT) += vout.o
+
diff --git a/drivers/media/video/omap_mot/omapvout-bp.c b/drivers/media/video/omap_mot/omapvout-bp.c
new file mode 100644
index 0000000..98308c7
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout-bp.c
@@ -0,0 +1,183 @@
+/*
+ * drivers/media/video/omap_mot/omapvout-bp.c
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/mm.h>
+
+#include "omapvout.h"
+#include "omapvout-mem.h"
+#include "omapvout-bp.h"
+
+#define OMAPVOUT_BP_MAX_BUFFERS (20)
+
+struct omapvout_bp *omapvout_bp_create(u8 num_bufs, u32 buf_size)
+{
+	struct omapvout_bp *bp;
+	int num = num_bufs;
+	int size;
+	int i;
+	u32 paddr;
+	u32 vaddr;
+	u32 bsize;
+
+	if (num > OMAPVOUT_BP_MAX_BUFFERS)
+		num = OMAPVOUT_BP_MAX_BUFFERS;
+
+	size = sizeof(struct omapvout_bp) +
+			(num * sizeof(struct omapvout_bp_entry));
+	bp = kzalloc(size, GFP_KERNEL);
+	if (!bp)
+		return NULL;
+
+	mutex_init(&bp->lock);
+	mutex_lock(&bp->lock);
+
+	bsize = PAGE_ALIGN(buf_size);
+	bp->num_entries = num;
+	for (i = 0; i < num; i++) {
+		if (omapvout_mem_alloc(bsize, &paddr, &vaddr) == 0) {
+			bp->buf[i].size = bsize;
+			bp->buf[i].phy_addr = paddr;
+			bp->buf[i].virt_addr = vaddr;
+		}
+	}
+
+	mutex_unlock(&bp->lock);
+
+	return bp;
+}
+
+void omapvout_bp_init(struct omapvout_device *vout)
+{
+	struct omapvout_bp *bp = vout->bp;
+
+	mutex_lock(&bp->lock);
+
+	bp->ref_cnt++;
+
+	mutex_unlock(&bp->lock);
+}
+
+void omapvout_bp_destroy(struct omapvout_device *vout)
+{
+	struct omapvout_bp *bp = vout->bp;
+	int i;
+
+	if (bp == NULL)
+		return;
+
+	vout->bp = NULL;
+
+	mutex_lock(&bp->lock);
+
+	if (bp->ref_cnt > 0)
+		bp->ref_cnt--;
+
+	if (bp->ref_cnt > 0) {
+		/* Release any buffers still alloc'd to this user */
+		for (i = 0; i < bp->num_entries; i++) {
+			if (bp->buf[i].size == 0)
+				continue;
+
+			if (bp->buf[i].in_use && bp->buf[i].user == vout->id)
+				bp->buf[i].in_use = 0;
+		}
+		mutex_unlock(&bp->lock);
+	} else {
+		/* Destroy everything */
+		for (i = 0; i < bp->num_entries; i++) {
+			if (bp->buf[i].size == 0)
+				continue;
+
+			if (bp->buf[i].in_use)
+				DBG("Destroying an in-use buffer\n");
+
+			omapvout_mem_free(bp->buf[i].phy_addr,
+					bp->buf[i].virt_addr,
+					bp->buf[i].size);
+		}
+		mutex_unlock(&bp->lock);
+
+		mutex_destroy(&bp->lock);
+		kfree(bp);
+	}
+}
+
+bool omapvout_is_bp_buffer(struct omapvout_device *vout, u32 phy_addr)
+{
+	struct omapvout_bp *bp = vout->bp;
+	int i;
+
+	if (!bp)
+		return false;
+
+	for (i = 0; i < bp->num_entries; i++) {
+		if (phy_addr == bp->buf[i].phy_addr)
+			return true;
+	}
+
+	return false;
+}
+
+int omapvout_bp_alloc(struct omapvout_device *vout, u32 req_size,
+				u32 *phy_addr, u32 *virt_addr, u32 *size)
+{
+	struct omapvout_bp *bp = vout->bp;
+	int i;
+	int rc = -ENOMEM;
+
+	if (!bp)
+		return -ENOMEM;
+
+	mutex_lock(&bp->lock);
+
+	for (i = 0; i < bp->num_entries; i++) {
+		if (bp->buf[i].in_use == 0 && bp->buf[i].size >= req_size) {
+			bp->buf[i].in_use = 1;
+			bp->buf[i].user = vout->id;
+			*phy_addr = bp->buf[i].phy_addr;
+			*virt_addr = bp->buf[i].virt_addr;
+			*size = bp->buf[i].size;
+			rc = 0;
+			break;
+		}
+	}
+
+	mutex_unlock(&bp->lock);
+
+	return rc;
+}
+
+int omapvout_bp_release(struct omapvout_device *vout, u32 phy_addr)
+{
+	struct omapvout_bp *bp = vout->bp;
+	int i;
+	int rc = -EINVAL;
+
+	mutex_lock(&bp->lock);
+
+	for (i = 0; i < bp->num_entries; i++) {
+		if (bp->buf[i].phy_addr == phy_addr) {
+			if (bp->buf[i].in_use)
+				bp->buf[i].in_use = 0;
+			else
+				DBG("Releasing an unused buffer\n");
+
+			/* Found the buffer, so say so */
+			rc = 0;
+
+			break;
+		}
+	}
+
+	mutex_unlock(&bp->lock);
+
+	return rc;
+}
+
diff --git a/drivers/media/video/omap_mot/omapvout-bp.h b/drivers/media/video/omap_mot/omapvout-bp.h
new file mode 100644
index 0000000..0b56709
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout-bp.h
@@ -0,0 +1,38 @@
+/*
+ * drivers/media/video/omap_mot/omapvout-bp.h
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __OMAPVOUT_BP_H__
+#define __OMAPVOUT_BP_H__
+
+struct omapvout_bp_entry {
+	u32 in_use;
+	u32 user;
+	u32 size;
+	u32 phy_addr;
+	u32 virt_addr;
+};
+
+struct omapvout_bp {
+	struct mutex lock; /* Lock for all buffer pool accesses */
+	int ref_cnt;
+	int num_entries;
+	struct omapvout_bp_entry buf[0];
+};
+
+extern struct omapvout_bp *omapvout_bp_create(u8 num_buffers, u32 buf_size);
+extern void omapvout_bp_init(struct omapvout_device *vout);
+extern void omapvout_bp_destroy(struct omapvout_device *vout);
+extern bool omapvout_is_bp_buffer(struct omapvout_device *vout, u32 phy_addr);
+extern int omapvout_bp_alloc(struct omapvout_device *vout, u32 req_size,
+				 u32 *phy_addr, u32 *virt_addr, u32 *size);
+extern int omapvout_bp_release(struct omapvout_device *vout, u32 phy_addr);
+
+#endif /* __OMAPVOUT_BP_H__ */
+
diff --git a/drivers/media/video/omap_mot/omapvout-dss.c b/drivers/media/video/omap_mot/omapvout-dss.c
new file mode 100644
index 0000000..211f365
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout-dss.c
@@ -0,0 +1,695 @@
+/*
+ * drivers/media/video/omap_mot/omapvout-dss.c
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * Based on drivers/media/video/omap24xx/omap24xxvout.c&h
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/mm.h>
+#include <mach/display.h>
+#include <mach/dma.h>
+#include <mach/vrfb.h>
+
+#include "omapvout.h"
+#include "omapvout-dss.h"
+#include "omapvout-mem.h"
+
+#define DMA_CHAN_ALLOTED	1
+#define DMA_CHAN_NOT_ALLOTED	0
+
+#define VRFB_TX_TIMEOUT		1000
+
+#define INVALID_SEQ_NUM		0
+
+/*=== Local Functions ==================================================*/
+
+static int omapvout_dss_format_bytespp(u32 pixelformat)
+{
+	int bpp = 2;
+
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_RGB32:
+		bpp = 4;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		bpp = 2;
+		break;
+	}
+
+	return bpp;
+}
+
+static enum omap_color_mode omapvout_dss_color_mode(u32 pixelformat)
+{
+	enum omap_color_mode mode = OMAP_DSS_COLOR_RGB16;
+
+	switch (pixelformat) {
+	case V4L2_PIX_FMT_RGB32:
+		mode = OMAP_DSS_COLOR_RGB24U;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+		mode = OMAP_DSS_COLOR_RGB16;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		mode = OMAP_DSS_COLOR_YUV2;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		mode = OMAP_DSS_COLOR_UYVY;
+		break;
+	}
+
+	return mode;
+}
+
+static int omapvout_dss_calc_offset(struct omapvout_device *vout)
+{
+	struct omapvout_dss *dss;
+	int rc = 0;
+	u32 fmt;
+	int bpp;
+	int bpp_mult = 1;
+	u16 ow, oh;
+	int iw, ih;
+	int cx, cy, cw, ch;
+
+	/* It is assumed that the caller has locked the vout mutex */
+
+	fmt = vout->pix.pixelformat;
+	bpp = omapvout_dss_format_bytespp(fmt);
+	if (fmt == V4L2_PIX_FMT_YUYV || fmt == V4L2_PIX_FMT_UYVY)
+		bpp_mult = 2;
+
+	iw = vout->pix.width;
+	ih = vout->pix.height;
+	cx = vout->crop.left;
+	cy = vout->crop.top;
+	cw = vout->crop.width;
+	ch = vout->crop.height;
+
+	ow = iw;
+	oh = ih;
+	omap_vrfb_adjust_size(&ow, &oh, bpp);
+	ow = ow - iw;
+	oh = oh - ih;
+
+	dss = vout->dss;
+
+	switch (vout->rotation)	{
+	case 1: /* 90 degrees */
+		dss->foffset = (cx * OMAP_VRFB_LINE_LEN * bpp * bpp_mult)
+				+ ((oh + (ih - cy - ch)) * bpp * bpp_mult);
+		break;
+	case 2: /* 180 degrees */
+		dss->foffset = ((oh + (ih - cy - ch)) * OMAP_VRFB_LINE_LEN
+							* bpp * bpp_mult)
+				+ ((ow + (iw - cx - cw)) * bpp * bpp_mult);
+		break;
+	case 3: /* 270 degrees */
+		dss->foffset = ((ow + (iw - cx - cw)) * OMAP_VRFB_LINE_LEN
+							* bpp * bpp_mult)
+				+ (cy * bpp * bpp_mult);
+		break;
+	default:
+	case 0: /* 0 degrees */
+		dss->foffset = ((cy * iw) + (cx)) * bpp;
+		break;
+	}
+
+	return rc;
+}
+
+static int omapvout_dss_config_colorkey(struct omapvout_device *vout, bool init)
+{
+	struct omap_overlay_manager *mgr;
+	struct omap_overlay_manager_info m_info;
+
+	mgr = vout->dss->overlay->manager;
+	if (mgr == NULL)
+		return -EINVAL;
+
+	if (mgr->set_manager_info == NULL || mgr->get_manager_info == NULL)
+		return -EINVAL;
+
+	mgr->get_manager_info(mgr, &m_info);
+	if (vout->colorkey_en) {
+		m_info.alpha_enabled = false;
+		if (init) {
+			m_info.trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;
+			m_info.trans_key = vout->colorkey;
+			m_info.trans_enabled = true;
+		} else {
+			m_info.trans_enabled = false;
+		}
+
+		mgr->set_manager_info(mgr, &m_info);
+	} else {
+		m_info.trans_enabled = false;
+		m_info.alpha_enabled = false;
+		mgr->set_manager_info(mgr, &m_info);
+	}
+
+	return 0;
+}
+
+/* This functions wakes up the application once the DMA transfer to
+ * VRFB space is completed.
+ */
+static void omapvout_dss_vrfb_dma_cb(int lch, u16 ch_status, void *data)
+{
+	struct omapvout_dss_vrfb *vrfb;
+
+	vrfb = (struct omapvout_dss_vrfb *) data;
+
+	vrfb->dma_complete = true;
+	wake_up_interruptible(&vrfb->wait);
+}
+
+static int omapvout_dss_acquire_vrfb(struct omapvout_device *vout)
+{
+	int rc = 0;
+	int size;
+	u16 w, h;
+	struct omapvout_dss_vrfb *vrfb;
+
+	/* It is assumed that the caller has locked the vout mutex */
+
+	vrfb = &vout->dss->vrfb;
+	vrfb->dma_id = OMAP_DMA_NO_DEVICE;
+	vrfb->dma_ch = -1;
+	vrfb->req_status = DMA_CHAN_NOT_ALLOTED;
+	vrfb->next = 0;
+
+	rc = omap_vrfb_request_ctx(&vrfb->ctx[0]);
+	if (rc != 0) {
+		DBG("VRFB context allocation 0 failed %d\n", rc);
+		goto failed_ctx0;
+	}
+
+	rc = omap_vrfb_request_ctx(&vrfb->ctx[1]);
+	if (rc != 0) {
+		DBG("VRFB context allocation 1 failed %d\n", rc);
+		goto failed_ctx1;
+	}
+
+	w = vout->max_video_width;
+	h = vout->max_video_height;
+	omap_vrfb_adjust_size(&w, &h, vout->max_video_bytespp);
+	size = PAGE_ALIGN(w * h * vout->max_video_bytespp);
+	vrfb->size = size;
+
+	rc = omapvout_mem_alloc(size, &vrfb->phy_addr[0], &vrfb->virt_addr[0]);
+	if (rc != 0) {
+		DBG("VRFB buffer alloc 0 failed %d\n", rc);
+		goto failed_mem0;
+	}
+
+	rc = omapvout_mem_alloc(size, &vrfb->phy_addr[1], &vrfb->virt_addr[1]);
+	if (rc != 0) {
+		DBG("VRFB buffer alloc 1 failed %d\n", rc);
+		goto failed_mem1;
+	}
+
+	rc = omap_request_dma(vrfb->dma_id, "VRFB DMA",
+				omapvout_dss_vrfb_dma_cb,
+				(void *)vrfb,
+				&vrfb->dma_ch);
+	if (rc != 0) {
+		printk(KERN_INFO "No VRFB DMA channel for %d\n", vout->id);
+		goto failed_dma;
+	}
+
+	vrfb->req_status = DMA_CHAN_ALLOTED;
+	init_waitqueue_head(&vrfb->wait);
+
+	return rc;
+
+failed_dma:
+	omapvout_mem_free(vrfb->phy_addr[1], vrfb->virt_addr[1], size);
+failed_mem1:
+	omapvout_mem_free(vrfb->phy_addr[0], vrfb->virt_addr[0], size);
+failed_mem0:
+	omap_vrfb_release_ctx(&vrfb->ctx[1]);
+failed_ctx1:
+	omap_vrfb_release_ctx(&vrfb->ctx[0]);
+failed_ctx0:
+	return rc;
+}
+
+static int omapvout_dss_release_vrfb(struct omapvout_device *vout)
+{
+	int rc = 0;
+	int size;
+	struct omapvout_dss_vrfb *vrfb;
+
+	/* It is assumed that the caller has locked the vout mutex */
+
+	vrfb = &vout->dss->vrfb;
+	if (vrfb->req_status == DMA_CHAN_ALLOTED) {
+		vrfb->req_status = DMA_CHAN_NOT_ALLOTED;
+		omap_free_dma(vrfb->dma_ch);
+		/* FIXME: de-init the wait queue? */
+
+		size = vrfb->size;
+		omapvout_mem_free(vrfb->phy_addr[0], vrfb->virt_addr[0], size);
+		omapvout_mem_free(vrfb->phy_addr[1], vrfb->virt_addr[1], size);
+
+		omap_vrfb_release_ctx(&vrfb->ctx[0]);
+		omap_vrfb_release_ctx(&vrfb->ctx[1]);
+	}
+
+	return rc;
+}
+
+static int omapvout_dss_perform_vrfb_dma(struct omapvout_device *vout,
+					int buf_idx, bool vrfb_cfg)
+{
+	int rc = 0;
+	struct omapvout_dss_vrfb *vrfb;
+	u32 src_paddr;
+	u32 dst_paddr;
+
+	/* It is assumed that the caller has locked the vout mutex */
+
+	if (vout->rotation == 0)
+		return 0;
+
+	if (vout->dss->vrfb.req_status != DMA_CHAN_ALLOTED)
+		return -EINVAL;
+
+	vrfb = &vout->dss->vrfb;
+
+	if (vrfb_cfg) {
+		enum omap_color_mode dss_fmt;
+		int bytespp;
+		int w, h;
+		u32 fmt = vout->pix.pixelformat;
+
+		w = vout->crop.width;
+		h = vout->crop.height;
+
+		dss_fmt = omapvout_dss_color_mode(vout->pix.pixelformat);
+		omap_vrfb_setup(&vrfb->ctx[0], vrfb->phy_addr[0],
+							w, h, dss_fmt);
+		omap_vrfb_setup(&vrfb->ctx[1], vrfb->phy_addr[1],
+							w, h, dss_fmt);
+
+		bytespp = omapvout_dss_format_bytespp(vout->pix.pixelformat);
+		vrfb->en = (w * bytespp) / 4; /* 32 bit ES */
+		vrfb->fn = h;
+		vrfb->dst_ei = 1;
+		if (fmt == V4L2_PIX_FMT_YUYV || fmt == V4L2_PIX_FMT_UYVY) {
+			vrfb->dst_fi = (OMAP_VRFB_LINE_LEN * bytespp * 2)
+							- (vrfb->en * 4) + 1;
+		} else {
+			vrfb->dst_fi = (OMAP_VRFB_LINE_LEN * bytespp)
+							- (vrfb->en * 4) + 1;
+		}
+	}
+
+	src_paddr = vout->fq[buf_idx].phy_addr;
+	dst_paddr = vrfb->ctx[vrfb->next].paddr[0];
+
+	omap_set_dma_transfer_params(vrfb->dma_ch, OMAP_DMA_DATA_TYPE_S32,
+				vrfb->en, vrfb->fn, OMAP_DMA_SYNC_ELEMENT,
+				vrfb->dma_id, 0x0);
+	omap_set_dma_src_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
+				src_paddr, 0, 0);
+	omap_set_dma_src_burst_mode(vrfb->dma_ch, OMAP_DMA_DATA_BURST_16);
+	omap_set_dma_dest_params(vrfb->dma_ch, 0, OMAP_DMA_AMODE_DOUBLE_IDX,
+				dst_paddr, vrfb->dst_ei, vrfb->dst_fi);
+	omap_set_dma_dest_burst_mode(vrfb->dma_ch, OMAP_DMA_DATA_BURST_16);
+	omap_dma_set_global_params(DMA_DEFAULT_ARB_RATE, 0x20, 0);
+
+	vrfb->dma_complete = false;
+	omap_start_dma(vrfb->dma_ch);
+	wait_event_interruptible_timeout(vrfb->wait, vrfb->dma_complete,
+							VRFB_TX_TIMEOUT);
+
+	if (!vrfb->dma_complete) {
+		DBG("VRFB DMA timeout\n");
+		omap_stop_dma(vrfb->dma_ch);
+		return -EINVAL;
+	}
+
+	return rc;
+}
+
+static int omapvout_dss_update_overlay(struct omapvout_device *vout,
+							int buf_idx)
+{
+	struct omap_overlay_info o_info;
+	struct omap_overlay *ovly;
+	int rc = 0;
+	int rot = vout->rotation;
+
+	/* It is assumed that the caller has locked the vout mutex */
+
+	/* Populate the overlay info struct and set it */
+	memset(&o_info, 0, sizeof(o_info));
+	o_info.enabled = true;
+	if (rot == 0) {
+		o_info.paddr = vout->fq[buf_idx].phy_addr;
+		o_info.paddr += vout->dss->foffset;
+		o_info.vaddr = NULL;
+		o_info.screen_width = vout->pix.width;
+	} else {
+		struct omapvout_dss_vrfb *vrfb;
+
+		vrfb = &vout->dss->vrfb;
+		o_info.paddr = vrfb->ctx[vrfb->next].paddr[rot];
+		o_info.paddr += vout->dss->foffset;
+		o_info.vaddr = NULL;
+		o_info.screen_width = OMAP_VRFB_LINE_LEN;
+
+		vrfb->next = (vrfb->next) ? 0 : 1;
+	}
+
+	if (rot == 1 || rot == 3) { /* 90 or 270 degree rotation */
+		o_info.width = vout->crop.height;
+		o_info.height = vout->crop.width;
+	} else {
+		o_info.width = vout->crop.width;
+		o_info.height = vout->crop.height;
+	}
+
+	o_info.pos_x = vout->win.w.left;
+	o_info.pos_y = vout->win.w.top;
+	o_info.out_width = vout->win.w.width;
+	o_info.out_height = vout->win.w.height;
+	o_info.color_mode = omapvout_dss_color_mode(vout->pix.pixelformat);
+	if (rot == 0)
+		o_info.rotation_type = OMAP_DSS_ROT_DMA;
+	else
+		o_info.rotation_type = OMAP_DSS_ROT_VRFB;
+
+	o_info.rotation = rot;
+	o_info.mirror = false;
+
+	ovly = vout->dss->overlay;
+	rc = ovly->set_overlay_info(ovly, &o_info);
+	if (rc) {
+		DBG("Failed setting the overlay info %d\n", rc);
+		return rc;
+	}
+
+	rc = ovly->manager->apply(ovly->manager);
+	if (rc) {
+		DBG("Failed apply to overlay manager %d\n", rc);
+		return rc;
+	}
+
+	rc = ovly->manager->device->update(ovly->manager->device,
+					o_info.pos_x, o_info.pos_y,
+					o_info.out_width, o_info.out_height);
+	if (rc)
+		DBG("Overlay update failed %d\n", rc);
+
+	return rc;
+}
+
+static void omapvout_dss_perform_update(struct work_struct *work)
+{
+	struct omapvout_device *vout;
+	struct omapvout_dss *dss;
+	struct omap_dss_device *dev;
+	int i;
+	int rc;
+	int idx = 0;
+	u32 seqn = INVALID_SEQ_NUM;
+
+	dss = container_of(work, struct omapvout_dss, work);
+	vout = dss->vout;
+
+	if (dss->exit_work)
+		return;
+
+	if (!dss->enabled)
+		return;
+
+	mutex_lock(&vout->mtx);
+
+	/* Find a frame to process */
+	for (i = vout->fq_cnt - 1; i >= 0; i--) {
+		if (vout->fq[i].seq_num != INVALID_SEQ_NUM) {
+			if (seqn == INVALID_SEQ_NUM ||
+					vout->fq[i].seq_num < seqn) {
+				seqn = vout->fq[i].seq_num;
+				idx = i;
+			}
+		}
+	}
+
+	if (seqn == INVALID_SEQ_NUM) {
+		DBG("No frame found to process\n");
+		goto failed;
+	}
+
+	vout->fq[idx].seq_num = INVALID_SEQ_NUM;
+
+	if (dss->need_cfg) {
+		rc = omapvout_dss_calc_offset(vout);
+		if (rc != 0) {
+			DBG("Offset calculation failed %d\n", rc);
+			goto failed_w_idx;
+		}
+
+		rc = omapvout_dss_config_colorkey(vout, true);
+		if (rc != 0) {
+			DBG("Alpha config failed %d\n", rc);
+			goto failed_w_idx;
+		}
+	}
+
+	rc = omapvout_dss_perform_vrfb_dma(vout, idx, dss->need_cfg);
+	if (rc != 0) {
+		DBG("VRFB rotation failed %d\n", rc);
+		goto failed_w_idx;
+	}
+
+	rc = omapvout_dss_update_overlay(vout, idx);
+	if (rc != 0) {
+		DBG("DSS update failed %d\n", rc);
+		goto failed_w_idx;
+	}
+
+	dss->need_cfg = false;
+
+	mutex_unlock(&vout->mtx);
+
+	/* Wait until the new frame is being used.  There is no problem
+	 * doing this here since we are in a worker thread.  The mutex
+	 * is unlocked since the sync may take some time.
+	 */
+	dev = dss->overlay->manager->device;
+	if (dev->sync)
+		dev->sync(dev);
+
+	/* Since the mutex was unlocked, it is possible that the DSS may
+	 * be exiting when we return, so check for this and exit if so.
+	 */
+	if (dss->exit_work)
+		return;
+
+	mutex_lock(&vout->mtx);
+
+	if (vout->rotation == 0) {
+		if (vout->fq_cur_idx != -1) {
+			vout->fq[vout->fq_cur_idx].flags &=
+						~(V4L2_BUF_FLAG_QUEUED);
+			vout->fq[vout->fq_cur_idx].flags |= V4L2_BUF_FLAG_DONE;
+			wake_up_interruptible(&vout->fq_wait);
+		}
+
+		vout->fq_cur_idx = idx;
+	} else {
+		vout->fq[idx].flags &= ~(V4L2_BUF_FLAG_QUEUED);
+		vout->fq[idx].flags |= V4L2_BUF_FLAG_DONE;
+		wake_up_interruptible(&vout->fq_wait);
+	}
+
+	mutex_unlock(&vout->mtx);
+
+	return;
+
+failed_w_idx:
+	/* Set the done flag on failures to be sure the buffer can be DQ'd */
+	vout->fq[idx].flags &= ~(V4L2_BUF_FLAG_QUEUED);
+	vout->fq[idx].flags |= V4L2_BUF_FLAG_DONE;
+	wake_up_interruptible(&vout->fq_wait);
+failed:
+	mutex_unlock(&vout->mtx);
+}
+
+/*=== Public Functions =================================================*/
+
+int  omapvout_dss_init(struct omapvout_device *vout, enum omap_plane plane)
+{
+	struct omap_overlay *ovly;
+	int rc = 0;
+	int i;
+	int cnt;
+
+	vout->dss = kzalloc(sizeof(struct omapvout_dss), GFP_KERNEL);
+	if (vout->dss == NULL) {
+		rc = -ENOMEM;
+		goto failed;
+	}
+
+	/* Retrieve the desired DSS overlay object */
+	vout->dss->overlay = NULL;
+	cnt = omap_dss_get_num_overlays();
+	for (i = 0; i < cnt; i++) {
+		ovly = omap_dss_get_overlay(i);
+		if (ovly->id == plane) {
+			vout->dss->overlay = ovly;
+			break;
+		}
+	}
+
+	if (vout->dss->overlay == NULL) {
+		DBG("No overlay %d found\n", plane);
+		rc = -ENODEV;
+		goto failed_mem;
+	}
+
+	rc = omapvout_dss_acquire_vrfb(vout);
+	if (rc != 0) {
+		DBG("VRFB allocation failed\n");
+		goto failed_mem;
+	}
+
+	vout->dss->vout = vout;
+
+	return rc;
+
+failed_mem:
+	kfree(vout->dss);
+failed:
+	return rc;
+}
+
+void omapvout_dss_remove(struct omapvout_device *vout)
+{
+	if (vout->dss != NULL) {
+		omapvout_dss_release_vrfb(vout);
+		kfree(vout->dss);
+	}
+}
+
+int omapvout_dss_open(struct omapvout_device *vout, u16 *disp_w, u16 *disp_h)
+{
+	struct omap_dss_device *dev;
+	int rc = 0;
+
+	if (vout->dss->overlay->manager == NULL) {
+		DBG("No manager found\n");
+		rc = -ENODEV;
+		goto failed;
+	}
+
+	if (vout->dss->overlay->manager->device == NULL) {
+		DBG("No device found\n");
+		rc = -ENODEV;
+		goto failed;
+	}
+
+	dev = vout->dss->overlay->manager->device;
+
+	/* TODO: Do we need to deal with rotation? */
+	dev->get_resolution(dev, disp_w, disp_h);
+
+	vout->dss->workqueue = create_singlethread_workqueue("OMAPVOUT-DSS");
+	if (vout->dss->workqueue == NULL) {
+		rc = -ENOMEM;
+		goto failed;
+	}
+	INIT_WORK(&vout->dss->work, omapvout_dss_perform_update);
+
+	vout->dss->exit_work = false;
+	vout->dss->enabled = false;
+
+failed:
+	return rc;
+}
+
+void omapvout_dss_release(struct omapvout_device *vout)
+{
+	vout->dss->exit_work = true;
+
+	flush_workqueue(vout->dss->workqueue);
+	destroy_workqueue(vout->dss->workqueue);
+}
+
+bool omapvout_dss_is_rotation_supported(struct omapvout_device *vout)
+{
+	return vout->dss->vrfb.req_status == DMA_CHAN_ALLOTED;
+}
+
+int omapvout_dss_enable(struct omapvout_device *vout)
+{
+	/* It is assumed that the caller has locked the vout mutex */
+
+	/* Force a reconfiguration */
+	vout->dss->need_cfg = true;
+
+	vout->dss->enabled = true;
+
+	return 0;
+}
+
+void omapvout_dss_disable(struct omapvout_device *vout)
+{
+	int rc = 0;
+	struct omap_overlay_info o_info;
+	struct omap_overlay *ovly;
+
+	/* It is assumed that the caller has locked the vout mutex */
+
+	memset(&o_info, 0, sizeof(o_info));
+	o_info.enabled = false;
+
+	rc = omapvout_dss_config_colorkey(vout, false);
+	if (rc)
+		DBG("Disabling alpha failed %d\n", rc);
+
+	ovly = vout->dss->overlay;
+	rc = ovly->set_overlay_info(ovly, &o_info);
+	if (rc)
+		DBG("Setting overlay info failed %d\n", rc);
+
+	rc = ovly->manager->apply(ovly->manager);
+	if (rc)
+		DBG("Overlay manager apply failed %d\n", rc);
+
+	rc = ovly->manager->device->update(ovly->manager->device,
+				0, 0, vout->disp_width, vout->disp_height);
+	if (rc)
+		DBG("Display update failed %d\n", rc);
+
+	vout->dss->enabled = false;
+}
+
+int omapvout_dss_update(struct omapvout_device *vout)
+{
+	if (!vout->dss->enabled) {
+		DBG("DSS overlay is not enabled\n");
+		return -EINVAL;
+	}
+
+	if (queue_work(vout->dss->workqueue, &vout->dss->work) == 0) {
+		DBG("Queuing DSS work failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
diff --git a/drivers/media/video/omap_mot/omapvout-dss.h b/drivers/media/video/omap_mot/omapvout-dss.h
new file mode 100644
index 0000000..a753825
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout-dss.h
@@ -0,0 +1,76 @@
+/*
+ * drivers/media/video/omap_mot/omapvout-dss.h
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * Based on drivers/media/video/omap24xx/omap24xxvout.c&h
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __OMAPVOUT_DSS_H__
+#define __OMAPVOUT_DSS_H__
+
+struct omapvout_dss_vrfb {
+	/* Ping-pong buffers and VRFB contexts */
+	struct vrfb ctx[2];
+	u32 phy_addr[2];
+	u32 virt_addr[2];
+	int size;
+	int next;
+
+	/* VRFB dma config data */
+	u32 en;
+	u32 fn;
+	u32 dst_ei;
+	u32 dst_fi;
+
+	/* VRFB dma channel data */
+	int dma_id;
+	int dma_ch;
+	int req_status;
+	bool dma_complete;
+	wait_queue_head_t wait;
+};
+
+struct omapvout_dss {
+	struct omap_overlay *overlay;
+
+	/* FIXME: This is a minor hack to allow the work callback to
+	 * gain access to the vout pointer.
+	 */
+	struct omapvout_device *vout;
+
+	bool enabled;
+	bool need_cfg;
+
+	struct omapvout_dss_vrfb vrfb;
+	int foffset; /* per frame address offset */
+
+	struct work_struct work;
+	struct workqueue_struct *workqueue;
+	bool exit_work;
+};
+
+/* Driver init/remove time calls */
+extern int  omapvout_dss_init(struct omapvout_device *vout,
+						enum omap_plane plane);
+extern void omapvout_dss_remove(struct omapvout_device *vout);
+
+/* Driver open/release time calls */
+extern int  omapvout_dss_open(struct omapvout_device *vout,
+						u16 *disp_w, u16 *disp_h);
+extern void omapvout_dss_release(struct omapvout_device *vout);
+
+/* Driver operation calls */
+extern bool omapvout_dss_is_rotation_supported(struct omapvout_device *vout);
+extern int  omapvout_dss_enable(struct omapvout_device *vout);
+extern void omapvout_dss_disable(struct omapvout_device *vout);
+extern int  omapvout_dss_update(struct omapvout_device *vout);
+
+#endif /* __OMAPVOUT_DSS_H__ */
+
diff --git a/drivers/media/video/omap_mot/omapvout-mem.c b/drivers/media/video/omap_mot/omapvout-mem.c
new file mode 100644
index 0000000..d919202
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout-mem.c
@@ -0,0 +1,118 @@
+/*
+ * drivers/media/video/omap_mot/omapvout-mem.c
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * Based on drivers/media/video/omap24xx/omap24xxvout.c&h
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+
+#include <asm/processor.h>
+#include <asm/cacheflush.h>
+#include <asm/page.h>
+
+#include "omapvout.h"
+#include "omapvout-mem.h"
+
+int omapvout_mem_alloc(u32 size, u32 *phy_addr, u32 *virt_addr)
+{
+	int	order;
+	u32	dss_page_addr;
+	u32	dss_page_phy;
+	u32	dss_page_virt;
+	u32	used, alloc_end;
+	struct page	*tmp_page;
+
+	size = PAGE_ALIGN(size);
+	order = get_order(size);
+
+	dss_page_addr = __get_free_pages(GFP_KERNEL, order);
+	if (!dss_page_addr) {
+		printk(KERN_ERR "Failed to allocate pages !!!! \n");
+		return -ENOMEM;
+	}
+
+	/*
+	 *'alloc_pages' allocates pages in power of 2,
+	 *so free the not needed pages
+	 */
+	split_page(virt_to_page(dss_page_addr), order);
+	alloc_end = dss_page_addr + (PAGE_SIZE<<order);
+	used = dss_page_addr + size;
+
+	DBG("mem_alloc: dss_page_addr=0x%x, alloc_end=0x%x, used=0x%x\n"
+		, dss_page_addr, alloc_end, used);
+	DBG("mem_alloc: physical_start=0x%lx, order=0x%x, size=0x%x\n"
+		, virt_to_phys((void *)dss_page_addr), order, size);
+
+	while (used < alloc_end) {
+		BUG_ON(!virt_addr_valid((void *)used));
+		tmp_page = virt_to_page((void *)used);
+		__free_page(tmp_page);
+		used += PAGE_SIZE;
+	}
+
+	dss_page_phy = virt_to_phys((void *)dss_page_addr);
+	dss_page_virt = (u32) ioremap_cached(dss_page_phy, size);
+
+	*phy_addr = dss_page_phy;
+	*virt_addr = dss_page_virt;
+
+	return 0;
+}
+
+void omapvout_mem_free(u32 phy_addr, u32 virt_addr, u32 size)
+{
+	u32 vaddr;
+	u32	end;
+
+	size = PAGE_ALIGN(size);
+	vaddr = (u32) __va((void *)phy_addr);
+	end = vaddr + size;
+	while (vaddr < end) {
+		free_page(vaddr);
+		vaddr += PAGE_SIZE;
+	}
+	iounmap((void *) virt_addr);
+}
+
+int omapvout_mem_map(struct vm_area_struct *vma, u32 phy_addr)
+{
+	struct page *cpage;
+	void *pos;
+	u32 start;
+	u32 size;
+
+
+	vma->vm_flags |= VM_RESERVED;
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	pos = (void *) phy_addr;
+	start = vma->vm_start;
+	size = (vma->vm_end - vma->vm_start);
+
+	while (size > 0) {
+		cpage = pfn_to_page(((unsigned int)pos) >> PAGE_SHIFT);
+		if (vm_insert_page(vma, start, cpage)) {
+			printk(KERN_ERR "Failed to insert page to VMA \n");
+			return -EAGAIN;
+		}
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	vma->vm_flags &= ~VM_IO; /* using shared anonymous pages */
+
+	return 0;
+}
+
+
diff --git a/drivers/media/video/omap_mot/omapvout-mem.h b/drivers/media/video/omap_mot/omapvout-mem.h
new file mode 100644
index 0000000..6fb2cb8
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout-mem.h
@@ -0,0 +1,23 @@
+/*
+ * drivers/media/video/omap_mot/omapvout-mem.h
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * Based on drivers/media/video/omap24xx/omap24xxvout.c&h
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __OMAPVOUT_MEM_H__
+#define __OMAPVOUT_MEM_H__
+
+extern int  omapvout_mem_alloc(u32 size, u32 *phy_addr, u32 *virt_addr);
+extern void omapvout_mem_free(u32 phy_addr, u32 virt_addr, u32 size);
+extern int  omapvout_mem_map(struct vm_area_struct *vma, u32 phy_addr);
+
+#endif /* __OMAPVOUT_MEM_H__ */
+
diff --git a/drivers/media/video/omap_mot/omapvout.c b/drivers/media/video/omap_mot/omapvout.c
new file mode 100644
index 0000000..f6436b4
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout.c
@@ -0,0 +1,1502 @@
+/*
+ * drivers/media/video/omap_mot/omapvout.c
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * Based on drivers/media/video/omap24xx/omap24xxvout.c&h
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+#include <linux/vmalloc.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+
+#include <mach/io.h>
+
+#include "omapvout.h"
+#include "omapvout-dss.h"
+#include "omapvout-mem.h"
+
+#ifdef CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+#include "omapvout-bp.h"
+#endif
+
+/*=====================================================*/
+/* These should be defined in a platform specific file */
+#ifndef OMAPVOUT_VIDEO_1_DEVICE_ID
+	#define OMAPVOUT_VIDEO_1_DEVICE_ID	1
+#endif
+#ifndef OMAPVOUT_VIDEO_2_DEVICE_ID
+	#define OMAPVOUT_VIDEO_2_DEVICE_ID	2
+#endif
+#ifndef OMAPVOUT_VIDEO_MAX_WIDTH
+	#define OMAPVOUT_VIDEO_MAX_WIDTH	864
+#endif
+#ifndef OMAPVOUT_VIDEO_MAX_HEIGHT
+	#define OMAPVOUT_VIDEO_MAX_HEIGHT	648
+#endif
+#ifndef OMAPVOUT_VIDEO_MAX_BPP
+	#define OMAPVOUT_VIDEO_MAX_BPP		2
+#endif
+
+#ifdef CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+#ifndef OMAPVOUT_VIDEO_BP_BUF_COUNT
+	#define OMAPVOUT_VIDEO_BP_BUF_COUNT	6
+#endif
+#ifndef OMAPVOUT_VIDEO_BP_BUF_SIZE
+	#define OMAPVOUT_VIDEO_BP_BUF_SIZE	\
+		PAGE_ALIGN(OMAPVOUT_VIDEO_MAX_WIDTH * \
+				OMAPVOUT_VIDEO_MAX_HEIGHT * 2)
+#endif
+#endif /* CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL */
+/*=====================================================*/
+
+
+#define MODULE_NAME "omapvout"
+#define VOUT1_NAME  "omapvout1"
+#define VOUT2_NAME  "omapvout2"
+
+#define V4L2_CID_PRIV_OFFSET		0x00530000 /* Arbitrary, semi-unique */
+#define V4L2_CID_PRIV_ROTATION		(V4L2_CID_PRIVATE_BASE \
+						+ V4L2_CID_PRIV_OFFSET + 0)
+#define V4L2_CID_PRIV_COLORKEY		(V4L2_CID_PRIVATE_BASE \
+						+ V4L2_CID_PRIV_OFFSET + 1)
+#define V4L2_CID_PRIV_COLORKEY_EN	(V4L2_CID_PRIVATE_BASE \
+						+ V4L2_CID_PRIV_OFFSET + 2)
+
+/* list of image formats supported by OMAP2 video pipelines */
+const static struct v4l2_fmtdesc omap2_formats[] = {
+{
+	/* Note:  V4L2 defines RGB565 as:
+	 *      Byte 0                    Byte 1
+	 *      g2 g1 g0 r4 r3 r2 r1 r0   b4 b3 b2 b1 b0 g5 g4 g3
+	 *
+	 * We interpret RGB565 as:
+	 *      Byte 0                    Byte 1
+	 *      g2 g1 g0 b4 b3 b2 b1 b0   r4 r3 r2 r1 r0 g5 g4 g3
+	 */
+	.description = "RGB565, le",
+	.pixelformat = V4L2_PIX_FMT_RGB565,
+},
+{
+	/* Note:  V4L2 defines RGB32 as: RGB-8-8-8-8  we use
+	 *        this for RGB24 unpack mode, the last 8 bits are ignored
+	 */
+	.description = "RGB32, le",
+	.pixelformat = V4L2_PIX_FMT_RGB32,
+},
+{
+	.description = "YUYV (YUV 4:2:2), packed",
+	.pixelformat = V4L2_PIX_FMT_YUYV,
+},
+{
+	.description = "UYVY (YUV 4:2:2), packed",
+	.pixelformat = V4L2_PIX_FMT_UYVY,
+},
+};
+
+#define NUM_OUTPUT_FORMATS (sizeof(omap2_formats)/sizeof(omap2_formats[0]))
+
+/*=== Local Functions ==================================================*/
+
+static int omapvout_try_pixel_format(struct omapvout_device *vout,
+				struct v4l2_pix_format *pix)
+{
+	int ifmt;
+	int bpp = 0;
+
+	if (pix->width > OMAPVOUT_VIDEO_MAX_WIDTH)
+		pix->width = OMAPVOUT_VIDEO_MAX_WIDTH;
+
+	if (pix->height > OMAPVOUT_VIDEO_MAX_HEIGHT)
+		pix->height = OMAPVOUT_VIDEO_MAX_HEIGHT;
+
+	for (ifmt = 0; ifmt < NUM_OUTPUT_FORMATS; ifmt++) {
+		if (pix->pixelformat == omap2_formats[ifmt].pixelformat)
+			break;
+	}
+
+	if (ifmt >= NUM_OUTPUT_FORMATS)
+		ifmt = 0;
+
+	pix->pixelformat = omap2_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_NONE;
+	pix->priv = 0;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_RGB565:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = 2;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = 4;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+	default:
+		pix->colorspace = V4L2_COLORSPACE_JPEG;
+		bpp = 2;
+		break;
+	}
+
+	pix->bytesperline = pix->width * bpp;
+	pix->sizeimage = pix->bytesperline * pix->height;
+
+	return 0;
+}
+
+/* Given a new render window in new_win, adjust the window to the
+ * nearest supported configuration.  The adjusted window parameters are
+ * returned in new_win.
+ * Returns zero if succesful, or -EINVAL if the requested window is
+ * impossible and cannot reasonably be adjusted.
+ */
+static int omapvout_try_window(struct omapvout_device *vout,
+				struct v4l2_window *win)
+{
+	struct v4l2_rect try_win;
+
+	/* make a working copy of the new_win rectangle */
+	try_win = win->w;
+
+	/* adjust the preview window so it fits on the display by clipping any
+	 * offscreen areas
+	 */
+	if (try_win.left < 0) {
+		try_win.width += try_win.left;
+		try_win.left = 0;
+	}
+	if (try_win.top < 0) {
+		try_win.height += try_win.top;
+		try_win.top = 0;
+	}
+
+	try_win.width = (try_win.width < vout->disp_width) ?
+	    try_win.width : vout->disp_width;
+	try_win.height = (try_win.height < vout->disp_height) ?
+	    try_win.height : vout->disp_height;
+
+	if (try_win.left + try_win.width > vout->disp_width)
+		try_win.width = vout->disp_width - try_win.left;
+	if (try_win.top + try_win.height > vout->disp_height)
+		try_win.height = vout->disp_height - try_win.top;
+
+	try_win.width &= ~1;
+	try_win.height &= ~1;
+
+	if (try_win.width <= 0 || try_win.height <= 0)
+		return -EINVAL;
+
+	/* We now have a valid preview window, so go with it */
+	win->w = try_win;
+	win->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+/* Return the default overlay cropping rectangle in crop given the image
+ * size in pix and the video display size in fbuf.  The default
+ * cropping rectangle is the largest rectangle no larger than the capture size
+ * that will fit on the display.  The default cropping rectangle is centered in
+ * the image.  All dimensions and offsets are rounded down to even numbers.
+ */
+void omapvout_default_crop(struct omapvout_device *vout,
+			struct v4l2_rect *crop)
+{
+	crop->width = (vout->pix.width < vout->disp_width) ?
+		vout->pix.width : vout->disp_width;
+	crop->height = (vout->pix.height < vout->disp_height) ?
+		vout->pix.height : vout->disp_height;
+	crop->width &= ~1;
+	crop->height &= ~1;
+	crop->left = ((vout->pix.width - crop->width) >> 1) & ~1;
+	crop->top = ((vout->pix.height - crop->height) >> 1) & ~1;
+}
+
+/* Given a new cropping rectangle in new_crop, adjust the cropping rectangle to
+ * the nearest supported configuration.  The image render window in win will
+ * also be adjusted if necessary.  The preview window is adjusted such that the
+ * horizontal and vertical rescaling ratios stay constant.  If the render
+ * window would fall outside the display boundaries, the cropping rectangle will
+ * also be adjusted to maintain the rescaling ratios.  If successful, crop
+ * and win are updated.
+ * Returns zero if succesful, or -EINVAL if the requested cropping rectangle is
+ * impossible and cannot reasonably be adjusted.
+ */
+int omapvout_try_crop(struct omapvout_device *vout, struct v4l2_rect *crop)
+{
+	struct v4l2_rect try;
+
+	/* make a working copy of the new_crop rectangle */
+	try = *crop;
+
+	/* adjust the cropping rectangle so it fits in the image */
+	if (try.left < 0) {
+		try.width += try.left;
+		try.left = 0;
+	}
+	if (try.top < 0) {
+		try.height += try.top;
+		try.top = 0;
+	}
+	try.width = (try.width < vout->pix.width) ?
+		try.width : vout->pix.width;
+	try.height = (try.height < vout->pix.height) ?
+		try.height : vout->pix.height;
+	if (try.left + try.width > vout->pix.width)
+		try.width = vout->pix.width - try.left;
+	if (try.top + try.height > vout->pix.height)
+		try.height = vout->pix.height - try.top;
+	try.width &= ~1;
+	try.height &= ~1;
+
+	if (try.width <= 0 || try.height <= 0)
+		return -EINVAL;
+
+	/* Check for resizing constraints */
+	if (try.height / vout->win.w.height >= 16) {
+		/* The maximum vertical downsizing ratio is 16:1 */
+		try.height = vout->win.w.height * 16;
+	}
+	if (try.width / vout->win.w.width >= 16) {
+		/* The maximum vertical downsizing ratio is 16:1 */
+		try.width = vout->win.w.width * 16;
+	}
+
+	/* update our cropping rectangle and we're done */
+	*crop = try;
+
+	return 0;
+}
+
+void omapvout_acquire_frames(struct omapvout_device *vout, int cnt, int size)
+{
+	int i;
+	int fcnt;
+	u32 paddr;
+	u32 vaddr;
+	u32 fs;
+
+	/* It is assumed that the vout->mtx is locked for this call */
+
+	vout->fq_min_size = 0x7FFFFFF; /* Some large value */
+	fcnt = 0;
+	for (i = 0; i < cnt; i++) {
+#ifdef CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+		if (vout->bp &&	omapvout_bp_alloc(vout, size,
+					&paddr, &vaddr, &fs) == 0) {
+			DBG("Alloc'd from the pool\n");
+		} else {
+#else
+		{
+#endif
+			if (omapvout_mem_alloc(size, &paddr, &vaddr)) {
+				DBG("Alloc failed %d\n", i);
+				break;
+			}
+			fs = size;
+		}
+
+		memset((void *)vaddr, 0, fs);
+
+		vout->fq[fcnt].flags = V4L2_BUF_FLAG_DONE;
+		vout->fq[fcnt].size = fs;
+		vout->fq[fcnt].phy_addr = paddr;
+		vout->fq[fcnt].virt_addr = vaddr;
+		/* Using OMAPVOUT_VIDEO_BP_BUF_SIZE is just convenient */
+		vout->fq[fcnt].offset = OMAPVOUT_VIDEO_BP_BUF_SIZE * i;
+
+		fcnt++;
+
+		if (fs < vout->fq_min_size)
+			vout->fq_min_size = fs;
+	}
+
+	vout->fq_cnt = fcnt;
+	vout->fq_dq_idx = 0;
+}
+
+void omapvout_release_frames(struct omapvout_device *vout)
+{
+	int i;
+	u32 paddr;
+	u32 vaddr;
+	u32 size;
+
+	/* It is assumed that the vout->mtx is locked for this call */
+
+	for (i = 0; i < vout->fq_cnt; i++) {
+		paddr = vout->fq[i].phy_addr;
+		vaddr = vout->fq[i].virt_addr;
+		size = vout->fq[i].size;
+
+#ifdef CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+		if (omapvout_is_bp_buffer(vout, paddr)) {
+			if (omapvout_bp_release(vout, paddr))
+				DBG("Error releasing to the pool\n");
+		} else {
+#else
+		{
+#endif
+			omapvout_mem_free(paddr, vaddr, size);
+		}
+	}
+
+	vout->fq_cnt = 0;
+	vout->fq_min_size = 0;
+	vout->fq_dq_idx = 0;
+	memset(vout->fq, 0, sizeof(vout->fq));
+}
+
+static void omapvout_free_resources(struct omapvout_device *vout)
+{
+	DBG("free_resources\n");
+
+	if (vout == NULL)
+		return;
+
+#ifdef CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+	if (vout->bp != NULL)
+		omapvout_bp_destroy(vout);
+#endif
+
+	video_set_drvdata(&vout->vdev, NULL);
+	kfree(vout);
+}
+
+static int omapvout_dqbuf(struct omapvout_device *vout, int *idx)
+{
+	int i, j;
+
+	j = vout->fq_dq_idx;
+
+	for (i = 0; i < vout->fq_cnt; i++) {
+		if (vout->fq[j].flags & V4L2_BUF_FLAG_DONE) {
+			DBG("DQ'ing Frame %d\n", j);
+			vout->fq_dq_idx = j;
+			break;
+		}
+
+		j++;
+		if (j >= vout->fq_cnt)
+			j = 0;
+	}
+
+	if (i >= vout->fq_cnt)
+		return -EINVAL;
+
+	*idx = j;
+
+	return 0;
+}
+
+/*=== V4L2 Interface Functions =========================================*/
+
+static int omapvout_open(struct file *file)
+{
+	struct omapvout_device *vout;
+	u16 w, h;
+	int rc;
+
+	DBG("omapvout_open\n");
+
+	vout = video_drvdata(file);
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	/* We only support single open */
+	if (vout->opened) {
+		DBG("Device already opened\n");
+		rc = -EBUSY;
+		goto failed;
+	}
+
+	rc = omapvout_dss_open(vout, &w, &h);
+	if (rc != 0)
+		goto failed;
+
+	DBG("Overlay Display %dx%d\n", w, h);
+
+	if (w == 0 || h == 0) {
+		DBG("Invalid display resolution\n");
+		rc = -EINVAL;
+		goto failed;
+	}
+
+	vout->disp_width = w;
+	vout->disp_height = h;
+	vout->opened = 1;
+
+	memset(&vout->pix, 0, sizeof(vout->pix));
+	vout->pix.width = w;
+	vout->pix.height = h;
+	vout->pix.field = V4L2_FIELD_NONE;
+	vout->pix.pixelformat = V4L2_PIX_FMT_RGB565; /* Arbitrary */
+	vout->pix.colorspace = V4L2_COLORSPACE_SRGB; /* Arbitrary */
+	vout->pix.bytesperline = w * 2;
+	vout->pix.sizeimage = w * h * 2;
+
+	memset(&vout->win, 0, sizeof(vout->win));
+	vout->win.w.width = w;
+	vout->win.w.height = h;
+	vout->win.field = V4L2_FIELD_NONE;
+
+	memset(&vout->crop, 0, sizeof(vout->crop));
+	vout->crop.width = w;
+	vout->crop.height = h;
+
+	vout->streaming = 0;
+	vout->rotation = 0;
+	vout->colorkey = 0;
+	vout->colorkey_en = 0;
+
+	memset(&vout->fq, 0, sizeof(vout->fq));
+	vout->fq_cnt = 0;
+	vout->fq_min_size = 0;
+	vout->fq_dq_idx = 0;
+	vout->fq_cur_idx = 0;
+
+	vout->mmap_cnt = 0;
+
+	mutex_unlock(&vout->mtx);
+
+	file->private_data = vout;
+
+	return 0;
+
+failed:
+	mutex_unlock(&vout->mtx);
+	return rc;
+}
+
+static int omapvout_release(struct file *file)
+{
+	struct omapvout_device *vout;
+
+	DBG("omapvout_release\n");
+
+	vout = video_drvdata(file);
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	if (vout->streaming)
+		omapvout_dss_disable(vout);
+
+	if (vout->mmap_cnt) {
+		vout->mmap_cnt = 0;
+		DBG("Releasing with non-zero mmap_cnt\n");
+	}
+
+	omapvout_dss_release(vout);
+
+	omapvout_release_frames(vout);
+
+	vout->opened = 0;
+
+	/* Force the DQ waiter (if present) to wakeup */
+	wake_up_interruptible(&vout->fq_wait);
+
+	mutex_unlock(&vout->mtx);
+
+	file->private_data = NULL;
+
+	return 0;
+}
+
+static void omapvout_vm_open(struct vm_area_struct *vma)
+{
+	struct omapvout_device *vout = vma->vm_private_data;
+	DBG("vm_open [vma=%08lx-%08lx]\n", vma->vm_start, vma->vm_end);
+	vout->mmap_cnt++;
+}
+
+static void omapvout_vm_close(struct vm_area_struct *vma)
+{
+	struct omapvout_device *vout = vma->vm_private_data;
+	DBG("vm_close [vma=%08lx-%08lx]\n", vma->vm_start, vma->vm_end);
+	vout->mmap_cnt--;
+}
+
+static struct vm_operations_struct omapvout_vm_ops = {
+	.open = omapvout_vm_open,
+	.close = omapvout_vm_close,
+};
+
+static int omapvout_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct omapvout_device *vout;
+	int idx;
+	int rc;
+	u32 offset;
+
+	vout = video_drvdata(file);
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	/* look for the buffer to map */
+	offset = (vma->vm_pgoff << PAGE_SHIFT);
+	for (idx = 0; idx < vout->fq_cnt; idx++) {
+		if (vout->fq[idx].offset == offset)
+			break;
+	}
+
+	if (idx >= vout->fq_cnt) {
+		DBG("Invalid offset 0x%lx\n", (unsigned long) offset);
+		mutex_unlock(&vout->mtx);
+		rc = -EINVAL;
+		goto failed;
+	}
+
+	DBG("omapvout_mmap %d\n", idx);
+
+	vma->vm_ops = &omapvout_vm_ops;
+	vma->vm_private_data = (void *) vout;
+
+	rc = omapvout_mem_map(vma, vout->fq[idx].phy_addr);
+	if (rc != 0) {
+		DBG("Failed mem_map %d\n", rc);
+		goto failed;
+	}
+
+	vout->mmap_cnt++;
+
+	mutex_unlock(&vout->mtx);
+
+	return 0;
+
+failed:
+	mutex_unlock(&vout->mtx);
+	return rc;
+}
+
+static int omapvout_vidioc_querycap(struct file *file, void *priv,
+				struct v4l2_capability *cap)
+{
+	struct omapvout_device *vout = priv;
+
+	memset(cap, 0, sizeof(*cap));
+	strncpy(cap->driver, MODULE_NAME, sizeof(cap->driver));
+	strncpy(cap->card, vout->vdev.name, sizeof(cap->card));
+	cap->bus_info[0] = '\0';
+	cap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
+
+	return 0;
+}
+
+static int omapvout_vidioc_enum_output(struct file *file, void *priv,
+				struct v4l2_output *output)
+{
+	int index = output->index;
+
+	if (index > 0)
+		return -EINVAL;
+
+	memset(output, 0, sizeof(*output));
+	output->index = index;
+
+	strncpy(output->name, "video out", sizeof(output->name));
+	output->type = V4L2_OUTPUT_TYPE_MODULATOR;
+
+	return 0;
+}
+
+static int omapvout_vidioc_g_output(struct file *file, void *priv,
+				unsigned int *i)
+{
+	*i = 0;
+
+	return 0;
+}
+
+static int omapvout_vidioc_s_output(struct file *file, void *priv,
+				unsigned int i)
+{
+	if (i > 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int omapvout_vidioc_enum_fmt_vid_overlay(struct file *file, void *priv,
+				struct v4l2_fmtdesc *f)
+{
+	int index = f->index;
+	enum v4l2_buf_type type = f->type;
+
+	if (index >= NUM_OUTPUT_FORMATS)
+		return -EINVAL;
+
+	memset(f, 0, sizeof(*f));
+	f->index = index;
+	f->type = type;
+	f->flags = omap2_formats[index].flags;
+	strncpy(f->description, omap2_formats[index].description,
+					sizeof(f->description));
+	f->pixelformat = omap2_formats[index].pixelformat;
+
+	return 0;
+}
+
+static int omapvout_vidioc_enum_fmt_vid_out(struct file *file, void *priv,
+				struct v4l2_fmtdesc *f)
+{
+	/* Same formats as the overlay */
+	return omapvout_vidioc_enum_fmt_vid_overlay(file, priv, f);
+}
+
+static int omapvout_vidioc_g_fmt_vid_overlay(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct omapvout_device *vout = priv;
+	struct v4l2_window *win = &f->fmt.win;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * The API has a bit of a problem here. We're returning a v4l2_window
+	 * structure, but that structure contains pointers to variable-sized
+	 * objects for clipping rectangles and clipping bitmaps.  We will just
+	 * return NULLs for those pointers.
+	 */
+
+	mutex_lock(&vout->mtx);
+
+	memset(win, 0, sizeof(*win));
+	win->w = vout->win.w;
+	win->field = vout->win.field;
+	win->chromakey = vout->win.chromakey;
+	win->global_alpha = vout->win.global_alpha;
+
+	mutex_unlock(&vout->mtx);
+
+	return 0;
+}
+
+static int omapvout_vidioc_g_fmt_vid_out(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct omapvout_device *vout = priv;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	memset(pix, 0, sizeof(*pix));
+	*pix = vout->pix;
+
+	mutex_unlock(&vout->mtx);
+
+	return 0;
+}
+
+static int omapvout_vidioc_try_fmt_vid_overlay(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct omapvout_device *vout = priv;
+	struct v4l2_window *win = &f->fmt.win;
+	int rc;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	rc = omapvout_try_window(vout, win);
+
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_try_fmt_vid_out(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct omapvout_device *vout = priv;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	int rc;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	rc = omapvout_try_pixel_format(vout, pix);
+
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_s_fmt_vid_overlay(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct omapvout_device *vout = priv;
+	struct v4l2_window *win = &f->fmt.win;
+	int rc = 0;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (vout->streaming)
+		return -EBUSY;
+
+	mutex_lock(&vout->mtx);
+
+	rc = omapvout_try_window(vout, win);
+	if (rc != 0)
+		goto failed;
+
+	vout->win.w = win->w;
+	vout->win.field = win->field;
+	vout->win.chromakey = win->chromakey;
+	vout->win.global_alpha = win->global_alpha;
+
+	/* Streaming has to be disabled, so config the hardware
+	 * later when streaming is enabled
+	 */
+
+failed:
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_s_fmt_vid_out(struct file *file, void *priv,
+				struct v4l2_format *f)
+{
+	struct omapvout_device *vout = priv;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	int rc = 0;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (vout->streaming)
+		return -EBUSY;
+
+	mutex_lock(&vout->mtx);
+
+	rc = omapvout_try_pixel_format(vout, pix);
+	if (rc != 0)
+		goto failed;
+
+	memcpy(&vout->pix, pix, sizeof(*pix));
+
+	/* Don't allow the crop window to be larger than the video */
+	omapvout_try_crop(vout, &vout->crop);
+
+	/* Streaming has to be disabled, so config the hardware
+	 * later when streaming is enabled
+	 */
+
+failed:
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_cropcap(struct file *file, void *priv,
+				struct v4l2_cropcap *ccap)
+{
+	struct omapvout_device *vout = priv;
+	enum v4l2_buf_type type = ccap->type;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	mutex_lock(&vout->mtx);
+
+	memset(ccap, 0, sizeof(*ccap));
+	ccap->type = type;
+	ccap->bounds.width = vout->pix.width & ~1;
+	ccap->bounds.height = vout->pix.height & ~1;
+	omapvout_default_crop(vout, &ccap->defrect);
+	ccap->pixelaspect.numerator = 1;
+	ccap->pixelaspect.denominator = 1;
+
+	mutex_unlock(&vout->mtx);
+
+	return 0;
+}
+
+static int omapvout_vidioc_g_crop(struct file *file, void *priv,
+				struct v4l2_crop *crop)
+{
+	struct omapvout_device *vout = priv;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	mutex_lock(&vout->mtx);
+
+	crop->c = vout->crop;
+
+	mutex_unlock(&vout->mtx);
+
+	return 0;
+}
+
+static int omapvout_vidioc_s_crop(struct file *file, void *priv,
+				struct v4l2_crop *crop)
+{
+	struct omapvout_device *vout = priv;
+	struct v4l2_rect rect = crop->c;
+	int rc = 0;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (vout->streaming)
+		return -EBUSY;
+
+	if (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	mutex_lock(&vout->mtx);
+
+	rc = omapvout_try_crop(vout, &rect);
+	if (rc != 0)
+		goto failed;
+
+	vout->crop = rect;
+
+	/* Streaming has to be disabled, so config the hardware
+	 * later when streaming is enabled
+	 */
+
+failed:
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_reqbufs(struct file *file, void *priv,
+				struct v4l2_requestbuffers *req)
+{
+	struct omapvout_device *vout = priv;
+	int rc;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (req->count > OMAPVOUT_VID_MAX_FRAMES)
+		req->count = OMAPVOUT_VID_MAX_FRAMES;
+
+	if (req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	if (req->memory != V4L2_MEMORY_MMAP)
+		return -EINVAL;
+
+	/* FIXME: Really should allow if req->count is zero */
+	if (vout->streaming)
+		return -EBUSY;
+
+	/* It is assumed that the video out format is correctly configured */
+	if (vout->pix.sizeimage == 0)
+		return -EINVAL;
+
+	mutex_lock(&vout->mtx);
+
+	if (req->count == 0) {
+		omapvout_release_frames(vout);
+		goto success;
+	}
+
+	/* Don't allow new buffers when some are still mapped */
+	if (vout->mmap_cnt) {
+		DBG("Buffers are still mapped\n");
+		rc = -EBUSY;
+		goto failed;
+	}
+
+	/* Use the existing frames if possible */
+	if (req->count <= vout->fq_cnt &&
+			vout->pix.sizeimage <= vout->fq_min_size)
+		goto success;
+
+	omapvout_release_frames(vout);
+	omapvout_acquire_frames(vout, req->count, vout->pix.sizeimage);
+
+	mutex_unlock(&vout->mtx);
+
+	if (vout->fq_min_size < vout->pix.sizeimage) {
+		DBG("Buffer allocation failed\n");
+		return -ENOMEM;
+	}
+
+	req->count = vout->fq_cnt;
+
+	return 0;
+
+success:
+failed:
+	mutex_unlock(&vout->mtx);
+	return rc;
+}
+
+static int omapvout_vidioc_querybuf(struct file *file, void *priv,
+				struct v4l2_buffer *b)
+{
+	struct omapvout_device *vout = priv;
+	int rc;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	mutex_lock(&vout->mtx);
+
+	if (b->index >= vout->fq_cnt) {
+		DBG("Invalid querybuf index %d\n", b->index);
+		rc = -EINVAL;
+		goto failed;
+	}
+
+	b->memory = V4L2_MEMORY_MMAP;
+	b->flags = vout->fq[b->index].flags;
+	b->length = vout->fq[b->index].size;
+	b->m.offset = vout->fq[b->index].offset;
+
+	mutex_unlock(&vout->mtx);
+
+	return 0;
+
+failed:
+	mutex_unlock(&vout->mtx);
+	return rc;
+}
+
+static int omapvout_vidioc_qbuf(struct file *file, void *priv,
+				struct v4l2_buffer *b)
+{
+	struct omapvout_device *vout = priv;
+	int rc = 0;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (!vout->streaming)
+		return -EINVAL;
+
+	if (b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	if (b->memory != V4L2_MEMORY_MMAP)
+		return -EINVAL;
+
+	if (b->index >= vout->fq_cnt)
+		return -EINVAL;
+
+	DBG("Q'ing Frame %d\n", b->index);
+
+	mutex_lock(&vout->mtx);
+
+	vout->fq[b->index].flags |= V4L2_BUF_FLAG_QUEUED|V4L2_BUF_FLAG_MAPPED;
+	vout->fq[b->index].flags &= ~(V4L2_BUF_FLAG_DONE);
+
+	/* TODO: Deal with the wrap-around case? */
+	vout->fq[b->index].seq_num = vout->fq_next_seq++;
+
+	rc = omapvout_dss_update(vout);
+
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_dqbuf(struct file *file, void *priv,
+				struct v4l2_buffer *b)
+{
+	struct omapvout_device *vout = priv;
+	int rc = 0;
+	int idx;
+	bool wait;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (b->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	wait = (file->f_flags & O_NONBLOCK) ? false : true;
+
+	mutex_lock(&vout->mtx);
+
+	if (vout->opened == 0) {
+		rc = -EINVAL;
+		goto failed;
+	}
+
+	if (omapvout_dqbuf(vout, &idx) != 0) {
+		if (!wait) {
+			mutex_unlock(&vout->mtx);
+			return -EAGAIN;
+		} else {
+			wait_event_interruptible(vout->fq_wait,
+					((omapvout_dqbuf(vout, &idx) == 0) ||
+						(vout->opened == 0)));
+		}
+	}
+
+	vout->fq[idx].flags &=
+		~(V4L2_BUF_FLAG_QUEUED|V4L2_BUF_FLAG_DONE|V4L2_BUF_FLAG_MAPPED);
+
+	memset(b, 0, sizeof(b));
+	b->index = idx;
+	b->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	b->memory = V4L2_MEMORY_MMAP;
+	b->flags = vout->fq[idx].flags;
+	b->length = vout->fq[idx].size;
+	b->bytesused = 0;
+
+failed:
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_streamon(struct file *file, void *priv,
+				enum v4l2_buf_type type)
+{
+	struct omapvout_device *vout = priv;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	if (vout->streaming) {
+		DBG("Streaming is already enabled\n");
+		mutex_unlock(&vout->mtx);
+		return -EBUSY;
+	}
+
+	/* Enable the streaming flag.
+	 * There can't be any frames queued, so when the first frame
+	 * is queued the DSS will be updated.
+	 */
+	vout->streaming = true;
+
+	omapvout_dss_enable(vout);
+
+	/* Reset the current frame idx & seq num */
+	vout->fq_cur_idx = -1;
+	vout->fq_next_seq = 1;
+
+	mutex_unlock(&vout->mtx);
+
+	return 0;
+}
+
+static int omapvout_vidioc_streamoff(struct file *file, void *priv,
+				enum v4l2_buf_type type)
+{
+	struct omapvout_device *vout = priv;
+	int rc = 0;
+	int i;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	if (!vout->streaming) {
+		DBG("Streaming is already disabled\n");
+		mutex_unlock(&vout->mtx);
+		return -EINVAL;
+	}
+
+	vout->streaming = false;
+
+	omapvout_dss_disable(vout);
+
+	/* Reset the queue and wakeup the DQ waiter */
+	for (i = 0; i < vout->fq_cnt; i++) {
+		if (vout->fq[i].flags & V4L2_BUF_FLAG_QUEUED) {
+			vout->fq[i].flags &= ~(V4L2_BUF_FLAG_QUEUED);
+			vout->fq[i].flags |= V4L2_BUF_FLAG_DONE;
+		}
+	}
+	wake_up_interruptible(&vout->fq_wait);
+
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_queryctrl(struct file *file, void *priv,
+				struct v4l2_queryctrl *a)
+{
+	/* TODO: Add me */
+	return 0;
+}
+
+static int omapvout_vidioc_g_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct omapvout_device *vout = priv;
+	int rc = 0;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&vout->mtx);
+
+	switch (ctrl->id) {
+	case V4L2_CID_PRIV_ROTATION:
+		ctrl->value = vout->rotation * 90;
+		break;
+	case V4L2_CID_PRIV_COLORKEY:
+		ctrl->value = vout->colorkey;
+		break;
+	case V4L2_CID_PRIV_COLORKEY_EN:
+		ctrl->value = vout->colorkey_en;
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+static int omapvout_vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	struct omapvout_device *vout = priv;
+	int v = ctrl->value;
+	int rc = 0;
+
+	if (vout == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	if (vout->streaming)
+		return -EBUSY;
+
+	mutex_lock(&vout->mtx);
+
+	switch (ctrl->id) {
+	case V4L2_CID_PRIV_ROTATION:
+		if (!omapvout_dss_is_rotation_supported(vout) && v != 0) {
+			rc = -EINVAL;
+		} else if (v == 0 || v == 90 || v == 180 || v == 270) {
+			vout->rotation = v / 90;
+		} else {
+			DBG("Invalid rotation %d\n", v);
+			rc = -ERANGE;
+		}
+		break;
+	case V4L2_CID_PRIV_COLORKEY:
+		vout->colorkey = v;
+		break;
+	case V4L2_CID_PRIV_COLORKEY_EN:
+		vout->colorkey_en = (v) ? 1 : 0;
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	/* Streaming has to be disabled, so config the hardware
+	 * later when streaming is enabled
+	 */
+
+	mutex_unlock(&vout->mtx);
+
+	return rc;
+}
+
+/*=== Driver Functions =================================================*/
+
+static struct v4l2_file_operations omapvout_fops = {
+	.owner = THIS_MODULE,
+	.open = omapvout_open,
+	.release = omapvout_release,
+	.mmap = omapvout_mmap,
+	.ioctl = video_ioctl2,
+};
+
+static const struct v4l2_ioctl_ops omapvout_ioctl_ops = {
+	.vidioc_querycap = omapvout_vidioc_querycap,
+	.vidioc_enum_output = omapvout_vidioc_enum_output,
+	.vidioc_g_output = omapvout_vidioc_g_output,
+	.vidioc_s_output = omapvout_vidioc_s_output,
+	.vidioc_enum_fmt_vid_overlay = omapvout_vidioc_enum_fmt_vid_overlay,
+	.vidioc_enum_fmt_vid_out = omapvout_vidioc_enum_fmt_vid_out,
+	.vidioc_g_fmt_vid_overlay = omapvout_vidioc_g_fmt_vid_overlay,
+	.vidioc_g_fmt_vid_out = omapvout_vidioc_g_fmt_vid_out,
+	.vidioc_try_fmt_vid_overlay = omapvout_vidioc_try_fmt_vid_overlay,
+	.vidioc_try_fmt_vid_out = omapvout_vidioc_try_fmt_vid_out,
+	.vidioc_s_fmt_vid_overlay = omapvout_vidioc_s_fmt_vid_overlay,
+	.vidioc_s_fmt_vid_out = omapvout_vidioc_s_fmt_vid_out,
+	.vidioc_cropcap = omapvout_vidioc_cropcap,
+	.vidioc_g_crop = omapvout_vidioc_g_crop,
+	.vidioc_s_crop = omapvout_vidioc_s_crop,
+	.vidioc_reqbufs = omapvout_vidioc_reqbufs,
+	.vidioc_querybuf = omapvout_vidioc_querybuf,
+	.vidioc_qbuf = omapvout_vidioc_qbuf,
+	.vidioc_dqbuf = omapvout_vidioc_dqbuf,
+	.vidioc_streamon = omapvout_vidioc_streamon,
+	.vidioc_streamoff = omapvout_vidioc_streamoff,
+	.vidioc_queryctrl = omapvout_vidioc_queryctrl,
+	.vidioc_g_ctrl = omapvout_vidioc_g_ctrl,
+	.vidioc_s_ctrl = omapvout_vidioc_s_ctrl,
+};
+
+static struct video_device omapvout_devdata = {
+	.name = MODULE_NAME,
+	.fops = &omapvout_fops,
+	.ioctl_ops = &omapvout_ioctl_ops,
+	.vfl_type = VID_TYPE_OVERLAY | VID_TYPE_CHROMAKEY,
+	.release = video_device_release,
+	.minor = -1,
+};
+
+static int __init omapvout_probe(struct platform_device *pdev,
+				enum omap_plane plane, int vid)
+{
+	struct omapvout_device *vout = NULL;
+	int rc = 0;
+
+	DBG("omapvout_probe %d %d\n", plane, vid);
+
+	vout = kzalloc(sizeof(struct omapvout_device), GFP_KERNEL);
+	if (vout == NULL) {
+		rc = -ENOMEM;
+		goto err0;
+	}
+
+	mutex_init(&vout->mtx);
+
+	vout->max_video_width = OMAPVOUT_VIDEO_MAX_WIDTH;
+	vout->max_video_height = OMAPVOUT_VIDEO_MAX_HEIGHT;
+	vout->max_video_bytespp = OMAPVOUT_VIDEO_MAX_BPP;
+
+	rc = omapvout_dss_init(vout, plane);
+	if (rc != 0) {
+		printk(KERN_INFO "DSS init failed\n");
+		goto cleanup;
+	}
+
+#ifdef CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+	vout->bp = dev_get_drvdata(&pdev->dev);
+	omapvout_bp_init(vout);
+#endif
+
+	/* register the V4L2 interface */
+	vout->vdev = omapvout_devdata;
+	video_set_drvdata(&vout->vdev, vout);
+	if (video_register_device(&vout->vdev, VFL_TYPE_GRABBER, vid) < 0) {
+		printk(KERN_ERR MODULE_NAME": could not register with V4L2\n");
+		rc = -EINVAL;
+		goto cleanup;
+	}
+
+	vout->id = plane;
+	init_waitqueue_head(&vout->fq_wait);
+
+	return 0;
+
+cleanup:
+	omapvout_free_resources(vout);
+err0:
+	dev_err(&pdev->dev, "failed to setup omapvout\n");
+	return rc;
+}
+
+static int __init omapvout1_probe(struct platform_device *pdev)
+{
+	return omapvout_probe(pdev, OMAP_DSS_VIDEO1,
+				OMAPVOUT_VIDEO_1_DEVICE_ID);
+}
+
+static int __init omapvout2_probe(struct platform_device *pdev)
+{
+	return omapvout_probe(pdev, OMAP_DSS_VIDEO2,
+				OMAPVOUT_VIDEO_2_DEVICE_ID);
+}
+
+static int omapvout_remove(struct platform_device *pdev)
+{
+	struct omapvout_device *vout = platform_get_drvdata(pdev);
+
+	DBG("omapvout_remove\n");
+
+	omapvout_dss_remove(vout);
+	omapvout_free_resources(vout);
+
+	return 0;
+}
+
+static struct platform_device omapvout1_dev = {
+	.name = VOUT1_NAME,
+	.id = 11,
+};
+
+static struct platform_device omapvout2_dev = {
+	.name = VOUT2_NAME,
+	.id = 12,
+};
+
+static struct platform_driver omapvout1_driver = {
+	.remove         = omapvout_remove,
+	.driver         = {
+		.name   = VOUT1_NAME,
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver omapvout2_driver = {
+	.remove         = omapvout_remove,
+	.driver         = {
+		.name   = VOUT2_NAME,
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init omapvout_init(void)
+{
+	struct omapvout_bp *bp;
+	int rc;
+
+	DBG("omapvout_init\n");
+
+#ifdef CONFIG_VIDEO_OMAP_MOT_VIDEOOUT_BUFPOOL
+	/* Create a buffer pool and pass it to both driver probes */
+	bp = omapvout_bp_create(OMAPVOUT_VIDEO_BP_BUF_COUNT,
+				OMAPVOUT_VIDEO_BP_BUF_SIZE);
+	omapvout1_dev.dev.driver_data = bp;
+	omapvout2_dev.dev.driver_data = bp;
+#endif
+
+	rc = platform_device_register(&omapvout1_dev);
+	if (rc != 0) {
+		printk(KERN_ERR "failed omapvout1 device register %d\n", rc);
+		goto faildev1;
+	}
+
+	rc = platform_driver_probe(&omapvout1_driver, omapvout1_probe);
+	if (rc != 0) {
+		printk(KERN_ERR "failed omapvout1 register/probe %d\n", rc);
+		goto faildrv1;
+	}
+
+	rc = platform_device_register(&omapvout2_dev);
+	if (rc != 0) {
+		printk(KERN_ERR "failed omapvout2 device register %d\n", rc);
+		goto faildev2;
+	}
+
+	rc = platform_driver_probe(&omapvout2_driver, omapvout2_probe);
+	if (rc != 0) {
+		printk(KERN_ERR "failed omapvout2 register/probe %d\n", rc);
+		goto faildrv2;
+	}
+
+	return 0;
+
+faildrv2:
+	platform_device_unregister(&omapvout2_dev);
+faildev2:
+	platform_driver_unregister(&omapvout1_driver);
+faildrv1:
+	platform_device_unregister(&omapvout1_dev);
+faildev1:
+	return -ENODEV;
+}
+
+static void __exit omapvout_exit(void)
+{
+	DBG("omapvout_exit\n");
+	platform_driver_unregister(&omapvout1_driver);
+	platform_driver_unregister(&omapvout2_driver);
+	platform_device_unregister(&omapvout1_dev);
+	platform_device_unregister(&omapvout2_dev);
+}
+
+module_init(omapvout_init);
+module_exit(omapvout_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("OMAP2/3 Video Out for V4L2");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/video/omap_mot/omapvout.h b/drivers/media/video/omap_mot/omapvout.h
new file mode 100644
index 0000000..124e7de
--- /dev/null
+++ b/drivers/media/video/omap_mot/omapvout.h
@@ -0,0 +1,91 @@
+/*
+ * drivers/media/video/omap_mot/omapvout.h
+ *
+ * Copyright (C) 2009 Motorola Inc.
+ *
+ * Based on drivers/media/video/omap24xx/omap24xxvout.c&h
+ *
+ * Copyright (C) 2005-2006 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __OMAPVOUT_H__
+#define __OMAPVOUT_H__
+
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <mach/display.h>
+#include <mach/vrfb.h>
+#include <media/v4l2-dev.h>
+
+/*#define DEBUG*/
+#ifdef DEBUG
+#define DBG(format, ...) \
+	printk(KERN_DEBUG "OMAPVOUT: " format, ## __VA_ARGS__)
+#else
+#define DBG(format, ...)
+#endif
+
+#define OMAPVOUT_VID_MAX_FRAMES	(10)
+
+struct omapvout_frm_q_entry {
+	u32 flags; /* same a V4L2_buffer.flags */
+	u32 size;
+	u32 phy_addr;
+	u32 virt_addr;
+	u32 offset; /* For mmap'ing purposes only */
+	u32 seq_num;
+};
+
+/* The device structure */
+
+struct omapvout_device {
+	struct video_device vdev;
+	struct mutex  mtx; /* Lock for all device accesses */
+	struct video_device *vfd;
+
+	int opened;
+	int id;
+
+	int disp_width;
+	int disp_height;
+
+	int max_video_width;
+	int max_video_height;
+	int max_video_bytespp;
+
+	/* Buffer pool */
+	struct omapvout_bp *bp;
+
+	/* DSS data */
+	struct omapvout_dss *dss;
+
+	/* V4L2 data */
+	bool streaming;
+	int rotation;
+	u32 colorkey;
+	int colorkey_en;
+	struct v4l2_pix_format pix;
+	struct v4l2_window win;
+	struct v4l2_rect crop;
+
+	/* Frame Q */
+	int fq_cnt; /* number of frames in the queue */
+	int fq_min_size; /* smallest frame in the queue */
+	int fq_dq_idx; /* the index to begin dQing from */
+	int fq_cur_idx; /* the index of the current displayed frame */
+	u32 fq_next_seq; /* a sequence number to maintain frame Q'ing order*/
+	struct omapvout_frm_q_entry fq[OMAPVOUT_VID_MAX_FRAMES];
+	wait_queue_head_t fq_wait;
+
+	/* Don't allow new buffers when some are still mapped */
+	int mmap_cnt;
+};
+
+#define vdev_to_omapvout(d) container_of(d, struct omapvout_device, vdev)
+
+#endif /* __OMAPVOUT_H__ */
diff --git a/drivers/media/video/ov8810.c b/drivers/media/video/ov8810.c
new file mode 100644
index 0000000..05822ca
--- /dev/null
+++ b/drivers/media/video/ov8810.c
@@ -0,0 +1,2606 @@
+/*
+ * drivers/media/video/ov8810.c
+ *
+ * ov8810 sensor driver
+ *
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * Leverage ov8810.c
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <media/v4l2-int-device.h>
+#include <mach/resource.h>
+#include "ov8810.h"
+#include "oldomap34xxcam.h"
+#include "oldisp/isp.h"
+#include "oldisp/ispcsi2.h"
+
+#define OV8810_DRIVER_NAME  "ov8810"
+#define MOD_NAME "OV8810: "
+
+#define I2C_M_WR 0
+#define CPU_CLK_LOCK	 1
+#define CPU_CLK_UNLOCK   0 
+
+/* OV8810 clock related parameters */
+struct ov8810_clk_freqs {
+	u32 xclk;
+	u32 sclk;
+	u32 pclk;
+	u32 mipiclk;
+};
+
+struct ov8810_sensor_id {
+	u16 revision;
+	u16 model;
+	u16 mfr;
+};
+
+/**
+ * struct ov8810_sensor_params
+ */
+struct ov8810_sensor_params {
+	u32 line_time;  /* usec, q8 */
+	u16 gain_frame_delay;
+	u16 exp_time_frame_delay;
+};
+
+struct ov8810_flash_params {
+	u16 flash_time;
+	u8 flash_type;
+	u8 shutter_type;
+};
+
+struct ov8810_shutter_params {
+	u32 exp_time;
+	u16 delay_time;
+	u16 type;
+};
+
+struct ov8810_exp_params {
+	u32 exp_time;
+	u32 line_time;
+	u16 coarse_int_tm;
+	u16 analog_gain;
+	u16 digital_gain;
+	u16 min_exp_time;
+	u32 fps_max_exp_time;
+	u32 abs_max_exp_time;
+	u16 min_linear_gain;
+	u16 max_linear_gain;
+};
+
+/**
+ * struct ov8810_sensor - main structure for storage of sensor information
+ * @pdata: access functions and data for platform level information
+ * @v4l2_int_device: V4L2 device structure structure
+ * @i2c_client: iic client device structure
+ * @pix: V4L2 pixel format information structure
+ * @timeperframe: time per frame expressed as V4L fraction
+ * @isize: base image size
+ * @ver: ov8810 chip version
+ * @width: configured width
+ * @height: configuredheight
+ * @vsize: vertical size for the image
+ * @hsize: horizontal size for the image
+ * @crop_rect: crop rectangle specifying the left,top and width and height
+ * @state:
+ * @frame: image frame parameters
+*/
+struct ov8810_sensor {
+	struct device *dev;
+	const struct ov8810_platform_data *pdata;
+	struct v4l2_int_device *v4l2_int_device;
+	struct i2c_client *i2c_client;
+	struct v4l2_pix_format pix;
+	struct v4l2_fract timeperframe;
+	int isize;
+	int fps;
+	unsigned long width;
+	unsigned long height;
+	unsigned long vsize;
+	unsigned long hsize;
+	struct v4l2_rect crop_rect;
+	int state;
+	bool resuming;
+	bool streaming;
+	struct ov8810_clk_freqs freq;
+	struct ov8810_sensor_id sensor_id;
+	struct ov8810_flash_params flash;
+	struct ov8810_shutter_params shutter;
+	struct ov8810_exp_params exposure;
+	enum ov8810_orientation orientation;
+};
+
+static struct ov8810_sensor ov8810 = {
+	.timeperframe = {
+		.numerator = 1,
+		.denominator = 15,
+	},
+	.sensor_id = {
+		.revision = 0,
+		.model = 0,
+		.mfr = 0
+	},
+	.state = SENSOR_NOT_DETECTED,
+	.freq = {
+		.xclk = OV8810_XCLK_MIN,
+	},
+	.shutter = {
+		.type = ROLLING_SHUTTER_TYPE,
+	},
+	.orientation = OV8810_HORZ_FLIP_ONLY,
+};
+
+static struct i2c_driver ov8810sensor_i2c_driver;
+static enum v4l2_power current_power_state = V4L2_POWER_OFF;
+
+/* List of image formats supported by OV8810 sensor */
+const static struct v4l2_fmtdesc ov8810_formats[] = {
+	{
+		.description	= "RAW10",
+		.pixelformat	= V4L2_PIX_FMT_SGRBG10,
+	},
+	{
+		.description	= "Walking 1's pattern",
+		.pixelformat	= V4L2_PIX_FMT_W1S_PATT,
+	}
+};
+
+#define NUM_CAPTURE_FORMATS (sizeof(ov8810_formats) / sizeof(ov8810_formats[0]))
+
+/* register initialization tables for ov8810 */
+#define OV8810_REG_TERM 0xFFFF	/* terminating list entry for reg */
+#define OV8810_VAL_TERM 0xFF	/* terminating list entry for val */
+
+const static struct ov8810_reg ov8810_strobe_ready_reg[] = {
+    {0x30e8 , 0x00},
+    {OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+const static struct ov8810_reg ov8810_strobe_trigger_reg[] = {
+    {0x30e7 , 0x03},
+    {0x30e8 , 0x80},
+    {OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+static struct ov8810_sensor_settings sensor_settings[] = {
+
+	/* SIZE_125K */
+		/* 2-lane, RAW 10, PCLK = 13.5MHz, MIPI_CLK = 67.5MHz,
+		MIPI_PCLK = 1.25x13.5 = 16.9MHz,
+		MCLK = 27Mhz, FPS = 30, Blanking = 10msec */
+	{
+		.clk = {
+			.pll_mult = 44,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 8,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 4,
+		},
+		.frame = {
+			.frame_len_lines_min = 433,
+			.line_len_pck_min = 4576,
+			.x_addr_start = 0,
+			.x_addr_end = 3359,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 408,
+			.y_output_size = 306,
+			.v_subsample = 8,
+			.h_subsample = 8,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 30,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+			.hs_settle_lower = 5,
+			.hs_settle_upper = 14,
+		},
+	},
+
+	/* SIZE_500K */
+		/* 2-lane, RAW 10, PCLK = 29.7MHz, MIPI_CLK = 148.5MHz,
+		   MIPI_PCLK = 1.25x29.7 = 37.1MHz,
+		   MCLK = 27Mhz, FPS = 30, Blanking = 10msec */
+	{
+		.clk = {
+			.pll_mult = 44,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 4,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 2,
+		},
+		.frame = {
+			.frame_len_lines_min = 845,
+			.line_len_pck_min = 2344,
+			.x_addr_start = 0,
+			.x_addr_end = 3311,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 816,
+			.y_output_size = 612,
+			.v_subsample = 4,
+			.h_subsample = 4,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 30,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 7,
+				.hs_settle_upper = 21,
+		},
+	},
+
+	/* SIZE_1_5M */
+		/* 2-lane, RAW 10, PCLK = 75.6MHz, MIPI_CLK = 312MHz,
+		   MIPI_PCLK = 1.25x75.6 = 94.5MHz,
+		   MCLK = 27Mhz, FPS = 26, Blanking = 10ms */
+	{
+		.clk = {
+			.pll_mult = 56,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 2,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 1,
+		},
+		.frame = {
+			.frame_len_lines_min = 1244,
+			.line_len_pck_min = 2336,
+			.x_addr_start = 4,
+			.x_addr_end = 3291,
+			.y_addr_start = 302,
+			.y_addr_end = 2161,
+			.x_output_size = 1632,
+			.y_output_size = 918,
+			.v_subsample = 2,
+			.h_subsample = 2,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 26,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 14,
+				.hs_settle_upper = 44,
+		},
+	},
+
+	/* SIZE_2M */
+		/* 2-lane, RAW 10, PCLK = 75.6MHz, MIPI_CLK = 312MHz,
+		   MIPI_PCLK = 1.25x75.6 = 94.5MHz,
+		   MCLK = 27Mhz, FPS = 21, Blanking = 10ms */
+	{
+		.clk = {
+			.pll_mult = 56,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 2,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 1,
+		},
+		.frame = {
+			.frame_len_lines_min = 1552,
+			.line_len_pck_min = 2320,
+			.x_addr_start = 0,
+			.x_addr_end = 3295,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 1632,
+			.y_output_size = 1224,
+			.v_subsample = 2,
+			.h_subsample = 2,
+			.min_time_per_frame = {
+				.numerator = 1,
+				.denominator = 21,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 14,
+				.hs_settle_upper = 44,
+		},
+	},
+
+	/* SIZE_8M */
+		/* 2-lane, RAW, 10, PCLK = 75.6MHz, MIPI_CLK = 312MHz,
+		   MIPI_PCLK = 1.25x75.6 = 94.5MHz,
+		   MCLK = 27Mhz, FPS = 7.685, Blanking = 2ms */
+	{
+		.clk = {
+			.pll_mult = 56,
+			.pll_pre_div = 2,
+			.vt_sys_div = 2,
+			.op_sys_div = 2,
+			.op_pix_div = 4,
+			.div8 = 5,
+			.rp_clk_div = 1,
+		},
+		.frame = {
+			.frame_len_lines_min = 2484,
+			.line_len_pck_min = 3960,
+			.x_addr_start = 0,
+			.x_addr_end = 3295,
+			.y_addr_start = 0,
+			.y_addr_end = 2463,
+			.x_output_size = 3264,
+			.y_output_size = 2448,
+			.v_subsample = 1,
+			.h_subsample = 1,
+			.min_time_per_frame = {
+				.numerator = 3,
+				.denominator = 24,
+			},
+		},
+		.mipi = {
+			.num_data_lanes = 2,
+				.hs_settle_lower = 14,
+				.hs_settle_upper = 44,
+		},
+	}
+};
+
+/*
+ * struct vcontrol - Video controls
+ * @v4l2_queryctrl: V4L2 VIDIOC_QUERYCTRL ioctl structure
+ * @current_value: current value of this control
+ */
+static struct vcontrol {
+	struct v4l2_queryctrl qc;
+	int current_value;
+} video_control[] = {
+	{
+		{
+			.id = V4L2_CID_EXPOSURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Exposure",
+			.minimum = 0,
+			.maximum = -1,
+			.step = EXPOSURE_STEP,
+			.default_value = DEF_EXPOSURE,
+		},
+		.current_value = DEF_EXPOSURE,
+	},
+	{
+		{
+			.id = V4L2_CID_GAIN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Analog Gain",
+			.minimum = OV8810_MIN_LINEAR_GAIN,
+			.maximum = OV8810_MAX_LINEAR_GAIN,
+			.step = LINEAR_GAIN_STEP,
+			.default_value = DEF_LINEAR_GAIN,
+		},
+		.current_value = DEF_LINEAR_GAIN,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_COLOR_BAR,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Color Bar",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_FLASH_NEXT_FRAME,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Flash On Next Frame",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_ORIENTATION,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Orientation",
+			.minimum = OV8810_NO_HORZ_FLIP_OR_VERT_FLIP,
+			.maximum = OV8810_HORZ_FLIP_AND_VERT_FLIP,
+			.step = 0,
+			.default_value = OV8810_HORZ_FLIP_ONLY,
+		},
+		.current_value = OV8810_HORZ_FLIP_ONLY,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_LENS_CORRECTION,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Lens Correction",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SENSOR_ID_REQ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Sensor ID",
+			.minimum = 0,
+			.maximum = -1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SHUTTER_PARAMS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Shutter Params",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_START_MECH_SHUTTER_CAPTURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Start Mech Shutter Capture",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SENSOR_REG_REQ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Sensor Register",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_PRIVATE_SENSOR_PARAMS_REQ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Sensor Params",
+			.minimum = 0,
+			.maximum = -1,
+			.step = 0,
+			.default_value = 0,
+		},
+		.current_value = 0,
+	},
+};
+
+struct i2c_client *ov8810_i2c_client;
+
+/*
+ * find_vctrl - Finds the requested ID in the video control structure array
+ * @id: ID of control to search the video control array.
+ *
+ * Returns the index of the requested ID from the control structure array
+ */
+static int find_vctrl(int id)
+{
+	int i = 0;
+
+	if (id < V4L2_CID_BASE)
+		return -EDOM;
+
+	for (i = (ARRAY_SIZE(video_control) - 1); i >= 0; i--)
+		if (video_control[i].qc.id == id)
+			break;
+	if (i < 0)
+		i = -EINVAL;
+	return i;
+}
+
+/*
+ * Read a value from a register in ov8810 sensor device.
+ * The value is returned in 'val'.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int ov8810_read_reg(struct i2c_client *client, u16 data_length, u16 reg,
+								u32 *val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[4];
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 2;
+	msg->buf = data;
+
+	/* High byte goes out first */
+	data[0] = (u8) (reg >> 8);
+	data[1] = (u8) (reg & 0xff);
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	if (err < 0) {
+		msleep(5);
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+
+	if (err >= 0) {
+		mdelay(3);
+		msg->flags = I2C_M_RD;
+		msg->len = data_length;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	if (err >= 0) {
+		*val = 0;
+		/* High byte comes first */
+		if (data_length == 1)
+			*val = data[0];
+		else if (data_length == 2)
+			*val = data[1] + (data[0] << 8);
+		else
+			*val = data[3] + (data[2] << 8) +
+				(data[1] << 16) + (data[0] << 24);
+		return 0;
+	}
+	printk(KERN_ERR "OV8810: read from offset 0x%x error %d\n", reg, err);
+	return err;
+}
+
+/* Write a value to a register in ov8810 sensor device.
+ * @client: i2c driver client structure.
+ * @reg: Address of the register to read value from.
+ * @val: Value to be written to a specific register.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+int ov8810_write_reg(struct i2c_client *client, u16 reg, u8 val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[3];
+	int retries = 5;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 3;
+	msg->buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8) (reg >> 8);
+	data[1] = (u8) (reg & 0xff);
+	data[2] = val;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			udelay(50);
+			return 0;
+		}
+		msleep(5);
+	} while ((--retries) > 0);
+
+	return err;
+}
+
+/*
+ * Initialize a list of ov8810 registers.
+ * The list of registers is terminated by the pair of values
+ * {OV8810_REG_TERM, OV8810_VAL_TERM}.
+ * @client: i2c driver client structure.
+ * @reglist[]: List of address of the registers to write data.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int ov8810_write_regs(struct i2c_client *client,
+					const struct ov8810_reg reglist[])
+{
+	int err = 0;
+	const struct ov8810_reg *next = reglist;
+
+	while (!((next->reg == OV8810_REG_TERM)
+		&& (next->val == OV8810_VAL_TERM))) {
+		err = ov8810_write_reg(client, next->reg, next->val);
+		udelay(100);
+		if (err)
+			return err;
+		next++;
+	}
+	return 0;
+}
+
+/**
+ * ov8810_set_exposure_time - sets exposure time per input value
+ * @exp_time: exposure time to be set on device
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 exposure entry in video_controls array
+ *
+ * If the requested exposure time is not within the allowed limits, the
+ * exposure time is forced to the limit value. The HW
+ * is configured to use the new exposure time, and the
+ * video_control[] array is updated with the new current value.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_exposure_time(u32 exp_time, struct v4l2_int_device *s,
+				struct vcontrol *lvc, enum image_size_ov isize)
+{
+	/* Inputs exp_time in usec */
+	u16 coarse_int_tm;
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	u32 line_time_q8 = sensor->exposure.line_time;
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+
+		/* Check for FREX (frame mode) setup case */
+		if (sensor->shutter.type == MECH_SHUTTER_TYPE) {
+			/* max out AECL to insure longer than 1 frame */
+			coarse_int_tm = 0xFFFF;
+			goto write_aecl;
+		}
+
+		if (exp_time < sensor->exposure.min_exp_time) {
+			printk(KERN_ERR "OV8810: Exposure time %dms is less " \
+				"than regal limit %dms\n",
+				exp_time, sensor->exposure.min_exp_time);
+
+			exp_time = sensor->exposure.min_exp_time;
+		}
+
+		/* OV8810 cannot accept exposure time longer than frame time */
+		if (exp_time > sensor->exposure.fps_max_exp_time) {
+			printk(KERN_ERR "OV8810: Exposure time %dms is " \
+				"greater than legal limit %dms\n",
+				exp_time, sensor->exposure.fps_max_exp_time);
+
+			exp_time = sensor->exposure.fps_max_exp_time;
+		}
+
+		/* calc num lines with rounding */
+		coarse_int_tm = ((exp_time << 8) + (line_time_q8 >> 1)) /
+			line_time_q8;
+
+write_aecl:
+
+		if (coarse_int_tm != sensor->exposure.coarse_int_tm) {
+			/* write number of line times to AECL/H registers */
+			err = ov8810_write_reg(client, OV8810_AECL_H,
+				coarse_int_tm >> 8);
+			err |= ov8810_write_reg(client, OV8810_AECL_L,
+				coarse_int_tm & 0xFF);
+
+			DPRINTK_OV8810("set_exposure_time = " \
+				"%d usec, CoarseIntTime = %d, sclk=%d, " \
+				"line_len_pck=%d clks, line_tm = %d/256 us\n",
+				exp_time, coarse_int_tm, sensor->freq.sclk,
+				sensor_settings[isize].frame.line_len_pck,
+				line_time_q8);
+
+			/* save results */
+			sensor->exposure.exp_time = exp_time;
+			sensor->exposure.coarse_int_tm = coarse_int_tm;
+		}
+	}
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting exposure time...%d\n",
+			err);
+	else {
+		if (lvc)
+			lvc->current_value = exp_time;
+	}
+
+	return err;
+}
+
+/**
+ * ov8810_set_gain - sets sensor analog & digital gain per input value
+ * @lineargain: q8 analog gain value to be set on device
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 analog gain entry in ov8810_video_control array
+ *
+ * If the requested analog gain is within the allowed limits, the HW
+ * is configured to use the new gain value, and the ov8810_video_control
+ * array is updated with the new current value.
+ * Up to 2x digital gain will be used in addition to analog gain to achieve
+ * the desired gain if necessary.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_gain(u16 linear_gain_Q8, struct v4l2_int_device *s,
+							struct vcontrol *lvc)
+{
+	/* Inputs linear Q8 gain */
+	u16 anlg_gain_stage_2x = 0, dgtl_gain_stage_2x = 0;
+	u16 shift_bits = 0;
+	u16 anlg_gain_fraction = 0;
+	u16 anlg_gain_register = 0, dgtl_gain_register = 0;
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+
+	if (linear_gain_Q8 < sensor->exposure.min_linear_gain) {
+		printk(KERN_ERR "OV8810: Gain %d less than regal limit %d\n",
+			linear_gain_Q8, sensor->exposure.min_linear_gain);
+
+		linear_gain_Q8 = sensor->exposure.min_linear_gain;
+	}
+
+	if (linear_gain_Q8 > sensor->exposure.max_linear_gain) {
+		printk(KERN_ERR "OV8810: Gain %d greater than regal limit %d\n",
+			linear_gain_Q8, sensor->exposure.max_linear_gain);
+
+		linear_gain_Q8 = sensor->exposure.max_linear_gain;
+	}
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+		if (linear_gain_Q8 >= 16*256) {
+			dgtl_gain_stage_2x = 0x80;
+			anlg_gain_stage_2x = 0x70;
+			shift_bits = 4;
+		} else if (linear_gain_Q8 >= 8*256) {
+			anlg_gain_stage_2x = 0x70;
+			shift_bits = 3;
+		} else if (linear_gain_Q8 >= 4*256) {
+			anlg_gain_stage_2x = 0x30;
+			shift_bits = 2;
+		} else if (linear_gain_Q8 >= 2*256) {
+			anlg_gain_stage_2x = 0x10;
+			shift_bits = 1;
+		}
+
+		anlg_gain_fraction = linear_gain_Q8 >> shift_bits;
+		 /* subt 1 (Q8) and take upper 4 bits */
+		anlg_gain_fraction = (anlg_gain_fraction - (1*256)) >> 4;
+		if (anlg_gain_fraction > 0x0f)
+			anlg_gain_fraction = 0x0f;
+
+		anlg_gain_register = anlg_gain_stage_2x | anlg_gain_fraction;
+		dgtl_gain_register = dgtl_gain_stage_2x;
+
+		if (sensor->exposure.analog_gain != anlg_gain_register) {
+			err = ov8810_write_reg(client, OV8810_AGCL,
+				anlg_gain_register);
+
+			DPRINTK_OV8810("gain =%d/256, " \
+				"angl_gain reg = 0x%x\n",
+				linear_gain_Q8, anlg_gain_register);
+		}
+
+		if (sensor->exposure.digital_gain != dgtl_gain_register) {
+			err = ov8810_write_reg(client, OV8810_DIG_GAIN,
+				dgtl_gain_register);
+
+			DPRINTK_OV8810("gain =%d/256, "
+				"dgtl_gain_reg = 0x%x\n",
+				linear_gain_Q8, dgtl_gain_register);
+		}
+	}
+
+	if (err) {
+		printk(KERN_ERR "OV8810: Error setting analog gain: %d\n", err);
+		return err;
+	} else {
+		if (lvc)
+			lvc->current_value = linear_gain_Q8;
+	}
+
+	return err;
+}
+
+static int ov8810_init_exposure_params(struct v4l2_int_device *s)
+{
+	struct ov8810_sensor *sensor = s->priv;
+
+	/* flag current exp_time & gain values as invalid */
+	sensor->exposure.analog_gain = 0;
+	sensor->exposure.digital_gain = 0;
+	sensor->exposure.coarse_int_tm = 0;
+
+	return 0;
+}
+
+/**
+ * ov8810_set_framerate - Sets framerate by adjusting frame_len_lines reg.
+ * @s: pointer to standard V4L2 device structure
+ * @fper: frame period numerator and denominator in seconds
+ *
+ * The maximum exposure time is also updated since it is affected by the
+ * frame rate.
+ **/
+static int ov8810_set_framerate(struct v4l2_int_device *s,
+			struct v4l2_fract *fper, enum image_size_ov isize)
+{
+	u8 lut[9] = {1, 1, 1, 1, 2, 2, 2, 2, 4}, skip_factor;
+	u32 frame_length_lines, line_time_q8;
+	int err = 0, i = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc = NULL;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	/* limit desired frame period to min frame period for this readout */
+	if (((fper->numerator << 8) / fper->denominator) <
+		((ss->frame.min_time_per_frame.numerator << 8) /
+		  ss->frame.min_time_per_frame.denominator)) {
+		fper->numerator = ss->frame.min_time_per_frame.numerator;
+		fper->denominator = ss->frame.min_time_per_frame.denominator;
+	}
+
+	skip_factor = lut[ss->frame.h_subsample];
+	line_time_q8 = /* usec's (q8) */
+		((((u32)ss->frame.line_len_pck * 1000) << 8) /
+		(sensor->freq.pclk / 1000) / skip_factor);
+
+	frame_length_lines = (((u32)fper->numerator * 1000000 * 256 /
+			       fper->denominator)) / line_time_q8;
+
+	/* Range check frame_length_lines */
+	if (frame_length_lines > OV8810_MAX_FRAME_LENGTH_LINES)
+		frame_length_lines = OV8810_MAX_FRAME_LENGTH_LINES;
+	else if (frame_length_lines < ss->frame.frame_len_lines_min)
+		frame_length_lines = ss->frame.frame_len_lines_min;
+
+	/* Write new frame length to sensor */
+	ov8810_write_reg(client, OV8810_FRM_LEN_LINES_H,
+		frame_length_lines >> 8);
+	ov8810_write_reg(client, OV8810_FRM_LEN_LINES_L,
+		frame_length_lines  & 0xFF);
+
+	/* Save results */
+	ss->frame.frame_len_lines = frame_length_lines;
+	sensor->exposure.line_time = line_time_q8;
+	/* min_exposure_time = (ss->exposure.fine_int_tm * 1000000 /
+		(sensor->freq.vt_pix_clk)) + 1; */
+	/* use line time for min until LAEC turned on */
+	sensor->exposure.min_exp_time = line_time_q8 >> 8;
+	sensor->exposure.fps_max_exp_time = (line_time_q8 *
+		(ss->frame.frame_len_lines - 8)) >> 8;
+	sensor->exposure.abs_max_exp_time = (line_time_q8 *
+		(OV8810_MAX_FRAME_LENGTH_LINES - 8)) >> 8;
+
+	/* Update Exposure Time */
+	i = find_vctrl(V4L2_CID_EXPOSURE);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		/* Update min/max for query control */
+		lvc->qc.minimum = sensor->exposure.min_exp_time;
+		lvc->qc.maximum = sensor->exposure.fps_max_exp_time;
+
+		ov8810_set_exposure_time(lvc->current_value, s, lvc, isize);
+	}
+
+	DPRINTK_OV8810("Set Framerate: fper=%d/%d, " \
+		"frame_len_lines=%d, fps_max_expT=%dus, " \
+		"abs_max_expT=%dus, line_tm=%d/256, " \
+		"skip_factor=%d\n",
+		fper->numerator, fper->denominator, frame_length_lines,
+		sensor->exposure.fps_max_exp_time,
+		sensor->exposure.abs_max_exp_time,
+		line_time_q8, skip_factor);
+
+	return err;
+}
+
+/**
+ * ov8810_set_color_bar_mode - puts sensor in color bar test mode
+ * @enable: 0 = off, 1 = on
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 exposure entry in video_controls array
+ * This function should be called after the resolution is setup. The sensor
+ * will stay in color bar mode until the next resolution is selected.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_color_bar_mode(u16 enable, struct v4l2_int_device *s,
+							struct vcontrol *lvc)
+{
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+		if (enable) {
+			err = ov8810_write_reg(client, OV8810_CBAR, 0x1);
+			err = ov8810_write_reg(client, OV8810_SIZE_H0, 0x2);
+		} else {
+			err = ov8810_write_reg(client, OV8810_CBAR, 0x0);
+			err = ov8810_write_reg(client, OV8810_SIZE_H0, 0x3);
+		}
+	}
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting color bar mode\n");
+	else {
+		if (lvc)
+			lvc->current_value = enable;
+	}
+
+	return err;
+}
+
+int ov8810_strobe_manual_trigger(void)
+{
+    return ov8810_write_regs(ov8810_i2c_client, ov8810_strobe_trigger_reg);
+}
+
+/**
+ * ov8810_set_flash_next_frame - configures flash on for the next frame
+ * @flash_params: flash type and time
+ * @s: pointer to standard V4L2 device structure
+ * @lvc: pointer to V4L2 exposure entry in video_controls array
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int ov8810_set_flash_next_frame(
+			struct ov8810_flash_params *flash_params,
+			struct v4l2_int_device *s, struct vcontrol *lvc)
+{
+	int err = 0, data;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	u32 strb_pulse_width;
+	u32	line_time_q8 = sensor->exposure.line_time;
+
+	DPRINTK_OV8810("set_flash_next_frame: time=%dusec, " \
+		"flash_type=%d, shutter_type=%d, power=%d\n",
+		flash_params->flash_time, flash_params->flash_type,
+		flash_params->shutter_type,
+		(current_power_state == V4L2_POWER_ON) || sensor->resuming);
+
+	if (((current_power_state == V4L2_POWER_ON) || sensor->resuming) &&
+		(flash_params->flash_time != 0)) {
+
+		/* Set strobe source frame type */
+		ov8810_read_reg(client, 1, OV8810_FRS4, &data);
+		if (flash_params->shutter_type ==
+			ROLLING_SHUTTER_TYPE) {
+			data |= 1 << OV8810_FRS4_STRB_SOURCE_SEL_SHIFT;
+		} else {
+			data &= ~(1 << OV8810_FRS4_STRB_SOURCE_SEL_SHIFT);
+		}
+		err = ov8810_write_reg(client, OV8810_FRS4, data);
+
+		DPRINTK_OV8810("set_flash_next_frame:  " \
+			"OV8810_FRS_4=0x%x\n", data);
+
+		/* Set Strobe Ctrl Reg */
+		data = 0;
+		if (flash_params->shutter_type ==
+						ROLLING_SHUTTER_TYPE) {
+			data |= 1 <<
+				OV8810_FRS5_ROLLING_SHUT_STRB_EN_SHIFT;
+		}
+		if (flash_params->flash_type == LED_FLASH_TYPE) {
+			data |= 1 <<
+				OV8810_FRS5_STROBE_MODE_SHIFT;
+		}
+
+		strb_pulse_width = (flash_params->flash_time << 8) /
+			line_time_q8;
+
+		if (strb_pulse_width < 1)
+			strb_pulse_width = 1;
+		else if (strb_pulse_width > 4)
+			strb_pulse_width = 4;
+
+		data |= (strb_pulse_width - 1) <<
+			OV8810_FRS5_STRB_PLS_WIDTH_SHIFT;
+
+		err |= ov8810_write_reg(client, OV8810_FRS5, data);
+
+		DPRINTK_OV8810("set_flash_next_frame:  " \
+			"OV8810_FRS_5=0x%x\n", data);
+
+		/* Set Frame Mode Strobe Pulse Width */
+		if (flash_params->shutter_type == MECH_SHUTTER_TYPE) {
+			strb_pulse_width = (flash_params->flash_time << 8) /
+				line_time_q8;
+
+			if (strb_pulse_width > 15)
+				strb_pulse_width = 15;
+
+			err |= ov8810_write_reg(client, OV8810_FRS6,
+				strb_pulse_width);
+
+			DPRINTK_OV8810("set_flash_next_frame:  " \
+				"OV8810_FRS_6=0x%x\n",
+				strb_pulse_width);
+		}
+
+		/* Auto reset */
+		flash_params->flash_time = 0;
+	}
+
+	if (err)
+		printk(KERN_ERR  "OV8810: Error setting flash register\n");
+	else {
+		sensor->flash.flash_time = flash_params->flash_time;
+		sensor->flash.flash_type = flash_params->flash_type;
+		sensor->flash.shutter_type = flash_params->shutter_type;
+	}
+	return err;
+}
+
+/**
+ * Sets the sensor orientation.
+ */
+static int ov8810_set_orientation(enum ov8810_orientation val,
+			struct v4l2_int_device *s, struct vcontrol *lvc)
+{
+	int err = 0;
+	u32 data;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+
+		err = ov8810_read_reg(client, 1,
+			OV8810_IMAGE_TRANSFORM, &data);
+			/* clear both orientation bits */
+			data &= ~OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+			data &= ~OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+		switch (val) {
+		case OV8810_NO_HORZ_FLIP_OR_VERT_FLIP:
+			/* set no bits */
+			break;
+		case OV8810_HORZ_FLIP_ONLY:
+			data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+			break;
+		case OV8810_VERT_FLIP_ONLY:
+			data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+			break;
+		case OV8810_HORZ_FLIP_AND_VERT_FLIP:
+			data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+			data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+			break;
+		default:
+			break;
+		}
+
+		err |= ov8810_write_reg(client,
+			OV8810_IMAGE_TRANSFORM, data);
+
+		DPRINTK_OV8810("set_orientation:  " \
+			"sensor->orientation=%d, IMAGE_TRANSFORM=0x%x\n",
+			val, data);
+	}
+
+	if (err) {
+		printk(KERN_ERR "OV8810: Error setting orientation.%d", err);
+		return err;
+	} else {
+		lvc->current_value = (u32)val;
+		sensor->orientation = val;
+	}
+
+	return err;
+}
+
+/**
+ * ov8810_start_mech_shutter_capture - initiates capture using mechanical shutter
+ * @shutter_params: expoosure and shutter delay time
+ * @s: pointer to standard V4L2 device structure
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ * This function is expected to be called after streaming has been started and
+ * after shutter parameters have been set.
+ */
+int ov8810_start_mech_shutter_capture(
+			struct ov8810_shutter_params *shutter_params,
+			struct v4l2_int_device *s, struct vcontrol *lvc)
+{
+	u16 Tr_lines = 1, Tfrex_lines, shutter_dly_lines, frame_len_lines_adj;
+	u16 data = 0;
+	int err = -EINVAL;
+	int adjusted_exp_time;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct ov8810_sensor_settings *ss = &sensor_settings[sensor->isize];
+	u32 line_time_q8 = sensor->exposure.line_time;
+
+	DPRINTK_OV8810("expTime=%dus, shutter delay=%dus, " \
+		"power=%d\n",
+		shutter_params->exp_time, shutter_params->delay_time,
+		(current_power_state == V4L2_POWER_ON) || sensor->resuming);
+
+	if (sensor->streaming == false) {
+		printk(KERN_ERR "OV8810: Error: Sensor must be streaming to " \
+			"start mech shutter capture.\n");
+		return err;
+	}
+
+	if ((shutter_params->type != MECH_SHUTTER_TYPE) ||
+			(shutter_params->exp_time == 0)) {
+		printk(KERN_ERR "OV8810: Error: Invalid shutter params.\n");
+		return err;
+	}
+
+	/* Set FREX Precharge Time */
+	err = ov8810_write_reg(client, OV8810_FRS1, Tr_lines);
+
+	/* Calc Tfrex time */
+	adjusted_exp_time = shutter_params->exp_time -
+		shutter_params->delay_time;
+	if (adjusted_exp_time < 0)
+		adjusted_exp_time = 0;
+
+	/* Convert Tfrex time to lines (with rounding) */
+	Tfrex_lines = (((adjusted_exp_time << 8) +
+		(line_time_q8 >> 1)) / line_time_q8) + Tr_lines;
+
+	err |= ov8810_write_reg(client, OV8810_FRS2,
+		((Tfrex_lines >> 8) & 0xFF));
+	err |= ov8810_write_reg(client, OV8810_FRS3,
+		((Tfrex_lines) & 0xFF));
+
+	/* Calc TFE2V  lines (with rounding)  */
+	shutter_dly_lines = (((shutter_params->delay_time << 8) +
+		(line_time_q8 >> 1)) / line_time_q8);
+
+	/*
+	 * start FREX capture & MIPI output simultaneously
+	 */
+	/* enable group latch */
+	err |= ov8810_write_reg(client, OV8810_FRS0, 0x88);
+
+	/* turn on MIPI output */
+	if (ss->mipi.num_data_lanes == 2)
+		data = 0;
+	else if (ss->mipi.num_data_lanes == 1)
+		data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+	else
+		data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_1_MASK |
+			OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+
+	err |= ov8810_write_reg(client, OV8810_MIPI_CTRL0B, 0x0C | data);
+
+	/* adjust frame length to delay readout */
+	frame_len_lines_adj = ss->frame.frame_len_lines + shutter_dly_lines;
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_H,
+		 (frame_len_lines_adj >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_L,
+		 frame_len_lines_adj & 0xFF);
+
+	/* do frame trigger */
+	err |= ov8810_write_reg(client, OV8810_FRS7, 0x01);
+
+	/* disable group latch */
+	err |= ov8810_write_reg(client, OV8810_FRS0, 0x80);
+
+	/* trigger group latch in the coming V-blank */
+	err |= ov8810_write_reg(client, OV8810_GROUP_WR, 0xFF);
+
+	DPRINTK_OV8810("start_mech_shutter_capture:  " \
+		"expT=%dus, line_time_q8=%dus/256, " \
+		"shutter_dly=%dus Tfrex_lines=%d, " \
+		"shutter_dly_lines=%d, frame_len_lines = %d\n",
+		shutter_params->exp_time, line_time_q8,
+		shutter_params->delay_time, Tfrex_lines,
+		shutter_dly_lines, frame_len_lines_adj);
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting mech shutter registers\n");
+
+	return err;
+}
+
+/*
+ * Calculates the PClk.
+ * 1) Read pclk related params
+ * 2) Calc pclk
+ *      Pclk = xclk * PLL_multiplier  / pll_pre_div / div8 /
+ * 		vt_sys_div / rp_clk_div
+ * NOTE:
+ *  - The lookup table 'lut1' has been multiplied by 2 so all its values
+ *    are integers. The numerator is multiplied by 2 in the Pclk
+ *    calculation to compensate.
+ */
+static int ov8810_calc_pclk(struct v4l2_int_device *s,
+	enum image_size_ov isize)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	sensor->freq.sclk = sensor->freq.xclk * ss->clk.pll_mult /
+				ss->clk.pll_pre_div / ss->clk.div8 /
+				ss->clk.vt_sys_div;
+
+	sensor->freq.pclk = sensor->freq.sclk / ss->clk.rp_clk_div;
+
+	DPRINTK_OV8810("ov8810_calc_pclk: vt_sys_div=%d, div8=%d, " \
+		"op_sys_div=%d, op_pix_div=%d, pll_mult=%d, pll_pre_div=%d, " \
+		"rp_clk_div=%d, sclk=%d, pclk=%d, # lanes=%d\n",
+		ss->clk.vt_sys_div, ss->clk.div8,
+		ss->clk.op_sys_div, ss->clk.op_pix_div,
+		ss->clk.pll_mult, ss->clk.pll_pre_div,
+		ss->clk.rp_clk_div, sensor->freq.sclk, sensor->freq.pclk,
+		ss->mipi.num_data_lanes);
+	return 0;
+}
+
+/*
+ * Set Lens Correction
+ */
+static int ov8810_set_lens_correction(u16 enable_lens_correction,
+	struct v4l2_int_device *s, struct vcontrol *lvc,
+	enum image_size_ov isize)
+{
+	u8 lenc_downsampling;
+	int data, err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	if ((current_power_state == V4L2_POWER_ON) || sensor->resuming) {
+		if (enable_lens_correction) {
+			/* Lock VDD1 to OPP5 - Temporary workaround for 720p
+			   mode only !!!*/
+			sensor->pdata->lock_cpufreq(CPU_CLK_LOCK);
+
+			err = ov8810_write_regs(client, len_correction_tbl);
+			/* enable 0x3300[4] */
+			err |= ov8810_read_reg(client, 1,
+				OV8810_ISP_ENBL_0, &data);
+			data |= 0x10;
+			err |= ov8810_write_reg(client,
+				OV8810_ISP_ENBL_0, data);
+
+			/* set downsampling */
+			if (ss->frame.h_subsample == 8)
+				lenc_downsampling = LENC_8_1_DOWNSAMPLING;
+			else if (ss->frame.h_subsample == 4)
+				lenc_downsampling = LENC_4_1_DOWNSAMPLING;
+			else if (ss->frame.h_subsample == 2)
+				lenc_downsampling = LENC_2_1_DOWNSAMPLING;
+			else
+				lenc_downsampling = LENC_1_1_DOWNSAMPLING;
+
+			err |= ov8810_write_reg(client,
+				OV8810_LENC, lenc_downsampling);
+
+			DPRINTK_OV8810("enabling lens correction: " \
+				"downsample=0x%x\n", lenc_downsampling);
+
+		} else {  /* disable lens correction */
+			err = ov8810_read_reg(client, 1,
+				OV8810_ISP_ENBL_0, &data);
+			data &= 0xef;
+			err |= ov8810_write_reg(client,
+				OV8810_ISP_ENBL_0, data);
+		}
+	}
+
+	if (err)
+		printk(KERN_ERR "OV8810: Error setting lens correction=%d.\n",
+			enable_lens_correction);
+	else {
+		if (lvc)
+			lvc->current_value = enable_lens_correction;
+	}
+
+	return err;
+}
+
+/* Find the best match for a requested image capture size.  The best match
+ * is chosen as the nearest match that has the same number or fewer pixels
+ * as the requested size, or the smallest image size if the requested size
+ * has fewer pixels than the smallest image.
+ */
+static enum image_size_ov
+ov8810_find_size(struct v4l2_int_device *s, unsigned int width,
+	unsigned int height)
+{
+	enum image_size_ov size;
+
+	if ((width > ov8810_sizes[SIZE_2M].width) ||
+		(height > ov8810_sizes[SIZE_2M].height))
+		size = SIZE_8M;
+	else if ((width > ov8810_sizes[SIZE_1_5M].width) ||
+		(height > ov8810_sizes[SIZE_1_5M].height))
+		size = SIZE_2M;
+	else if ((width > ov8810_sizes[SIZE_500K].width) ||
+		(height > ov8810_sizes[SIZE_500K].height))
+		size = SIZE_1_5M;
+	else if ((width > ov8810_sizes[SIZE_125K].width) ||
+		(height > ov8810_sizes[SIZE_125K].height))
+		size = SIZE_500K;
+	else
+		size = SIZE_125K;
+
+	DPRINTK_OV8810("find_size: Req Width=%d, "
+			"Find Size=%dx%d\n",
+			width, (int)ov8810_sizes[size].width,
+			(int)ov8810_sizes[size].height);
+
+	return size;
+}
+
+/*
+ * Set CSI2 Virtual ID.
+ */
+static int ov8810_set_virtual_id(struct i2c_client *client, u32 id)
+{
+	return ov8810_write_reg(client, OV8810_MIPI_CTRL02, (0x3 & id) << 6 |
+									0x12);
+}
+
+/*
+ * Calculates the MIPIClk.
+ */
+static u32 ov8810_calc_mipiclk(struct v4l2_int_device *s,
+	enum image_size_ov isize)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	sensor->freq.mipiclk = (sensor->freq.xclk * ss->clk.pll_mult) /
+		(ss->clk.pll_pre_div * ss->clk.op_sys_div);
+
+	DPRINTK_OV8810("mipiclk=%u  pre_divider=%u  " \
+		"multiplier=%u  op_sys_div=%u\n",
+		sensor->freq.mipiclk, ss->clk.pll_pre_div,
+		ss->clk.pll_mult, ss->clk.op_sys_div);
+
+	return sensor->freq.mipiclk;
+}
+
+/**
+ * ov8810_configure_frame - Setup the frame, clock and exposure parmas in the
+ * sensor_settings array.
+ *
+ * @s: pointer to standard V4L2 device structure
+ * @isize: current image size
+ *
+ * The sensor_settings is a common list used by all image sizes & frame
+ * rates that is filled in by this routine.
+ */
+int ov8810_configure_frame(struct v4l2_int_device *s,
+			    enum image_size_ov isize)
+{
+	u8 lut[9] = { 0, 0, 1, 1, 2, 2, 2, 2, 3 };
+	u32 data;
+	int err = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	struct ov8810_sensor_settings *ss = &sensor_settings[isize];
+
+	err |= ov8810_write_reg(client, OV8810_DSIO0,
+		(lut[ss->clk.rp_clk_div] & OV8810_DSIO0_RPCLK_DIV_MASK) | 0x8);
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL1,
+		 (ss->clk.div8 & OV8810_R_PLL1_DIV8_MASK) |
+		((ss->clk.vt_sys_div << OV8810_R_PLL1_VT_SYS_DIV_SHIFT) &
+		  OV8810_R_PLL1_VT_SYS_DIV_MASK));
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL4,
+		 (ss->clk.pll_pre_div & OV8810_R_PLL4_PRE_DIV_MASK) | 0x20);
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL3,
+		 ss->clk.pll_mult & OV8810_R_PLL3_PLL_MULT_MASK);
+
+	err |= ov8810_write_reg(client, OV8810_R_PLL2,
+		 (ss->clk.op_pix_div & OV8810_R_PLL2_OP_PIX_DIV_MASK) |
+		((ss->clk.op_sys_div << OV8810_R_PLL2_OP_SYS_DIV_SHIFT) &
+		  OV8810_R_PLL2_OP_SYS_DIV_MASK));
+
+	err |= ov8810_write_reg(client, OV8810_X_OUTPUT_SIZE_H,
+		 (ss->frame.x_output_size >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_OUTPUT_SIZE_L,
+		 ss->frame.x_output_size & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_OUTPUT_SIZE_H,
+		 (ss->frame.y_output_size >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_OUTPUT_SIZE_L,
+		 ss->frame.y_output_size & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_START_H,
+		 (ss->frame.x_addr_start >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_START_L,
+		 ss->frame.x_addr_start & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_START_H,
+		 (ss->frame.y_addr_start >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_START_L,
+		 ss->frame.y_addr_start & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_END_H,
+		 (ss->frame.x_addr_end >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_X_ADDR_END_L,
+		 ss->frame.x_addr_end & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_END_H,
+		 (ss->frame.y_addr_end >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_Y_ADDR_END_L,
+		 ss->frame.y_addr_end & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_H,
+		 (ss->frame.frame_len_lines_min >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_FRM_LEN_LINES_L,
+		 ss->frame.frame_len_lines_min & 0xFF);
+	ss->frame.frame_len_lines = ss->frame.frame_len_lines_min;
+
+	err |= ov8810_write_reg(client, OV8810_LINE_LEN_PCK_H,
+		 (ss->frame.line_len_pck_min >> 8) & 0xFF);
+
+	err |= ov8810_write_reg(client, OV8810_LINE_LEN_PCK_L,
+		 ss->frame.line_len_pck_min & 0xFF);
+	ss->frame.line_len_pck = ss->frame.line_len_pck_min;
+
+	data = ((lut[ss->frame.v_subsample] <<
+		 OV8810_IMAGE_TRANSFORM_VSUB_SHIFT) &
+		 OV8810_IMAGE_TRANSFORM_VSUB_MASK) |
+		 (lut[ss->frame.h_subsample] &
+		 OV8810_IMAGE_TRANSFORM_HSUB_MASK);
+
+/*
+printk("ov8810_configure_frame: sensor->orientation = %d\n",
+	sensor->orientation);
+*/
+
+/*
+	switch (sensor->orientation) {
+	case OV8810_NO_HORZ_FLIP_OR_VERT_FLIP:
+		break;
+	case OV8810_HORZ_FLIP_ONLY:
+		data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+		break;
+	case OV8810_VERT_FLIP_ONLY:
+		data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+		break;
+	case OV8810_HORZ_FLIP_AND_VERT_FLIP:
+		data |= OV8810_IMAGE_TRANSFORM_HMIRROR_MASK;
+		data |= OV8810_IMAGE_TRANSFORM_VFLIP_MASK;
+		break;
+	default:
+		break;
+	}
+*/
+	data |= 0x40;  /* TEMP force orientation */
+	err |= ov8810_write_reg(client, OV8810_IMAGE_TRANSFORM, data);
+
+	sensor->isize = isize;
+	if (err)
+		return -EIO;
+	else
+		return 0;
+}
+
+/*
+ * Configure the ov8810 for a specified image size, pixel format, and frame
+ * period.  xclk is the frequency (in Hz) of the xclk input to the OV8810.
+ * fper is the frame period (in seconds) expressed as a fraction.
+ * Returns zero if successful, or non-zero otherwise.
+ * The actual frame period is returned in fper.
+ */
+static int ov8810_configure(struct v4l2_int_device *s)
+{
+	enum image_size_ov isize;
+	u16 data = 0;
+	int err = 0, i = 0;
+	u32 mipiclk;
+	enum pixel_format_ov pfmt = RAW10;
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &sensor->pix;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc = NULL;
+
+	switch (pix->pixelformat) {
+
+	case V4L2_PIX_FMT_SGRBG10:
+		pfmt = RAW10;
+		break;
+	}
+
+	/* Set receivers virtual channel before sensor setup starts.
+	 * Only set the sensors virtual channel after all other setup
+	 * for the sensor is complete.
+	 */
+	isp_csi2_ctx_config_virtual_id(0, OV8810_CSI2_VIRTUAL_ID);
+	isp_csi2_ctx_update(0, false);
+
+	isize = ov8810_find_size(s, pix->width, pix->height);
+
+	printk(KERN_INFO "ov8810_configure: isize=%d, Req Size=%dx%d, " \
+		"Find Size = %dx%d, fps=%d/%d\n", \
+		isize, pix->width, pix->height,
+		(int)ov8810_sizes[isize].width,
+		(int)ov8810_sizes[isize].height,
+		sensor->timeperframe.denominator,
+		sensor->timeperframe.numerator);
+
+	/* Reset */
+	isp_csi2_ctrl_config_if_enable(false);
+	isp_csi2_ctrl_update(false);
+
+	ov8810_write_reg(client, OV8810_SYS, 0x80);
+	mdelay(5);
+
+	/* Set CSI2 common register settings */
+	err = ov8810_write_regs(client, ov8810_common_csi2);
+	if (err)
+		return err;
+
+	/* configure image size, pll, and pixel format */
+	if (pix->pixelformat == V4L2_PIX_FMT_SGRBG10) {
+		err = ov8810_write_regs(client, ov8810_common[isize]);
+
+	} else if (pix->pixelformat == V4L2_PIX_FMT_W1S_PATT) {
+		isize = SIZE_8M;
+		err = ov8810_write_regs(client, ov8810_common[isize]);
+
+		err |= ov8810_write_reg(client, OV8810_DVP_CTRL08, 0x80);
+	}
+	if (err)
+		return err;
+
+	/* Turn on 50-60 Hz Detection */
+	if (isize != SIZE_8M) {
+		err = ov8810_write_regs(client, ov8810_50_60_hz_detect_tbl);
+		if (err)
+			return err;
+	}
+
+	/* Set Shutter related register settings */
+	if (sensor->shutter.type == MECH_SHUTTER_TYPE) {
+		/* Leave MIPI output disabled until
+		   start_mech_shutter_capture */
+		err = ov8810_write_regs(client, ov8810_mech_shutter);
+		if (err)
+			return err;
+	} else {
+		/* Enable MIPI output */
+		if (sensor_settings[isize].mipi.num_data_lanes == 2)
+			data = 0;
+		else if (sensor_settings[isize].mipi.num_data_lanes == 1)
+			data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+		else
+			data = OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_1_MASK |
+				OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK;
+
+		err = ov8810_write_reg(client, OV8810_MIPI_CTRL0B, 0x0c | data);
+		if (err)
+			return err;
+	}
+
+	sensor->isize = isize;
+
+	/* if the image size correspond to one of the base image sizes
+		then we don't need to scale the image */
+	sensor->hsize = pix->width;
+	sensor->vsize = pix->height;
+
+	/* Setup the ISP VP based on image format */
+	if (pix->pixelformat == V4L2_PIX_FMT_SGRBG10) {
+		isp_configure_interface_bridge(0x00);
+		isp_csi2_ctrl_config_vp_out_ctrl(2);
+		isp_csi2_ctrl_update(false);
+	} else {
+		isp_configure_interface_bridge(0x03);
+		isp_csi2_ctrl_config_vp_out_ctrl(1);
+		isp_csi2_ctrl_update(false);
+	}
+
+	/* Store image size */
+	sensor->width = pix->width;
+	sensor->height = pix->height;
+
+	/* Update sensor clk, frame, & exposure params */
+	ov8810_calc_pclk(s, isize);
+	ov8810_init_exposure_params(s);
+	err = ov8810_configure_frame(s, isize);
+	if (err)
+		return err;
+
+	/* Setting of frame rate */
+	err = ov8810_set_framerate(s, &sensor->timeperframe, isize);
+	if (err)
+		return err;
+
+	mipiclk = ov8810_calc_mipiclk(s, isize);
+
+	DPRINTK_OV8810("mipiclk = %d, lbound_hs_settle = %d, " \
+		"ubound_hs_settle = %d \n", mipiclk,
+		sensor_settings[isize].mipi.hs_settle_lower,
+		sensor_settings[isize].mipi.hs_settle_upper);
+
+	/* Send settings to ISP-CSI2 Receiver PHY */
+	isp_csi2_calc_phy_cfg0(mipiclk,
+		sensor_settings[isize].mipi.hs_settle_lower,
+		sensor_settings[isize].mipi.hs_settle_upper);
+
+	/* Set sensors virtual channel*/
+	ov8810_set_virtual_id(client, OV8810_CSI2_VIRTUAL_ID);
+
+	isp_csi2_ctrl_config_if_enable(true);
+	isp_csi2_ctrl_update(false);
+
+	/* Set initial exposure time */
+	i = find_vctrl(V4L2_CID_EXPOSURE);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_exposure_time(lvc->current_value,
+			sensor->v4l2_int_device, lvc, isize);
+	}
+
+	/* Set initial gain */
+	i = find_vctrl(V4L2_CID_GAIN);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_gain(lvc->current_value,
+			sensor->v4l2_int_device, lvc);
+	}
+
+	if (pix->pixelformat != V4L2_PIX_FMT_W1S_PATT) {
+		/* Set initial color bars */
+		i = find_vctrl(V4L2_CID_PRIVATE_COLOR_BAR);
+		if (i >= 0) {
+			lvc = &video_control[i];
+			ov8810_set_color_bar_mode(lvc->current_value,
+				sensor->v4l2_int_device, lvc);
+		}
+	}
+
+	/* Set initial flash mode */
+	i = find_vctrl(V4L2_CID_PRIVATE_FLASH_NEXT_FRAME);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_flash_next_frame(&(sensor->flash),
+			sensor->v4l2_int_device, lvc);
+	}
+
+	i = find_vctrl(V4L2_CID_PRIVATE_LENS_CORRECTION);
+	if (i >= 0) {
+		lvc = &video_control[i];
+		ov8810_set_lens_correction(lvc->current_value,
+			sensor->v4l2_int_device, lvc, isize);
+	}
+
+	/* start streaming */
+	ov8810_write_reg(client, OV8810_IMAGE_SYSTEM, 0x01);
+	sensor->streaming = true;
+
+	return err;
+}
+
+
+/* Detect if an ov8810 is present, returns a negative error number if no
+ * device is detected, or pidl as version number if a device is detected.
+ */
+static int ov8810_detect(struct v4l2_int_device *s)
+{
+	u16 pid, rev;
+	u32 val;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct ov8810_sensor_id *sensor_id = &(sensor->sensor_id);
+
+	if (!client)
+		return -ENODEV;
+
+	if (ov8810_read_reg(client, 1, OV8810_PIDH, &val))
+		return -ENODEV;
+	pid = (val & 0xff) << 8;
+
+	if (ov8810_read_reg(client, 1, OV8810_PIDL, &val))
+		return -ENODEV;
+	pid |= val & 0xf0;
+	rev = val & 0xf;
+
+	/* Check ID & max supported rev */
+	if (pid == OV8810_PID) {
+		DPRINTK_OV8810("Detect success " \
+			"(pid=0x%x rev=0x%x\n", pid, rev);
+
+		sensor_id->model = pid;
+		sensor_id->revision = rev;
+
+		return 0;
+	} else {
+		/* We didn't read the values we expected, so
+		 * this must not be an OV8810.
+		 */
+		printk(KERN_ERR "OV8810: pid mismatch 0x%x rev 0x%x\n",
+			pid, rev);
+
+		return -ENODEV;
+	}
+}
+
+/*
+ * ioctl_queryctrl - V4L2 sensor interface handler for VIDIOC_QUERYCTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @qc: standard V4L2 VIDIOC_QUERYCTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control information
+ * from the video_control[] array.  Otherwise, returns -EINVAL if the
+ * control is not supported.
+ */
+static int ioctl_queryctrl(struct v4l2_int_device *s,
+						struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	i = find_vctrl(qc->id);
+	if (i == -EINVAL)
+		qc->flags = V4L2_CTRL_FLAG_DISABLED;
+
+	if (i < 0)
+		return -EINVAL;
+
+	*qc = video_control[i].qc;
+	return 0;
+}
+
+/*
+ * ioctl_g_ctrl - V4L2 sensor interface handler for VIDIOC_G_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_G_CTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control's current
+ * value from the video_control[] array.  Otherwise, returns -EINVAL
+ * if the control is not supported.
+ */
+
+static int ioctl_g_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	int i, retval = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc;
+	struct  ov8810_sensor_params sensor_params;
+	struct ov8810_sensor_regif sensor_reg;
+
+	i = find_vctrl(vc->id);
+	if (i < 0)
+		return -EINVAL;
+	lvc = &video_control[i];
+
+	switch (vc->id) {
+	case  V4L2_CID_EXPOSURE:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_GAIN:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_COLOR_BAR:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_FLASH_NEXT_FRAME:
+		if (copy_to_user((void *)vc->value, &(sensor->flash),
+				sizeof(sensor->flash))) {
+			retval = -EINVAL;
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+		}
+		break;
+	case V4L2_CID_PRIVATE_ORIENTATION:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_LENS_CORRECTION:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_PRIVATE_SHUTTER_PARAMS:
+		if (copy_to_user((void *)vc->value, &(sensor->shutter),
+				sizeof(sensor->shutter))) {
+			retval = -EINVAL;
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+		}
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_ID_REQ:
+		if (copy_to_user((void *)vc->value, &(sensor->sensor_id),
+				sizeof(sensor->sensor_id))) {
+			retval = -EINVAL;
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+		}
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_REG_REQ:
+		if ((current_power_state != V4L2_POWER_ON) &&
+			!sensor->resuming) {
+			printk(KERN_ERR "OV8810: I2C Read Err: Power Off\n");
+			return -EINVAL;
+		}
+		if (copy_from_user(&sensor_reg,
+			(struct ov8810_sensor_regif *)vc->value,
+			sizeof(struct ov8810_sensor_regif)) == 0) {
+			retval =  ov8810_read_reg(client, sensor_reg.len,
+				sensor_reg.addr, &sensor_reg.val);
+			DPRINTK_OV8810("SENSOR_REG_REQ IOCTL read-" \
+				"%d: 0x%x=0x%x\n", sensor_reg.len,
+				sensor_reg.addr, sensor_reg.val);
+		}
+		if (copy_to_user((void *)vc->value, &(sensor_reg),
+				sizeof(sensor_reg))) {
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_PARAMS_REQ:
+		sensor_params.line_time = sensor->exposure.line_time;
+		sensor_params.gain_frame_delay = OV8810_GAIN_FRAME_DELAY;
+		sensor_params.exp_time_frame_delay =
+			OV8810_EXP_TIME_FRAME_DELAY;
+		if (copy_to_user((void *)vc->value, &(sensor_params),
+				sizeof(sensor_params))) {
+			printk(KERN_ERR "OV8810: Failed copy_to_user\n");
+			return -EINVAL;
+		}
+		break;
+	}
+	return retval;
+}
+
+/*
+ * ioctl_s_ctrl - V4L2 sensor interface handler for VIDIOC_S_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
+ *
+ * If the requested control is supported, sets the control's current
+ * value in HW (and updates the video_control[] array).  Otherwise,
+ * returns -EINVAL if the control is not supported.
+ */
+static int ioctl_s_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	int retval = -EINVAL;
+	int i;
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *client = sensor->i2c_client;
+	struct vcontrol *lvc;
+	struct ov8810_flash_params flash_params;
+	struct ov8810_sensor_regif sensor_reg;
+
+	i = find_vctrl(vc->id);
+	if (i < 0)
+		return -EINVAL;
+
+	lvc = &video_control[i];
+
+	switch (vc->id) {
+	case V4L2_CID_EXPOSURE:
+		retval = ov8810_set_exposure_time(vc->value, s, lvc,
+			sensor->isize);
+		break;
+	case V4L2_CID_GAIN:
+		retval = ov8810_set_gain(vc->value, s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_COLOR_BAR:
+		retval = ov8810_set_color_bar_mode(vc->value, s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_FLASH_NEXT_FRAME:
+		if (copy_from_user(&flash_params,
+				(struct ov8810_flash_params *)vc->value,
+				sizeof(struct ov8810_flash_params)) == 0) {
+			retval = ov8810_set_flash_next_frame(&flash_params,
+				s, lvc);
+		}
+		break;
+	case V4L2_CID_PRIVATE_ORIENTATION:
+		retval = ov8810_set_orientation(vc->value, s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_LENS_CORRECTION:
+		retval = ov8810_set_lens_correction(vc->value, s, lvc,
+			sensor->isize);
+		break;
+	case V4L2_CID_PRIVATE_SHUTTER_PARAMS:
+		retval = copy_from_user(&(sensor->shutter),
+				(struct ov8810_shutter_params *)vc->value,
+				sizeof(struct ov8810_shutter_params));
+		DPRINTK_OV8810("SHUTTER_PARAMS IOCTL write-" \
+			"exp_time=%d, delay_time=%d, type=%d\n",
+			sensor->shutter.exp_time, sensor->shutter.delay_time,
+			sensor->shutter.type);
+		break;
+	case V4L2_CID_PRIVATE_START_MECH_SHUTTER_CAPTURE:
+		retval = ov8810_start_mech_shutter_capture(
+			&(sensor->shutter), s, lvc);
+		break;
+	case V4L2_CID_PRIVATE_SENSOR_REG_REQ:
+		if ((current_power_state != V4L2_POWER_ON) &&
+			!sensor->resuming) {
+			printk(KERN_ERR "OV8810: Reg Write Err: Power Off\n");
+			return -EINVAL;
+		}
+		if (copy_from_user(&sensor_reg,
+			(struct ov8810_sensor_regif *)vc->value,
+			sizeof(struct ov8810_sensor_regif)) == 0) {
+
+			/* ov8810_write_reg only supports 1-byte writes */
+			DPRINTK_OV8810("SENSOR_REG_REQ IOCTL write-" \
+				"%d: 0x%x=0x%x\n", sensor_reg.len,
+				sensor_reg.addr, sensor_reg.val);
+			if (sensor_reg.len == 1) {
+				retval = ov8810_write_reg(client,
+					sensor_reg.addr, sensor_reg.val);
+			} else if (sensor_reg.len == 2) {
+				retval = ov8810_write_reg(client,
+					sensor_reg.addr,
+					(sensor_reg.val & 0xff00) >> 8);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 1,
+					sensor_reg.val & 0xff);
+			} else if (sensor_reg.len == 4) {
+				retval = ov8810_write_reg(client,
+					sensor_reg.addr,
+					(sensor_reg.val & 0xff000000) >> 24);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 1,
+					(sensor_reg.val & 0xff0000) >> 16);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 2,
+					(sensor_reg.val & 0xff00) >> 8);
+				retval |= ov8810_write_reg(client,
+					sensor_reg.addr + 3,
+					sensor_reg.val & 0xff);
+			} else {
+				printk(KERN_ERR "OV8810: Error: " \
+					"SENSOR_REG_REQ IOCTL " \
+					"length must = 1, 2, or 4\n");
+			}
+		}
+		break;
+	}
+	if (!retval)
+		lvc->current_value = vc->value;
+	return retval;
+}
+
+/*
+ * ioctl_enum_fmt_cap - Implement the CAPTURE buffer VIDIOC_ENUM_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fmt: standard V4L2 VIDIOC_ENUM_FMT ioctl structure
+ *
+ * Implement the VIDIOC_ENUM_FMT ioctl for the CAPTURE buffer type.
+ */
+ static int ioctl_enum_fmt_cap(struct v4l2_int_device *s,
+				   struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	memset(fmt, 0, sizeof(*fmt));
+	fmt->index = index;
+	fmt->type = type;
+
+	switch (fmt->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (index >= NUM_CAPTURE_FORMATS)
+			return -EINVAL;
+	break;
+	default:
+		return -EINVAL;
+	}
+
+	fmt->flags = ov8810_formats[index].flags;
+	strlcpy(fmt->description, ov8810_formats[index].description,
+					sizeof(fmt->description));
+	fmt->pixelformat = ov8810_formats[index].pixelformat;
+
+	return 0;
+}
+
+
+/*
+ * ioctl_try_fmt_cap - Implement the CAPTURE buffer VIDIOC_TRY_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_TRY_FMT ioctl structure
+ *
+ * Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type.  This
+ * ioctl is used to negotiate the image capture size and pixel format
+ * without actually making it take effect.
+ */
+
+static int ioctl_try_fmt_cap(struct v4l2_int_device *s,
+			     struct v4l2_format *f)
+{
+	int ifmt;
+	enum image_size_ov isize;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	if (pix->width > ov8810_sizes[SIZE_8M].width)
+		pix->width = ov8810_sizes[SIZE_8M].width;
+	if (pix->height > ov8810_sizes[SIZE_8M].height)
+		pix->height = ov8810_sizes[SIZE_8M].height;
+
+	isize = ov8810_find_size(s, pix->width, pix->height);
+	pix->width = ov8810_sizes[isize].width;
+	pix->height = ov8810_sizes[isize].height;
+
+	for (ifmt = 0; ifmt < NUM_CAPTURE_FORMATS; ifmt++) {
+		if (pix->pixelformat == ov8810_formats[ifmt].pixelformat)
+			break;
+	}
+	if (ifmt == NUM_CAPTURE_FORMATS)
+		ifmt = 0;
+	pix->pixelformat = ov8810_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = pix->width*2;
+	pix->sizeimage = pix->bytesperline*pix->height;
+	pix->priv = 0;
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_SGRBG10:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		break;
+	}
+	return 0;
+}
+
+
+/*
+ * ioctl_s_fmt_cap - V4L2 sensor interface handler for VIDIOC_S_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_S_FMT ioctl structure
+ *
+ * If the requested format is supported, configures the HW to use that
+ * format, returns error code if format not supported or HW can't be
+ * correctly configured.
+ */
+ static int ioctl_s_fmt_cap(struct v4l2_int_device *s,
+				struct v4l2_format *f)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	int rval;
+
+	rval = ioctl_try_fmt_cap(s, f);
+	if (rval)
+		return rval;
+
+	sensor->pix = *pix;
+
+	return 0;
+}
+
+/*
+ * ioctl_g_fmt_cap - V4L2 sensor interface handler for ioctl_g_fmt_cap
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 v4l2_format structure
+ *
+ * Returns the sensor's current pixel format in the v4l2_format
+ * parameter.
+ */
+static int ioctl_g_fmt_cap(struct v4l2_int_device *s,
+				struct v4l2_format *f)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	f->fmt.pix = sensor->pix;
+
+	return 0;
+}
+
+/*
+ * ioctl_g_parm - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the sensor's video CAPTURE parameters.
+ */
+static int ioctl_g_parm(struct v4l2_int_device *s,
+			     struct v4l2_streamparm *a)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(a, 0, sizeof(*a));
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	cparm->capability = V4L2_CAP_TIMEPERFRAME;
+	cparm->timeperframe = sensor->timeperframe;
+
+	return 0;
+}
+
+/*
+ * ioctl_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the sensor to use the input parameters, if possible.  If
+ * not possible, reverts to the old parameters and returns the
+ * appropriate error code.
+ */
+static int ioctl_s_parm(struct v4l2_int_device *s,
+			     struct v4l2_streamparm *a)
+{
+	int rval = 0;
+	struct ov8810_sensor *sensor = s->priv;
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	struct v4l2_fract timeperframe_old;
+	int desired_fps;
+	timeperframe_old = sensor->timeperframe;
+	sensor->timeperframe = *timeperframe;
+
+	desired_fps = timeperframe->denominator / timeperframe->numerator;
+	if ((desired_fps < OV8810_MIN_FPS) || (desired_fps > OV8810_MAX_FPS)) {
+		sensor->timeperframe = timeperframe_old;
+		printk(KERN_ERR "OV8810: Error setting FPS=%d/%d, " \
+			"FPS must be between %d & %d,",
+			timeperframe->denominator, timeperframe->numerator,
+			OV8810_MIN_FPS, OV8810_MAX_FPS);
+		rval = -EINVAL;
+	} else {
+		DPRINTK_OV8810("Setting FPS=%d\n", desired_fps);
+		if ((current_power_state == V4L2_POWER_ON) ||
+				sensor->resuming) {
+			rval = ov8810_set_framerate(s, &sensor->timeperframe,
+				sensor->isize);
+		}
+	}
+
+	return rval;
+}
+
+/*
+ * ioctl_g_priv - V4L2 sensor interface handler for vidioc_int_g_priv_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: void pointer to hold sensor's private data address
+ *
+ * Returns device's (sensor's) private data area address in p parameter
+ */
+static int ioctl_g_priv(struct v4l2_int_device *s, void *p)
+{
+	struct ov8810_sensor *sensor = s->priv;
+
+	return sensor->pdata->priv_data_set(p);
+}
+
+/*
+ * ioctl_s_power - V4L2 sensor interface handler for vidioc_int_s_power_num
+ * @s: pointer to standard V4L2 device structure
+ * @on: power state to which device is to be set
+ *
+ * Sets devices power state to requrested state, if possible.
+ */
+ static int ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power on)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	struct i2c_client *c = sensor->i2c_client;
+	struct omap34xxcam_hw_config hw_config;
+	int rval;
+
+	rval = ioctl_g_priv(s, &hw_config);
+	if (rval) {
+		printk(KERN_ERR "OV8810: Unable to get hw params\n");
+		return rval;
+	}
+
+	if (on == V4L2_POWER_ON) {
+		isp_set_xclk(sensor->freq.xclk, OV8810_USE_XCLKA);
+	} else if (on == V4L2_POWER_OFF) {
+		isp_set_xclk(0, OV8810_USE_XCLKA);
+		sensor->streaming = false;
+		/* release resource lock */
+		sensor->pdata->lock_cpufreq(CPU_CLK_UNLOCK);
+	} else {
+		sensor->streaming = false;
+	}
+
+	rval = sensor->pdata->power_set(sensor->dev, c, on);
+	if (rval < 0) {
+		printk(KERN_ERR "OV8810: Unable to set the power state: "
+			OV8810_DRIVER_NAME " sensor\n");
+		isp_set_xclk(0, OV8810_USE_XCLKA);
+		return rval;
+	}
+
+	if ((current_power_state == V4L2_POWER_STANDBY) &&
+			(on == V4L2_POWER_ON) &&
+			(sensor->state == SENSOR_DETECTED)) {
+		sensor->resuming = true;
+		ov8810_configure(s);
+	}
+
+	if ((on == V4L2_POWER_ON) && (sensor->state == SENSOR_NOT_DETECTED)) {
+
+		rval = ov8810_detect(s);
+		if (rval < 0) {
+			printk(KERN_ERR "OV8810: Unable to detect "
+					OV8810_DRIVER_NAME " sensor\n");
+			sensor->state = SENSOR_NOT_DETECTED;
+			return rval;
+		}
+		sensor->state = SENSOR_DETECTED;
+		pr_info(OV8810_DRIVER_NAME " Chip version 0x%02x detected\n",
+			sensor->sensor_id.revision);
+	}
+
+	sensor->resuming = false;
+	current_power_state = on;
+	return 0;
+}
+
+/*
+ * ioctl_init - V4L2 sensor interface handler for VIDIOC_INT_INIT
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialize the sensor device (call ov8810_configure())
+ */
+static int ioctl_init(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_exit - V4L2 sensor interface handler for vidioc_int_dev_exit_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Delinitialise the dev. at slave detach.  The complement of ioctl_dev_init.
+ */
+static int ioctl_dev_exit(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_init - V4L2 sensor interface handler for vidioc_int_dev_init_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialise the device when slave attaches to the master.  Returns 0 if
+ * ov8810 device could be found, otherwise returns appropriate error.
+ */
+static int ioctl_dev_init(struct v4l2_int_device *s)
+{
+	struct ov8810_sensor *sensor = s->priv;
+	int err;
+
+	err = ov8810_detect(s);
+	if (err < 0) {
+		printk(KERN_ERR "OV8810: Unable to detect " OV8810_DRIVER_NAME
+			" sensor\n");
+		return err;
+	}
+
+	pr_info(OV8810_DRIVER_NAME " chip version 0x%02x detected\n",
+		sensor->sensor_id.revision);
+
+	return 0;
+}
+
+/**
+ * ioctl_enum_framesizes - V4L2 sensor if handler for vidioc_int_enum_framesizes
+ * @s: pointer to standard V4L2 device structure
+ * @frms: pointer to standard V4L2 framesizes enumeration structure
+ *
+ * Returns possible framesizes depending on choosen pixel format
+ **/
+static int ioctl_enum_framesizes(struct v4l2_int_device *s,
+					struct v4l2_frmsizeenum *frms)
+{
+	int ifmt;
+
+	for (ifmt = 0; ifmt < NUM_CAPTURE_FORMATS; ifmt++) {
+		if (frms->pixel_format == ov8810_formats[ifmt].pixelformat)
+			break;
+	}
+	/* Is requested pixelformat not found on sensor? */
+	if (ifmt == NUM_CAPTURE_FORMATS)
+		return -EINVAL;
+
+	/* Do we already reached all discrete framesizes? */
+	/* Filtering out resolution 2 in the table if the isp
+		LSC workaround is disable */
+	if (isp_lsc_workaround_enabled() == 0) {
+		if (frms->index >= OV_NUM_IMAGE_SIZES)
+			return -EINVAL;
+	} else {
+		if (frms->index >= (OV_NUM_IMAGE_SIZES - 1))
+			return -EINVAL;
+	}
+
+	frms->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+
+	if (isp_lsc_workaround_enabled() == 0) {
+		frms->discrete.width = ov8810_sizes[frms->index].width;
+		frms->discrete.height = ov8810_sizes[frms->index].height;
+   } else {
+		if (frms->index < 2) {
+			frms->discrete.width =
+				ov8810_sizes[frms->index].width;
+			frms->discrete.height =
+				ov8810_sizes[frms->index].height;
+		} else {
+			frms->discrete.width =
+				ov8810_sizes[frms->index + 1].width;
+			frms->discrete.height =
+				ov8810_sizes[frms->index + 1].height;
+		}
+	}
+
+	return 0;
+}
+
+const struct v4l2_fract ov8810_frameintervals[] = {
+	{ .numerator = 3, .denominator = 3 },   /* 0 */
+	{ .numerator = 3, .denominator = 6 },   /* 1 */
+	{ .numerator = 3, .denominator = 9 },   /* 2 */
+	{ .numerator = 3, .denominator = 12 },  /* 3 */
+	{ .numerator = 3, .denominator = 15 },  /* 4 */
+	{ .numerator = 3, .denominator = 18 },  /* 5 */
+	{ .numerator = 3, .denominator = 21 },  /* 6 */
+	{ .numerator = 3, .denominator = 24 },  /* 7- SIZE_8M max fps */
+	{ .numerator = 1, .denominator = 10 },  /* 8 */
+	{ .numerator = 1, .denominator = 15 },  /* 9 */
+	{ .numerator = 1, .denominator = 20 },  /* 10 */
+	{ .numerator = 1, .denominator = 21 },  /* 11 - SIZE_2M max fps */
+	{ .numerator = 1, .denominator = 25 },  /* 12 */
+	{ .numerator = 1, .denominator = 26 },  /* 13 - SIZE_1_5M max fps */
+	{ .numerator = 1, .denominator = 30 },  /* 14 - SIZE_500K &
+							SIZE_125K max fps */
+};
+
+static int ioctl_enum_frameintervals(struct v4l2_int_device *s,
+					struct v4l2_frmivalenum *frmi)
+{
+	int ifmt;
+
+	for (ifmt = 0; ifmt < NUM_CAPTURE_FORMATS; ifmt++) {
+		if (frmi->pixel_format == ov8810_formats[ifmt].pixelformat)
+			break;
+	}
+	/* Is requested pixelformat not found on sensor? */
+	if (ifmt == NUM_CAPTURE_FORMATS)
+		return -EINVAL;
+
+	/* Do we already reached all discrete framesizes? */
+
+	if ((frmi->width == ov8810_sizes[SIZE_8M].width) &&
+			(frmi->height == ov8810_sizes[SIZE_8M].height)) {
+		/* The max framerate supported by SIZE_8M capture is 7 fps
+		 */
+		if (frmi->index > 7)
+			return -EINVAL;
+
+	} else if ((frmi->width == ov8810_sizes[SIZE_2M].width) &&
+			(frmi->height == ov8810_sizes[SIZE_2M].height)) {
+		/* The max framerate supported by SIZE_2M capture 21 fps
+		 */
+		if (frmi->index > 11)
+			return -EINVAL;
+	} else if ((frmi->width == ov8810_sizes[SIZE_1_5M].width) &&
+			(frmi->height == ov8810_sizes[SIZE_1_5M].height)) {
+		/* The max framerate supported by SIZE_1_5M capture 26 fps
+		 */
+		if (frmi->index > 13)
+			return -EINVAL;
+	} else {
+		if (frmi->index > 14)
+			return -EINVAL;
+	}
+
+	frmi->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	frmi->discrete.numerator =
+				ov8810_frameintervals[frmi->index].numerator;
+	frmi->discrete.denominator =
+				ov8810_frameintervals[frmi->index].denominator;
+
+	return 0;
+}
+
+static struct v4l2_int_ioctl_desc ov8810_ioctl_desc[] = {
+	{vidioc_int_enum_framesizes_num,
+	  (v4l2_int_ioctl_func *)ioctl_enum_framesizes},
+	{vidioc_int_enum_frameintervals_num,
+	  (v4l2_int_ioctl_func *)ioctl_enum_frameintervals},
+	{vidioc_int_dev_init_num,
+	  (v4l2_int_ioctl_func *)ioctl_dev_init},
+	{vidioc_int_dev_exit_num,
+	  (v4l2_int_ioctl_func *)ioctl_dev_exit},
+	{vidioc_int_s_power_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_power},
+	{vidioc_int_g_priv_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_priv},
+	{vidioc_int_init_num,
+	  (v4l2_int_ioctl_func *)ioctl_init},
+	{vidioc_int_enum_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_enum_fmt_cap},
+	{vidioc_int_try_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_try_fmt_cap},
+	{vidioc_int_g_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_fmt_cap},
+	{vidioc_int_s_fmt_cap_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_fmt_cap},
+	{vidioc_int_g_parm_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_parm},
+	{vidioc_int_s_parm_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_parm},
+	{vidioc_int_queryctrl_num,
+	  (v4l2_int_ioctl_func *)ioctl_queryctrl},
+	{vidioc_int_g_ctrl_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_ctrl},
+	{vidioc_int_s_ctrl_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_ctrl},
+/*
+	{ vidioc_int_g_crop_num,
+	  (v4l2_int_ioctl_func *)ioctl_g_crop},
+	{vidioc_int_s_crop_num,
+	  (v4l2_int_ioctl_func *)ioctl_s_crop},
+	{ vidioc_int_cropcap_num,
+	  (v4l2_int_ioctl_func *)ioctl_cropcap},
+*/
+};
+
+static struct v4l2_int_slave ov8810_slave = {
+	.ioctls		= ov8810_ioctl_desc,
+	.num_ioctls	= ARRAY_SIZE(ov8810_ioctl_desc),
+};
+
+static struct v4l2_int_device ov8810_int_device = {
+	.module	= THIS_MODULE,
+	.name	= OV8810_DRIVER_NAME,
+	.priv	= &ov8810,
+	.type	= v4l2_int_type_slave,
+	.u	= {
+		.slave = &ov8810_slave,
+	},
+};
+
+int ov8810_strobe_manual_ready(void)
+{
+    return ov8810_write_regs(ov8810_i2c_client, ov8810_strobe_ready_reg);
+}
+
+
+/*
+ * ov8810_probe - sensor driver i2c probe handler
+ * @client: i2c driver client device structure
+ *
+ * Register sensor as an i2c client device and V4L2
+ * device.
+ */
+static int __init
+ov8810_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct ov8810_sensor *sensor = &ov8810;
+	int err;
+
+	if (i2c_get_clientdata(client))
+		return -EBUSY;
+
+	sensor->pdata = client->dev.platform_data;
+
+	if (!sensor->pdata) {
+		printk(KERN_ERR "OV8810: No platform data?\n");
+		return -ENODEV;
+	}
+
+	sensor->v4l2_int_device = &ov8810_int_device;
+	sensor->i2c_client = client;
+	sensor->dev = &client->dev;
+
+	i2c_set_clientdata(client, sensor);
+
+	/* Set sensor default values */
+	sensor->pix.width = ov8810_sizes[SIZE_500K].width;
+	sensor->pix.height = ov8810_sizes[SIZE_500K].height;
+	sensor->pix.pixelformat = V4L2_PIX_FMT_SGRBG10;
+
+	/* Set min/max limits */
+	sensor->exposure.min_exp_time = OV8810_MIN_EXPOSURE;
+	sensor->exposure.fps_max_exp_time = 33333;
+	sensor->exposure.abs_max_exp_time = OV8810_MAX_EXPOSURE;
+	sensor->exposure.min_linear_gain = OV8810_MIN_LINEAR_GAIN;
+	sensor->exposure.max_linear_gain = OV8810_MAX_LINEAR_GAIN;
+
+	err = v4l2_int_device_register(sensor->v4l2_int_device);
+	if (err)
+		i2c_set_clientdata(client, NULL);
+
+       ov8810_i2c_client = client;
+	return 0;
+}
+
+/*
+ * ov8810_remove - sensor driver i2c remove handler
+ * @client: i2c driver client device structure
+ *
+ * Unregister sensor as an i2c client device and V4L2
+ * device. Complement of ov8810_probe().
+ */
+static int __exit
+ov8810_remove(struct i2c_client *client)
+{
+	struct ov8810_sensor *sensor = i2c_get_clientdata(client);
+
+	if (!client->adapter)
+		return -ENODEV;	/* our client isn't attached */
+
+	v4l2_int_device_unregister(sensor->v4l2_int_device);
+	i2c_set_clientdata(client, NULL);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov8810_id[] = {
+	{ OV8810_DRIVER_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ov8810_id);
+
+static struct i2c_driver ov8810sensor_i2c_driver = {
+	.driver = {
+		.name	= OV8810_DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe	= ov8810_probe,
+	.remove	= __exit_p(ov8810_remove),
+	.id_table = ov8810_id,
+};
+
+/*
+ * ov8810sensor_init - sensor driver module_init handler
+ *
+ * Registers driver as an i2c client driver.  Returns 0 on success,
+ * error code otherwise.
+ */
+static int __init ov8810sensor_init(void)
+{
+	int err;
+
+	err = i2c_add_driver(&ov8810sensor_i2c_driver);
+	if (err) {
+		printk(KERN_ERR "OV8810: Failed to register" \
+			OV8810_DRIVER_NAME ".\n");
+		return err;
+	}
+	return 0;
+}
+late_initcall(ov8810sensor_init);
+
+/*
+ * ov8810sensor_cleanup - sensor driver module_exit handler
+ *
+ * Unregisters/deletes driver as an i2c client driver.
+ * Complement of ov8810sensor_init.
+ */
+static void __exit ov8810sensor_cleanup(void)
+{
+	i2c_del_driver(&ov8810sensor_i2c_driver);
+}
+module_exit(ov8810sensor_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("OV8810 camera sensor driver");
diff --git a/drivers/media/video/ov8810.h b/drivers/media/video/ov8810.h
new file mode 100644
index 0000000..40cc01b
--- /dev/null
+++ b/drivers/media/video/ov8810.h
@@ -0,0 +1,985 @@
+/*
+ * drivers/media/video/ov8810.h
+ *
+ * Register definitions for the OV8810 CameraChip.
+ *
+ * Author: Pallavi Kulkarni (ti.com)
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/* #if 0
+#define SENSOR_OV8810_DEBUG
+#endif */
+
+#ifdef SENSOR_OV8810_DEBUG
+#define DPRINTK_OV8810(format, ...)\
+	printk(KERN_INFO "OV8810: " format, ## __VA_ARGS__)
+#else
+#define DPRINTK_OV8810(format, ...)
+#endif
+
+#ifndef OV8810_H
+#define OV8810_H
+#define OV8810_I2C_ADDR		(0x6c >> 1)
+
+/* ISP uses a 10-bit value, OV8810 uses a 12-bit value */
+#define OV8810_BLACK_LEVEL_10BIT	8
+
+/* ISP Private IOCTLs */
+#define V4L2_CID_PRIVATE_SENSOR_REG_REQ		(V4L2_CID_PRIVATE_BASE + 20)
+#define V4L2_CID_PRIVATE_SENSOR_ID_REQ		(V4L2_CID_PRIVATE_BASE + 22)
+#define V4L2_CID_PRIVATE_COLOR_BAR     		(V4L2_CID_PRIVATE_BASE + 23)
+#define V4L2_CID_PRIVATE_FLASH_NEXT_FRAME	(V4L2_CID_PRIVATE_BASE + 24)
+#define V4L2_CID_PRIVATE_ORIENTATION     	(V4L2_CID_PRIVATE_BASE + 25)
+#define V4L2_CID_PRIVATE_LENS_CORRECTION     	(V4L2_CID_PRIVATE_BASE + 26)
+#define V4L2_CID_PRIVATE_SENSOR_PARAMS_REQ	(V4L2_CID_PRIVATE_BASE + 27)
+#define V4L2_CID_PRIVATE_START_MECH_SHUTTER_CAPTURE (V4L2_CID_PRIVATE_BASE + 28)
+#define V4L2_CID_PRIVATE_SHUTTER_PARAMS     	(V4L2_CID_PRIVATE_BASE + 29)
+
+/* Register initialization tables for ov8810 */
+/* Terminating list entry for reg */
+#define OV8810_REG_TERM		0xFFFF
+/* Terminating list entry for val */
+#define OV8810_VAL_TERM		0xFF
+
+#define OV8810_USE_XCLKA	0
+#define OV8810_USE_XCLKB	1
+
+#define OV8810_CSI2_VIRTUAL_ID	0x1
+
+#define DEBUG_BASE		0x08000000
+
+#define VAUX_2_8_V		0x09
+#define VAUX_1_8_V		0x05
+#define VAUX_DEV_GRP_P1	0x20
+#define VAUX_DEV_GRP_NONE	0x00
+
+/* Sensor specific GPIO signals */
+#define OV8810_RESET_GPIO	98
+#define OV8810_STANDBY_GPIO	64
+
+/* FPS Capabilities */
+#define OV8810_MIN_FPS			3
+#define OV8810_DEF_FPS			15
+#define OV8810_MAX_FPS			30
+
+/* Frame Delays */
+#define OV8810_GAIN_FRAME_DELAY 1
+#define OV8810_EXP_TIME_FRAME_DELAY 2
+
+#define SENSOR_DETECTED		1
+#define SENSOR_NOT_DETECTED	0
+
+/* XCLK Frequency in Hz*/
+#define OV8810_XCLK_MIN		27000000
+#define OV8810_XCLK_MAX		27000000
+
+#define OV8810_MAX_FRAME_LENGTH_LINES 0xFFF8
+#define OV8810_MAX_LINE_LENGTH_PCK 0xFFF0
+
+/* Gain Values (linear, Q8) */
+#define OV8810_MIN_LINEAR_GAIN	((u16)(1.0 * 256))
+#define OV8810_MAX_LINEAR_GAIN	((u16)(31.0 * 256))
+
+/* Exposure time values (usecs)*/
+#define OV8810_MIN_EXPOSURE	100
+#define OV8810_MAX_EXPOSURE	1000000
+
+
+/* Product ID */
+#define OV8810_PID			0x8810
+/* Max supported Rev */
+#define OV8810_REV			3
+
+/* ------------------ Register defines ------------------ */
+/*
+ * System Control Registers
+ */
+#define OV8810_AGCL				0x3000
+#define OV8810_AECL_H			0x3002
+#define OV8810_AECL_L			0x3003
+#define OV8810_PIDH				0x300A
+#define OV8810_PIDL				0x300B
+#define OV8810_R_PLL1			0x300E
+#define OV8810_R_PLL1_VT_SYS_DIV_SHIFT 4
+#define OV8810_R_PLL1_VT_SYS_DIV_MASK (0xF << \
+	OV8810_R_PLL1_VT_SYS_DIV_SHIFT)
+#define OV8810_R_PLL1_DIV8_MASK 	0x7
+#define OV8810_R_PLL2			0x300F
+#define OV8810_R_PLL2_OP_SYS_DIV_SHIFT 4
+#define OV8810_R_PLL2_OP_SYS_DIV_MASK (0xF << \
+	OV8810_R_PLL2_OP_SYS_DIV_SHIFT)
+#define OV8810_R_PLL2_OP_PIX_DIV_MASK 	0xF
+#define OV8810_R_PLL3			0x3010
+#define OV8810_R_PLL3_PLL_MULT_MASK 	0x7F
+#define OV8810_R_PLL4			0x3011
+#define OV8810_R_PLL4_PRE_DIV_MASK 		0xF
+
+#define OV8810_SYS				0x3012
+#define OV8810_ADDVS_H				0x301E
+#define OV8810_ADDVS_L				0x301F
+#define OV8810_FRM_LEN_LINES_H			0x3020
+#define OV8810_FRM_LEN_LINES_L			0x3021
+#define OV8810_LINE_LEN_PCK_H			0x3022
+#define OV8810_LINE_LEN_PCK_L			0x3023
+#define OV8810_X_ADDR_START_H			0x3024
+#define OV8810_X_ADDR_START_L			0x3025
+#define OV8810_Y_ADDR_START_H			0x3026
+#define OV8810_Y_ADDR_START_L			0x3027
+#define OV8810_X_ADDR_END_H			0x3028
+#define OV8810_X_ADDR_END_L			0x3029
+#define OV8810_Y_ADDR_END_H			0x302A
+#define OV8810_Y_ADDR_END_L			0x302B
+#define OV8810_X_OUTPUT_SIZE_H			0x302C
+#define OV8810_X_OUTPUT_SIZE_L			0x302D
+#define OV8810_Y_OUTPUT_SIZE_H			0x302E
+#define OV8810_Y_OUTPUT_SIZE_L			0x302F
+#define OV8810_RESERVED_3058			0x3058
+#define OV8810_IO_CTRL2				0x30B2
+#define OV8810_DSIO0				0x30B3
+#define OV8810_DSIO0_RPCLK_DIV_MASK 	0x3
+#define OV8810_FRS0				0x30B7
+#define OV8810_RESERVED_30E1			0x30E1
+#define OV8810_FRS1				0x30E4
+#define OV8810_FRS2				0x30E5
+#define OV8810_FRS3				0x30E6
+#define OV8810_FRS4				0x30E7
+#define OV8810_FRS4_STRB_SOURCE_SEL_SHIFT 1
+#define OV8810_FRS5				0x30E8
+#define OV8810_FRS5_ROLLING_SHUT_STRB_EN_SHIFT 7
+#define OV8810_FRS5_STRB_PLS_WIDTH_SHIFT 2
+#define OV8810_FRS5_STROBE_MODE_SHIFT 0
+#define OV8810_FRS6				0x30EA
+#define OV8810_FRS7				0x30EB
+#define OV8810_IMAGE_SYSTEM			0x30FA
+#define OV8810_IMAGE_TRANSFORM			0x30F8
+#define OV8810_IMAGE_TRANSFORM_HSUB_MASK (0x3)
+#define OV8810_IMAGE_TRANSFORM_VSUB_SHIFT 2
+#define OV8810_IMAGE_TRANSFORM_VSUB_MASK (0x3 << \
+	OV8810_IMAGE_TRANSFORM_VSUB_SHIFT)
+#define OV8810_IMAGE_TRANSFORM_HMIRROR_SHIFT 6
+#define OV8810_IMAGE_TRANSFORM_HMIRROR_MASK (0x1 << \
+	OV8810_IMAGE_TRANSFORM_HMIRROR_SHIFT)
+#define OV8810_IMAGE_TRANSFORM_VFLIP_SHIFT 7
+#define OV8810_IMAGE_TRANSFORM_VFLIP_MASK (0x1 << \
+	OV8810_IMAGE_TRANSFORM_VFLIP_SHIFT)
+#define OV8810_GROUP_WR			0x30FF
+#define OV8810_ISP_ENBL_0			0x3300
+#define OV8810_CBAR	 			0x3303
+#define OV8810_DIG_GAIN 			0x3309
+#define OV8810_SIZE_H0 				0x3316
+#define OV8810_LENC				0x33E4
+#define OV8810_DVP_CTRL08			0x3508
+#define OV8810_DVP_CTRL0E			0x350E
+
+/* len correction */
+#define LENC_1_1_DOWNSAMPLING 0x02
+#define LENC_2_1_DOWNSAMPLING 0x07
+#define LENC_4_1_DOWNSAMPLING 0x0b
+#define LENC_8_1_DOWNSAMPLING 0x0f
+
+/*
+ * END - System Control Registers
+ */
+
+
+/*
+ * OUT_TOP Registers
+ */
+
+#define OV8810_MIPI_CTRL01	0x3601
+
+#define OV8810_MIPI_CTRL02	0x3602
+#define OV8810_MIPI_CTRL02_VIRTUALCH_ID_MASK	(0x3 << 6)
+
+
+#define OV8810_MIPI_CTRL0A	0x360A
+#define OV8810_MIPI_CTRL0B	0x360B
+#define OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_2_MASK  0x1
+#define OV8810_MIPI_CTRL0B_DSBL_DATA_LANE_1_MASK  0x2
+
+#define OV8810_MIPI_CTRL14	0x3614
+#define OV8810_MIPI_CTRL14_MIN_HS_ZERO_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL14_MIN_HS_ZERO_NUI_MASK		(0x3F << \
+				OV8810_MIPI_CTRL14_MIN_HS_ZERO_NUI_SHIFT)
+#define OV8810_MIPI_CTRL14_MIN_HS_ZERO_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL15	0x3615
+#define OV8810_MIPI_CTRL15_MIN_HS_ZERO_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL16	0x3616
+#define OV8810_MIPI_CTRL16_MIN_HS_TRAIL_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL16_MIN_HS_TRAIL_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL16_MIN_HS_TRAIL_NUI_SHIFT)
+#define OV8810_MIPI_CTRL16_MIN_HS_TRAIL_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL17	0x3617
+#define OV8810_MIPI_CTRL17_MIN_HS_TRAIL_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL18	0x3618
+#define OV8810_MIPI_CTRL18_MIN_CLK_ZERO_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL18_MIN_CLK_ZERO_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL18_MIN_CLK_ZERO_NUI_SHIFT)
+#define OV8810_MIPI_CTRL18_MIN_CLK_ZERO_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL19	0x3619
+#define OV8810_MIPI_CTRL19_MIN_CLK_ZERO_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL1A	0x361A
+#define OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_NUI_MASK		(0x3F << \
+				OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL1A_MIN_CLK_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL1B	0x361B
+#define OV8810_MIPI_CTRL1B_MIN_CLK_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL1C	0x361C
+#define OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_NUI_MASK		(0x3F << \
+				OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL1C_MAX_CLK_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL1D	0x361D
+#define OV8810_MIPI_CTRL1D_MAX_CLK_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL1E	0x361E
+#define OV8810_MIPI_CTRL1E_MIN_CLK_POST_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL1E_MIN_CLK_POST_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL1E_MIN_CLK_POST_NUI_SHIFT)
+#define OV8810_MIPI_CTRL1E_MIN_CLK_POST_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL1F	0x361F
+#define OV8810_MIPI_CTRL1F_MIN_CLK_POST_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL20	0x3620
+#define OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_NUI_SHIFT)
+#define OV8810_MIPI_CTRL20_MIN_CLK_TRAIL_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL21	0x3621
+#define OV8810_MIPI_CTRL21_MIN_CLK_TRAIL_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL22	0x3622
+#define OV8810_MIPI_CTRL22_MIN_LPX_P_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL22_MIN_LPX_P_NUI_MASK	(0x3F << \
+					OV8810_MIPI_CTRL22_MIN_LPX_P_NUI_SHIFT)
+#define OV8810_MIPI_CTRL22_MIN_LPX_P_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL23	0x3623
+#define OV8810_MIPI_CTRL23_MIN_LPX_P_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL24	0x3624
+#define OV8810_MIPI_CTRL24_MIN_HS_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL24_MIN_HS_PREPARE_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL24_MIN_HS_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL24_MIN_HS_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL25	0x3625
+#define OV8810_MIPI_CTRL25_MIN_HS_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL26	0x3626
+#define OV8810_MIPI_CTRL26_MAX_HS_PREPARE_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL26_MAX_HS_PREPARE_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL26_MAX_HS_PREPARE_NUI_SHIFT)
+#define OV8810_MIPI_CTRL26_MAX_HS_PREPARE_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL27	0x3627
+#define OV8810_MIPI_CTRL27_MAX_HS_PREPARE_L_MASK	0xFF
+
+#define OV8810_MIPI_CTRL28	0x3628
+#define OV8810_MIPI_CTRL28_MIN_HS_EXIT_NUI_SHIFT	2
+#define OV8810_MIPI_CTRL28_MIN_HS_EXIT_NUI_MASK	(0x3F << \
+				OV8810_MIPI_CTRL28_MIN_HS_EXIT_NUI_SHIFT)
+#define OV8810_MIPI_CTRL28_MIN_HS_EXIT_H_MASK	0x3
+
+#define OV8810_MIPI_CTRL29	0x3629
+#define OV8810_MIPI_CTRL29_MIN_HS_EXIT_L_MASK	0xFF
+
+/*
+ * END - OUT_TOP Registers
+ */
+/* ------------------------------------------------------ */
+
+int ov8810_write_reg(struct i2c_client *client, u16 reg, u8 val);
+
+/* Exposure time values */
+#define DEF_MIN_EXPOSURE	250
+#define DEF_MAX_EXPOSURE	128000
+#define DEF_EXPOSURE	    33000
+#define EXPOSURE_STEP	    50
+
+#define DEF_LINEAR_GAIN	(2*256)
+#define LINEAR_GAIN_STEP	0x1
+
+struct ov8810_sensor_regif {
+	u16 len;
+	u32 addr;
+	u32 val;
+} ;
+
+enum ov8810_orientation {
+	OV8810_NO_HORZ_FLIP_OR_VERT_FLIP = 0,
+	OV8810_HORZ_FLIP_ONLY,
+	OV8810_VERT_FLIP_ONLY,
+	OV8810_HORZ_FLIP_AND_VERT_FLIP
+};
+
+enum ov8810_shutter_type {
+	ROLLING_SHUTTER_TYPE = 0,
+	MECH_SHUTTER_TYPE
+};
+
+enum ov8810_flash_type {
+	LED_FLASH_TYPE = 0,
+	XENON_FLASH_TYPE
+};
+
+/* define a structure for ov8810 register initialization values */
+struct ov8810_reg {
+	unsigned int reg;
+	unsigned char val;
+};
+
+struct capture_size_ov {
+	unsigned long width;
+	unsigned long height;
+};
+
+/*
+ * struct ov8810_clk_settings - struct for storage of sensor
+ * clock settings
+ * @pll_mult: pll multiplier
+ * @pll_pre_div: pre pll divider
+ * @vt_sys_div: video system clock divider
+ * @op_pix_div: output pixel clock divider
+ * @op_sys_div: output system clock divider
+ * @div8: pixel bit divider
+ * @rp_clk_div: video pixel clock divider
+ */
+struct ov8810_clk_settings {
+	u16 pll_mult;
+	u16 pll_pre_div;
+	u16 vt_sys_div;
+	u16 op_sys_div;
+	u16 op_pix_div;
+	u16 div8;
+	u16 rp_clk_div;
+};
+
+/*
+ * struct ov8810_frame_settings - struct for storage of sensor
+ * frame settings
+ * @frame_len_lines: number of lines in frame
+ * @line_len_pck: number of pixels in line
+ */
+struct ov8810_frame_settings {
+	u16	frame_len_lines_min;
+	u16	frame_len_lines;
+	u16	line_len_pck_min;
+	u16	line_len_pck;
+	u16	x_addr_start;
+	u16	x_addr_end;
+	u16	y_addr_start;
+	u16	y_addr_end;
+	u16	x_output_size;
+	u16	y_output_size;
+	u8 v_subsample;
+	u8 h_subsample;
+	struct v4l2_fract min_time_per_frame;
+};
+
+/*
+ * struct ov8810_mipi_settings - struct for storage of sensor
+ * initial exposure settings
+ * @coarse_int_tm: coarse resolution interval time (line times)
+ * @fine_int_tm: fine resolution interval time (pixel times)
+ */
+struct ov8810_mipi_settings {
+	u16	num_data_lanes;
+	u16	hs_settle_lower;
+	u16	hs_settle_upper;
+};
+
+/*
+ * struct ov8810_sensor_settings - struct for storage of
+ * sensor settings.
+ */
+struct ov8810_sensor_settings {
+	struct ov8810_clk_settings clk;
+	struct ov8810_frame_settings frame;
+	struct ov8810_mipi_settings mipi;
+};
+
+/* Array of image sizes supported by OV8810.  These must be ordered from
+ * smallest image size to largest.
+ */
+const static struct capture_size_ov ov8810_sizes[] = {
+	/* SIZE_125K */
+	{ 408, 306 },
+	/* SIZE_500K */
+	{ 816, 612 },
+	/* SIZE_1_5M */
+	{ 1632, 918 },
+	/* SIZE_2M */
+	{ 1632, 1224 },
+	/* SIZE_8M */
+	{ 3264, 2448 },
+};
+
+enum image_size_ov {
+	SIZE_125K,
+	SIZE_500K,
+	SIZE_1_5M,
+	SIZE_2M,
+	SIZE_8M
+};
+enum pixel_format_ov {
+	RAW10
+};
+
+#define OV_NUM_IMAGE_SIZES		5
+#define OV_NUM_PIXEL_FORMATS		1
+#define OV_NUM_FPS			3
+
+const static struct ov8810_reg ov8810_common[OV_NUM_IMAGE_SIZES][150] = {
+	/* SIZE_408x306_Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x02},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x07},	/* enable dig_gain & vario_pixel */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x02},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x02},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_816x612_Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x01},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x07},	/* enable dig_gain & vario_pixel */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x01},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x02},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_1632x918 Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x00},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x03}, /* enable dig_gain */
+		{0x3308, 0x3b}, /* set dig_gain manual mode */
+		{0x3309, 0x00}, /* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x02},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x04},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_1632x1224 Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x00},
+		{0x3058, 0x01},
+		{0x3071, 0x50},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x03},	/* enable dig_gain */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x02},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3072, 0x0d},
+		{0x3319, 0x04},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x309e, 0x09},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC off */
+		{0x3300, 0x81},	/* all ISP except BLC off */
+		{0x3320, 0xc2},	/* AWB use manual 1x gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+	/* SIZE_3264x2448 Default settings */
+	{
+		{0x3100, 0x06},
+		{0x30fa, 0x00},
+		{0x3302, 0x20},
+		{0x3099, 0x81},
+		{0x309d, 0x64},
+		{0x309e, 0x2d},
+		{0x3321, 0x02},
+		{0x3322, 0x04},
+		{0x3328, 0x40},
+		{0x3329, 0x00},
+		{0x3306, 0x00},
+		{0x3316, 0x03},
+		{0x33e5, 0x00},
+		{0x3058, 0x01},
+		{0x3071, 0x40},
+		{0x3300, 0xef},
+		{0x3334, 0x02},
+		{0x3331, 0x20},
+		{0x3332, 0x20},
+		{0x3301, 0x03},	/* enable dig_gain */
+		{0x3308, 0x3b},	/* set dig_gain manual mode */
+		{0x3309, 0x00},	/* set dig_gain = 1x */
+		{0x3082, 0x80},
+		{0x331e, 0x94},
+		{0x331f, 0x6e},
+		{0x331c, 0x28},
+		{0x331d, 0x21},
+		{0x3092, 0x00},
+		{0x30ab, 0x44},
+		{0x3095, 0x0a},
+		{0x308d, 0x00},
+		{0x3082, 0x00},
+		{0x3080, 0x40},
+		{0x309f, 0x23},	/* reset DSP */
+		{0x3084, 0x44},
+		{0x3016, 0x03},
+		{0x308a, 0x01},
+		{0x30e9, 0x09},
+		{0x3087, 0x41},
+		{0x3305, 0xa0},
+		{0x3072, 0x01},
+		{0x3319, 0x08},
+		{0x3300, 0xe3},
+		{0x309e, 0x1b},
+		{0x30e3, 0x0e},
+		{0x30f0, 0x00},
+		{0x30f2, 0x00},
+		{0x30f4, 0x90},
+		{0x3347, 0x00},
+		{0x3100, 0x88},
+		{0x3101, 0x77},
+		{0x3092, 0x00},
+		{0x30f0, 0x10},
+		{0x30f1, 0x56},
+		{0x30fb, 0x50},
+		{0x308d, 0x02},
+		{0x3090, 0x2e},
+		{0x3095, 0x0a},
+		{0x3071, 0x40},
+		{0x3013, 0x00},	/* AEC/AGC, off */
+		{0x3300, 0x83},	/* all, ISP, except BLC, off */
+		{0x3320, 0xc2},	/* AWB, use, manual, 1x, gain */
+		{0x30e7, 0x41},	/* active lo FREX */
+		{OV8810_REG_TERM, OV8810_VAL_TERM},
+	},
+};
+
+/* 50-60 Hz Detection settings */
+const static struct ov8810_reg ov8810_50_60_hz_detect_tbl[] = {
+	{0x3014, 0x40},
+	{0x304c, 0x0c},
+	{0x30a4, 0x00},
+	{0x30ad, 0x04},
+	{0x3040, 0x00},
+	{0x3041, 0x34},
+	{0x3044, 0x28},
+	{0x3045, 0x98},
+	{0x3046, 0x00},
+	{0x3047, 0x00},
+	{0x3048, 0x01},
+	{0x3049, 0xc2},
+	{0x304e, 0x02},
+	{0x304a, 0xaf},	/* 27Mhz */
+	{0x304b, 0xc8},	/* 27Mhz */
+	/* read 303d[0], 1=50hz, 0=60hz */
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+/* Lens correction settings */
+const static struct ov8810_reg len_correction_tbl[] = {
+	/* G */
+	{0x3358, 0x28},
+	{0x3359, 0x0d},
+	{0x335a, 0x0c},
+	{0x335b, 0x0a},
+	{0x335c, 0x0a},
+	{0x335d, 0x0b},
+	{0x335e, 0x0d},
+	{0x335f, 0x13},
+	{0x3360, 0x0d},
+	{0x3361, 0x0a},
+	{0x3362, 0x07},
+	{0x3363, 0x05},
+	{0x3364, 0x05},
+	{0x3365, 0x06},
+	{0x3366, 0x08},
+	{0x3367, 0x09},
+	{0x3368, 0x0b},
+	{0x3369, 0x06},
+	{0x336a, 0x03},
+	{0x336b, 0x02},
+	{0x336c, 0x01},
+	{0x336d, 0x02},
+	{0x336e, 0x04},
+	{0x336f, 0x06},
+	{0x3370, 0x08},
+	{0x3371, 0x04},
+	{0x3372, 0x01},
+	{0x3373, 0x00},
+	{0x3374, 0x00},
+	{0x3375, 0x00},
+	{0x3376, 0x02},
+	{0x3377, 0x04},
+	{0x3378, 0x08},
+	{0x3379, 0x04},
+	{0x337a, 0x01},
+	{0x337b, 0x00},
+	{0x337c, 0x00},
+	{0x337d, 0x00},
+	{0x337e, 0x03},
+	{0x337f, 0x04},
+	{0x3380, 0x0b},
+	{0x3381, 0x06},
+	{0x3382, 0x04},
+	{0x3383, 0x02},
+	{0x3384, 0x02},
+	{0x3385, 0x03},
+	{0x3386, 0x05},
+	{0x3387, 0x07},
+	{0x3388, 0x0f},
+	{0x3389, 0x0b},
+	{0x338a, 0x08},
+	{0x338b, 0x07},
+	{0x338c, 0x07},
+	{0x338d, 0x07},
+	{0x338e, 0x0a},
+	{0x338f, 0x0b},
+	{0x3390, 0x26},
+	{0x3391, 0x11},
+	{0x3392, 0x0e},
+	{0x3393, 0x0c},
+	{0x3394, 0x0b},
+	{0x3395, 0x0c},
+	{0x3396, 0x0e},
+	{0x3397, 0x11},
+
+	/* B */
+	{0x3398, 0x10},
+	{0x3399, 0x10},
+	{0x339a, 0x10},
+	{0x339b, 0x10},
+	{0x339c, 0x10},
+	{0x339d, 0x10},
+	{0x339e, 0x10},
+	{0x339f, 0x10},
+	{0x33a0, 0x10},
+	{0x33a1, 0x10},
+	{0x33a2, 0x10},
+	{0x33a3, 0x10},
+	{0x33a4, 0x10},
+	{0x33a5, 0x10},
+	{0x33a6, 0x10},
+	{0x33a7, 0x10},
+	{0x33a8, 0x10},
+	{0x33a9, 0x10},
+	{0x33aa, 0x10},
+	{0x33ab, 0x10},
+	{0x33ac, 0x10},
+	{0x33ad, 0x10},
+	{0x33ae, 0x10},
+	{0x33af, 0x10},
+	{0x33b0, 0x10},
+	{0x33b1, 0x10},
+	{0x33b2, 0x10},
+	{0x33b3, 0x10},
+	{0x33b4, 0x10},
+	{0x33b5, 0x10},
+	{0x33b6, 0x10},
+	{0x33b7, 0x10},
+	{0x33b8, 0x10},
+	{0x33b9, 0x10},
+	{0x33ba, 0x10},
+	{0x33bb, 0x10},
+
+	/* R */
+	{0x33bc, 0x10},
+	{0x33bd, 0x10},
+	{0x33be, 0x10},
+	{0x33bf, 0x10},
+	{0x33c0, 0x10},
+	{0x33c1, 0x10},
+	{0x33c2, 0x10},
+	{0x33c3, 0x10},
+	{0x33c4, 0x10},
+	{0x33c5, 0x10},
+	{0x33c6, 0x10},
+	{0x33c7, 0x10},
+	{0x33c8, 0x10},
+	{0x33c9, 0x10},
+	{0x33ca, 0x10},
+	{0x33cb, 0x10},
+	{0x33cc, 0x10},
+	{0x33cd, 0x10},
+	{0x33ce, 0x10},
+	{0x33cf, 0x10},
+	{0x33d0, 0x10},
+	{0x33d1, 0x10},
+	{0x33d2, 0x10},
+	{0x33d3, 0x10},
+	{0x33d4, 0x10},
+	{0x33d5, 0x10},
+	{0x33d6, 0x10},
+	{0x33d7, 0x10},
+	{0x33d8, 0x10},
+	{0x33d9, 0x10},
+	{0x33da, 0x10},
+	{0x33db, 0x10},
+	{0x33dc, 0x10},
+	{0x33dd, 0x10},
+	{0x33de, 0x10},
+	{0x33df, 0x10},
+	{0x3350, 0x06},
+	{0x3351, 0xab},
+	{0x3352, 0x05},
+	{0x3353, 0x00},
+	{0x3354, 0x04},
+	{0x3355, 0xf8},
+	{0x3356, 0x07},
+	{0x3357, 0x74},
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+const static struct ov8810_reg ov8810_common_csi2[] = {
+	{OV8810_MIPI_CTRL0B, 0x0f},  /* disable MIPI output (enabled later) */
+	{0x3601, 0x16},
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+const static struct ov8810_reg ov8810_mech_shutter[] = {
+	{0x30e1, 0xd0},	/* Set array reset control for frame mode */
+	{0x350e, 0x44},	/* Use sensor native vsync for frame mode */
+	{0x3058, 0x0c},	/* Set internal analog control for frame mode */
+	{OV8810_REG_TERM, OV8810_VAL_TERM},
+};
+
+struct ov8810_platform_data {
+	/* Set power state, zero is off, non-zero is on. */
+	int (*power_set)(struct device *dev, struct i2c_client *i2c_client,\
+				enum v4l2_power power);
+	/* Default registers written after power-on or reset. */
+	const struct ov8810_reg *default_regs;
+	int (*ifparm)(struct v4l2_ifparm *p);
+	int (*priv_data_set)(void *);
+	void (*lock_cpufreq)(int lock);	
+};
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+extern bool bd7885_device_detection(void);
+#endif
+
+#endif /* ifndef OV8810_H */
+
diff --git a/drivers/media/video/tda19989.c b/drivers/media/video/tda19989.c
new file mode 100644
index 0000000..0cf55b7
--- /dev/null
+++ b/drivers/media/video/tda19989.c
@@ -0,0 +1,489 @@
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/kmod.h>
+#include <linux/ioctl.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <mach/gpio.h>
+#include <linux/irq.h> 
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#if defined(CONFIG_MOT_FEAT_DEVICE_TREE)
+#include <mach/mot-gpio-omap.h>
+#endif
+#include "tda19989.h"
+
+#ifdef TDA19989_CEC_AVAILABLE
+#include <linux/regulator/consumer.h>
+#endif
+
+static dev_t tda19989_dev_num;
+static struct cdev tda19989_cdev;
+static struct class *tda19989_class;
+static int tda19989_major = -1;
+
+static struct i2c_client *tda19989_client=NULL;
+
+static int hdmi_int_enabled=0;
+static int hdmi_int_done=0;
+static int hdmi_sleep_on=0;
+wait_queue_head_t hdmi_int_wait;
+#ifdef TDA19989_CEC_AVAILABLE
+static struct  regulator *cec_regulator;
+#endif
+
+static irqreturn_t hdmi_int_irq(int irq, void *dev_inst)
+{
+    printk("hdmi_int_irq() pre state : %d \n", hdmi_sleep_on);
+    if(hdmi_sleep_on)
+    {
+        wake_up_interruptible(&hdmi_int_wait);
+        hdmi_sleep_on=0;
+    }
+    else
+    {
+        printk("hdmi_int_irq error !!! \n");
+    }
+
+    return IRQ_HANDLED;
+}
+
+static ssize_t tda19989_read(struct file *fp, char __user *buf, size_t count, loff_t *ppos)
+{
+    printk("Tda19989_read() pre state : %d \n", hdmi_sleep_on);
+
+    if(!hdmi_sleep_on)
+    {
+        printk("sleep ..... enter !!!!  \n");
+        hdmi_sleep_on=1;
+        interruptible_sleep_on(&hdmi_int_wait);
+        printk("sleep ..... exit !!!!  \n");
+    }
+    else
+    {
+        printk("tda19989_read error !!! \n");
+    }
+    return 0;
+}
+
+static ssize_t tda19989_write( struct file * file, const char __user * buf, size_t count, loff_t *ppos )
+{
+    printk("hdmi_write start \n");
+    return 0;
+}
+
+static int tda19989_open(struct inode * inode, struct file * filp)
+{
+    int ret;
+
+    printk("tda19989_open start \n");
+    init_waitqueue_head(&hdmi_int_wait);
+
+    ret=gpio_request(HDMI_PWR_EN_GPIO_NUM, "HDMI_PWR_EN");
+    if(ret<0)
+    {
+        printk("tda19989 GPIO Pwr On request error !!! \n");
+        return -1;
+    }
+    gpio_direction_output(HDMI_PWR_EN_GPIO_NUM, 0);
+
+    ret=gpio_request(HDMI_INT_PIN_GPIO_NUM, "HDMI_INT");
+    if(ret<0)
+    {
+        printk("tda19989 GPIO INT request error !!! \n");
+        gpio_free(HDMI_PWR_EN_GPIO_NUM);
+        return -1;
+    }
+#ifdef TDA19989_CEC_AVAILABLE
+    cec_regulator  = regulator_get(NULL, "vwlan2");
+    if (IS_ERR(cec_regulator)) {
+        printk("tda19989 failed to get regulator for HDMI");
+        return -ENODEV;
+    }
+    printk("pass 3 \n");
+    if (regulator_enable(cec_regulator) < 0)
+    {
+        printk("tda19989 Failed to enable regulator\n");
+        return -ENODEV;
+    }
+     printk("pass 4 \n");
+    regulator_set_voltage(cec_regulator,3300000,3300000);
+#endif
+
+    return 0;
+}
+
+static int tda19989_release(struct inode * inode, struct file * filp)
+{
+    printk("tda19989_release start \n");
+    return 0;
+}
+
+static int I2cTda19989_write(i2cKernelModeArg* pArg)
+{
+    u8 reg;
+    u8 length;
+    u8 *pData;
+    int retval=0;
+
+    reg = pArg->firstRegister;
+    length = pArg->lenData;
+    pData = &pArg->Data[0];
+
+    tda19989_client->addr=pArg->slaveAddr;
+    /*printk("[W] addr = %x, length = %d, pData = %d \n", tda19989_client->addr, length, *pData);*/
+    while(length--)
+    {
+        retval=i2c_smbus_write_byte_data(tda19989_client, reg, *pData);
+        if (retval != 0)
+        {
+            printk("I2cTda19989_write error [%d] \n", retval);
+            break;
+        }
+
+        reg++;
+        pData++;
+    }
+    return ((retval==0)?0:-1);
+}
+
+static int I2cTda19989_read(i2cKernelModeArg* pArg)
+{
+    u8 reg;
+    u8 length;
+    u8 *pData;
+
+    reg = pArg->firstRegister;
+    length = pArg->lenData;
+    pData = &pArg->Data[0];
+
+    tda19989_client->addr=pArg->slaveAddr;
+    /*printk("[R] addr = %x, length = %d, pData = %d \n", tda19989_client->addr, length, *pData);*/
+    while(length--)
+    {
+        *pData = (u8)i2c_smbus_read_byte_data(tda19989_client, reg);
+        reg++;
+        pData++;
+    }
+    return 0;
+}
+
+static int tda19989_ioctl(struct inode * inode, struct file *filp, u_int cmd, u_long arg)
+{
+    int result=0;
+
+    switch(cmd)
+    {
+        case HDMI_I2C_WRITE:
+        {
+            i2cKernelModeArg mArg;
+            if(copy_from_user((char*)&mArg, (char*)arg, sizeof(mArg)))
+            {
+                printk("tda19989 HDMI_I2C_WRITE copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }
+            result=I2cTda19989_write(&mArg);
+        }
+        break;
+
+        case HDMI_I2C_READ:
+        {
+            i2cKernelModeArg mArg;
+            if(copy_from_user((char*)&mArg, (char*)arg, sizeof(mArg)))
+            {
+                printk("tda19989 HDMI_I2C_READ copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }	
+            result=I2cTda19989_read(&mArg);
+            if(copy_to_user((char*)arg, (char*)&mArg, sizeof(mArg)))
+            {
+                printk("tda19989 HDMI_I2C_READ copy_to_user error \n");
+                result = -EFAULT;
+            }
+        }
+        break;
+
+        case HDMI_PWR_ONOFF:
+        {
+            int hdmi5VOn;
+            if (copy_from_user(&hdmi5VOn, (int*)arg, sizeof(hdmi5VOn)))
+            {
+                printk("tda19989 HDMI_5V_ENABLE copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }	
+            if(hdmi5VOn)
+                gpio_set_value(HDMI_PWR_EN_GPIO_NUM, 1);
+            else
+                gpio_set_value(HDMI_PWR_EN_GPIO_NUM, 0);
+        }
+        break;
+
+        case HDMI_INT_ENABLE:
+        {
+            int hdmiIntEn;
+            if (copy_from_user(&hdmiIntEn, (int*)arg, sizeof(hdmiIntEn)))
+            {
+                printk("tda19989 HDMI_INT_ENABLE copy_from_user error \n");
+                result = -EFAULT;
+                break;
+            }	
+
+            if(hdmiIntEn)
+            {
+                if(!hdmi_int_done)
+                {
+                    gpio_direction_input(HDMI_INT_PIN_GPIO_NUM);
+                    set_irq_type(gpio_to_irq(HDMI_INT_PIN_GPIO_NUM), IRQ_TYPE_EDGE_FALLING);
+                    result=request_irq(gpio_to_irq(HDMI_INT_PIN_GPIO_NUM), hdmi_int_irq,
+                                                  IRQF_TRIGGER_FALLING|IRQF_DISABLED, HDMI_TRNS_NAME, (void *)NULL);
+                    if(result)
+                    {
+                        printk(KERN_ERR "tda19989 request irq Error : %d\n", result);
+                        gpio_free(HDMI_INT_PIN_GPIO_NUM);
+                        return -1;
+                    }
+                    hdmi_int_done=1;
+                    hdmi_int_enabled=1;
+                }
+                else
+                {
+                    if(!hdmi_int_enabled)
+                    {
+                        enable_irq(OMAP_GPIO_IRQ(HDMI_INT_PIN_GPIO_NUM));
+                        hdmi_int_enabled=1;
+                    }
+                }
+            }
+            else
+            {
+                if(hdmi_int_enabled)
+                {
+                    disable_irq(OMAP_GPIO_IRQ(HDMI_INT_PIN_GPIO_NUM));
+                    hdmi_int_enabled=0;
+                }
+            }
+        }
+        break;
+
+#ifdef TDA19989_CEC_AVAILABLE
+        case HDMI_CEC_CAL_TIME:
+        {
+            int i;
+            struct timeval prevTime, curTime, resultTime;
+
+            gpio_direction_output(HDMI_INT_PIN_GPIO_NUM, 0);
+            gpio_set_value(HDMI_INT_PIN_GPIO_NUM, 0);
+
+            do_gettimeofday(&prevTime);
+            mdelay(9);
+            for(i=0; i<500; i++)
+            {
+                do_gettimeofday(&curTime);
+                resultTime.tv_usec=curTime.tv_usec-prevTime.tv_usec;
+                if(resultTime.tv_usec>9980) break;
+                udelay(2);
+            }
+
+            gpio_set_value(HDMI_INT_PIN_GPIO_NUM, 1);
+            do_gettimeofday(&curTime);
+
+            gpio_direction_output(HDMI_INT_PIN_GPIO_NUM, 1);
+
+            resultTime.tv_usec=curTime.tv_usec-prevTime.tv_usec;
+            printk("Time interval: %d\n", (int)resultTime.tv_usec);
+        }
+        break;
+#endif
+
+	 default:
+        break;
+    }
+
+    return result;
+}
+
+struct file_operations tda19989_fops =
+{
+    .owner = THIS_MODULE,
+    .read = tda19989_read,
+    .write = tda19989_write,
+    .open = tda19989_open,
+    .release = tda19989_release,
+    .ioctl = tda19989_ioctl,
+};
+
+static int i2cTda19989_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    printk("I2cTda19989_Probe \n");
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+    {
+        printk("tda19989 Can't support SMBUS \n");
+        return -ENODEV;
+    }	
+    tda19989_client = client;
+
+    return 0;
+}
+
+static int i2cTda19989_remove(struct i2c_client *client)
+{
+    printk("I2cTda19989_Remove \n");
+    return 0;
+}
+
+static const struct i2c_device_id tda19989_id[] = {
+	{ HDMI_TRNS_NAME, 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(i2c, tda19989_id);
+
+static struct i2c_driver i2c_driver_tda19989 = 
+{
+    .driver =
+    {
+        .name = HDMI_TRNS_NAME,
+        .owner = THIS_MODULE,
+    },
+    .probe = i2cTda19989_probe,
+    .remove = __devexit_p(i2cTda19989_remove),
+    .id_table = tda19989_id,
+};
+
+static int tda19989_probe(struct platform_device *p_dev)
+{
+    printk("tda19989_probe \n");
+    return 0;
+}
+
+static int tda19989_remove(struct platform_device *p_dev)
+{
+    printk("tda19989_remove  \n");
+    return 0;
+}
+
+#if defined(CONFIG_PM)
+static int tda19989_suspend(struct platform_device* p_dev, pm_message_t event)
+{
+    printk("tda19989_suspend  \n");
+    /*need to check how to control tda19989 power state*/
+    return 0;
+}
+
+static int tda19989_resume(struct platform_device *p_dev)
+{
+    printk("tda19989_resume  \n");
+    /*need to check how to control tda19989 power state*/
+    return 0;
+}
+#endif
+
+static struct platform_driver tda19989_driver =
+{
+	.probe		= tda19989_probe,
+	.remove		= tda19989_remove,
+#if defined(CONFIG_PM)
+	.suspend		= tda19989_suspend,
+	.resume		= tda19989_resume,
+#endif
+	.driver		= {
+		.name	= HDMI_TRNS_NAME,
+		.owner	= THIS_MODULE,	
+	},
+};
+
+static struct platform_device tda19989_device = {
+	.name			= HDMI_TRNS_NAME,
+};
+
+static int __init hdmiTda19989_init (void)
+{
+    int ret;
+
+    ret = i2c_add_driver(&i2c_driver_tda19989);
+    if(ret){
+        printk("tda19989 : i2c add driver fail : err = %d\n", ret);		
+        return ret;
+    }
+
+    ret=alloc_chrdev_region(&tda19989_dev_num, 0, 1, HDMI_TRNS_NAME);
+    if(ret){
+        printk("tda19989 : alloc_chrdev_region failed: err = %d\n", ret);		
+        return ret;
+    }
+
+    cdev_init(&tda19989_cdev, &tda19989_fops);
+    tda19989_cdev.owner = THIS_MODULE;
+    ret=cdev_add(&tda19989_cdev, tda19989_dev_num, 1);
+    if(ret){
+        printk("tda19989 : add cdev failed: err = %d\n", ret);			
+        goto exit_err1;
+    }
+    tda19989_major = MAJOR(tda19989_dev_num);
+
+    ret=platform_driver_register(&tda19989_driver);
+    if(ret){
+        printk("can't register tda19989_driver driver\n");
+        goto exit_err2;
+    }
+	
+    ret=platform_device_register(&tda19989_device);
+    if(ret){
+        printk("can't register tda19989_driver device\n"); 
+        goto exit_err3;
+    }
+
+    tda19989_class=class_create(THIS_MODULE, HDMI_TRNS_NAME);
+    if(!tda19989_class){
+        printk("can't create tda19989 class \n"); 
+        goto exit_err4;			
+    }
+
+    device_create(tda19989_class, NULL, tda19989_dev_num, NULL, HDMI_TRNS_NAME);
+
+    return 0;
+
+exit_err4:
+	platform_device_unregister(&tda19989_device);
+exit_err3:
+	platform_driver_unregister(&tda19989_driver);
+exit_err2:
+   cdev_del(&tda19989_cdev);  
+exit_err1 :
+    unregister_chrdev_region(tda19989_dev_num, 1);
+
+    return ret;
+
+}
+
+static void __exit hdmiTda19989_exit (void)
+{
+    i2c_del_driver(&i2c_driver_tda19989);
+    device_destroy(tda19989_class, tda19989_dev_num);
+    class_destroy(tda19989_class);
+    platform_device_unregister(&tda19989_device);
+    platform_driver_unregister(&tda19989_driver);	
+    cdev_del(&tda19989_cdev);	
+    unregister_chrdev_region(tda19989_dev_num, 1);
+}
+
+module_init(hdmiTda19989_init);
+module_exit(hdmiTda19989_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/tda19989.h b/drivers/media/video/tda19989.h
new file mode 100644
index 0000000..3b50be6
--- /dev/null
+++ b/drivers/media/video/tda19989.h
@@ -0,0 +1,30 @@
+#ifndef __INCLUDED_TDA19989__
+#define __INCLUDED_TDA19989__
+
+#include <linux/types.h>
+
+/*#define TDA19989_CEC_AVAILABLE*/
+
+#define HDMI_I2C_WRITE		0
+#define HDMI_I2C_READ		1
+#define HDMI_PWR_ONOFF	2
+#define HDMI_INT_ENABLE	3
+#ifdef TDA19989_CEC_AVAILABLE
+#define HDMI_CEC_CAL_TIME	4
+#endif
+
+#define HDMI_TRNS_NAME  "tda19989"
+
+#define HDMI_INT_PIN_GPIO_NUM 25
+#define HDMI_PWR_EN_GPIO_NUM 26
+
+typedef struct _i2cKernelModeArg
+{
+    u8 slaveAddr;
+    u8 firstRegister;
+    u8 lenData;
+    u8 Data[128];
+} i2cKernelModeArg;
+
+#endif
+
diff --git a/drivers/media/video/videobuf-core.c b/drivers/media/video/videobuf-core.c
index b7b0584..efbe9f9 100644
--- a/drivers/media/video/videobuf-core.c
+++ b/drivers/media/video/videobuf-core.c
@@ -667,6 +667,7 @@ int videobuf_dqbuf(struct videobuf_queue *q,
 		buf->state = VIDEOBUF_IDLE;
 		break;
 	case VIDEOBUF_DONE:
+	case VIDEOBUF_IDLE:
 		dprintk(1, "dqbuf: state is done\n");
 		CALL(q, sync, q, buf);
 		buf->state = VIDEOBUF_IDLE;
diff --git a/drivers/mfd/cpcap-3mm5.c b/drivers/mfd/cpcap-3mm5.c
index 6579a4d..9d53634 100644
--- a/drivers/mfd/cpcap-3mm5.c
+++ b/drivers/mfd/cpcap-3mm5.c
@@ -88,6 +88,7 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 {
 	struct cpcap_3mm5_data *data_3mm5 = data;
 	int new_state = NO_DEVICE;
+	int cpcap_status_gpio_2, cpcap_status_gpio_4;
 
 	if (irq != CPCAP_IRQ_HS)
 		return;
@@ -109,13 +110,23 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_HS);
 
 		send_key_event(data_3mm5, 0);
+		cpcap_uc_stop(data_3mm5->cpcap, CPCAP_MACRO_5);
 	} else {
+		cpcap_status_gpio_2 = cpcap_regacc_write(data_3mm5->cpcap,
+                        CPCAP_REG_GPIO2, 0,
+                        CPCAP_BIT_GPIO2DRV);
+
+                cpcap_status_gpio_4 = cpcap_regacc_write(data_3mm5->cpcap,
+                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4DRV,
+                        CPCAP_BIT_GPIO4DRV);
+		if ((cpcap_status_gpio_2 < 0) || (cpcap_status_gpio_4 < 0)) {
+                	pr_err("Cpcap TV_out: %s: "
+                                "Control Analog Switch failed: \n", __func__);
+        	}
+		
 		cpcap_regacc_write(data_3mm5->cpcap, CPCAP_REG_TXI,
 				   (CPCAP_BIT_MB_ON2 | CPCAP_BIT_PTT_CMP_EN),
 				   (CPCAP_BIT_MB_ON2 | CPCAP_BIT_PTT_CMP_EN));
-		cpcap_regacc_write(data_3mm5->cpcap, CPCAP_REG_RXOA,
-				   CPCAP_BIT_ST_HS_CP_EN,
-				   CPCAP_BIT_ST_HS_CP_EN);
 		audio_low_power_clear(data_3mm5);
 
 		/* Give PTTS time to settle */
@@ -134,6 +145,9 @@ static void hs_handler(enum cpcap_irqs irq, void *data)
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_HS);
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_MB2);
 		cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_UC_PRIMACRO_5);
+
+		cpcap_uc_start(data_3mm5->cpcap, CPCAP_MACRO_5);
+                cpcap_uc_start(data_3mm5->cpcap, CPCAP_MACRO_4);
 	}
 
 	switch_set_state(&data_3mm5->sdev, new_state);
@@ -175,6 +189,51 @@ static void key_handler(enum cpcap_irqs irq, void *data)
 	cpcap_irq_unmask(data_3mm5->cpcap, CPCAP_IRQ_UC_PRIMACRO_5);
 }
 
+static int init_analog_switch(struct cpcap_3mm5_data *data)
+{
+        int cpcap_status = 0;
+        struct cpcap_3mm5_data *data_3mm5 = data;
+
+        /* set vlev = 2.775V for GPIO 2 */
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO2, CPCAP_BIT_GPIO2VLEV,
+                                        CPCAP_BIT_GPIO2VLEV);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO2 VLEV failed: \n", __func__);
+                return cpcap_status;
+        }
+
+        /* set vlev = 2.775V for GPIO 4 */
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4VLEV,
+                                        CPCAP_BIT_GPIO4VLEV);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO4 VLEV failed: \n", __func__);
+                return cpcap_status;
+        }
+
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO2, CPCAP_BIT_GPIO2DIR,
+                                        CPCAP_BIT_GPIO2DIR);
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO2 failed: \n", __func__);
+                return cpcap_status;
+        }
+        cpcap_status = cpcap_regacc_write(data_3mm5->cpcap,
+                                        CPCAP_REG_GPIO4, CPCAP_BIT_GPIO4DIR,
+                                        CPCAP_BIT_GPIO4DIR);
+
+        if (cpcap_status < 0) {
+                pr_err("Cpcap TV_out: %s: "
+                                "Configuring GPIO4 failed: \n", __func__);
+                return cpcap_status;
+        }
+        return 0;
+}
+
 static int __init cpcap_3mm5_probe(struct platform_device *pdev)
 {
 	int retval = 0;
@@ -195,7 +254,10 @@ static int __init cpcap_3mm5_probe(struct platform_device *pdev)
 	data->sdev.print_name = print_name;
 	switch_dev_register(&data->sdev);
 	platform_set_drvdata(pdev, data);
-
+	retval = init_analog_switch(data);
+        if (retval < 0)
+              return retval;
+	
 	data->regulator = regulator_get(NULL, "vaudio");
 	if (IS_ERR(data->regulator)) {
 		dev_err(&pdev->dev, "Could not get regulator for cpcap_3mm5\n");
diff --git a/drivers/mfd/cpcap-adc.c b/drivers/mfd/cpcap-adc.c
index 4ec653d..98b5f3c 100644
--- a/drivers/mfd/cpcap-adc.c
+++ b/drivers/mfd/cpcap-adc.c
@@ -441,6 +441,27 @@ static void adc_convert(struct cpcap_adc_request *req, int index)
 		req->result[index] = convert_to_kelvins(req->result[tbl_index]);
 }
 
+static void adc_raw(struct cpcap_adc_request *req, int index)
+{
+	struct conversion_tbl *conv_tbl = bank0_conversion;
+	struct phasing_tbl *phase_tbl = bank0_phasing;
+	int tbl_index = index;
+
+	if (req->type == CPCAP_ADC_TYPE_BANK_1)
+		return;
+
+	if (req->type == CPCAP_ADC_TYPE_BATT_PI)
+		tbl_index = (tbl_index % 2) ? CPCAP_ADC_BATTI_ADC :
+			    CPCAP_ADC_BATTP;
+
+	req->result[index] += conv_tbl[tbl_index].align_offset;
+
+	if (req->result[index] < phase_tbl[tbl_index].min)
+		req->result[index] = phase_tbl[tbl_index].min;
+	else if (req->result[index] > phase_tbl[tbl_index].max)
+		req->result[index] = phase_tbl[tbl_index].max;
+}
+
 static void adc_result(struct cpcap_device *cpcap,
 		       struct cpcap_adc_request *req)
 {
@@ -463,6 +484,9 @@ static void adc_result(struct cpcap_device *cpcap,
 			break;
 
 		case CPCAP_ADC_FORMAT_RAW:
+			adc_raw(req, j);
+			break;
+
 		default:
 			break;
 		}
@@ -544,6 +568,7 @@ static void cpcap_adc_cancel(struct work_struct *work)
 static int __devinit cpcap_adc_probe(struct platform_device *pdev)
 {
 	struct cpcap_adc *adc;
+	unsigned short cal_data;
 
 	if (pdev->dev.platform_data == NULL) {
 		dev_err(&pdev->dev, "no platform_data\n");
@@ -564,9 +589,14 @@ static int __devinit cpcap_adc_probe(struct platform_device *pdev)
 	adc_setup_calibrate(adc->cpcap, CPCAP_ADC_CHG_ISENSE);
 	adc_setup_calibrate(adc->cpcap, CPCAP_ADC_BATTI_ADC);
 
-	cpcap_regacc_write(adc->cpcap, CPCAP_REG_ADCC2,
-			   CPCAP_BIT_CAL_FACTOR_ENABLE,
-			   CPCAP_BIT_CAL_FACTOR_ENABLE);
+	cal_data = 0;
+	cpcap_regacc_read(adc->cpcap, CPCAP_REG_ADCAL1, &cal_data);
+	bank0_conversion[CPCAP_ADC_CHG_ISENSE].align_offset =
+		((short)cal_data * -1);
+	cal_data = 0;
+	cpcap_regacc_read(adc->cpcap, CPCAP_REG_ADCAL2, &cal_data);
+	bank0_conversion[CPCAP_ADC_BATTI_ADC].align_offset =
+		((short)cal_data * -1);
 
 	INIT_DELAYED_WORK(&adc->work, cpcap_adc_cancel);
 
diff --git a/drivers/mfd/cpcap-core.c b/drivers/mfd/cpcap-core.c
index 1c83551..417cf85 100644
--- a/drivers/mfd/cpcap-core.c
+++ b/drivers/mfd/cpcap-core.c
@@ -28,6 +28,7 @@
 #include <linux/reboot.h>
 #include <linux/notifier.h>
 #include <linux/delay.h>
+#include <asm/bootinfo.h>
 
 static int ioctl(struct inode *inode,
 		 struct file *file, unsigned int cmd, unsigned long arg);
@@ -146,6 +147,16 @@ static struct platform_device cpcap_rtc_device = {
 	.dev.platform_data = NULL,
 };
 
+#ifdef CONFIG_LEDS_AF_LED
+struct platform_device cpcap_af_led = {
+	.name		= LD_AF_LED_DEV,
+	.id		= -1,
+	.dev		= {
+		.platform_data  = NULL,
+	},
+};
+#endif
+
 static struct platform_device *cpcap_devices[] = {
 	&cpcap_adc_device,
 	&cpcap_key_device,
@@ -164,6 +175,9 @@ static struct platform_device *cpcap_devices[] = {
 	&cpcap_3mm5_device,
 	&cpcap_rtc_device,
 	&cpcap_uc_device,
+#ifdef CONFIG_LEDS_AF_LED
+	&cpcap_af_led,
+#endif
 };
 
 static struct cpcap_device *misc_cpcap;
@@ -186,13 +200,25 @@ static int cpcap_reboot(struct notifier_block *this, unsigned long code,
 	}
 
 	if (code == SYS_RESTART) {
-		/* Set the soft reset bit in the cpcap */
-		ret = cpcap_regacc_write(misc_cpcap, CPCAP_REG_VAL1,
-				CPCAP_BIT_SOFT_RESET, CPCAP_BIT_SOFT_RESET);
-		if (ret) {
-			dev_err(&(misc_cpcap->spi->dev),
-				"SW Reset cpcap set failure.\n");
-			result = NOTIFY_BAD;
+		if (mode != NULL && !strncmp("outofcharge", mode, 12)) {
+			/* Set the outofcharge bit in the cpcap */
+			ret = cpcap_regacc_write(misc_cpcap, CPCAP_REG_VAL1,
+				CPCAP_BIT_OUT_CHARGE_ONLY,
+				CPCAP_BIT_OUT_CHARGE_ONLY);
+			if (ret) {
+				dev_err(&(misc_cpcap->spi->dev),
+					"outofcharge cpcap set failure.\n");
+				result = NOTIFY_BAD;
+			}
+			/* Set the soft reset bit in the cpcap */
+			cpcap_regacc_write(misc_cpcap, CPCAP_REG_VAL1,
+				CPCAP_BIT_SOFT_RESET,
+				CPCAP_BIT_SOFT_RESET);
+			if (ret) {
+				dev_err(&(misc_cpcap->spi->dev),
+					"reset cpcap set failure.\n");
+				result = NOTIFY_BAD;
+			}
 		}
 
 		/* Check if we are starting recovery mode */
@@ -228,6 +254,15 @@ static int cpcap_reboot(struct notifier_block *this, unsigned long code,
 		}
 		cpcap_regacc_write(misc_cpcap, CPCAP_REG_MI2, 0, 0xFFFF);
 	} else {
+		ret = cpcap_regacc_write(misc_cpcap, CPCAP_REG_VAL1,
+					 0,
+					 CPCAP_BIT_OUT_CHARGE_ONLY);
+		if (ret) {
+			dev_err(&(misc_cpcap->spi->dev),
+				"outofcharge cpcap set failure.\n");
+			result = NOTIFY_BAD;
+		}
+
 		/* Clear the soft reset bit in the cpcap */
 		ret = cpcap_regacc_write(misc_cpcap, CPCAP_REG_VAL1, 0,
 					CPCAP_BIT_SOFT_RESET);
@@ -324,10 +359,16 @@ static int __devinit cpcap_probe(struct spi_device *spi)
 	if (retval < 0)
 		goto free_cpcap_irq;
 
-	/* Set Kpanic bit, which will be cleared at normal reboot */
-	cpcap_regacc_write(cpcap, CPCAP_REG_VAL1,
+	if (bi_powerup_reason() != PU_REASON_CHARGER) {
+		/* Set Kpanic bit, which will be cleared at normal reboot */
+		cpcap_regacc_write(cpcap, CPCAP_REG_VAL1,
 			CPCAP_BIT_AP_KERNEL_PANIC, CPCAP_BIT_AP_KERNEL_PANIC);
 
+	/* Set the soft reset bit in the cpcap */
+	cpcap_regacc_write(misc_cpcap, CPCAP_REG_VAL1,
+			CPCAP_BIT_SOFT_RESET, CPCAP_BIT_SOFT_RESET);
+	}
+
 	cpcap_vendor_read(cpcap);
 
 	for (i = 0; i < ARRAY_SIZE(cpcap_devices); i++)
@@ -462,6 +503,18 @@ static int adc_ioctl(unsigned int cmd, unsigned long arg)
 	return retval;
 }
 
+#if defined(CONFIG_LEDS_FLASH_RESET)
+int cpcap_direct_misc_write(unsigned short reg, unsigned short value,\
+						unsigned short mask)
+{
+	int retval = -EINVAL;
+
+	retval = cpcap_regacc_write(misc_cpcap, reg, value, mask);
+
+	return retval;
+}
+#endif
+
 static int ioctl(struct inode *inode,
 		 struct file *file, unsigned int cmd, unsigned long arg)
 {
diff --git a/drivers/mfd/cpcap-regacc.c b/drivers/mfd/cpcap-regacc.c
index 3ef0376..d06cfb3 100644
--- a/drivers/mfd/cpcap-regacc.c
+++ b/drivers/mfd/cpcap-regacc.c
@@ -117,7 +117,7 @@ static const struct {
 	[CPCAP_REG_VHVIOC]    = {401, 0xFFE8, 0xFFFF},
 	[CPCAP_REG_VSDIOC]    = {402, 0xFF40, 0xFFFF},
 	[CPCAP_REG_VPLLC]     = {403, 0xFFA4, 0xFFFF},
-	[CPCAP_REG_VRF1C]     = {404, 0xFF52, 0xFFFF},
+	[CPCAP_REG_VRF1C]     = {404, 0xFF50, 0xFFFF},
 	[CPCAP_REG_VRF2C]     = {405, 0xFFD4, 0xFFFF},
 	[CPCAP_REG_VRFREFC]   = {406, 0xFFD4, 0xFFFF},
 	[CPCAP_REG_VWLAN1C]   = {407, 0xFFA8, 0xFFFF},
@@ -244,6 +244,11 @@ static const struct {
 	[CPCAP_REG_LMACE]     = {1183, 0xFFF8, 0xFFFF},
 };
 
+#ifdef CPCAP_AUDIO_REG_DEBUG
+static unsigned short
+CPCAP_AUD_CACHE[CPCAP_REG_LVAB-CPCAP_REG_VAUDIOC+1] = { 0 };
+#endif
+
 static int cpcap_spi_access(struct spi_device *spi, u8 *buf,
 			    size_t len)
 {
@@ -348,6 +353,13 @@ int cpcap_regacc_write(struct cpcap_device *cpcap,
 		old_value &= register_info_tbl[reg].rbw_mask;
 		old_value &= ~mask;
 		value |= old_value;
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+		if (reg >= CPCAP_REG_VAUDIOC && reg <= CPCAP_REG_LVAB)
+			CPCAP_AUD_CACHE[reg - CPCAP_REG_VAUDIOC] =
+					value & register_info_tbl[reg].rbw_mask;
+#endif
+
 		retval = cpcap_config_for_write(spi,
 						register_info_tbl[reg].address,
 						value);
@@ -381,3 +393,21 @@ int cpcap_regacc_init(struct cpcap_device *cpcap)
 
 	return retval;
 }
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+void cpcap_regacc_audio_reg_dump(void)
+{
+  printk(KERN_INFO
+	"CPCAP_aud:V:%04X C:%04X,%04X S:%04X,%04X In:%04X,%04X Out:%04X,%04X ",
+	CPCAP_AUD_CACHE[0], CPCAP_AUD_CACHE[1], CPCAP_AUD_CACHE[2],
+	CPCAP_AUD_CACHE[3], CPCAP_AUD_CACHE[4], CPCAP_AUD_CACHE[5],
+	CPCAP_AUD_CACHE[6], CPCAP_AUD_CACHE[7], CPCAP_AUD_CACHE[8]
+	);
+  printk(KERN_INFO
+	"Sw:%04X,%04X,%04X  %04X %04X %04X %04X %04X %04X\n",
+	CPCAP_AUD_CACHE[9], CPCAP_AUD_CACHE[10], CPCAP_AUD_CACHE[11],
+	CPCAP_AUD_CACHE[12], CPCAP_AUD_CACHE[13], CPCAP_AUD_CACHE[14],
+	CPCAP_AUD_CACHE[15], CPCAP_AUD_CACHE[16], CPCAP_AUD_CACHE[17]
+	);
+}
+#endif
diff --git a/drivers/mfd/cpcap-uc.c b/drivers/mfd/cpcap-uc.c
index f7038a1..c027a36 100644
--- a/drivers/mfd/cpcap-uc.c
+++ b/drivers/mfd/cpcap-uc.c
@@ -18,7 +18,9 @@
 
 #include <linux/completion.h>
 #include <linux/errno.h>
+#include <linux/firmware.h>
 #include <linux/fs.h>
+#include <linux/ihex.h>
 #include <linux/miscdevice.h>
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
@@ -567,6 +569,62 @@ unsigned char cpcap_uc_status(struct cpcap_device *cpcap,
 }
 EXPORT_SYMBOL_GPL(cpcap_uc_status);
 
+static int fw_load(struct cpcap_uc_data *uc_data, struct device *dev)
+{
+	int err;
+	const struct ihex_binrec *rec;
+	const struct firmware *fw;
+	unsigned short *buf;
+	int i;
+	unsigned short num_words;
+
+	if (!uc_data || !dev)
+		return -EINVAL;
+
+	err = request_ihex_firmware(&fw, "cpcap/firmware_1_2x.fw", dev);
+	if (err) {
+		dev_err(dev, "Failed to load \"cpcap/firmware_1_2x.fw\": %d\n",
+		       err);
+		return err;
+	}
+
+	for (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {
+		num_words = be16_to_cpu(rec->len) >> 1;
+		dev_info(dev, "Loading %d word(s) at 0x%04x\n",
+			 num_words, be32_to_cpu(rec->addr));
+
+		buf = kmalloc(be16_to_cpu(rec->len), GFP_KERNEL);
+		if (buf) {
+			for (i = 0; i < num_words; i++)
+				buf[i] = be16_to_cpu(((uint16_t *)rec->data)[i]);
+
+			err = ram_write(uc_data, be32_to_cpu(rec->addr),
+					num_words, buf);
+			kfree(buf);
+
+			if (err) {
+				dev_err(dev, "RAM write failed: %d\n", err);
+				break;
+			}
+		} else {
+			err = -ENOMEM;
+			dev_err(dev, "RAM write failed: %d\n", err);
+			break;
+		}
+	}
+
+	release_firmware(fw);
+
+	if (!err) {
+		uc_data->is_ready = 1;
+
+		err = cpcap_uc_start(uc_data->cpcap, CPCAP_MACRO_4);
+		dev_info(dev, "Started macro 4: %d\n", err);
+	}
+
+	return err;
+}
+
 static int cpcap_uc_probe(struct platform_device *pdev)
 {
 	int retval = 0;
@@ -628,12 +686,17 @@ static int cpcap_uc_probe(struct platform_device *pdev)
 
 		cpcap_regacc_write(data->cpcap, CPCAP_REG_MIM1, 0xFFFF,
 				   0xFFFF);
-	} else {
+
+		retval = fw_load(data, &pdev->dev);
+		if (retval)
+			goto err_fw;
+	} else
 		retval = -ENODEV;
-	}
 
 	return retval;
 
+err_fw:
+	misc_deregister(&uc_dev);
 err_priramw:
 	cpcap_irq_free(data->cpcap, CPCAP_IRQ_UC_PRIRAMW);
 err_priramr:
@@ -677,7 +740,7 @@ static int __init cpcap_uc_init(void)
 {
 	return platform_driver_register(&cpcap_uc_driver);
 }
-module_init(cpcap_uc_init);
+subsys_initcall(cpcap_uc_init);
 
 static void __exit cpcap_uc_exit(void)
 {
@@ -689,3 +752,4 @@ MODULE_ALIAS("platform:cpcap_uc");
 MODULE_DESCRIPTION("CPCAP uC driver");
 MODULE_AUTHOR("Motorola");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE("cpcap/firmware_1_2x.fw");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 7f05dd2..524f3a6 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -291,6 +291,14 @@ config SENSORS_LIS331DLH
 	 Say yes here if you wish to include the STI Micro
 	 LIS331DLH accelerometer driver.
 
+config UMTS_SYSPANIC
+        tristate "Motorola UMTS phone syspanic driver"
+	default n
+        help 
+         This option enables support to detect BP panic from AP, with the syspanic IRQ.
+         Only available on SAM-OMAP platform.
+         say y if your BP support this feature (needed for panic daemon)
+
 config WL127X_RFKILL
 	tristate "Bluetooth power control driver for TI wl127x"
 	depends on RFKILL
@@ -301,7 +309,7 @@ config WL127X_RFKILL
 
 config WL127X_TEST
 	tristate "TI wl127x Bluetooth GPIO test driver for board-sholes"
-	depends on MACH_SHOLES && WL127X_RFKILL && BT
+	depends on (MACH_SHOLES || MACH_MAPPHONE) && WL127X_RFKILL && BT
 	default n
 	---help---
 	 Creates sysfs GPIO entries for testing TI wl127x BT on board-sholes.
@@ -323,5 +331,9 @@ config APANIC_PLABEL
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/ts27010mux/Kconfig"
+source "drivers/misc/netmux/Kconfig"
+source "drivers/misc/netmux_linkdriver/Kconfig"
+source "drivers/misc/modem_pm_driver/Kconfig"
+source "drivers/misc/sec/Kconfig"
 
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 2f088cd..20e5efc 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -30,8 +30,15 @@ obj-$(CONFIG_SENSORS_LIS331DLH)	+= lis331dlh.o
 obj-y				+= eeprom/
 obj-y				+= ts27010mux/
 obj-$(CONFIG_VIB_OMAP_PWM)	+= vib-omap-pwm.o
+obj-$(CONFIG_NETMUX_DRIVER)	+= netmux/
+obj-$(CONFIG_NETMUX_LINKDRIVER)	+= netmux_linkdriver/
+obj-$(CONFIG_UMTS_SYSPANIC)     += syspanic.o
 obj-$(CONFIG_OMAP_MODEM_CONTROL)       += omap_mdm_ctrl.o
 obj-$(CONFIG_VIB_GPIO)		+= vib-gpio.o
 obj-$(CONFIG_WL127X_RFKILL)	+= wl127x-rfkill.o
 obj-$(CONFIG_WL127X_TEST)	+= wl127x-test.o
+obj-$(CONFIG_MODEM_PM_DRIVER)   += modem_pm_driver/
+obj-$(CONFIG_SEC_DRIVER)        += sec/
+obj-$(CONFIG_ARCH_OMAP3)        += clk_32k_rw.o
 obj-$(CONFIG_APANIC)		+= apanic.o
+
diff --git a/drivers/misc/akm8973.c b/drivers/misc/akm8973.c
index e9727de..2527318 100644
--- a/drivers/misc/akm8973.c
+++ b/drivers/misc/akm8973.c
@@ -225,6 +225,7 @@ static void akm8973_device_power_off(struct akm8973_data *akm)
 {
 	if (akm->pdata->power_off) {
 		disable_irq_nosync(akm->client->irq);
+		mutex_unlock(&akm->lock);
 		akm->pdata->power_off();
 		clear_bit(BUSY, &akm->flags);
 		akm->hw_initialized = 0;
diff --git a/drivers/misc/akm8973_akmd.c b/drivers/misc/akm8973_akmd.c
index b47cd19..0806cba 100755
--- a/drivers/misc/akm8973_akmd.c
+++ b/drivers/misc/akm8973_akmd.c
@@ -284,8 +284,8 @@ static void AKECS_Report_Value(short *rbuf)
 		input_report_abs(data->input_dev, ABS_THROTTLE, rbuf[3]);
 
 	if (atomic_read(&mv_flag)) {
-		input_report_abs(data->input_dev, ABS_HAT0X, rbuf[9]);
-		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[10]);
+		input_report_abs(data->input_dev, ABS_HAT0X, 0 - rbuf[10]);
+		input_report_abs(data->input_dev, ABS_HAT0Y, rbuf[9]);
 		input_report_abs(data->input_dev, ABS_BRAKE, rbuf[11]);
 	}
 
diff --git a/drivers/misc/apanic.c b/drivers/misc/apanic.c
index ca875f8..25c0270 100644
--- a/drivers/misc/apanic.c
+++ b/drivers/misc/apanic.c
@@ -1,6 +1,7 @@
 /* drivers/misc/apanic.c
  *
  * Copyright (C) 2009 Google, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
  * Author: San Mehat <san@android.com>
  *
  * This software is licensed under the terms of the GNU General Public
@@ -30,12 +31,13 @@
 #include <linux/uaccess.h>
 #include <linux/mtd/mtd.h>
 #include <linux/notifier.h>
-#include <linux/mtd/mtd.h>
 #include <linux/debugfs.h>
 #include <linux/fs.h>
 #include <linux/proc_fs.h>
+#include <linux/rtc.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
+#include <linux/console.h>
 #include <linux/preempt.h>
 
 extern void ram_console_enable_console(int);
@@ -60,6 +62,7 @@ struct apanic_data {
 	void			*bounce;
 	struct proc_dir_entry	*apanic_console;
 	struct proc_dir_entry	*apanic_threads;
+
 };
 
 static struct apanic_data drv_ctx;
@@ -197,7 +200,7 @@ static int apanic_proc_read(char *buffer, char **start, off_t offset,
 		count -= page_offset;
 	memcpy(buffer, ctx->bounce + page_offset, count);
 
-	*start = count;
+	*start = (char *)count;
 
 	if ((offset + count) == file_length)
 		*peof = 1;
@@ -285,7 +288,7 @@ static void apanic_remove_proc_work(struct work_struct *work)
 }
 
 static int apanic_proc_write(struct file *file, const char __user *buffer,
-				unsigned long count, void *data)
+		unsigned long count, void *data)
 {
 	schedule_work(&proc_removal_work);
 	return count;
@@ -494,6 +497,10 @@ static int apanic(struct notifier_block *this, unsigned long event,
 	int threads_offset = 0;
 	int threads_len = 0;
 	int rc;
+	struct timespec now;
+	struct timespec uptime;
+	struct rtc_time rtc_timestamp;
+	struct console *con;
 
 	if (in_panic)
 		return NOTIFY_DONE;
@@ -511,6 +518,28 @@ static int apanic(struct notifier_block *this, unsigned long event,
 		printk(KERN_EMERG "Crash partition in use!\n");
 		goto out;
 	}
+
+	/*
+	 * Add timestamp to displays current UTC time and uptime (in seconds).
+	 */
+	now = current_kernel_time();
+	rtc_time_to_tm((unsigned long)now.tv_sec, &rtc_timestamp);
+	do_posix_clock_monotonic_gettime(&uptime);
+	bust_spinlocks(1);
+	printk(KERN_EMERG "Timestamp = %lu.%03lu\n",
+			(unsigned long)now.tv_sec,
+			(unsigned long)(now.tv_nsec / 1000000));
+	printk(KERN_EMERG "Current Time = "
+			"%02d-%02d %02d:%02d:%lu.%03lu, "
+			"Uptime = %lu.%03lu seconds\n",
+			rtc_timestamp.tm_mon + 1, rtc_timestamp.tm_mday,
+			rtc_timestamp.tm_hour, rtc_timestamp.tm_min,
+			(unsigned long)rtc_timestamp.tm_sec,
+			(unsigned long)(now.tv_nsec / 1000000),
+			(unsigned long)uptime.tv_sec,
+			(unsigned long)(uptime.tv_nsec/USEC_PER_SEC));
+	bust_spinlocks(0);
+
 	console_offset = ctx->mtd->writesize;
 
 	/*
@@ -534,6 +563,11 @@ static int apanic(struct notifier_block *this, unsigned long event,
 	ram_console_enable_console(0);
 
 	log_buf_clear();
+
+	for (con = console_drivers; con; con = con->next) {
+		con->flags &= ~CON_ENABLED;
+	}
+
 	show_state_filter(0);
 	threads_len = apanic_write_console(ctx->mtd, threads_offset);
 	if (threads_len < 0) {
@@ -590,7 +624,7 @@ static int panic_dbg_set(void *data, u64 val)
 
 DEFINE_SIMPLE_ATTRIBUTE(panic_dbg_fops, panic_dbg_get, panic_dbg_set, "%llu\n");
 
-int __init apanic_init(void)
+static int __init apanic_init(void)
 {
 	register_mtd_user(&mtd_panic_notifier);
 	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
diff --git a/drivers/misc/clk_32k_rw.c b/drivers/misc/clk_32k_rw.c
new file mode 100644
index 0000000..1647426
--- /dev/null
+++ b/drivers/misc/clk_32k_rw.c
@@ -0,0 +1,190 @@
+/*
+ *  Copyright (C) 2009 Motorola, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Adds ability to program periodic interrupts from user space that
+ *  can wake the phone out of low power modes.
+ *
+ */
+/*
+ * DATE			AUTHOR		 COMMENT
+ * -----		-----		 --------
+ * Sep 08, 2009		Motorola	 Initial version for omap Android
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/moduleparam.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <linux/ktime.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/wakeup_timer.h>
+
+#define DRV_NAME "clock_32k"
+
+struct timer_list timer_32k;
+static struct platform_device *clock_platform_device;
+static DEFINE_SPINLOCK(clock_32k_spin_lock);
+struct timespec clock_32k_read(void)
+{
+	static unsigned long long roll_over;
+	struct timespec my_time_32k;
+	unsigned long long current_time;
+	static unsigned long long curr_val;
+	static unsigned long long last_val;
+	curr_val = sched_clock();
+	/* Check if sched_clock returned value has rolled over */
+	if (curr_val < last_val) {
+		roll_over += (1ULL << (32-15))*1000000000ULL;
+		}
+	current_time = curr_val + roll_over ;
+	my_time_32k = ns_to_timespec(current_time);
+	last_val = curr_val;
+	/* Restart the 24 hrs timer to be sure that
+	   all roll over will be detected */
+	mod_timer(&timer_32k, jiffies + 24*60*60*HZ);
+	return my_time_32k;
+}
+
+static int clock_32k_ioctl(struct inode *inode,
+		struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct timespec my_time_32k;
+	/* Acquire mutx to be sure that user read and
+	*timer read will not happen at same time */
+
+	/* Then evaluate the command and take according action */
+	switch (cmd) {
+	case IOC_32KHZ_READ:
+		spin_lock_bh(&clock_32k_spin_lock);
+		my_time_32k = clock_32k_read();
+		spin_unlock_bh(&clock_32k_spin_lock);
+		ret = __copy_to_user((int *)arg, \
+		&my_time_32k, sizeof(my_time_32k));
+		break;
+	default:
+		printk(KERN_ERR "Invalid IOCTL command\n");
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static int clock_32k_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int clock_32k_free(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations clock_32k_fops = {
+	.owner =        THIS_MODULE,
+	.ioctl =        clock_32k_ioctl,
+	.open =         clock_32k_open,
+	.release =      clock_32k_free,
+};
+
+static struct miscdevice clock_32k_miscdev = {
+	.minor	= MISC_DYNAMIC_MINOR,
+	.name	= "clock_32k",
+	.fops	= &clock_32k_fops,
+};
+
+void timer_32k_callback(unsigned long param)
+{
+	spin_lock(&clock_32k_spin_lock);
+	clock_32k_read();
+	spin_unlock(&clock_32k_spin_lock);
+}
+
+static int __devinit clock_32k_probe(struct platform_device *dev)
+{
+	int ret;
+	spin_lock_init(&clock_32k_spin_lock);
+	ret = misc_register(&clock_32k_miscdev);
+	if (ret != 0)
+		goto out;
+	init_timer(&timer_32k);
+	timer_32k.function = timer_32k_callback;
+	timer_32k.data = 0 ;
+	timer_32k.expires = jiffies + 24*60*60*HZ;
+	add_timer(&timer_32k);
+	return 0;
+out:
+	return ret;
+}
+
+static int __devexit clock_32k_remove(struct platform_device *dev)
+{
+	misc_deregister(&clock_32k_miscdev);
+	return 0;
+}
+
+static struct platform_driver clock_32k_driver = {
+	.probe		= clock_32k_probe,
+	.remove		= __devexit_p(clock_32k_remove),
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= DRV_NAME,
+		},
+};
+
+static int __init clock_32k_init(void)
+{
+	int err;
+	err = platform_driver_register(&clock_32k_driver);
+	if (err)
+		return err;
+	clock_platform_device = platform_device_register_simple(DRV_NAME,
+								-1, NULL, 0);
+	if (IS_ERR(clock_platform_device)) {
+		err = PTR_ERR(clock_platform_device);
+		goto unreg_platform_driver;
+	}
+	return 0;
+
+unreg_platform_driver:
+	platform_driver_unregister(&clock_32k_driver);
+	return err;
+}
+static void __exit clock_32k_exit(void)
+{
+	platform_device_unregister(clock_platform_device);
+	platform_driver_unregister(&clock_32k_driver);
+}
+
+module_init(clock_32k_init);
+module_exit(clock_32k_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Motorola 32K sync timer driver");
diff --git a/drivers/misc/lis331dlh.c b/drivers/misc/lis331dlh.c
index bab1fd9..a9b7e6e 100644
--- a/drivers/misc/lis331dlh.c
+++ b/drivers/misc/lis331dlh.c
@@ -202,7 +202,8 @@ static int lis331dlh_hw_init(struct lis331dlh_data *lis)
 static void lis331dlh_device_power_off(struct lis331dlh_data *lis)
 {
 	int err;
-	u8 buf[2] = { CTRL_REG4, PM_OFF };
+/*	u8 buf[2] = { CTRL_REG4, PM_OFF }; */
+	u8 buf[2] = { CTRL_REG1, PM_OFF };
 
 	err = lis331dlh_i2c_write(lis, buf, 1);
 	if (err < 0)
diff --git a/drivers/misc/modem_pm_driver/Kconfig b/drivers/misc/modem_pm_driver/Kconfig
new file mode 100755
index 0000000..daa4aa2
--- /dev/null
+++ b/drivers/misc/modem_pm_driver/Kconfig
@@ -0,0 +1,27 @@
+#
+# Copyright (C) 2009 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307, USA
+#
+# Motorola 2009-Feb-18 - Initial Creation
+#
+
+menu "Motorola Modem PM Driver"
+
+config MODEM_PM_DRIVER
+        tristate
+        default m
+
+endmenu
diff --git a/drivers/misc/modem_pm_driver/Makefile b/drivers/misc/modem_pm_driver/Makefile
new file mode 100755
index 0000000..c97ae66
--- /dev/null
+++ b/drivers/misc/modem_pm_driver/Makefile
@@ -0,0 +1,26 @@
+#
+# Copyright (C) 2009 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307, USA
+#
+# Motorola 2009-Feb-18 - Initial Creation
+#
+
+MODULE_NAME = modem_pm_driver
+
+obj-$(CONFIG_MODEM_PM_DRIVER) += $(MODULE_NAME).o
+$(MODULE_NAME)-objs := modem_pm_driver_main.o
+
+#obj-y           += modem_pm_driver_main.o
diff --git a/drivers/misc/modem_pm_driver/modem_pm_driver.h b/drivers/misc/modem_pm_driver/modem_pm_driver.h
new file mode 100755
index 0000000..5f6c248
--- /dev/null
+++ b/drivers/misc/modem_pm_driver/modem_pm_driver.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2009, Motorola, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ *
+ * Motorola 2009-Jul-13 - Update for K29 to use Resource Framework
+ * Motorola 2009-Jan-28 - Initial Creation
+ */
+
+#ifndef __MODEM_PM_DRIVER_H__
+#define __MODEM_PM_DRIVER_H__
+
+#include <linux/ioctl.h>
+
+#define MODEM_PM_DRIVER_DEV_NAME  "modem_pm_driver"
+
+enum MODEM_PM_SHARED_DDR_FREQUENCY_OPP_CONSTRAINT_T {
+	MODEM_PM_SHARED_DDR_FREQUENCY_OPP_HIGH,
+	MODEM_PM_SHARED_DDR_FREQUENCY_OPP_NO_VOTE,
+};
+
+enum MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_CONSTRAINT_T {
+	MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_ON_INACTIVE,
+	MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_RET,
+	MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_NO_VOTE,
+};
+
+/* Frequency OPP constraint command */
+#define MODEM_PM_DRIVER_IOCTL_CMD_HANDLE_FREQUENCY_OPP_CONSTRAINT     (0x00)
+
+/* Low power policy contraint command */
+#define MODEM_PM_DRIVER_IOCTL_CMD_HANDLE_LOW_POWER_POLICY_CONSTRAINT  (0x01)
+
+/* Handle frequency OPP constraint */
+#define MODEM_PM_DRIVER_IOCTL_HANDLE_FREQUENCY_OPP_CONSTRAINT \
+    _IOW(0, MODEM_PM_DRIVER_IOCTL_CMD_HANDLE_FREQUENCY_OPP_CONSTRAINT, \
+	 enum MODEM_PM_SHARED_DDR_FREQUENCY_OPP_CONSTRAINT_T)
+
+/* Handle low power policy constraint */
+#define MODEM_PM_DRIVER_IOCTL_HANDLE_LOW_POWER_POLICY_CONSTRAINT \
+    _IOW(0, MODEM_PM_DRIVER_IOCTL_CMD_HANDLE_LOW_POWER_POLICY_CONSTRAINT, \
+	 enum MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_CONSTRAINT_T)
+
+#endif
+
diff --git a/drivers/misc/modem_pm_driver/modem_pm_driver_main.c b/drivers/misc/modem_pm_driver/modem_pm_driver_main.c
new file mode 100755
index 0000000..d172fae
--- /dev/null
+++ b/drivers/misc/modem_pm_driver/modem_pm_driver_main.c
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2009, Motorola, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ *
+ * Motorola 2009-Sep-08 - Bug fix for frequency constraint
+ * Motorola 2009-Jul-13 - Update for K29 to use Resource Framework
+ * Motorola 2009-Jan-28 - Initial Creation
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/semaphore.h>
+#include <mach/omap34xx.h>
+#include <mach/resource.h>
+#include "modem_pm_driver.h"
+
+static char modem_pm_driver_opened;
+
+static struct device my_device;
+
+static struct class *modem_pm_driver_class;
+static struct device *modem_pm_driver_dev;
+
+static int modem_pm_driver_major_num;
+
+static DECLARE_MUTEX(modem_pm_driver_lock);
+
+
+static int modem_pm_driver_init(void);
+
+static void modem_pm_driver_exit(void);
+
+static int modem_pm_driver_open(struct inode *inode, struct file *file);
+
+static int modem_pm_driver_free(struct inode *inode, struct file *file);
+
+static int modem_pm_driver_ioctl(struct inode *inode,
+				 struct file *file,
+				 unsigned int cmd,
+				 unsigned long arg);
+
+/* This structure defines the file operations for the Modem PM Driver */
+static const struct file_operations modem_pm_driver_fops = {
+	.owner =    THIS_MODULE,
+	.ioctl =    modem_pm_driver_ioctl,
+	.open =     modem_pm_driver_open,
+	.release =  modem_pm_driver_free
+};
+
+static int modem_pm_driver_init(void)
+{
+	int retval = 0;
+
+	/* Register the character device. */
+	modem_pm_driver_major_num =
+		register_chrdev(0, MODEM_PM_DRIVER_DEV_NAME,
+				&modem_pm_driver_fops);
+
+	/* If the character device is registered, continue. */
+	if (modem_pm_driver_major_num >= 0) {
+		/* Make the character device. */
+		modem_pm_driver_class = class_create(THIS_MODULE,
+						     MODEM_PM_DRIVER_DEV_NAME);
+
+		if (IS_ERR(modem_pm_driver_class)) {
+			unregister_chrdev(modem_pm_driver_major_num,
+					  MODEM_PM_DRIVER_DEV_NAME);
+			retval = -EFAULT;
+		} else {
+			modem_pm_driver_dev =
+				device_create(modem_pm_driver_class,
+					      NULL,
+					      MKDEV(modem_pm_driver_major_num,
+						    0),
+					      NULL,
+					      MODEM_PM_DRIVER_DEV_NAME);
+
+			if (IS_ERR(modem_pm_driver_dev)) {
+				class_destroy(modem_pm_driver_class);
+				unregister_chrdev(modem_pm_driver_major_num,
+						  MODEM_PM_DRIVER_DEV_NAME);
+				retval = -EFAULT;
+			}
+		}
+	}
+	/* If we failed to get a character device, return the error. */
+	else
+		retval = modem_pm_driver_major_num;
+
+	return retval;
+}
+
+static void modem_pm_driver_exit(void)
+{
+	/* Unregister the character device */
+	device_destroy(modem_pm_driver_class,
+		       MKDEV(modem_pm_driver_major_num, 0));
+	class_destroy(modem_pm_driver_class);
+	unregister_chrdev(modem_pm_driver_major_num, MODEM_PM_DRIVER_DEV_NAME);
+}
+
+static int modem_pm_driver_open(struct inode *inode, struct file *file)
+{
+	int retval = -EINTR;
+
+	/* Acquire the mutex */
+	if (down_interruptible(&modem_pm_driver_lock) == 0) {
+		/* Check if it is not already open */
+		if (modem_pm_driver_opened == 0) {
+			/* Set the opened state */
+			modem_pm_driver_opened = 1;
+			retval = 0;
+		} else
+			retval = -EBUSY;
+
+		/* Release the mutex */
+		up(&modem_pm_driver_lock);
+	}
+
+	return retval;
+}
+
+static int modem_pm_driver_free(struct inode *inode, struct file *file)
+{
+	int retval = -EINTR;
+
+	/* Acquire the mutex */
+	if (down_interruptible(&modem_pm_driver_lock) == 0) {
+		modem_pm_driver_opened = 0;
+		retval = 0;
+
+		/* Remove the setting of the VDD2 OPP constraint */
+		resource_release("vdd2_opp", &my_device);
+
+		/* Remove the setting of the latency constraint */
+		resource_release("core_latency", &my_device);
+
+		/* Release the mutex */
+		up(&modem_pm_driver_lock);
+	}
+
+	return retval;
+}
+
+static int modem_pm_driver_ioctl(struct inode *inode,
+				 struct file *file,
+				 unsigned int cmd,
+				 unsigned long arg)
+{
+	int status = -EFAULT;
+
+	switch (cmd) {
+	case MODEM_PM_DRIVER_IOCTL_HANDLE_FREQUENCY_OPP_CONSTRAINT: {
+		switch (arg) {
+		case MODEM_PM_SHARED_DDR_FREQUENCY_OPP_HIGH: {
+			/* Set the target value of the VDD2 OPP constraint  */
+			/* Make sure the interconnect is at 150Mhz or above */
+			/* Throughput in KiB/s for 150 Mhz = 150 * 1000 * 4 */
+			resource_request("vdd2_opp", &my_device, 600000);
+			status = 0;
+			break;
+		}
+		case MODEM_PM_SHARED_DDR_FREQUENCY_OPP_NO_VOTE: {
+			/* Remove the setting of the VDD2 OPP constraint */
+			resource_release("vdd2_opp", &my_device);
+			status = 0;
+			break;
+		}
+		default:
+			break;
+		}
+		break;
+	}
+	case MODEM_PM_DRIVER_IOCTL_HANDLE_LOW_POWER_POLICY_CONSTRAINT: {
+		switch (arg) {
+		case MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_ON_INACTIVE: {
+			/* Set the target value of the latency constraint */
+			resource_request("core_latency", &my_device, 9999);
+			status = 0;
+			break;
+		}
+		case MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_RET: {
+			/* Set the target value of the latency constraint */
+			resource_request("core_latency", &my_device, 39999);
+			status = 0;
+			break;
+		}
+		case MODEM_PM_SHARED_DDR_LOW_POWER_POLICY_NO_VOTE: {
+			/* Remove the setting of the latency constraint */
+			resource_release("core_latency", &my_device);
+			status = 0;
+			break;
+		}
+		default:
+			break;
+		}
+		break;
+	}
+	default:
+		break;
+	}
+
+	return status;
+}
+
+/* Module entry points */
+module_init(modem_pm_driver_init);
+module_exit(modem_pm_driver_exit);
+
+MODULE_DESCRIPTION("Modem PM Driver");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/netmux/Kconfig b/drivers/misc/netmux/Kconfig
new file mode 100644
index 0000000..3d6bf61
--- /dev/null
+++ b/drivers/misc/netmux/Kconfig
@@ -0,0 +1,11 @@
+#
+# Netmux configuration
+#
+
+menu "Motorola netmux driver"
+
+config NETMUX_DRIVER
+        tristate "Motorola netmux driver"
+        default m
+
+endmenu
diff --git a/drivers/misc/netmux/LICENSE b/drivers/misc/netmux/LICENSE
new file mode 100755
index 0000000..5004b6f
--- /dev/null
+++ b/drivers/misc/netmux/LICENSE
@@ -0,0 +1,28 @@
+Copyright Motorola 2006
+
+This program is licensed under a BSD license with the following terms:
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+o Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+o Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+o Neither the name of Motorola nor the names of its contributors may be
+  used to endorse or promote products derived from this software without
+  specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/drivers/misc/netmux/Makefile b/drivers/misc/netmux/Makefile
new file mode 100644
index 0000000..e911877
--- /dev/null
+++ b/drivers/misc/netmux/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for the netmux drivers.
+#
+
+MODULE_NAME = netmux
+
+obj-$(CONFIG_NETMUX_DRIVER) += $(MODULE_NAME).o
+$(MODULE_NAME)-objs := debug.o utility.o config.o direct.o network.o tty.o interface.o protocol.o mux.o channelconfig.o register.o main.o
+
+
+#obj-m   := $(MODULE_NAME).o
+#$(MODULE_NAME)-objs := debug.o utility.o config.o direct.o network.o tty.o interface.o protocol.o mux.o channelconfig.o register.o main.o
diff --git a/drivers/misc/netmux/channelconfig.c b/drivers/misc/netmux/channelconfig.c
new file mode 100755
index 0000000..a3bab94
--- /dev/null
+++ b/drivers/misc/netmux/channelconfig.c
@@ -0,0 +1,51 @@
+/******************************************************************************
+ * NetMUX channelconfig.c                                                     *
+ *                                                                            *
+ * Copyright (C) Motorola 2006                                                *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Changed configdata to be NULL                    *
+ ******************************************************************************/
+
+/* channelconfig.c initializes channel configuration structures for the       */
+/* NetMUX that masters such data to be sent to the other NetMUX during init   */
+
+#include "config.h"
+
+
+/*
+ * Configuration is done BP->AP, so the linux side has
+ * no configuration data and hence no config count.
+ * As such, the pointer to config data is null.
+ */
+int32 netmux_configdata_count = 0;
+
+CONFIGDATA* netmux_configdata = NULL;
diff --git a/drivers/misc/netmux/config.c b/drivers/misc/netmux/config.c
new file mode 100755
index 0000000..7b9064c
--- /dev/null
+++ b/drivers/misc/netmux/config.c
@@ -0,0 +1,1419 @@
+/******************************************************************************
+ * NetMUX config.c                                                            *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2007                                           *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/11/10  Motorola    Fixed /proc/netmux_config_host0 bugs             *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ *   2007/12/05  Motorola    Change code for INIT_WORK changed in kernel      *
+ ******************************************************************************/
+
+/* config.c defines the various functionality responsible for setting up the  */
+/* NetMUX and maintaining its integrity.                                      */
+
+#include <linux/proc_fs.h>
+
+#include "config.h"
+#include "debug.h"
+typedef struct USERCONFIGDATA
+{
+    struct proc_dir_entry* host_config_file;
+    struct proc_dir_entry* client_config_file;
+
+    sint8* host_config_data;
+    sint8* client_config_data;
+
+    int32 host_config_datasize;
+    int32 client_config_datasize;
+    int32 host_config_dataused;
+
+    int32 mux_id;
+
+    COMMBUFFQUEUE   commandqueue;
+    TASKDATA        commandtask;
+    CRITICALSECTION config_synch;
+
+    wait_queue_head_t event_wait;
+    CONFIGINTERFACE *config;
+}USERCONFIGDATA;
+
+
+/*
+ * ConfigInform is notified by the mux when an interesting
+ * event happens. The config interface pays attention to
+ * these events to accomplish several things.
+ *
+ * First, the config interface listens for enable mux,
+ * enable channel, and query interface to help
+ * initialize the NetMUX.
+ *
+ * Second, the config interface listens for disable mux.
+ * This case signifies an error has happened within the
+ * NetMUX or a linkdriver and the config interface should
+ * attempt to bring the NetMUX back into a working state.
+ *
+ * Third, the config interface listens for disable channel.
+ * If this signal is received the config interface assumes
+ * the NetMUX is shutting down, and as such, the config
+ * interface will help bring down anything it's
+ * responsible for.
+ *
+ * Params:
+ *
+ * param1 -- a custom value, in this case the mux always
+ *           delivers a pointer to an INTERFACEINFORM struct
+ * param2 -- a custom value provided by the interface
+ *           creator. In this case, the config interface
+ *           specified a CONFIGINTERFACE struct
+ */
+int32 ConfigInform (void* param1, void* param2)
+{
+    INTERFACEINFORM        passinformdata;
+    CONFIGPACKET           configpacket;
+    ENABLECHANNEL_PACKET*  enablechannel;
+    QUERYINTERFACE_PACKET* queryinterface;
+    ENABLEMUX_PACKET*      enablemux;
+    CONFIGINTERFACE*       config;
+    CONFIGDATA*            configdata;
+    INTERFACEINFORM*       informdata;
+    int32                  result;
+    int32                  index;
+    int8                   type;
+
+    DEBUG("ConfigInform(0x%p, 0x%p)\n", param1, param2);
+
+    informdata = (INTERFACEINFORM*)param1;
+    config     = (CONFIGINTERFACE*)param2;
+
+    switch(informdata->inform_type)
+    {
+        case INFORM_INTERFACE_ENABLEMUX:
+        {
+            if(config->state != CONFIG_STATE_ENABLING)
+                break;
+
+            enablemux = (ENABLEMUX_PACKET*)informdata->data;
+
+            type = (int8)strip_end(enablemux->acktype);
+            if(type == SUCCESS)
+            {
+                config->state = CONFIG_STATE_CONNECTING;
+                configdata    = config->configdata;
+
+                for(index = 0; index < config->configdata_count; index++)
+                {
+                    result = QueryInterfaceIndex(configdata[index].host_interface,
+                                                 config->mux->interface_lib,
+                                                 &configdata[index].host_interface_id);
+
+                    if(result == ERROR_NONE)
+                        configdata[index].state = CONFIGDATA_STATE_VERIFIED;
+                    else
+                        configdata[index].state = CONFIGDATA_STATE_DEFAULT;
+                }
+
+                if(config->host)
+                    QueryExternalInterface(host_end(COMMAND), config->host_interface, 0, CONFIG_INTERFACE_NAME, config->mux);
+            }
+            else
+            {
+                if(config->host)
+                    EnableMUX(host_end(COMMAND), config->mux);
+            }
+        }break;
+
+        case INFORM_INTERFACE_DISABLEMUX:
+        {
+            if(config->state == CONFIG_STATE_DEFAULT)
+                break;
+
+            config->state = CONFIG_STATE_ENABLING;
+
+            if(config->host)
+                EnableMUX(host_end(COMMAND), config->mux);
+        }break;
+
+        case INFORM_INTERFACE_ENABLECHANNEL:
+        {
+            enablechannel = (ENABLECHANNEL_PACKET*)informdata->data;
+
+            type = (int8)strip_end(enablechannel->acktype);
+            if(type == SUCCESS)
+            {
+                config->state = CONFIG_STATE_CONNECTED;
+
+                if(config->configdata_count)
+                    QueryExternalInterface(host_end(COMMAND), config->host_interface, 0, config->configdata[0].client_interface, config->mux);
+            }
+            else
+            {
+                if(config->host)
+                {
+                    EnableChannel(
+                                  host_end(COMMAND),
+                                  config->channel,
+                                  CONFIG_BURSTSIZE,
+                                  CONFIG_MAXDATA,
+                                  config->host_interface,
+                                  config->client_interface,
+                                  CONFIG_BYTECREDIT,
+                                  CONFIG_SENDCREDIT,
+                                  0,
+                                  0,
+                                  config->mux
+                                 );
+                }
+                else
+                {
+                    config->client_interface = enablechannel->host_interface;
+                    config->state            = CONFIG_STATE_CONNECTED;
+
+                    EnableChannel(
+                                  client_end(COMMAND),
+                                  enablechannel->channel,
+                                  CONFIG_BURSTSIZE,
+                                  CONFIG_MAXDATA,
+                                  enablechannel->host_interface,
+                                  enablechannel->client_interface,
+                                  CONFIG_BYTECREDIT,
+                                  CONFIG_SENDCREDIT,
+                                  enablechannel->bytecredit,
+                                  enablechannel->sendcredit,
+                                  config->mux
+                                 );
+
+                    if(config->configdata_count)
+                        QueryExternalInterface(host_end(COMMAND), config->host_interface, 0, config->configdata[0].client_interface, config->mux);
+                }
+            }
+        }break;
+
+        case INFORM_INTERFACE_DISABLECHANNEL:
+        {
+            config->state = CONFIG_STATE_CONNECTING;
+            if(config->host)
+            {
+                EnableChannel(
+                              host_end(COMMAND),
+                              config->channel,
+                              CONFIG_BURSTSIZE,
+                              CONFIG_MAXDATA,
+                              config->host_interface,
+                              config->client_interface,
+                              CONFIG_BYTECREDIT,
+                              CONFIG_SENDCREDIT,
+                              0,
+                              0,
+                              config->mux
+                             );
+            }
+        }break;
+
+        case INFORM_INTERFACE_QUERYINTERFACE:
+        {
+            queryinterface = (QUERYINTERFACE_PACKET*)informdata->data;
+
+            type = (int8)strip_end(queryinterface->acktype);
+            if(config->state == CONFIG_STATE_CONNECTING)
+            {
+                if(type == SUCCESS)
+                {
+                    config->client_interface = queryinterface->result;
+
+                    if(config->host)
+                    {
+                        EnableChannel(
+                                      host_end(COMMAND),
+                                      config->channel,
+                                      CONFIG_BURSTSIZE,
+                                      CONFIG_MAXDATA,
+                                      config->host_interface,
+                                      config->client_interface,
+                                      CONFIG_BYTECREDIT,
+                                      CONFIG_SENDCREDIT,
+                                      0,
+                                      0,
+                                      config->mux
+                                     );
+                    }
+                }
+                else
+                    QueryExternalInterface(host_end(COMMAND), config->host_interface, 0, CONFIG_INTERFACE_NAME, config->mux);
+            }
+            else if(config->state == CONFIG_STATE_CONNECTED)
+            {
+                configdata = config->configdata;
+
+                if(type == SUCCESS)
+                    result = 0;
+                else
+                    result = 1;
+
+                for(index = 0; index < config->configdata_count; index++)
+                {
+                    if(configdata[index].state != CONFIGDATA_STATE_VERIFIED)
+                        continue;
+
+                    if(type == FAILURE)
+                    {
+                        if(result)
+                        {
+                            configdata[index].state = CONFIGDATA_STATE_DEFAULT;
+                            result                  = 0;
+
+                            continue;
+                        }
+                        else
+                        {
+                            result = 1;
+
+                            QueryExternalInterface(host_end(COMMAND),
+                                            config->host_interface,
+                                            0,
+                                            configdata[index].client_interface,
+                                            config->mux);
+
+                            break;
+                        }
+                    }
+
+                    if(!strcmp((char*)configdata[index].client_interface, (char*)queryinterface->name))
+                    {
+                        configdata[index].state = CONFIGDATA_STATE_DISTRIBUTE;
+                        configdata[index].client_interface_id = queryinterface->result;
+                    }
+                    else if(!result)
+                    {
+                        result = 1;
+                        QueryExternalInterface(host_end(COMMAND),
+                                           config->host_interface,
+                                           0,
+                                           configdata[index].client_interface,
+                                           config->mux);
+                    }
+                }
+
+                if(!result)
+                {
+                    passinformdata.source      = config->mux;
+                    passinformdata.inform_type = INFORM_INTERFACE_CONFIGPACKET;
+
+                    for(index = 0; index < config->configdata_count; index++)
+                    {
+                        if(configdata[index].state != CONFIGDATA_STATE_DISTRIBUTE)
+                            continue;
+
+                        configpacket.channel            = configdata[index].channel;
+                        configpacket.client_burstsize   = configdata[index].host_burstsize;
+                        configpacket.client_maxdata     = configdata[index].host_maxdata;
+                        configpacket.client_byte_credit = configdata[index].host_byte_credit;
+                        configpacket.client_send_credit = configdata[index].host_send_credit;
+                        configpacket.host_interface     = configdata[index].client_interface_id;
+                        configpacket.client_interface   = configdata[index].host_interface_id;
+                        configpacket.channel_extra      = configdata[index].channel_extra;
+
+                        memcpy((void*)configpacket.channel_name, configdata[index].channel_name, PACKET_MAXNAME_LENGTH);
+
+                        passinformdata.data = (void*)&configpacket;
+
+                        LIBRARY_INFORM(&passinformdata, configpacket.client_interface, config->mux->interface_lib);
+                        GenerateConfigPacket(&configdata[index], config);
+                    }
+                }
+            }
+        }break;
+
+        default:
+        {
+            return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+        }break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * ConfigReceive is called by the mux whenever data is received
+ * on the config interface's channel.
+ *
+ * All data received on this channel is assumed to be a
+ * configuration packet.
+ *
+ * Once a packet is received it is parsed and communicated to
+ * the responsible interface. That interface then configures
+ * what is necessary. The config interface merely acts as
+ * the middle man.
+ *
+ * Params:
+ * commbuff -- the buffer being delivered to the interface
+ * param -- a custom value, in this case the mux provides
+ *          an INTERFACEINFORM struct
+ */
+int32 ConfigReceive (COMMBUFF* commbuff, void* param)
+{
+    CONFIGPACKET     configpacket;
+    INTERFACEINFORM  passinformdata;
+    CONFIGINTERFACE* config;
+    INTERFACEINFORM* informdata;
+    MUX*             mux;
+    int8             type;
+
+    DEBUG("ConfigReceive(0x%p, 0x%p)\n", commbuff, param);
+
+    informdata = (INTERFACEINFORM*)param;
+
+    mux    = informdata->source;
+    config = (CONFIGINTERFACE*)informdata->inform_type;
+
+    commbuff_copyout((void*)&type, commbuff, 0, sizeof(int8));
+
+    if(type != CONFIG_CORE_TYPE)
+        ReceiveClientConfigRequest(config, commbuff);
+    else
+    {
+        commbuff_remove_front(commbuff, sizeof(sint8));
+        commbuff_copyout((void*)&configpacket, commbuff, 0, sizeof(CONFIGPACKET));
+        free_commbuff(commbuff);
+
+        passinformdata.source      = mux;
+        passinformdata.inform_type = INFORM_INTERFACE_CONFIGPACKET;
+        passinformdata.data        = (void*)&configpacket;
+
+        convert_dword(configpacket.channel);
+        convert_dword(configpacket.host_interface);
+        convert_dword(configpacket.client_interface);
+        convert_dword(configpacket.client_burstsize);
+        convert_dword(configpacket.client_maxdata);
+        convert_dword(configpacket.client_byte_credit);
+        convert_dword(configpacket.client_send_credit);
+        convert_dword(configpacket.channel_extra);
+
+        LIBRARY_INFORM(&passinformdata, configpacket.client_interface, mux->interface_lib);
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * CreateConfigInterface creates a config interface object.
+ * There is only one config interface object per NetMUX and each
+ * object keeps track of the necessary data to bring up the NetMUX
+ * and keep it running.
+ *
+ * Params:
+ * channel -- the channel the config interface works over
+ * mux -- the mux to be associated with this interface
+ * configdata_count -- number of configuration entries
+ * configdata -- list of configuration entries
+ * config -- a poitner to a pointer to receive the new object
+ */
+int32 CreateConfigInterface  (
+                              int32             channel,
+                              MUX*              mux,
+                              int32             configdata_count,
+                              CONFIGDATA*       configdata,
+                              CONFIGINTERFACE** config
+                             )
+{
+    CONFIGINTERFACE* newconfig;
+    int32            result;
+
+    DEBUG(
+          "CreateConfigInterface(%lu, 0x%p, %lu, 0x%p, 0x%p)\n",
+          channel,
+          mux,
+          configdata_count,
+          configdata,
+          config
+         );
+
+    if(!mux || !config)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    newconfig = alloc_mem(sizeof(CONFIGINTERFACE));
+
+    newconfig->channel          = channel;
+    newconfig->configdata       = configdata;
+    newconfig->configdata_count = configdata_count;
+    newconfig->mux              = mux;
+    newconfig->state            = CONFIG_STATE_DEFAULT;
+
+    result = RegisterInterface(CONFIG_INTERFACE_NAME, &ConfigInform, &ConfigReceive, (int32)newconfig, mux->interface_lib);
+    if(result != ERROR_NONE)
+        goto REGISTER_CONFIGIF_FAILED;
+
+    QueryInterfaceIndex(CONFIG_INTERFACE_NAME, mux->interface_lib, &newconfig->host_interface);
+
+    result = StartupConfigUserInterface(newconfig);
+    if(result != ERROR_NONE)
+        goto INIT_USERIF_FAILED;
+
+    *config = newconfig;
+
+    return DEBUGERROR(ERROR_NONE);
+
+INIT_USERIF_FAILED:
+    UnregisterInterface(newconfig->host_interface, newconfig->mux->interface_lib);
+REGISTER_CONFIGIF_FAILED:
+    free_mem(newconfig);
+
+    return DEBUGERROR(result);
+}
+
+/*
+ * DestroyConfigInterface will free up any resources consumed by a
+ * config interface object. This call depends on there being
+ * absolutely no activity on the specified object.
+ *
+ * Params:
+ * config -- the config object to be destroyed
+ */
+int32 DestroyConfigInterface (CONFIGINTERFACE* config)
+{
+    int32 result;
+
+    DEBUG("DestroyConfigInterface(0x%p)\n", config);
+
+    if(config->state != CONFIG_STATE_DEFAULT)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    ShutdownConfigUserInterface(config);
+
+    result = UnregisterInterface(config->host_interface, config->mux->interface_lib);
+    if(result != ERROR_NONE)
+        return DEBUGERROR(result);
+
+    free_mem(config);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * ActivateConfigInterface is called when a NetMUx is to be initialized.
+ * This is currently done once a linkdriver registers itself.
+ *
+ * Params:
+ * host -- non-zero if the specified interface is to act as a host
+ * config -- a pointer to the interface to be activated
+ */
+int32 ActivateConfigInterface (int32 host, CONFIGINTERFACE* config)
+{
+    DEBUG("ActivateConfigInterface(%lu, 0x%p)\n", host, config);
+
+    config->state = CONFIG_STATE_DEFAULT;
+
+    config->host  = host;
+    config->state = CONFIG_STATE_ENABLING;
+
+    if(host)
+        EnableMUX(host_end(COMMAND), config->mux);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DeactivateconfigInterface is called when it's time to bringdown a
+ * NetMUX. This is currently done when a linkdriver unregisters
+ * itself.
+ *
+ * Params:
+ * config -- the interface to be deactivated
+ */
+int32 DeactivateConfigInterface (CONFIGINTERFACE* config)
+{
+    DEBUG("DeactivateConfigInterface(0x%p)\n", config);
+
+    config->state = CONFIG_STATE_DEFAULT;
+
+    DisableMUX(host_end(COMMAND), config->mux);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/* GenerateConfigPacket is a helper function for the config interface.
+ * This function is called when configuration data needs to be delivered
+ * to a participating NetMUX. The config data will be formed into a
+ * packet and sent over the link.
+ *
+ * Params:
+ * configdata -- pointer to the configuration data to be sent
+ * config -- the config interface to deliver the data on
+ */
+int32 GenerateConfigPacket (CONFIGDATA* configdata, CONFIGINTERFACE* config)
+{
+    CONFIGPACKET configpacket;
+    COMMBUFF*    commbuff;
+    int32        result;
+    int8         type;
+
+    DEBUG("GenerateConfigPacket(0x%p, 0x%p)\n", configdata, config);
+
+    if(config->state != CONFIG_STATE_CONNECTED)
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+    commbuff = alloc_commbuff(sizeof(CONFIGPACKET)+sizeof(int8),
+                              sizeof(DATA_PACKET_HDR));
+
+    type = CONFIG_CORE_TYPE;
+
+    configpacket.channel            = configdata->channel;
+    configpacket.host_interface     = configdata->host_interface_id;
+    configpacket.client_interface   = configdata->client_interface_id;
+    configpacket.client_burstsize   = configdata->client_burstsize;
+    configpacket.client_maxdata     = configdata->client_maxdata;
+    configpacket.client_byte_credit = configdata->client_byte_credit;
+    configpacket.client_send_credit = configdata->client_send_credit;
+    configpacket.channel_extra      = configdata->channel_extra;
+
+    memcpy((void*)configpacket.channel_name, configdata->channel_name, PACKET_MAXNAME_LENGTH);
+
+    convert_dword(configpacket.channel);
+    convert_dword(configpacket.host_interface);
+    convert_dword(configpacket.client_interface);
+    convert_dword(configpacket.client_burstsize);
+    convert_dword(configpacket.client_maxdata);
+    convert_dword(configpacket.client_byte_credit);
+    convert_dword(configpacket.client_send_credit);
+    convert_dword(configpacket.channel_extra);
+
+    commbuff_copyin(commbuff, 0, (void*)&type, sizeof(int8));
+    commbuff_copyin(commbuff, sizeof(int8), (void*)&configpacket,
+                    sizeof(CONFIGPACKET));
+
+    result = SendData(config->channel, commbuff, NULL, config->mux);
+    if(result != ERROR_NONE)
+    {
+        free_commbuff(commbuff);
+
+        return DEBUGERROR(result);
+    }
+
+    deref_commbuff(commbuff);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+
+static
+void GenerateStatusReport (CONFIGINTERFACE* config)
+{
+    CHANNEL**       channels;
+    CHANNELCREDIT*  channelcredit;
+    CHANNEL*        channel;
+    MUX*            mux;
+    USERCONFIGDATA* cdata;
+    sint8*          newdata;
+    int32           enabled_channels;
+    int32           sendqueue_length;
+    int32           receivequeue_length;
+    int32           index;
+    int32           remaining_space;
+    int32           result;
+
+    DEBUG("GenerateStatusReport(0x%p)\n", config);
+
+    mux   = config->mux;
+    cdata = (USERCONFIGDATA*)config->user_interface_data;
+
+    enter_write_criticalsection(&mux->lock);
+
+    remaining_space             = cdata->host_config_datasize;
+    cdata->host_config_dataused = 0;
+    enabled_channels            = 0;
+    result                      = 0;
+    channels                    = mux->channels;
+    receivequeue_length         = queue_length(&mux->receive_queue);
+    sendqueue_length            = queue_length(&mux->send_queue);
+
+    for(index = 0; index < mux->maxchannels; index++)
+    {
+        if(channels[index])
+            enabled_channels++;
+    }
+
+    do
+    {
+        if(result)
+        {
+            newdata = alloc_mem(result+1);
+
+            memcpy(newdata, cdata->host_config_data, cdata->host_config_dataused);
+            free_mem(cdata->host_config_data);
+
+            cdata->host_config_data     = newdata;
+            cdata->host_config_datasize = result+1;
+            remaining_space             = cdata->host_config_datasize-cdata->host_config_dataused;
+        }
+
+        result = (int32)snprintf(
+                          &cdata->host_config_data[cdata->host_config_dataused],
+                          remaining_space,
+                          "\n\nStatus of the MUX:\n"
+                              "\tStatus flag value: %lu\n"
+                              "\tTotal amount of data queued: %lu\n"
+                              "\tNumber of channels enabled: %lu\n"
+                              "\tLocal receive buffer size: %lu\n"
+                              "\tRemote receive buffer size: %lu\n"
+                              "\tSend buffers available: %lu\n"
+                              "\tMUX Send Queue Status:\n"
+                                  "\t\tNumber of items queued: %lu\n"
+                              "\tMux Receive Queue Status:\n"
+                                  "\t\tNumber of items queued: %lu\n"
+                              "\tSend task state value: %u\n"
+                              "\tReceive task state value: %u\n"
+                              "\tShutdown task state value: %u\n"
+                              "\tMUX Partial Receive Status:\n"
+                                  "\t\tType: %u\n"
+                                  "\t\tExpected length: %lu\n"
+                                  "\t\tCurrent length: %lu\n"
+                          "\n\n",
+                          mux->status,
+                          mux->total_queued_amount,
+                          enabled_channels,
+                          mux->local_rcv_buffer_size,
+                          mux->remote_rcv_buffer_size,
+                          mux->send_buffers_available,
+                          sendqueue_length,
+                          receivequeue_length,
+                          mux->send_task.state,
+                          mux->receive_task.state,
+                          mux->shutdown_task.state,
+                          mux->partial_receive.type,
+                          mux->partial_receive.expectedLen,
+                          mux->partial_receive.currentLen
+                         );
+    }while(result >= remaining_space);
+
+    cdata->host_config_dataused += result;
+    remaining_space             -= result;
+
+    for(index = 0; index < mux->maxchannels; index++)
+    {
+        if(!channels[index])
+            continue;
+
+        result        = 0;
+        channel       = channels[index];
+        channelcredit = &mux->channelcredit[index];
+
+        do
+        {
+            if(result)
+            {
+                newdata = alloc_mem(cdata->host_config_dataused+result+1);
+
+                memcpy(newdata, cdata->host_config_data, cdata->host_config_dataused);
+                free_mem(cdata->host_config_data);
+
+                cdata->host_config_data     = newdata;
+                cdata->host_config_datasize = cdata->host_config_dataused+result+1;
+                remaining_space             = cdata->host_config_datasize-cdata->host_config_dataused;
+            }
+
+            receivequeue_length  = queue_length(&channel->receive_queue);
+            sendqueue_length     = queue_length(&channel->send_queue);
+
+            result = (int32)snprintf(
+                        &cdata->host_config_data[cdata->host_config_dataused],
+                        remaining_space,
+                        "\n\nStatus of Channel %lu:\n"
+                            "\tChannel Send Queue Status:\n"
+                                "\t\tNumber of items queued: %lu\n"
+                            "\tChannel Receive Queue Status:\n"
+                                "\t\tNumber of items queued: %lu\n"
+                            "\tBurst size: %lu\n"
+                            "\tMax queued data: %lu\n"
+                            "\tCurrent queued data: %lu\n"
+                            "\tState: %lu\n"
+                            "\tChannel Credit Status:\n"
+                                "\t\tMax host byte credit: %lu\n"
+                                "\t\tMax host send credit: %lu\n"
+                                "\t\tClient byte credit: %lu\n"
+                                "\t\tClient send credit: %lu\n"
+                                "\t\tReplenished byte credit: %lu\n"
+                                "\t\tReplenished send credit: %lu\n"
+                        "\n\n",
+                        index,
+                        sendqueue_length,
+                        receivequeue_length,
+                        channel->burst_size,
+                        channel->max_data_amount,
+                        channel->qed_data_amount,
+                        channel->state,
+                        channelcredit->max_host_byte_credit,
+                        channelcredit->max_host_send_credit,
+                        channelcredit->client_byte_credit,
+                        channelcredit->client_send_credit,
+                        channelcredit->replenished_byte_credit,
+                        channelcredit->replenished_send_credit
+                      );
+        }while(result >= remaining_space);
+
+        cdata->host_config_dataused += result;
+        remaining_space             -= result;
+    }
+
+    cdata->host_config_dataused++;
+
+    exit_write_criticalsection(&mux->lock);
+}
+
+static
+void ProcessClientConfigRequest (int8 type, CONFIGINTERFACE* config, COMMBUFF* commbuff)
+{
+    USERCONFIG_STATUS       statuspacket;
+    USERCONFIG_ADJUSTCREDIT creditpacket;
+    USERCONFIGDATA*         cdata;
+    CHANNELCREDIT*          credit;
+    MUX*                    mux;
+    COMMBUFF*               senddata;
+    int32                   size;
+    int32                   result;
+
+    DEBUG(
+          "ProcessClientConfigRequest(%lu, 0x%p, 0x%p)\n",
+          (int32)type,
+          config,
+          commbuff
+         );
+
+    cdata = (USERCONFIGDATA*)config->user_interface_data;
+    mux   = config->mux;
+
+    switch(type)
+    {
+        case CONFIG_USERIF_ADJUSTCREDIT:
+        {
+            commbuff_copyout((void*)&creditpacket, commbuff, 0, sizeof(USERCONFIG_ADJUSTCREDIT));
+            commbuff_remove_front(commbuff, sizeof(USERCONFIG_ADJUSTCREDIT));
+
+            convert_dword(creditpacket.channel_valid);
+            convert_dword(creditpacket.channel);
+            convert_dword(creditpacket.max_host_byte_credit);
+            convert_dword(creditpacket.max_host_send_credit);
+            convert_dword(creditpacket.replenished_byte_credit);
+            convert_dword(creditpacket.replenished_send_credit);
+            convert_dword(creditpacket.client_byte_credit);
+            convert_dword(creditpacket.client_send_credit);
+            convert_dword(creditpacket.global_send_credit);
+
+            enter_write_criticalsection(&mux->lock);
+
+            if(creditpacket.channel_valid)
+            {
+                credit = &mux->channelcredit[creditpacket.channel];
+
+                credit->client_byte_credit      += creditpacket.client_byte_credit;
+                credit->client_send_credit      += creditpacket.client_send_credit;
+                credit->replenished_byte_credit += creditpacket.replenished_byte_credit;
+                credit->replenished_send_credit += creditpacket.replenished_send_credit;
+                credit->max_host_byte_credit    += creditpacket.max_host_byte_credit;
+                credit->max_host_send_credit    += creditpacket.max_host_send_credit;
+            }
+
+            mux->send_buffers_available += creditpacket.global_send_credit;
+
+            exit_write_criticalsection(&mux->lock);
+        }break;
+
+        case CONFIG_USERIF_STATUSREPORT:
+        {
+            commbuff_copyout((void*)&statuspacket, commbuff, 0, sizeof(USERCONFIG_STATUS));
+            commbuff_remove_front(commbuff, sizeof(USERCONFIG_STATUS));
+
+            convert_dword(statuspacket.request);
+            convert_dword(statuspacket.size);
+
+            if(statuspacket.request)
+            {
+                enter_write_criticalsection(&cdata->config_synch);
+
+                GenerateStatusReport(config);
+
+                size     = cdata->host_config_dataused+sizeof(USERCONFIG_STATUS)+sizeof(int8);
+                senddata = alloc_commbuff(size, sizeof(DATA_PACKET_HDR));
+
+                statuspacket.request = 0;
+                statuspacket.size    = cdata->host_config_dataused;
+
+                convert_dword(statuspacket.request);
+                convert_dword(statuspacket.size);
+
+                type = CONFIG_USERIF_STATUSREPORT;
+
+                commbuff_copyin(senddata, 0, (void*)&type, sizeof(int8));
+                commbuff_copyin(
+                                senddata,
+                                sizeof(int8),
+                                (void*)&statuspacket,
+                                sizeof(USERCONFIG_STATUS)
+                               );
+                commbuff_copyin(
+                                senddata,
+                                sizeof(int8) + sizeof(USERCONFIG_STATUS),
+                                cdata->host_config_data,
+                                cdata->host_config_dataused
+                               );
+
+                result = SendData(config->channel, senddata, 0, config->mux);
+                if(result != ERROR_NONE)
+                    free_commbuff(senddata);
+
+                exit_write_criticalsection(&cdata->config_synch);
+            }
+            else
+            {
+                enter_write_criticalsection(&cdata->config_synch);
+
+                if(cdata->client_config_data)
+                {
+                    free_mem(cdata->client_config_data);
+
+                    cdata->client_config_data     = 0;
+                    cdata->client_config_datasize = 0;
+                }
+
+                cdata->client_config_data = int_alloc_mem(statuspacket.size);
+                cdata->client_config_datasize = statuspacket.size;
+
+                commbuff_copyout(cdata->client_config_data, commbuff, 0, statuspacket.size);
+
+                exit_write_criticalsection(&cdata->config_synch);
+
+                wake_up_interruptible(&cdata->event_wait);
+            }
+        }break;
+    }
+}
+
+static void ProcessClientCommands (struct work_struct *work)
+{
+    CONFIGINTERFACE* config;
+    USERCONFIGDATA*  cdata;
+    COMMBUFF*        commanddata;
+    int8             type;
+
+    cdata = container_of (work, USERCONFIGDATA, commandtask.work);
+    config = cdata->config; 
+
+    commanddata = dequeue_commbuff(&cdata->commandqueue);
+
+    while(commanddata)
+    {
+        commbuff_copyout((void*)&type, commanddata, 0, sizeof(int8));
+        commbuff_remove_front(commanddata, sizeof(int8));
+
+        ProcessClientConfigRequest(type, config, commanddata);
+        free_commbuff(commanddata);
+
+        commanddata = dequeue_commbuff(&cdata->commandqueue);
+    }
+}
+
+int ReadConfiguredHostNetMUXStatus (
+                                    char*  destination,
+                                    char** start,
+                                    off_t  offset,
+                                    int    count,
+                                    int*   eof,
+                                    void*  param
+                                   )
+{
+    CONFIGINTERFACE* config;
+    USERCONFIGDATA*  cdata;
+    int              bytes;
+
+    DEBUG(
+          "ReadConfiguredHostNetMUXStatus(0x%p, 0x%p, %lu, %d, 0x%p, 0x%p)\n",
+          destination,
+          start,
+          offset,
+          count,
+          eof,
+          param
+         );
+
+    config = (CONFIGINTERFACE*)param;
+    cdata  = config->user_interface_data;
+
+    enter_write_criticalsection(&cdata->config_synch);
+
+    if(offset)
+    {
+        bytes = cdata->host_config_dataused-offset;
+        if(bytes < 0)
+        {
+            *eof = 1;
+            return 0;
+        }
+
+        if(bytes > count)
+            bytes = count;
+
+        memcpy(destination, &cdata->host_config_data[offset], bytes);
+
+        exit_write_criticalsection(&cdata->config_synch);
+
+	*start = destination;
+
+        return bytes;
+    }
+
+    GenerateStatusReport(config);
+
+    bytes = cdata->host_config_dataused;
+    if(bytes > count)
+        bytes = count;
+
+    memcpy(destination, cdata->host_config_data, bytes);
+
+    exit_write_criticalsection(&cdata->config_synch);
+
+    *start = destination;
+
+    return bytes;
+}
+
+int ConfigureHostNetMUXStatus (
+                               struct file*  fileid,
+                               const char*   data,
+                               unsigned long count,
+                               void*         param
+                              )
+{
+    char                    buffer[128]  = {0};
+    char                    command[128];
+    USERCONFIG_ADJUSTCREDIT credit;
+    CONFIGINTERFACE*        config;
+    USERCONFIGDATA*         cdata;
+    COMMBUFF*               senddata;
+    int32                   size;
+    int                     bytes;
+    int                     input;
+
+    DEBUG(
+          "ConfigureHostNetMUXStatus(0x%p, 0x%p, %lu, 0x%p)\n",
+          fileid,
+          data,
+          count,
+          param
+         );
+
+    config = (CONFIGINTERFACE*)param;
+    cdata  = config->user_interface_data;
+
+    if(count >= 128)
+        return -EINVAL;
+
+    bytes = copy_from_user(buffer, data, count);
+    if(bytes)
+        return -EFAULT;
+
+    sscanf(
+           buffer,
+           "%s ",
+           command
+          );
+
+    if(!strcmp(command, "credit"))
+    {
+        input = sscanf(
+                       buffer,
+                       "%s %d %lu %lu %lu %lu %lu %lu %lu",
+                       command,
+                       (int*)&credit.channel,
+                       &credit.max_host_byte_credit,
+                       &credit.max_host_send_credit,
+                       &credit.replenished_byte_credit,
+                       &credit.replenished_send_credit,
+                       &credit.client_byte_credit,
+                       &credit.client_send_credit,
+                       &credit.global_send_credit
+                      );
+        if(input < 10)
+            return -EINVAL;
+
+        if(credit.channel == (int32)-1)
+            credit.channel_valid = 0;
+        else
+            credit.channel_valid = 1;
+
+        convert_dword(&credit.channel_valid);
+        convert_dword(&credit.channel);
+        convert_dword(&credit.max_host_byte_credit);
+        convert_dword(&credit.max_host_send_credit);
+        convert_dword(&credit.replenished_byte_credit);
+        convert_dword(&credit.replenished_send_credit);
+        convert_dword(&credit.client_byte_credit);
+        convert_dword(&credit.client_send_credit);
+        convert_dword(&credit.global_send_credit);
+
+        size     = sizeof(USERCONFIG_ADJUSTCREDIT);
+        senddata = alloc_commbuff(size, sizeof(DATA_PACKET_HDR));
+
+        commbuff_copyin(
+                        senddata,
+                        0,
+                        (void*)&credit,
+                        sizeof(USERCONFIG_ADJUSTCREDIT)
+                       );
+
+        ProcessClientConfigRequest(CONFIG_USERIF_ADJUSTCREDIT, config, senddata);
+
+        deref_commbuff(senddata);
+    }
+    else
+        return -EINVAL;
+
+    return count;
+}
+
+int ReadConfiguredClientNetMUXStatus (
+                                      char*  destination,
+                                      char** start,
+                                      off_t  offset,
+                                      int    count,
+                                      int*   eof,
+                                      void*  param
+                                     )
+{
+    USERCONFIG_STATUS statuspacket;
+    CONFIGINTERFACE*  config;
+    USERCONFIGDATA*   cdata;
+    COMMBUFF*         senddata;
+    int32             size;
+    int32             result;
+    int8              type;
+    int               bytes;
+
+    DEBUG(
+          "ReadConfiguredClientNetMUXStatus(0x%p, 0x%p, %d, %d, 0x%p, 0x%p)\n",
+          destination,
+          start,
+          (int)offset,
+          count,
+          eof,
+          param
+         );
+
+    config = (CONFIGINTERFACE*)param;
+    cdata  = config->user_interface_data;
+
+    enter_write_criticalsection(&cdata->config_synch);
+
+    if(offset)
+    {
+        bytes = cdata->client_config_datasize-offset;
+        if(bytes < 0)
+        {
+            *eof = 1;
+
+            return 0;
+        }
+
+        if(bytes > count)
+            bytes = count;
+        else
+            *eof = 1;
+
+        memcpy(destination, &cdata->client_config_data[offset], bytes);
+
+        exit_write_criticalsection(&cdata->config_synch);
+
+        return bytes;
+    }
+
+    if(cdata->client_config_data)
+    {
+        free_mem(cdata->client_config_data);
+
+        cdata->client_config_data     = 0;
+        cdata->client_config_datasize = 0;
+    }
+
+    size     = sizeof(USERCONFIG_STATUS)+sizeof(int8);
+    senddata = alloc_commbuff(size, sizeof(DATA_PACKET_HDR));
+
+    statuspacket.request = 1;
+    statuspacket.size    = 0;
+
+    convert_dword(statuspacket.request);
+    convert_dword(statuspacket.size);
+
+    type = CONFIG_USERIF_STATUSREPORT;
+
+    commbuff_copyin(senddata, 0, (void*)&type, sizeof(int8));
+    commbuff_copyin(
+                    senddata,
+                    sizeof(int8),
+                    (void*)&statuspacket,
+                    sizeof(USERCONFIG_STATUS)
+                   );
+
+    result = SendData(config->channel, senddata, 0, config->mux);
+    if(result != ERROR_NONE)
+    {
+        exit_write_criticalsection(&cdata->config_synch);
+        free_commbuff(senddata);
+
+        return -EBUSY;
+    }
+
+    exit_write_criticalsection(&cdata->config_synch);
+    interruptible_sleep_on_timeout(&cdata->event_wait, HZ*10);
+    enter_write_criticalsection(&cdata->config_synch);
+
+    bytes = cdata->client_config_datasize;
+
+    if(cdata->client_config_data)
+    {
+        if(bytes > count)
+            bytes = count;
+        else
+            *eof = 1;
+
+        memcpy(destination, cdata->client_config_data, bytes);
+    }
+
+    exit_write_criticalsection(&cdata->config_synch);
+
+    return bytes;
+}
+
+int ConfigureClientNetMUXStatus (
+                                 struct file* fileid,
+                                 const char*   data,
+                                 unsigned long count,
+                                 void*         param
+                                )
+{
+    char                    buffer[128]  = {0};
+    char                    command[128];
+    USERCONFIG_ADJUSTCREDIT credit;
+    CONFIGINTERFACE*        config;
+    USERCONFIGDATA*         cdata;
+    COMMBUFF*               senddata;
+    int32                   size;
+    int32                   type;
+    int32                   result;
+    int                     bytes;
+    int                     input;
+
+    DEBUG(
+          "ConfigureClientNetMUXStatus(0x%p, 0x%p, %lu, 0x%p)\n",
+          fileid,
+          data,
+          count,
+          param
+         );
+
+    config = (CONFIGINTERFACE*)param;
+    cdata  = config->user_interface_data;
+
+    if(count >= 128)
+        return -EINVAL;
+
+    bytes = copy_from_user(buffer, data, count);
+    if(bytes)
+        return -EFAULT;
+
+    sscanf(
+           buffer,
+           "%s ",
+           command
+          );
+
+    if(!strcmp(command, "credit"))
+    {
+        input = sscanf(
+                       buffer,
+                       "%s %d %lu %lu %lu %lu %lu %lu %lu",
+                       command,
+                       (int*)&credit.channel,
+                       &credit.max_host_byte_credit,
+                       &credit.max_host_send_credit,
+                       &credit.replenished_byte_credit,
+                       &credit.replenished_send_credit,
+                       &credit.client_byte_credit,
+                       &credit.client_send_credit,
+                       &credit.global_send_credit
+                      );
+        if(input < 10)
+            return -EINVAL;
+
+        if(credit.channel == (int32)-1)
+            credit.channel_valid = 0;
+        else
+            credit.channel_valid = 1;
+
+        convert_dword(&credit.channel_valid);
+        convert_dword(&credit.channel);
+        convert_dword(&credit.max_host_byte_credit);
+        convert_dword(&credit.max_host_send_credit);
+        convert_dword(&credit.replenished_byte_credit);
+        convert_dword(&credit.replenished_send_credit);
+        convert_dword(&credit.client_byte_credit);
+        convert_dword(&credit.client_send_credit);
+        convert_dword(&credit.global_send_credit);
+
+        size     = sizeof(USERCONFIG_ADJUSTCREDIT)+sizeof(int8);
+        senddata = alloc_commbuff(size, sizeof(DATA_PACKET_HDR));
+
+        type = CONFIG_USERIF_ADJUSTCREDIT;
+
+        commbuff_copyin(senddata, 0, (void*)&type, sizeof(int8));
+        commbuff_copyin(
+                        senddata,
+                        sizeof(int8),
+                        (void*)&credit,
+                        sizeof(USERCONFIG_ADJUSTCREDIT)
+                       );
+
+        result = SendData(config->channel, senddata, 0, config->mux);
+        if(result != ERROR_NONE)
+        {
+            free_commbuff(senddata);
+
+            return -EBUSY;
+        }
+    }
+    else
+        return -EINVAL;
+
+    return count;
+}
+
+int32 StartupConfigUserInterface (CONFIGINTERFACE* config)
+{
+    static int32   id                     = 0;
+    sint8           host_entry_name[32];
+    sint8           client_entry_name[32];
+    USERCONFIGDATA* cdata;
+    int32           size;
+
+    DEBUG("StartupConfigUserInterface(0x%p)\n", config);
+
+    sprintf(host_entry_name, "%s%lu", CONFIG_INTERFACE_NAME "_host", id);
+    sprintf(client_entry_name, "%s%lu", CONFIG_INTERFACE_NAME "_client", id);
+
+    cdata         = alloc_mem(sizeof(USERCONFIGDATA));
+    cdata->mux_id = id;
+
+    id++;
+
+    cdata->host_config_file = create_proc_entry(host_entry_name, 0644, 0);
+    if(!cdata->host_config_file)
+        goto CREATE_HOSTPROCENTRY_FAILED;
+
+    cdata->host_config_file->owner      = THIS_MODULE;
+    cdata->host_config_file->data       = (void*)config;
+    cdata->host_config_file->read_proc  = &ReadConfiguredHostNetMUXStatus;
+    cdata->host_config_file->write_proc = &ConfigureHostNetMUXStatus;
+
+    cdata->client_config_file = create_proc_entry(client_entry_name, 0644, 0);
+    if(!cdata->client_config_file)
+        goto CREATE_CLIENTPROCENTRY_FAILED;
+
+    cdata->client_config_file->owner      = THIS_MODULE;
+    cdata->client_config_file->data       = (void*)config;
+    cdata->client_config_file->read_proc  = &ReadConfiguredClientNetMUXStatus;
+    cdata->client_config_file->write_proc = &ConfigureClientNetMUXStatus;
+
+    size = sizeof(sint8)*DEFAULT_CONFIG_DATASIZE;
+
+    cdata->host_config_data   = alloc_mem(size);
+    cdata->client_config_data = 0;
+   
+    cdata->config = config;
+
+    cdata->host_config_datasize   = size;
+    cdata->client_config_datasize = 0;
+    cdata->host_config_dataused   = 0;
+
+    initialize_commbuff_queue(&cdata->commandqueue);
+    initialize_criticalsection_lock(&cdata->config_synch);
+    init_waitqueue_head(&cdata->event_wait);
+    initialize_task(&cdata->commandtask, &ProcessClientCommands);
+
+    config->user_interface_data = (void*)cdata;
+
+    return DEBUGERROR(ERROR_NONE);
+
+CREATE_CLIENTPROCENTRY_FAILED:
+    remove_proc_entry(host_entry_name, 0);
+
+CREATE_HOSTPROCENTRY_FAILED:
+    return DEBUGERROR(ERROR_OPERATIONFAILED);
+}
+
+void ShutdownConfigUserInterface (CONFIGINTERFACE* config)
+{
+    sint8           host_entry_name[32];
+    sint8           client_entry_name[32];
+    USERCONFIGDATA* cdata;
+
+    DEBUG("StartupConfigUserInterface(0x%p)\n", config);
+
+    cdata = (USERCONFIGDATA*)config->user_interface_data;
+
+    sprintf(host_entry_name, "%s%lu", CONFIG_INTERFACE_NAME "_host", cdata->mux_id);
+    sprintf(client_entry_name, "%s%lu", CONFIG_INTERFACE_NAME "_client", cdata->mux_id);
+
+    remove_proc_entry(host_entry_name, 0);
+    remove_proc_entry(client_entry_name, 0);
+
+    destroy_task(&cdata->commandtask);
+    destroy_commbuff_queue(&cdata->commandqueue);
+    destroy_criticalsection_lock(&cdata->config_synch);
+
+    if(cdata->client_config_data)
+        free_mem(cdata->client_config_data);
+
+    free_mem(cdata->host_config_data);
+    free_mem(cdata);
+}
+
+void ReceiveClientConfigRequest (CONFIGINTERFACE* config, COMMBUFF* commbuff)
+{
+    USERCONFIGDATA* cdata;
+
+    DEBUG(
+          "ReceiveClientConfigRequest(0x%p, 0x%p)\n",
+          config,
+          commbuff
+         );
+
+    cdata = (USERCONFIGDATA*)config->user_interface_data;
+
+    queue_commbuff(commbuff, &cdata->commandqueue);
+    task_schedule(&cdata->commandtask);
+}
diff --git a/drivers/misc/netmux/config.h b/drivers/misc/netmux/config.h
new file mode 100755
index 0000000..c8eed61
--- /dev/null
+++ b/drivers/misc/netmux/config.h
@@ -0,0 +1,256 @@
+/******************************************************************************
+ * NetMUX config.h                                                            *
+ *                                                                            *
+ * Copyright (C) Motorola 2006                                                *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ ******************************************************************************/
+
+/* config.h is responsible for setting up constant values and data types to   */
+/* be used by config.c as well as channelconfig.c                             */
+
+#ifndef _NETMUX_CONFIG_H_
+#define _NETMUX_CONFIG_H_
+
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "mux.h"
+#include "protocol.h"
+
+
+/*
+ * Definition of different commands the config interface knows about
+ */
+#define CONFIG_CORE_TYPE           0
+#define CONFIG_USERIF_STATUSREPORT 1
+#define CONFIG_USERIF_ADJUSTCREDIT 2
+
+/*
+ * Definitions to define standard parameters
+ */
+#define CONFIG_BURSTSIZE   10000
+#define CONFIG_MAXDATA     10000
+#define CONFIG_BYTECREDIT  10000
+#define CONFIG_SENDCREDIT  10
+
+/*
+ * Definitions to declare possible states for the interface
+ */
+#define CONFIG_STATE_DEFAULT    0
+#define CONFIG_STATE_ENABLING   1
+#define CONFIG_STATE_CONNECTING 2
+#define CONFIG_STATE_CONNECTED  3
+
+/*
+ * Definitions to declare possible states for the configuration data
+ */
+#define CONFIGDATA_STATE_DEFAULT    0
+#define CONFIGDATA_STATE_VERIFIED   1
+#define CONFIGDATA_STATE_DISTRIBUTE 2
+
+/*
+ * Definition of the config interface name
+ */
+#define CONFIG_INTERFACE_NAME "netmux_config"
+
+/*
+ * Initial amount of memory used to hold a status report
+ */
+#define DEFAULT_CONFIG_DATASIZE 4096
+
+
+/*
+ * CONFIGDATA defines a structure used for channel description and declaration.
+ * The format is briefly described below.
+ *
+ * channel represents the channel number
+ * channel_extra is additional data to be associated with the channel
+ * channel_name names the channel
+ * host_interface defines the host interface to be used with this channel
+ * host_interface_index is the interface id of the host interface
+ * host_burstsize is the maximum amount of data that can be sent at a time hostly
+ * host_maxdata is the maximum amount of data that can be queued hostly
+ * host_byte_credit is the initial amount of byte credit delivered to the client on open
+ * host_send_credit is the initial amount of send credit delivered to the client on open
+ * client_interface defines the client interface to be used with this channel
+ * client_interface_index defines the interface id of the client interface
+ * client_burstsize defines the maximum amount of data that can be sent a time cliently
+ * client_maxdata defines the maximum amount of data the can be queued cliently
+ * client_byte_credit is the max number of bytes the host can send to the client
+ * client_send_credit is the max number of sends the host can perform to the client
+ * state is the current state of this configuration data entry
+ * msgid stores the 4 byte message id, used by RTA
+ */
+typedef struct CONFIGDATA
+{
+    int32 channel;
+    int32 channel_extra;
+    sint8 channel_name[PACKET_MAXNAME_LENGTH];
+    sint8 host_interface[PACKET_MAXNAME_LENGTH];
+    int32 host_interface_id;
+    int32 host_burstsize;
+    int32 host_maxdata;
+    int32 host_byte_credit;
+    int32 host_send_credit;
+    sint8 client_interface[PACKET_MAXNAME_LENGTH];
+    int32 client_interface_id;
+    int32 client_burstsize;
+    int32 client_maxdata;
+    int32 client_byte_credit;
+    int32 client_send_credit;
+    int32 state;
+    int32 msgid;
+}CONFIGDATA;
+
+/*
+ * CONFIGPACKET defines the configuration data to be transmitted.
+ * The format is briefly described below.
+ *
+ * channel represents the channel to associate this data with
+ * host_interface is the interface id for the channel to communicate on
+ * client_interface is the interface id on which this data should be used
+ * client_burstsize is the maximum amount of data that can be sent at a time
+ * client_maxdata is the maximum amount of data that can be queued at a time
+ * client_byte_credit is the max number of bytes the host can send to the client
+ * client_send_credit is the max number of sends the host can perform to the client
+ * channel_extra is additional data to be associated with the channel
+ * channel_name is the name of the channel
+ */
+START_PACKED_STRUCT(CONFIGPACKET)
+    PACKED_MEMBER(int32 channel);
+    PACKED_MEMBER(int32 host_interface);
+    PACKED_MEMBER(int32 client_interface);
+    PACKED_MEMBER(int32 client_burstsize);
+    PACKED_MEMBER(int32 client_maxdata);
+    PACKED_MEMBER(int32 client_byte_credit);
+    PACKED_MEMBER(int32 client_send_credit);
+    PACKED_MEMBER(int32 channel_extra);
+    PACKED_MEMBER(sint8 channel_name[PACKET_MAXNAME_LENGTH]);
+END_PACKED_STRUCT(CONFIGPACKET)
+
+/*
+ * USERCONFIG_ADJUSTCREDIT defines a packet type that is used when a user
+ * issues a command to adjust mux credit levels.
+ *
+ * channel_valid indicates whether or not a channels credit levels should be tweaked
+ * channel is the channel to tweak the credit levels on
+ * max_host_byte_credit is the amount to tweak the channels max byte credit value by
+ * max_host_send_credit is the amount to tweak the channels max send credit value by
+ * replenished_byte_credit is the amount to tweak the channels replenished byte credit value by
+ * replenished_send_credit is the amount to tweak the channels replenished send credit value by
+ * client_byte_credit is the amount to tweak the channels client byte credit value by
+ * client_send_credit is the amount to tweak the channels client send credit value by
+ * global_send_credit is the amount to tweak the muxs send credit by
+ * max_global_send_credit is the amount to tweak the muxs max send credit by
+ */
+START_PACKED_STRUCT(USERCONFIG_ADJUSTCREDIT)
+    PACKED_MEMBER(int32 channel_valid);
+    PACKED_MEMBER(int32 channel);
+    PACKED_MEMBER(int32 max_host_byte_credit);
+    PACKED_MEMBER(int32 max_host_send_credit);
+    PACKED_MEMBER(int32 replenished_byte_credit);
+    PACKED_MEMBER(int32 replenished_send_credit);
+    PACKED_MEMBER(int32 client_byte_credit);
+    PACKED_MEMBER(int32 client_send_credit);
+    PACKED_MEMBER(int32 global_send_credit);
+    PACKED_MEMBER(int32 max_global_send_credit);
+END_PACKED_STRUCT(USERCONFIG_ADJUSTCREDIT)
+
+/*
+ * USERCONFIG_STATUS defines a packet type that is used when a user
+ * issues a command to request or deliver a mux status report
+ *
+ * request indicates whether the user is asking for a report or delivering one
+ * size is only valid if request = 0 and it indicates the size of the report
+ * data is an array of size 'size' and it contains the status report
+ */
+START_PACKED_STRUCT(USERCONFIG_STATUS)
+    PACKED_MEMBER(int32 request);
+    PACKED_MEMBER(int32 size);
+
+    PACKED_MEMBER(int8 data[0]);
+END_PACKED_STRUCT(USERCONFIG_STATUS)
+
+
+/*
+ * CONFIGINTERFACE defines parameters for the configuration interface.
+ * The format is briefly described below.
+ *
+ * configdata points to channel configuration data
+ * configdata_count specifies the number of entries in configdata
+ * host_interface is the host interface id of the config interface
+ * client_interface is the client interface id of the config interface
+ * channel is the channel the config interface operates on
+ * state is the current state of the config interface
+ * host is non zero if the config interface is to act as a host
+ * mux points to the MUX object to be oeprated on
+ * user_interface_data points to environment specific data used for user configuration
+ */
+typedef struct CONFIGINTERFACE
+{
+    CONFIGDATA*     configdata;
+    int32           configdata_count;
+    int32           host_interface;
+    int32           client_interface;
+    int32           channel;
+    int32           state;
+    int32           host;
+    MUX*            mux;
+
+    void* user_interface_data;
+}CONFIGINTERFACE;
+
+
+/*
+ * Define various functions used by the config interface
+ */
+
+int32 ConfigInform  (void*, void*);
+int32 ConfigReceive (COMMBUFF*, void*);
+
+int32 CreateConfigInterface  (int32, MUX*, int32, CONFIGDATA*, CONFIGINTERFACE**);
+int32 DestroyConfigInterface (CONFIGINTERFACE*);
+
+int32 ActivateConfigInterface   (int32, CONFIGINTERFACE*);
+int32 DeactivateConfigInterface (CONFIGINTERFACE*);
+
+int32 GenerateConfigPacket (CONFIGDATA*, CONFIGINTERFACE*);
+
+int32 StartupConfigUserInterface  (CONFIGINTERFACE*);
+void  ShutdownConfigUserInterface (CONFIGINTERFACE*);
+
+void ReceiveClientConfigRequest (CONFIGINTERFACE*, COMMBUFF*);
+
+
+#endif
diff --git a/drivers/misc/netmux/debug.c b/drivers/misc/netmux/debug.c
new file mode 100755
index 0000000..88b4143
--- /dev/null
+++ b/drivers/misc/netmux/debug.c
@@ -0,0 +1,144 @@
+/******************************************************************************
+ * NetMUX debug.c                                                             *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ ******************************************************************************/
+
+/* debug.c provides functions that only get used when logging or debugging    */
+/* are turned on.  The defined functions output data via the provided output  */
+/* function declared in utility.*.                                            */
+
+#include "debug.h"
+
+
+/*
+ * debug_error provides a mechanism to record the result of an error.
+ * This function is generally called at the return of a function to
+ * assist in debugging any function failures.
+ *
+ * Params:
+ * function -- the name of the function the error occurred in
+ * file -- the file the function resides in
+ * line -- the line number the error was reported on
+ * code -- the error code to be reported
+ *
+ * Returns:
+ * int32 -- the same value as code
+ */
+int32 debug_error (sint8* function, sint8* file, int32 line, int32 code)
+{
+    switch(code)
+    {
+        case ERROR_NONE:
+        {
+            DEBUG("%s returned SUCCESS [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        case ERROR_INVALIDPARAMETER:
+        {
+            DEBUG("%s returned ERROR_INVALIDPARAMETER [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        case ERROR_MEMORY:
+        {
+            DEBUG("%s returned ERROR_MEMORY [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        case ERROR_OPERATIONFAILED:
+        {
+            DEBUG("%s returned ERROR_OPERATIONFAILED [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        case ERROR_OPERATIONRESTRICTED:
+        {
+            DEBUG("%s returned ERROR_OPERATIONRESTRICTED [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        case ERROR_INCOMPLETE:
+        {
+            DEBUG("%s returned ERROR_INCOMPLETE [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        default:
+        {
+            DEBUG("%s returned UNKNOWN ERROR [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+    }
+
+    return code;
+}
+
+/*
+ * debug_ldp provides a mechanism to record the result of an error in 
+ * the linkdriver protocol. This function is generally called at the 
+ * return of a function to assist in debugging any function failures.
+ *
+ * Params:
+ * function -- the name of the function the error occurred in
+ * file -- the file the function resides in
+ * line -- the line number the error was reported on
+ * code -- the error code to be reported
+ *
+ * Returns:
+ * int32 -- the same value as code
+ */
+int32 debug_ldp (sint8* function, sint8* file, int32 line, int32 code)
+{
+    switch(code)
+    {
+        case LDP_ERROR_NONE:
+        {
+            DEBUG("%s returned SUCCESS [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        case LDP_ERROR_FATAL:
+        {
+            DEBUG("%s returned LDP_ERROR_FATAL  [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        case LDP_ERROR_RECOVERABLE:
+        {
+            DEBUG("%s returned LDP_ERROR_RECOVERABLE [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+
+        default:
+        {
+            DEBUG("%s returned UNKNOWN ERROR [%lu] at %s:%lu\n", function, code, file, line);
+        }break;
+    }
+
+    return code;
+}
+
diff --git a/drivers/misc/netmux/debug.h b/drivers/misc/netmux/debug.h
new file mode 100755
index 0000000..68d5536
--- /dev/null
+++ b/drivers/misc/netmux/debug.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ * NetMUX debug.h                                                             *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ ******************************************************************************/
+
+#ifndef _NETMUX_DEBUG_H_
+#define _NETMUX_DEBUG_H_
+
+
+#include "debug_host.h"
+#include "debug_client.h"
+
+
+#endif
diff --git a/drivers/misc/netmux/debug_client.h b/drivers/misc/netmux/debug_client.h
new file mode 100755
index 0000000..8f919b3
--- /dev/null
+++ b/drivers/misc/netmux/debug_client.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ * NetMUX debug_client.h                                                      *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/06/25  Motorola    Modified Copyright                               *
+ ******************************************************************************/
+
+#ifndef _NETMUX_DEBUG_CLIENT_H_
+#define _NETMUX_DEBUG_CLIENT_H_
+
+#endif
diff --git a/drivers/misc/netmux/debug_host.h b/drivers/misc/netmux/debug_host.h
new file mode 100755
index 0000000..4539973
--- /dev/null
+++ b/drivers/misc/netmux/debug_host.h
@@ -0,0 +1,167 @@
+/******************************************************************************
+ * NetMUX debug_host.h                                                        *
+ *                                                                            *
+ * Copyright (C) 2006-2008 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/06/25  Motorola    Modified Copyright                               *
+ *   2008/10/14  Motorola    Add two new panic ID                             *
+ ******************************************************************************/
+
+/* debug_host.h provides conditional macros that will resolve to something    */
+/* meaningful if debugging or logging is enabled. These macros will record    */
+/* data via the output function provided by the NetMUX utilities.             */
+
+#ifndef _NETMUX_DEBUG_HOST_H_
+#define _NETMUX_DEBUG_HOST_H_
+
+
+#include "shared/ldprotocol.h"
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+
+
+/* Reserved NetMUX Message/Primitive IDs */
+#define NETMUX_MSGID_BASE 0xA6800
+enum {
+    NETMUX_TRACE                  /* @LOG */
+                 = NETMUX_MSGID_BASE,
+    NETMUX_PACKET_INVALID,        /* @LOG */
+    NETMUX_PACKET_DATA,           /* @LOG */
+    NETMUX_PACKET_CREDIT,         /* @LOG */
+    NETMUX_PACKET_ENABLEMUX,      /* @LOG */
+    NETMUX_PACKET_DISABLEMUX,     /* @LOG */
+    NETMUX_PACKET_ENABLECHANNEL,  /* @LOG */
+    NETMUX_PACKET_DISABLECHANNEL, /* @LOG */
+    NETMUX_PACKET_QUERYINTERFACE, /* @LOG */
+    NETMUX_PACKET_CHANNELSIGNAL,  /* @LOG */
+    NETMUX_COMMBUFF_HEADER,       /* @LOG NETMUX_COMMBUFF_HEADER_T */
+    NETMUX_RECEIVE_FROM_LD,       /* @LOG */
+    NETMUX_CH_DATA_NSAPI5,        /* @LOG */
+    NETMUX_CH_DATA_NSAPI6,        /* @LOG */
+    NETMUX_CH_DATA_NSAPI7,        /* @LOG */
+    NETMUX_CH_DATA_NSAPI8,        /* @LOG */
+    NETMUX_CH_DATA_NSAPI9,        /* @LOG */
+    NETMUX_CH_DATA_NSAPI10,       /* @LOG */
+    NETMUX_CH_MUXTESTNET,         /* @LOG */
+    NETMUX_CH_UDI_CTRL,           /* @LOG */
+    NETMUX_CH_UDI_DATA,           /* @LOG */
+    NETMUX_CH_TEL,                /* @LOG */
+    NETMUX_CH_MM_AUDIO_DEC,       /* @LOG */
+    NETMUX_CH_MM_AUDIO_ENC,       /* @LOG */
+    NETMUX_CH_UDI_PTP,            /* @LOG */
+    NETMUX_CH_PSC5,               /* @LOG */
+    NETMUX_CH_PSC6,               /* @LOG */
+    NETMUX_CH_PSC7,               /* @LOG */
+    NETMUX_CH_PSC8,               /* @LOG */
+    NETMUX_CH_PSC9,               /* @LOG */
+    NETMUX_CH_PSC10,              /* @LOG */
+    NETMUX_CH_PS_CONTROL,         /* @LOG */
+    NETMUX_CH_AUDIO,              /* @LOG */
+    NETMUX_CH_NVM_PROXY,          /* @LOG */
+    NETMUX_CH_SIM_PROXY,          /* @LOG */
+    NETMUX_CH_POWER,              /* @LOG */
+    NETMUX_CH_GPS,                /* @LOG */
+    NETMUX_CH_TESTCMD,            /* @LOG */
+    NETMUX_CH_SUBSIDY_LOCK,       /* @LOG */
+    NETMUX_CH_EFEM,               /* @LOG */
+    NETMUX_CH_NETMON,             /* @LOG */
+    NETMUX_CH_OPPROF,             /* @LOG */
+    NETMUX_CH_UMA_URLC,           /* @LOG */
+    NETMUX_CH_UMA_RRC,            /* @LOG */
+    NETMUX_CH_DLOG,               /* @LOG */
+    NETMUX_CH_MUXTESTDIR1,        /* @LOG */
+    NETMUX_CH_MUXTESTDIR2,        /* @LOG */
+    NETMUX_CH_CS_DATA,            /* @LOG */
+    NETMUX_CH_MUXTESTTTY1,        /* @LOG */
+    NETMUX_CH_MUXTESTTTY2         /* @LOG */
+};
+
+typedef void *SU_PORT_HANDLE;
+
+void output (SU_PORT_HANDLE, int32, sint8*, ...);
+
+/*
+ * Define debugging macros
+ */
+int32 debug_error (sint8*, sint8*, int32, int32);
+int32 debug_ldp   (sint8*, sint8*, int32, int32);
+
+#define DEBUG(...) \
+  output(0, 0, __VA_ARGS__)
+#define DBGFC(...) \
+  output(0, 0, __VA_ARGS__)
+#define DEBUGERROR(code) \
+  debug_error((sint8*)__FUNCTION__, " ", __LINE__, code)
+#define DEBUGLDP(code) \
+  debug_ldp((sint8*)__FUNCTION__, " ", __LINE__, code)
+
+/*
+ * Define logging macros
+ */
+void log_commbuff (int32, sint8*, COMMBUFF*, int32);
+void log_packettype (COMMBUFF*);
+
+#define LOG_TRACE(...) \
+  output(0, 0, __VA_ARGS__)
+#define LOGCOMMBUFF_RECV_LD(h, cb, l) \
+  log_commbuff(0, h, cb, l)
+#define LOGCOMMBUFF_CH(ch_num, h, cb, l) \
+  log_commbuff(0, h, cb, l)
+#define LOGCOMMBUFF_PROTO(port, id, len, buff)
+#define LOG_PACKETTYPE(cb) \
+  log_packettype(cb)
+
+/*
+ * Define some panic location codes
+ */
+/*----------------------------------------------*/
+#define netmuxPanicFirst 0x00080c00
+/*----------------------------------------------*/
+#define netmuxPanicILDFail  0x00080c00
+#define netmuxPanicABSFail  0x00080c01
+#define netmuxPanicCBUFFail 0x00080c02
+#define netmuxPanicSKBFail1 0x00080c03
+#define netmuxPanicSKBFail2 0x00080c04
+#define netmuxPanicSKBFail3 0x00080c05
+#define netmuxPanicSKBFail4 0x00080c06
+#define netmuxPanicMemFail1 0x00080c07
+#define netmuxPanicMemFail2 0x00080c08
+#define netmuxPanicPkgFail1 0x00080c09
+#define netmuxPanicPkgFail2 0x00080c10
+/*----------------------------------------------*/
+#define netmuxPanicLast  0x00080c7f
+/*----------------------------------------------*/
+
+
+#endif
diff --git a/drivers/misc/netmux/direct.c b/drivers/misc/netmux/direct.c
new file mode 100755
index 0000000..5b40e96
--- /dev/null
+++ b/drivers/misc/netmux/direct.c
@@ -0,0 +1,738 @@
+/******************************************************************************
+ * NetMUX direct.c                                                            *
+ *                                                                            *
+ * Copyright (C) 2006-2010 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/11/15  Motorola    Fixed DestroyDirectInterface disable channel code* 
+ *   2006/11/18  Motorola    Fixed CreateDirectInterface() such that memory   *
+ *                           is now being allocated, while interrupts are not *
+ *                           disabled.                                        *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ *   2007/12/05  Motorola    port to kernel 2.6.22 for OMAP3430               * 
+ *   2008/07/09  Motorola    port to kernel 2.6.24 for TI 23.5                *
+ *   2008/10/25  Motorola    update  kernel to TI 25.1                        *
+ *   2009/08/13  Motorola    Remove wait in DirectClose()                     *
+ *   2009/10/02  Motorola    Replace LOGCOMMBUFF with DEBUG                   *
+ ******************************************************************************/
+
+/* direct.c defines an interface between a NetMUX and the Linux raw character */
+/* device layer.  This code is responsible for assisting application in       */
+/* communication with the NetMUX by implementing the standard file operations */
+/* such as open(), close(), read(), and write().                              */
+
+#include "direct.h"
+#include "protocol.h"
+#include "config.h"
+#include "debug.h"
+
+
+/*
+ * major_list keeps track of a list of major numbers
+ * associated with a NetMUX. Each item in the list
+ * contains information to be associated with the
+ * major number.
+ */
+DIRECT_MAJOR_LIST* major_list = 0;
+
+extern struct class *netmux_class;
+
+/*
+ * DirectInform is called by the mux (and sometimes the
+ * config interface) to inform the interface that something
+ * important has happened. The direct interface listens for
+ * several things of importance.
+ *
+ * First, it listens for config packets. If a config packet
+ * is recieved it processes it and sets up the appropriate
+ * channel and entries in /dev/netmux.
+ *
+ * Second, it listens for a disable mux event. If such an
+ * event happens all channels are forced closed and no
+ * application can perform any operation on the channel until
+ * all application accessing that device perform a close().
+ *
+ * Third, it waits for enable channel messages. If such a
+ * message is ever received it immediately responds with a
+ * failure because the direct interface does not support
+ * external open requests.
+ *
+ * Fourth, it waits for a disable channel message. If
+ * one is received the channel is placed into an inoperable
+ * state until all applications accessing the device recognize
+ * the closure by performing a close().
+ *
+ * Fifth, it waits a data message, which signifies that the
+ * channel has successfuly delivered data. The direct interface
+ * uses this information to wakeup any event waiting to write
+ * data to the channel.
+ *
+ * Params:
+ * param1 -- a custom pointer, in this case an INTERFACEINFORM struct
+ * param2 -- a custom pointer, in this case a DIRECTINTERFACE struct
+ */
+int32 DirectInform (void* param1, void* param2)
+{
+    DIRECTINTERFACE*      direct;
+    DIRECT_CHANNELDATA*   chdat;
+    CONFIGPACKET*         configpacket;
+    ENABLECHANNEL_PACKET* enablechannel;
+    INTERFACEINFORM*      informdata;
+    int32                 channel;
+    int32                 type;
+
+    DEBUG("DirectInform(0x%p, 0x%p)\n", param1, param2);
+
+    informdata = (INTERFACEINFORM*)param1;
+    direct     = (DIRECTINTERFACE*)param2;
+
+    switch(informdata->inform_type)
+    {
+        case INFORM_INTERFACE_CONFIGPACKET:
+        {
+            channel = ((CONFIGPACKET*)informdata->data)->channel;
+
+            if(channel > direct->channel_max || channel < direct->channel_min)
+            {
+                return DEBUGERROR(ERROR_INVALIDPARAMETER);
+            }
+
+            chdat        = &direct->channel_data[channel-direct->channel_min];
+            configpacket = (CONFIGPACKET*)informdata->data;
+
+            chdat->client_interface = configpacket->host_interface;
+            chdat->burstsize        = configpacket->client_burstsize;
+            chdat->maxdata          = configpacket->client_maxdata;
+            chdat->host_byte_credit = configpacket->client_byte_credit;
+            chdat->host_send_credit = configpacket->client_send_credit;
+
+            memcpy(chdat->device_file, configpacket->channel_name, PACKET_MAXNAME_LENGTH);
+
+            init_waitqueue_head(&chdat->event_wait);
+            init_waitqueue_head(&chdat->close_wait);
+            init_waitqueue_head(&chdat->rdevent);
+            init_waitqueue_head(&chdat->wrevent);
+
+            if(netmux_class)
+            {
+                if(IS_ERR(device_create(netmux_class, NULL, 
+                           MKDEV(direct->major, channel), NULL, "%s", chdat->device_file)))
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+            else
+            {
+                DEBUGERROR(ERROR_INVALIDPARAMETER);
+            }
+            
+            if(chdat->refcount == 0)
+                chdat->state = DIRECT_STATE_READY;
+        }break;
+
+        case INFORM_INTERFACE_DISABLEMUX:
+        {
+            for(channel = 0; channel < direct->channel_max-direct->channel_min+1; channel++)
+            {
+                wake_up_interruptible(&direct->channel_data[channel].event_wait);
+
+                direct->channel_data[channel].state = DIRECT_STATE_DEFAULT;
+            }
+        }break;
+
+        case INFORM_INTERFACE_ENABLECHANNEL:
+        {
+            enablechannel = (ENABLECHANNEL_PACKET*)informdata->data;
+            type          = strip_end(enablechannel->acktype);
+
+            if(type == COMMAND)
+            {
+                EnableChannel(
+                              client_end(FAILURE),
+                              enablechannel->channel,
+                              0,
+                              0,
+                              enablechannel->host_interface,
+                              enablechannel->client_interface,
+                              0,
+                              0,
+                              0,
+                              0,
+                              direct->mux
+                             );
+            }
+            else if(type == SUCCESS)
+            {
+                channel = enablechannel->channel;
+                chdat   = &direct->channel_data[channel-direct->channel_min];
+
+                chdat->refcount++;
+                chdat->state |= DIRECT_STATE_EVENT|DIRECT_STATE_EVENT_SUCCESS;
+
+                wake_up_interruptible(&chdat->event_wait);
+            }
+            else if(type == FAILURE)
+            {
+                channel = enablechannel->channel;
+                chdat   = &direct->channel_data[channel-direct->channel_min];
+
+                chdat->state |= DIRECT_STATE_EVENT;
+
+                wake_up_interruptible(&chdat->event_wait);
+            }
+        }break;
+
+        case INFORM_INTERFACE_DISABLECHANNEL:
+        {
+	    printk("DisableChannel: ackType = %x, channel = %x, host = %x, client = %x\n", 
+		   ((DISABLECHANNEL_PACKET*)informdata->data)->acktype,
+		   ((DISABLECHANNEL_PACKET*)informdata->data)->channel,
+		   ((DISABLECHANNEL_PACKET*)informdata->data)->host_interface,
+		   ((DISABLECHANNEL_PACKET*)informdata->data)->client_interface);
+            channel = ((DISABLECHANNEL_PACKET*)informdata->data)->channel;
+	    chdat   = &direct->channel_data[channel-direct->channel_min];
+
+            chdat->refcount--;
+            wake_up_interruptible(&chdat->close_wait);
+        }break;
+
+        case INFORM_INTERFACE_DATA:
+        {
+            channel = (int32)informdata->data;
+
+            wake_up_interruptible(&direct->channel_data[channel-direct->channel_min].wrevent);
+        }break;
+
+        default:break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DirectReceive is called when a buffer is available for
+ * delivery to an application. The direct interface can not
+ * force a buffer onto an application, so this function always
+ * returns an error so the mux knows to stop trying to deliver
+ * the buffer. The buffer will eventually be pulled from the
+ * mux as soon as a user requests the data.
+ *
+ * Params:
+ * commbuff -- a pointer to the received data
+ * param -- a custom pointer, in this case an INTERFACEINFORM struct
+ */
+int32 DirectReceive (COMMBUFF* commbuff, void* param)
+{
+    DIRECTINTERFACE*   direct;
+    INTERFACEINFORM*   inform_data;
+    int32              channel;
+
+    DEBUG("DirectReceive(0x%p, 0x%p)\n", commbuff, param);
+
+    inform_data = (INTERFACEINFORM*)param;
+    direct      = (DIRECTINTERFACE*)inform_data->inform_type;
+    channel     = (int32)inform_data->data;
+
+    wake_up_interruptible(&direct->channel_data[channel-direct->channel_min].rdevent);
+
+    return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+}
+
+/*
+ * CreateDirectInterface will create an interface object to be used by
+ * a NetMUX. This object will keep track of all settings required to
+ * communicate with the raw device layer. As such, any direct operation
+ * will make reference to this interface object.
+ *
+ * Params:
+ * name -- the name of the interface
+ * path -- the path to create device entries in
+ * major -- the major number for the driver, 0 if it's to be dynamic
+ * channel_min -- the inclusive lower bound of channel numbers assigned to the interface
+ * channel_max -- the inclusive upper bound of channel numbers assigned to the interface
+ * mux -- the mux object this interface is associated with
+ * direct -- a pointer to a pointer to receive the newly created object
+ */
+int32 CreateDirectInterface (sint8* name, sint8* path, int32 major, int32 channel_min, int32 channel_max, MUX* mux, DIRECTINTERFACE** direct)
+{
+    DIRECT_MAJOR_LIST** browse;
+    DIRECT_MAJOR_LIST*  node;
+    DIRECTINTERFACE*    newdirect;
+    DIRECT_CHANNELDATA* chdat;
+    INTERRUPT_STATE     state;
+    int32               result;
+    int32               namesize;
+    int32               pathsize;
+    int32               size;
+
+    DEBUG("CreateDirectInterface(0x%p, %lu, %lu, %lu, 0x%p, 0x%p)\n", name, major, channel_min, channel_max, mux, direct);
+
+    if(!direct || !name || !mux)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    if(channel_min > channel_max)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    if(channel_max >= mux->maxchannels)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    size = (channel_max-channel_min+1)*sizeof(DIRECT_CHANNELDATA);
+
+    namesize = strlen(name)+1;
+    if(namesize > PACKET_MAXNAME_LENGTH)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    pathsize = strlen(path)+1;
+    if(pathsize > PACKET_MAXNAME_LENGTH)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    chdat     = (DIRECT_CHANNELDATA*)alloc_mem(size);
+    newdirect = (DIRECTINTERFACE*)alloc_mem(sizeof(DIRECTINTERFACE));
+
+    memset(newdirect, 0, sizeof(DIRECTINTERFACE));
+
+    result = RegisterInterface(name, &DirectInform, &DirectReceive, (int32)newdirect, mux->interface_lib);
+    if(result != ERROR_NONE)
+    {
+        free_mem(newdirect);
+        free_mem(chdat);
+
+        return DEBUGERROR(result);
+    }
+
+    QueryInterfaceIndex(name, mux->interface_lib, &newdirect->host_interface);
+
+    newdirect->operations.open    = &DirectOpen;
+    newdirect->operations.release = &DirectClose;
+    newdirect->operations.read    = &DirectRead;
+    newdirect->operations.write   = &DirectWrite;
+    newdirect->operations.poll    = &DirectPoll;
+
+    newdirect->operations.owner   = THIS_MODULE;
+
+    result = register_chrdev(major, name, &newdirect->operations);
+    if(result < 0)
+    {
+        UnregisterInterface(newdirect->host_interface, mux->interface_lib);
+
+        free_mem(chdat);
+        free_mem(newdirect);
+
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    if(major == DIRECT_DYNAMIC_MAJOR_ASSIGNMENT)
+        major = result;
+
+    newdirect->major        = major;
+    newdirect->channel_min  = channel_min;
+    newdirect->channel_max  = channel_max;
+    newdirect->channel_data = chdat;
+    newdirect->mux          = mux;
+
+    memcpy(newdirect->device_directory, path, pathsize);
+    memcpy(newdirect->interface_name, name, namesize);
+    memset(chdat, 0, size);
+
+    node           = alloc_mem(sizeof(DIRECT_MAJOR_LIST));
+    node->major    = major;
+    node->directif = newdirect;
+    node->next     = 0;
+
+    disable_interrupts(state);
+
+    browse = &major_list;
+    while(*browse)
+        browse = &(*browse)->next;
+
+    *browse = node;
+
+    enable_interrupts(state);
+
+    *direct = newdirect;
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DestroyDirectInterface is invoked when a NetMUX is being destroyed.
+ * The interface object will be 'undone'.
+ *
+ * Params:
+ * direct -- the interface to be destroyed
+ */
+int32 DestroyDirectInterface (DIRECTINTERFACE* direct)
+{
+    DIRECT_MAJOR_LIST** browse;
+    DIRECT_MAJOR_LIST*  found;
+    DIRECT_CHANNELDATA* chdat;
+    INTERRUPT_STATE     state;
+    int32               channels;
+    int32               index;
+
+    DEBUG("DestroyDirectInterface(0x%p)\n", direct);
+
+    chdat    = direct->channel_data;
+    channels = direct->channel_max-direct->channel_min+1;
+
+    for(index = 0; index < channels; index++)
+    {
+        if(chdat[index].state&DIRECT_STATE_READY)
+        {
+            DisableChannel(
+                           host_end(COMMAND),
+                           index+direct->channel_min,
+                           direct->host_interface,
+                           chdat[index].client_interface,
+                           direct->mux
+                          );
+
+            if(chdat[index].refcount)
+                wait_event_interruptible(chdat[index].close_wait, !(chdat[index].refcount));
+
+            device_destroy(netmux_class, MKDEV(direct->major, index));
+        }
+    }
+
+    unregister_chrdev(direct->major, direct->interface_name);
+
+    disable_interrupts(state);
+
+    browse = &major_list;
+    while(*browse && (*browse)->major != direct->major)
+        browse = &(*browse)->next;
+
+    if(*browse)
+    {
+        found   = *browse;
+        *browse = found->next;
+
+        free_mem(found);
+    }
+
+    enable_interrupts(state);
+
+    UnregisterInterface(direct->host_interface, direct->mux->interface_lib);
+
+    free_mem(direct->channel_data);
+    free_mem(direct);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DirectOpen is called by the linux file system whenever an open
+ * is performed on a device belonging to this interface. The open
+ * will send an enable request to a client netmux and wait for a
+ * reply. If any errors occurr the device will not be open.
+ *
+ * Params:
+ * inode -- used to let us fetch the major/minor of the device
+ * filp -- some private data is set within this structure
+ */
+int DirectOpen (struct inode* inode, struct file* filp)
+{
+    DIRECT_MAJOR_LIST*  browse;
+    DIRECTINTERFACE*    direct;
+    DIRECT_CHANNELDATA* chdat;
+    INTERRUPT_STATE     state;
+    int32               major;
+    int32               minor;
+    int32               result;
+
+    DEBUG("DirectOpen(0x%p, 0x%p)\n", inode, filp);
+
+    major = MAJOR(inode->i_rdev);
+    minor = MINOR(inode->i_rdev);
+
+    disable_interrupts(state);
+
+    browse = major_list;
+    while(browse && browse->major != major)
+        browse = browse->next;
+
+    direct = browse->directif;
+
+    enable_interrupts(state);
+
+    if(minor < direct->channel_min || minor > direct->channel_max)
+        return -EADDRNOTAVAIL;
+
+    chdat = &direct->channel_data[minor-direct->channel_min];
+    if(!(chdat->state&DIRECT_STATE_READY))
+        return -EADDRNOTAVAIL;
+
+    if(chdat->refcount > 0)
+        return -EBUSY;
+
+    result = EnableChannel(
+                           host_end(COMMAND),
+                           minor,
+                           chdat->burstsize,
+                           chdat->maxdata,
+                           direct->host_interface,
+                           chdat->client_interface,
+                           chdat->host_byte_credit,
+                           chdat->host_send_credit,
+                           0,
+                           0,
+                           direct->mux
+                          );
+    if(result != ERROR_NONE)
+        return -ECONNABORTED;
+
+    /* Wake up when either one of two conditions occur:
+       1 - A response is received from the BP for our open request.
+       2 - The channel is not configured and running properly.
+       In case the latter is true an error will be returned eventually. */
+    wait_event_interruptible(chdat->event_wait,
+                            (chdat->state&DIRECT_STATE_EVENT) ||
+                            !(chdat->state&DIRECT_STATE_READY));
+
+    chdat->state &= ~DIRECT_STATE_EVENT;
+
+    if(!(chdat->state&DIRECT_STATE_EVENT_SUCCESS))
+        return -ECONNREFUSED;
+
+    chdat->state &= ~DIRECT_STATE_EVENT_SUCCESS;
+
+    filp->private_data = direct;
+
+    return 0;
+}
+
+/*
+ * DirectClose is called by the file system whenever a close is
+ * performed on an open device. A disable is sent to the client
+ * NetMUX but no response is expected or required. If there is
+ * an error with the device being closed an error will be
+ * returned.
+ *
+ * Params:
+ * inode -- used to fetch the minor number of the device
+ * filp -- stores some private data which we use to fetch the direct
+ *         interface structure
+ */
+int DirectClose (struct inode* inode, struct file* filp)
+{
+    DIRECTINTERFACE*    direct;
+    DIRECT_CHANNELDATA* chdat;
+    int32               minor;
+    int32               client_interface;
+    int32               result;
+
+    DEBUG("DirectClose(0x%p, 0x%p)\n", inode, filp);
+
+    direct = filp->private_data;
+    minor  = MINOR(inode->i_rdev);
+
+    if(minor < direct->channel_min || minor > direct->channel_max)
+        return -EADDRNOTAVAIL;
+
+    chdat = &direct->channel_data[minor-direct->channel_min];
+
+    chdat->state = DIRECT_STATE_READY;
+
+    client_interface = chdat->client_interface;
+
+    result = DisableChannel(host_end(COMMAND), minor, direct->host_interface, client_interface, direct->mux);
+
+    if (chdat->refcount <= 0)
+    {
+        if(result != ERROR_NONE)
+            return -ENOTCONN;
+    }
+
+    return 0;
+}
+
+/*
+ * DirectPoll is invoked whenever a user performs a select() or
+ * a poll(). This function allows a user to wait for a certain
+ * set of conditions to be met before it returns. The direct
+ * interface supports notification of the following events:
+ * Data available to be read, Space available to be written
+ * to, and whether or not the device is functioning.
+ *
+ * Params:
+ * filp -- used to fetch the minor and direct structure
+ * table -- used to notify the upper driver layer that
+ *          the function needs to wait for some conditions
+ *          to be met.
+ */
+unsigned int DirectPoll (struct file* filp, poll_table* table)
+{
+    DIRECTINTERFACE*    direct;
+    DIRECT_CHANNELDATA* chdat;
+    int32               minor;
+    int32               mask;
+
+    DEBUG("DirectPoll(0x%p, 0x%p)\n", filp, table);
+
+    direct = filp->private_data;
+    minor  = MINOR(filp->f_dentry->d_inode->i_rdev);
+    mask   = 0;
+
+    if(minor < direct->channel_min || minor > direct->channel_max)
+        return POLLERR;
+
+    chdat = &direct->channel_data[minor-direct->channel_min];
+    if(!(chdat->state&DIRECT_STATE_READY) || chdat->refcount == 0)
+        return POLLERR;
+
+    poll_wait(filp, &chdat->rdevent, table);
+    poll_wait(filp, &chdat->wrevent, table);
+
+    if(ReadDataAvailable(minor, direct->mux))
+      mask |= POLLIN|POLLRDNORM;
+
+    if(SendDataAvailable(minor, direct->mux))
+      mask |= POLLOUT|POLLWRNORM;
+
+    return mask;
+}
+
+/*
+ * DirectRead is called whenever a device is read from. This function
+ * will pull data from the mux and copy it into a user supplied buffer.
+ * If the device is in a blocking mode this call will block until
+ * data is available to be read. If any errors occur the user will
+ * be notified.
+ *
+ * Params:
+ * filp -- used to get the direct struct and the minor number
+ * buf -- pointer to where the data is to be received
+ * count -- the amount of data to attempt to read
+ * f_pos -- an unused paramater
+ */
+ssize_t DirectRead (struct file* filp, char* buf, size_t count, loff_t* f_pos)
+{
+    DIRECTINTERFACE*    direct;
+    DIRECT_CHANNELDATA* chdat;
+    COMMBUFF*           commbuff = 0;
+    int32               minor;
+    int32               result;
+    int32               commbuffsize;
+
+    DEBUG("DirectRead(0x%p, 0x%p, %d, 0x%p)\n", filp, buf, count, f_pos);
+
+    direct = filp->private_data;
+    minor  = MINOR(filp->f_dentry->d_inode->i_rdev);
+
+    if(minor < direct->channel_min || minor > direct->channel_max)
+        return -EADDRNOTAVAIL;
+
+    chdat = &direct->channel_data[minor-direct->channel_min];
+    if(!(chdat->state&DIRECT_STATE_READY) || chdat->refcount == 0)
+        return -ENOTCONN;
+
+    if (count <= 0)
+        return 0;
+
+    if(!(filp->f_flags&O_NONBLOCK))
+        wait_event_interruptible(chdat->rdevent, ReadDataAvailable(minor, direct->mux));
+
+    ReadData(minor, direct->mux, &commbuff, count);
+    if(!commbuff)
+        return -EAGAIN;
+
+    commbuffsize = commbuff_length(commbuff);
+
+    result = copy_to_user(buf, commbuff_data(commbuff), commbuffsize);
+    if(result)
+    {
+        free_commbuff(commbuff);
+
+        return -EFAULT;
+    }
+
+    LOGCOMMBUFF_CH(minor, "DirectRead( )-->", commbuff, commbuffsize);
+
+    free_commbuff(commbuff);
+
+    return commbuffsize;
+}
+
+/*
+ * DirectWrite is called whenever the user tries to write data
+ * to a device. If the device cannot take the data or there
+ * is some other error the user will be notified. The data
+ * to be delivered is copied out of the user supplied buffer
+ * and into an allocated commbuff.
+ *
+ * Params:
+ * filp -- used to get the direct interface and the minor number
+ * buf -- a pointer to the data to be copied
+ * count -- the number of bytes to be copied
+ * f_pos -- not used
+ */
+ssize_t DirectWrite (struct file* filp, const char* buf, size_t count, loff_t* f_pos)
+{
+    COMMBUFF*           commbuff;
+    DIRECTINTERFACE*    direct;
+    DIRECT_CHANNELDATA* chdat;
+    int32               minor;
+    int32               result;
+
+    DEBUG("DirectWrite begin(0x%p, 0x%p, %d, 0x%p)\n", filp, buf, count, f_pos);
+
+    direct = filp->private_data;
+    minor  = MINOR(filp->f_dentry->d_inode->i_rdev);
+
+    if(minor < direct->channel_min || minor > direct->channel_max)
+        return -EADDRNOTAVAIL;
+
+    chdat = &direct->channel_data[minor-direct->channel_min];
+    if(!(chdat->state&DIRECT_STATE_READY) || chdat->refcount == 0)
+        return -ENOTCONN;
+
+    commbuff = alloc_commbuff(count, sizeof(DATA_PACKET_HDR));
+
+    result = copy_from_user(commbuff_data(commbuff), buf, count);
+    if(result)
+    {
+        free_commbuff(commbuff);
+
+        return -EFAULT;
+    }
+
+    result = SendData(minor, commbuff, NULL, direct->mux);
+    if(result != ERROR_NONE)
+    {
+        free_commbuff(commbuff);
+
+        return 0;
+    }
+
+    DEBUG("DirectWrite end(0x%p, 0x%p, %d, 0x%p)\n", filp, buf, count, f_pos);
+
+    return count;
+}
diff --git a/drivers/misc/netmux/direct.h b/drivers/misc/netmux/direct.h
new file mode 100755
index 0000000..4c6964d
--- /dev/null
+++ b/drivers/misc/netmux/direct.h
@@ -0,0 +1,176 @@
+/******************************************************************************
+ * NetMUX direct.h                                                            *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2007                                           *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ *   2007/12/05  Motorola    change header file as kernel change              *
+ ******************************************************************************/
+
+/* direct.h is responsible for setting up a method of communication between   */
+/* the NetMUX and user space applications.                                    */
+
+#ifndef _NETMUX_DIRECT_H_
+#define _NETMUX_DIRECT_H_
+
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "mux.h"
+
+
+#include <linux/device.h>
+
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+
+
+/*
+ * Defined to allow for dynamic major assignment upon driver registration
+ */
+#define DIRECT_DYNAMIC_MAJOR_ASSIGNMENT 0
+
+/*
+ * Declares different states a direct channel can be placed in
+ */
+#define DIRECT_STATE_DEFAULT       0
+#define DIRECT_STATE_READY         1
+#define DIRECT_STATE_EVENT         2
+#define DIRECT_STATE_EVENT_SUCCESS 4
+
+
+/*
+ * DIRECT_MAJOR_LIST defines a structure to hold information about a
+ * major number. A brief description of the members is below.
+ *
+ * major is the major# to associate the data with
+ * directif points to direct interface
+ * next points to the next major number
+ */
+typedef struct DIRECT_MAJOR_LIST
+{
+    int32                   major;
+    struct DIRECTINTERFACE* directif;
+
+    struct DIRECT_MAJOR_LIST* next;
+}DIRECT_MAJOR_LIST;
+
+/*
+ * DIRECT_CHANNELDATA defines a structure to bind channels to a
+ * certain configuration. A brief description of the members is
+ * below.
+ *
+ * refcount is the total number of times the channel has been enabled
+ * state represents the current state of this channel
+ * remote_interface is the interface id of the external interface
+ * burstsize is the default maximum amount of data to be sent at a time
+ * maxdata is the default maximum amount of data to be queued
+ * host_byte_credit is the default number of bytes that can be received
+ * host_send_credit is the default number of sends that can be received
+ * event_wait defines a structure that a direct device can sleep on
+ * close_wait defines a structure that a close operation can sleep on
+ * rdevent defines a wait queue for read operations to wake up
+ * wrevent defines a wait queue for write operations to wake up
+ * device_file is the name of the file entry in /dev
+ */
+typedef struct DIRECT_CHANNELDATA
+{
+    int32 refcount;
+    int32 state;
+    int32 client_interface;
+    int32 burstsize;
+    int32 maxdata;
+    int32 host_byte_credit;
+    int32 host_send_credit;
+
+    wait_queue_head_t event_wait;
+    wait_queue_head_t close_wait;
+    wait_queue_head_t rdevent;
+    wait_queue_head_t wrevent;
+
+    sint8 device_file[PACKET_MAXNAME_LENGTH];
+}DIRECT_CHANNELDATA;
+
+/*
+ * DIRECTINTERFACE declares a structure to manage direct channel
+ * data pointers. A brief description of the members is below.
+ *
+ * major is the major number of the registered direct interface
+ * channel_min is the inclusive lower boundary of channel numbers
+ * channel_max is the inclusive upper boundary of channel numbers
+ * local_interface is the interface id for the local interface
+ * channel_data is a list of structures bound to specific channels
+ * mux points to the MUX object associated with this direct interface
+ * device_directory is the directory within /dev to create devices
+ * interface_name is the name of this interface
+ * operations defines standard operations a direct device should use
+ */
+typedef struct DIRECTINTERFACE
+{
+    int32 major;
+    int32 channel_min;
+    int32 channel_max;
+    int32 host_interface;
+
+    DIRECT_CHANNELDATA* channel_data;
+    MUX*                mux;
+
+    sint8  device_directory[PACKET_MAXNAME_LENGTH];
+    sint8  interface_name[PACKET_MAXNAME_LENGTH];
+
+    struct file_operations operations;
+}DIRECTINTERFACE;
+
+
+/*
+ * Define various functions used by the direct interface
+ */
+
+int32 DirectInform  (void*, void*);
+int32 DirectReceive (COMMBUFF*, void*);
+
+int32 CreateDirectInterface  (sint8*, sint8*, int32, int32, int32, MUX*, DIRECTINTERFACE**);
+int32 DestroyDirectInterface (DIRECTINTERFACE*);
+
+int          DirectOpen  (struct inode*, struct file*);
+int          DirectClose (struct inode*, struct file*);
+unsigned int DirectPoll  (struct file*, poll_table*);
+ssize_t      DirectRead  (struct file*, char*, size_t, loff_t*);
+ssize_t      DirectWrite (struct file*, const char*, size_t, loff_t*);
+
+
+#endif
diff --git a/drivers/misc/netmux/errorcodes.h b/drivers/misc/netmux/errorcodes.h
new file mode 100755
index 0000000..93fef53
--- /dev/null
+++ b/drivers/misc/netmux/errorcodes.h
@@ -0,0 +1,81 @@
+/******************************************************************************
+ * NetMUX errorcodes.h                                                        *
+ *                                                                            *
+ * Copyright Motorola 2006                                                    *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ ******************************************************************************/
+
+/* errorcodes.h defines a list of common return values that have a unique     */
+/* mapping to a certain meaning. Generally, any function returning an int32   */
+/* is returning one of the following errors.                                  */
+
+#ifndef _NETMUX_ERRORCODES_H_
+#define _NETMUX_ERRORCODES_H_
+
+
+/* 
+ * ERROR_NONE specifies no error occured 
+ */
+#define ERROR_NONE 0
+
+/* 
+ * ERROR_INVALIDPARAMETER specifies a value to a function is not 
+ * valid 
+ */
+#define ERROR_INVALIDPARAMETER 1
+
+/* 
+ * ERROR_MEMORY states an error involving memory occured, usually
+ * allocating it 
+ */
+#define ERROR_MEMORY 2
+
+/* 
+ * ERROR_OPERATIONFAILED occurs if a something went wrong within 
+ * the function 
+ */
+#define ERROR_OPERATIONFAILED 3
+
+ /* 
+  * ERROR_OPERATIONRESTRICTED occurs if the function couldn't 
+  * proceed 
+  */
+#define ERROR_OPERATIONRESTRICTED 4
+
+ /* 
+  * ERROR_INCOMPLETE occurs if the function needs to be called again 
+  */
+#define ERROR_INCOMPLETE 5
+
+
+#endif
+
diff --git a/drivers/misc/netmux/interface.c b/drivers/misc/netmux/interface.c
new file mode 100755
index 0000000..1f70f08
--- /dev/null
+++ b/drivers/misc/netmux/interface.c
@@ -0,0 +1,335 @@
+/******************************************************************************
+ * NetMUX interface.c                                                         *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ ******************************************************************************/
+
+/* interface.c provides an API to the mux and its interfaces which allows     */
+/* them to communicate easily. This API merely allows simple searching of     */
+/* interfaces to be performed as well as simple communication routines.       */
+
+#include "interface.h"
+#include "debug.h"
+
+
+/*
+ * CreateInterfaceLibrary creates an object to store a list of
+ * interfaces. These interfaces define a receive function and
+ * an inform function with which the mux can communicate. By
+ * placing all interfaces in a common library the mux can
+ * access all the functionality attached to it on a whim.
+ *
+ * Params:
+ * maxinterfaces -- the number of shelves in the library
+ * lib -- a poitner to receive the library object 
+ */
+int32 CreateInterfaceLibrary (int32 maxinterfaces, MUXINTERFACE_LIBRARY** lib)
+{
+    MUXINTERFACE**        newinterfaces;
+    sint8**               newnames;
+    MUXINTERFACE_LIBRARY* newlib;
+    int32                 size;
+
+    DEBUG("CreateInterfaceLibrary(%lu, %p)\n", maxinterfaces, lib);
+
+    if(!maxinterfaces || !lib)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    newlib        = (MUXINTERFACE_LIBRARY*)alloc_mem(sizeof(MUXINTERFACE_LIBRARY));
+    size          = maxinterfaces*sizeof(void*);
+    newinterfaces = (MUXINTERFACE**)alloc_mem(size);
+
+    newnames = (sint8**)alloc_mem(size);
+
+    memset(newinterfaces, 0, size);
+    memset(newnames, 0, size);
+
+    newlib->interfaces    = newinterfaces;
+    newlib->names         = newnames;
+    newlib->maxinterfaces = maxinterfaces;
+
+    initialize_criticalsection_lock(&newlib->lock);
+
+    *lib = newlib;
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DestroyInterfaceLibrary will free any resources currently consumed
+ * by the library object itself. If there are any interfaces still 
+ * contained in the library this function call will fail. It is assumed
+ * that there are no operations happening on this object at the time 
+ * the destroy is called.
+ * 
+ * Params:
+ * lib -- a pointer to the library to be destroyed
+ */
+int32 DestroyInterfaceLibrary (MUXINTERFACE_LIBRARY* lib)
+{
+    int32 index;
+
+    DEBUG("DestroyInterfaceLibrary(%p)\n", lib);
+
+    for(index = 0; index < lib->maxinterfaces; index++)
+    {
+        if(lib->interfaces[index])
+            return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    destroy_criticalsection_lock(&lib->lock);
+
+    free_mem(lib->interfaces);
+    free_mem(lib->names);
+    free_mem(lib);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * RegisterInterface is invoked when an interface wishes to register
+ * itself with a certain interface library. Normally that library is
+ * attached to the NetMUX and by registering the interface the mux
+ * can communicate with it. The interface must supply its inform and
+ * receive functions the mux is to use as well as a custom parameter
+ * and a name.
+ *
+ * Params:
+ * name -- the name of the interface
+ * inform -- the inform function to be called by the mux
+ * receive -- the receive function to be called by the mux
+ * param -- the custom value the interface wishes to be passed
+ *          into an inform or receive call
+ * lib -- the library object to attach the interface to
+ */
+int32 RegisterInterface (sint8* name, int32 (*inform) (void*, void*), int32 (*receive) (COMMBUFF*, void*), int32 param, MUXINTERFACE_LIBRARY* lib)
+{
+    MUXINTERFACE* newinterface;
+    sint8*        newname;
+    int32         namelength;
+    int32         index;
+
+    DEBUG("RegisterInterface(%p, %p, %p, %lu, %p)\n", name, inform, receive, param, lib);
+
+    if(!name || !inform || !receive || !lib)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    enter_write_criticalsection(&lib->lock);
+
+    for(index = 0; index < lib->maxinterfaces; index++)
+    {
+        if(!lib->interfaces[index])
+            break;
+    }
+
+    if(index >= lib->maxinterfaces)
+    {
+        exit_write_criticalsection(&lib->lock);
+
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    namelength = strlen((char*)name)+1;
+
+    newinterface = (MUXINTERFACE*)alloc_mem(sizeof(MUXINTERFACE));
+    newname      = (sint8*)alloc_mem(namelength);
+
+    memcpy(newname, name, namelength);
+
+    newinterface->Inform          = inform;
+    newinterface->Receive         = receive;
+    newinterface->interface_index = index;
+    newinterface->param           = param;
+
+    lib->interfaces[index] = newinterface;
+    lib->names[index]      = newname;
+
+    exit_write_criticalsection(&lib->lock);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * UnregisterInterface will pull a interface from the library. The caller
+ * should take care to ensure no operations are depending on this interface.
+ * 
+ * Params:
+ * interface_index -- the interface id/index for the interface to be removed
+ * lib -- the library which holds the interface
+ */
+int32 UnregisterInterface (int32 interface_index, MUXINTERFACE_LIBRARY* lib)
+{
+    MUXINTERFACE* unreg_interface;
+
+    DEBUG("UnregisterInterface(%lu, %p)\n", interface_index, lib);
+
+    if(interface_index >= lib->maxinterfaces)
+    {
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    enter_write_criticalsection(&lib->lock);
+
+    unreg_interface = lib->interfaces[interface_index];
+    if(!unreg_interface)
+    {
+        exit_write_criticalsection(&lib->lock);
+
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    free_mem(unreg_interface);
+    free_mem(lib->names[interface_index]);
+
+    lib->interfaces[interface_index] = 0;
+    lib->names[interface_index]      = 0;
+
+    exit_write_criticalsection(&lib->lock);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * QueryInterfaceIndex allows an interface or a mux to locate the interface
+ * id by supplying the ascii name of the interface assigned upon registration.
+ * The interface index is a speedier and more convenient way of accessing
+ * an interface within a library.
+ *
+ * Params:
+ * name -- the name of the interface to search for
+ * lib -- the library the interface belongs to
+ * interface_index -- a pointer to a location to receive the index
+ */
+int32 QueryInterfaceIndex (sint8* name, MUXINTERFACE_LIBRARY* lib, int32* interface_index)
+{
+    int32 index;
+
+    DEBUG("QueryInterfaceIndex(%p, %p, %p)\n", name, lib, interface_index);
+
+    enter_read_criticalsection(&lib->lock);
+
+    for(index = 0; index < lib->maxinterfaces; index++)
+    {
+        if(lib->names[index] && (!strcmp((char*)lib->names[index], (char*)name)))
+            break;
+    }
+
+    exit_read_criticalsection(&lib->lock);
+
+    if(index >= lib->maxinterfaces)
+    {
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    if(interface_index)
+        *interface_index = index;
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * ConnectInterface simply assigns a mux connection to a registered interface.
+ * This function call is very simple and almost not needed. Extra verification
+ * is done to ensure that the interface is available.
+ *
+ * Params:
+ * interface_index -- interface id of the interface to be connected
+ * lib -- the library holding the interface
+ * interface_connection -- pointer to a variable to hold the interface pointer
+ */
+int32 ConnectInterface (int32 interface_index, MUXINTERFACE_LIBRARY* lib, MUXINTERFACE** interface_connection)
+{
+    MUXINTERFACE* connecting_interface;
+
+    DEBUG("ConnectInterface(%lu, %p, %p)\n", interface_index, lib, interface_connection);
+
+    if(!lib || !interface_connection)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    if(interface_index >= lib->maxinterfaces)
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+    enter_write_criticalsection(&lib->lock);
+
+    connecting_interface = lib->interfaces[interface_index];
+    if(!connecting_interface)
+    {
+        exit_write_criticalsection(&lib->lock);
+
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    *interface_connection = connecting_interface;
+
+    exit_write_criticalsection(&lib->lock);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * BroadcastLibraryInform is used to communicate a message to every
+ * interface within a library. The message is distributed via the
+ * interface's registered inform function.
+ *
+ * informdata -- some known data to be passed to the inform function
+ * interface_lib -- the library to perform the broadcast on 
+ */
+int32 BroadcastLibraryInform (INTERFACEINFORM* informdata, MUXINTERFACE_LIBRARY* interface_lib)
+{
+    int32 (*Inform)  (void*, void*);
+    void*   param;
+    int32   index;
+
+    DEBUG("BroadcastLibraryInform(%p, %p)\n", informdata,interface_lib);
+
+    for(index = 0; index < interface_lib->maxinterfaces; index++)
+    {
+        enter_read_criticalsection(&interface_lib->lock);
+
+        if(interface_lib->interfaces[index])
+        {
+            Inform = interface_lib->interfaces[index]->Inform;
+            param  = (void*)interface_lib->interfaces[index]->param;
+
+            exit_read_criticalsection(&interface_lib->lock);
+
+            Inform((void*)informdata, param);
+        }
+        else
+            exit_read_criticalsection(&interface_lib->lock);
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
diff --git a/drivers/misc/netmux/interface.h b/drivers/misc/netmux/interface.h
new file mode 100755
index 0000000..4f1d7eb
--- /dev/null
+++ b/drivers/misc/netmux/interface.h
@@ -0,0 +1,126 @@
+/******************************************************************************
+ * NetMUX interface.h                                                         *
+ *                                                                            *
+ * Copyright Motorola 2006                                                    *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ ******************************************************************************/
+
+/* interface.h provides the necessary data types and macros to interface.c.   */
+/* Each interface and mux should include this header file if they intend on   */
+/* using the interface API.                                                   */
+
+#ifndef _NETMUX_MUXINTERFACE_H_
+#define _NETMUX_MUXINTERFACE_H_
+
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+
+
+/*
+ * LIBRARY_INFORM defines a macro to easily invoke an interfaces
+ * inform function
+ */
+#define LIBRARY_INFORM(if, index, l) ((l)->interfaces[index]->Inform((void*)if, (void*)(l)->interfaces[index]->param))
+
+/* 
+ * INTERFACEINFORM defines a structure to be delivered to 
+ * interface inform functions. The members are briefly described
+ * below.
+ *
+ * inform_type is the reason why the interface inform function is 
+ *             being invoked
+ * inform_type is the reason why the interface inform function is 
+ *             being invoked
+ * data associates a particular set of data with the inform function call
+ */
+typedef struct INTERFACEINFORM
+{
+    int32        inform_type;
+    struct MUX*  source;
+    void*        data;
+}INTERFACEINFORM;
+
+/* 
+ * MUXINTERFACE defines and associates an interface with specific 
+ * functionality . The members are briefly described below
+ * 
+ * Inform points to an inform function the mux can invoke
+ * Receive points to a receive function the mux can invoke
+ * interface_index stores the index of the interface which is equivlent to the id
+ * param is a parameter passed to the invoke and receive functions
+ */
+typedef struct MUXINTERFACE
+{
+    int32 (*Inform)  (void*, void*);
+    int32 (*Receive) (COMMBUFF*, void*);
+
+    int32 interface_index;
+    int32 param;
+}MUXINTERFACE;
+
+/* 
+ * MUXINTERFACE_LIBRARY stores a list of registered interfaces. The
+ * members are briefly described below.
+ * 
+ * maxinterfaces is the maximum number of interfaces that the library 
+ *               can hold
+ * names is a list of names for each interface in the library
+ * interfaces is a list of interfaces within the library
+ */
+typedef struct MUXINTERFACE_LIBRARY
+{
+    int32           maxinterfaces;
+    sint8**         names;
+    MUXINTERFACE**  interfaces;
+    CRITICALSECTION lock;
+}MUXINTERFACE_LIBRARY;
+
+
+/*
+ * Define various functions used by the interface API
+ */
+
+int32 CreateInterfaceLibrary  (int32, MUXINTERFACE_LIBRARY**);
+int32 DestroyInterfaceLibrary (MUXINTERFACE_LIBRARY*);
+
+int32 RegisterInterface   (sint8*, int32 (*inform) (void*, void*), int32 (*receive) (COMMBUFF*, void*), int32, MUXINTERFACE_LIBRARY*);
+int32 UnregisterInterface (int32, MUXINTERFACE_LIBRARY*);
+
+int32 QueryInterfaceIndex (sint8*, MUXINTERFACE_LIBRARY*, int32*);
+int32 ConnectInterface    (int32, MUXINTERFACE_LIBRARY*, MUXINTERFACE**);
+
+int32 BroadcastLibraryInform (INTERFACEINFORM*, MUXINTERFACE_LIBRARY*);
+
+
+#endif
diff --git a/drivers/misc/netmux/main.c b/drivers/misc/netmux/main.c
new file mode 100755
index 0000000..a443ce2
--- /dev/null
+++ b/drivers/misc/netmux/main.c
@@ -0,0 +1,128 @@
+/******************************************************************************
+ * NetMUX main.c                                                              *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/04/29  Motorola    Removed DEBUG statement from init                *
+ *   2007/05/01  Motorola    Use printk to replace DEBUG.                     *
+ *   2007/12/05  Motorola    change code as kernel upgrade                    *
+ *   2007/12/05  Motorola    Add NetmuxLogInit in init module                 *
+ *   2009/07/23  Motorola    Add wake lock functionality                      *
+ ******************************************************************************/
+
+/* main.c defines entry points for the NetMUX.  Each entry point is unique    */
+/* based on the current  environment.                                         */
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "register.h"
+#include "debug.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/wakelock.h>
+
+/*
+ * Decribe the module to Linux so it doesn't complain that
+ * we are tainting the kernel.
+ */
+MODULE_DESCRIPTION("NetMUX driver for Linux");
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+/*
+ * Define an interface for the linkdrivers
+ */
+EXPORT_SYMBOL(RegisterMUXLink);
+EXPORT_SYMBOL(UnregisterMUXLink);
+
+
+struct wake_lock netmux_send_wakelock;
+struct wake_lock netmux_receive_wakelock;
+
+/*
+ * A list of registered interfaces is defined in register.c
+ */
+extern INTERFACELIST* interfacelist;
+
+/*
+ * create /dev/netmux
+ */
+struct class *netmux_class = NULL;
+
+/*
+ * When the module is insmod'd this is the first thing that happens.
+ * Currently the only thing that needs to be done is the initialization
+ * of the utilities xpi.
+ */
+static int __init netmux_init(void)
+{
+    printk("Running NetMUX\n");
+    initialize_utilities();
+
+    netmux_class = class_create(THIS_MODULE, "netmux");
+    if (IS_ERR(netmux_class))
+    {
+        printk(KERN_ERR "Error in creating netmux_class class\n");
+        return PTR_ERR(netmux_class);
+    }
+
+    NetmuxLogInit();
+
+    wake_lock_init(&netmux_send_wakelock, WAKE_LOCK_SUSPEND, "NETMUX_send");
+    wake_lock_init(&netmux_receive_wakelock, WAKE_LOCK_SUSPEND, "NETMUX_receive");
+
+    return 0;
+}
+
+/*
+ * When the NetMUX is rmmod'd we unregister ourself from all the
+ * connected linkdrivers and free up any resources.
+ */
+static void __exit netmux_exit(void)
+{
+    printk("Cleaning Up NetMUX\n");
+    while(interfacelist)
+        DeactivateMUX(interfacelist);
+    shutdown_utilities();
+
+    wake_lock_destroy(&netmux_send_wakelock);
+    wake_lock_destroy(&netmux_receive_wakelock);
+
+    class_destroy(netmux_class);
+}
+
+module_init(netmux_init);
+module_exit(netmux_exit);
+
diff --git a/drivers/misc/netmux/mux.c b/drivers/misc/netmux/mux.c
new file mode 100755
index 0000000..d074eb7
--- /dev/null
+++ b/drivers/misc/netmux/mux.c
@@ -0,0 +1,2382 @@
+/******************************************************************************
+ * NetMUX mux.c                                                               *
+ *                                                                            *
+ * Copyright (C) 2006-2010 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ *   2007/04/11  Motorola    Reduce lock/unlocks in ProcessSendQueues         *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ *   2007/08/16  Motorola    Add support for larger bytecredit                *
+ *   2007/12/05  Motorola    Change codes as INIT_WORK changes in kernel      *
+ *   2008/07/14  Motorola    fix memory leak issue                            *
+ *   2008/10/14  Motorola    Panic if receive packet is invalide              *
+ *   2008/10/28  Motorola    fix issue in ReceivePartial                      *
+ *   2009/07/23  Motorola    Add wake lock functionality                      *
+ *   2009/11/18  Motorola    Switch host/client interface in DC resp          *
+ ******************************************************************************/
+
+/* mux.c defines all the functionality of the mux. This functionality allows  */
+/* an interface to communicate over a link.                                   */
+
+#include "mux.h"
+#include "protocol.h"
+#include "debug.h"
+#include <linux/wakelock.h>
+
+extern struct wake_lock netmux_send_wakelock;
+extern struct wake_lock netmux_receive_wakelock;
+
+void check_all_receive_queues_emptiness(MUX *mux);
+void check_all_send_queues_emptiness(MUX *mux);
+
+/*
+ * CloseChannel encapsulates the set of actions that are needed to close a
+ * channel
+ *
+ * Callers are responsible for obtaining the mux lock before calling
+ * CloseChannel and for releasing the lock after this function returns.
+ *
+ * Params:
+ * chanlNum -- the number of the channel being closed
+ * mux -- the mux object pointer
+ */
+static
+void CloseChannel(int32 chanlNum, MUX* mux)
+{
+    CHANNEL* channel = NULL;
+
+    channel = mux->channels[chanlNum];
+
+    if (channel)
+    {
+
+        mux->channels[chanlNum] = 0;
+        mux->total_queued_amount -= channel->qed_totl_amount;
+
+        empty_commbuff_queue(&channel->receive_queue);
+        empty_commbuff_queue(&channel->send_queue);
+
+        destroy_commbuff_queue(&channel->receive_queue);
+        destroy_commbuff_queue(&channel->send_queue);
+
+        free_mem(channel);
+    }
+}
+
+
+/*
+ * ExecuteStateTransition is a helper function that can change a channel's
+ * state based on a particular event happening and perform some of the
+ * actions associated with the state transition.
+ *
+ * Callers must obtain the mux lock before calling and are responsible for
+ * releasing the lock after this function returns.
+ *
+ * MAINTENANCE NOTE: not all state transitions and not all actions are handled
+ * by this function.  For example, this function does not call any interface
+ * inform functions since the mux lock is held here.
+ *
+ * Params:
+ * event -- the event that occurred
+ * mux -- the mux object
+ * channel_num -- the channel number the event occurred on
+ */
+int32 ExecuteStateTransition(int32 event, MUX* mux, int32 channel_num)
+{
+    CHANNEL* channel;
+
+    DEBUG("ExecuteStateTransition(0x%lu, %p, 0x%lu)\n", event, mux, channel_num);
+
+    channel = mux->channels[channel_num];
+
+    switch(channel->state)
+    {
+        case OPENING:
+        {
+            switch(event)
+            {
+                case LOCAL_CLOSE:
+                {
+                    /* send client close and wait for ack */
+                    TransmitDisableChannel((int8)client_end(COMMAND),
+                                           (int8)channel_num,
+                                           (int8)channel->host_interface,
+                                           (int8)channel->client_interface,
+                                           mux);
+
+                    channel->state = LOCAL_CLOSING;
+                }break;
+
+                default:
+                {
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+        }break;
+
+        case OPEN:
+        {
+            switch(event)
+            {
+                /* the REMOTE_DATA event is handled outside of this function */
+
+                case LOCAL_DATA:
+                {
+                    channel->state = SENDING;
+                    /* data is queued and send task is scheduled by the caller */
+                }break;
+
+                case REMOTE_CLOSE:
+                {
+                    channel->state = REMOTE_CLOSING;
+                    /* the interface will be informed by the caller */
+                }break;
+
+                case LOCAL_CLOSE:
+                {
+                    /* send client close and wait for ack */
+                    TransmitDisableChannel((int8)client_end(COMMAND),
+                                           (int8)channel_num,
+                                           (int8)channel->host_interface,
+                                           (int8)channel->client_interface,
+                                           mux);
+
+                    channel->state = LOCAL_CLOSING;
+                }break;
+
+                default:
+                {
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+        }break;
+
+        case SENDING:
+        {
+            switch(event)
+            {
+                /* the REMOTE_DATA event is handled outside of this function */
+
+                case LOCAL_CLOSE:
+                {
+                    /* finish sending the data first     */
+                    /* we'll send a close response later */
+                    channel->state = FLUSHING;
+                }
+                break;
+
+                case REMOTE_CLOSE:
+                {
+                    /* purge this channel's send queue */
+                    empty_commbuff_queue(&channel->send_queue);
+                    channel->state = REMOTE_CLOSING;
+                    /* the interfaces will be informed by the caller */
+                }
+                break;
+
+                case SEND_COMPLETE:
+                {
+                    channel->state = OPEN;
+                }break;
+
+                case LOCAL_DATA:
+                {
+                    /* we're already sending so no state change or action is needed */
+                }break;
+
+                default:
+                {
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+        }break;
+
+        case FLUSHING:
+        {
+            switch(event)
+            {
+                /* the REMOTE_DATA event is handled outside of this function */
+
+                case REMOTE_CLOSE:
+                {
+                    /* we got a close from the remote while we */
+                    /* getting ready to send our own close so  */
+                    /* ditch the data, and send a response     */
+                    empty_commbuff_queue(&channel->send_queue);
+
+                    /* the local channel has already triggered a close   */
+                    /* immediately sending back a response to the remote */
+                    /* switch the interfaces as a result                 */
+                    TransmitDisableChannel((int8)host_end(SUCCESS),
+                                           (int8)channel_num,
+                                           (int8)channel->client_interface,
+                                           (int8)channel->host_interface,
+                                           mux);
+                    /* this channel will be closed by the caller */
+                }break;
+
+                case SEND_COMPLETE:
+                {
+                    /* now that the data is flushed we can send a close */
+                    channel->state = LOCAL_CLOSING;
+
+                    TransmitDisableChannel((int8)client_end(COMMAND),
+                                           (int8)channel_num,
+                                           (int8)channel->host_interface,
+                                           (int8)channel->client_interface,
+                                           mux);
+                }break;
+
+                default:
+                {
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+        }break;
+
+        case LOCAL_CLOSING:
+        {
+            switch(event)
+            {
+                /* the REMOTE_DATA event is handled outside of this function */
+
+                /* the OPEN_RESPONSE event is handled outside of this function */
+
+                case REMOTE_CLOSE:
+                {
+                    /* we got a close from the remote while we  */
+                    /* are closing so just send a response and  */
+                    /* keep waiting for a response to the close */
+                    /* we sent                                  */
+
+                    /* the local channel has already triggered a close   */
+                    /* immediately sending back a response to the remote */
+                    /* switch the interfaces as a result                 */
+                    TransmitDisableChannel((int8)host_end(SUCCESS),
+                                           (int8)channel_num,
+                                           (int8)channel->client_interface,
+                                           (int8)channel->host_interface,
+                                           mux);
+                }break;
+
+                case CLOSE_RESPONSE:
+                {
+                    /* we got the response we were expecting, now we're closed */
+                    CloseChannel(channel_num, mux);
+                    /* the interface is informed by the caller */
+                }break;
+
+                default:
+                {
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+        }break;
+
+        case REMOTE_CLOSING:
+        {
+            switch(event)
+            {
+                case LOCAL_CLOSE:
+                {
+                    /* send the close response */
+                    TransmitDisableChannel((int8)host_end(SUCCESS),
+                                           (int8)channel_num,
+                                           (int8)channel->host_interface,
+                                           (int8)channel->client_interface,
+                                           mux);
+
+                    /* free the channel resources */
+                    CloseChannel(channel_num, mux);
+                }break;
+
+                default:
+                {
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+        }break;
+
+        default:
+        {
+            return DEBUGERROR(ERROR_OPERATIONFAILED);
+        }
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * InformMUX is called by the linkdriver when a change of status
+ * needs to be reported to the NetMUX. The status could be an
+ * error state or a working state. If the state is made 'working'
+ * then the mux continues its work.
+ *
+ * Params:
+ * type -- the state to switch to
+ * param -- data associated with the type
+ */
+int32 InformMUX (void* type, void* param)
+{
+    MUX* mux;
+
+    DEBUG("InformMUX(%p, %p)\n", type, param);
+
+    mux = (MUX*)param;
+
+    if(!mux)
+        return DEBUGLDP(LDP_ERROR_FATAL);
+
+    switch((int32)type)
+    {
+        case LDP_INFORM_SHUTDOWN:
+        {
+            task_schedule(&mux->shutdown_task);
+        }break;
+
+        case LDP_INFORM_RECOVERED:
+        {
+            enable_task(&mux->send_task);
+            task_schedule(&mux->send_task);
+        }break;
+    }
+
+    return DEBUGLDP(LDP_ERROR_NONE);
+}
+
+/*
+ * CommBuffReleased is called when a commbuff is freed somewhere
+ * on the system. This function then handles any credit adjustments.
+ *
+ * Params:
+ * channel -- the channel the commbuff belongs to
+ * size -- the size of the commbuff being released
+ * param -- the mux object
+ */
+void CommBuffReleased (int32 channel, int32 size, void* param)
+{
+    MUX*           mux;
+    CHANNELCREDIT* credit;
+    int32          replenish_send_limit;
+    int32          replenish_byte_limit;
+    int32          buffers_used;
+
+    DEBUG("CommBuffReleased(%lu, %lu, %p)\n", channel, size, param);
+    DBGFC("CommBuffReleased(%lu, %lu, %p)\n", channel, size, param);
+
+    mux = (MUX*)param;
+
+    enter_write_criticalsection(&mux->lock);
+
+    buffers_used = size/mux->local_rcv_buffer_size;
+
+    if(size%mux->local_rcv_buffer_size)
+        buffers_used++;
+
+    credit = &mux->channelcredit[channel];
+
+    credit->replenished_byte_credit += (size - sizeof(DATA_PACKET_HDR));
+    credit->replenished_send_credit += buffers_used;
+
+    replenish_send_limit = credit->max_host_send_credit/MUX_SENDCREDIT_SEND_LIMIT_DIVISOR;
+    replenish_byte_limit = credit->max_host_byte_credit/MUX_BYTECREDIT_SEND_LIMIT_DIVISOR;
+
+    if(
+       credit->replenished_send_credit >= replenish_send_limit ||
+       credit->replenished_byte_credit >= replenish_byte_limit
+      )
+    {
+        DBGFC("Sending Credit: %d, %d, %d", channel,
+              credit->replenished_byte_credit, credit->replenished_send_credit);
+
+        AdjustCredit(
+                     host_end(COMMAND),
+                     (int8)channel,
+                     credit->replenished_byte_credit,
+                     credit->replenished_send_credit,
+                     mux
+                    );
+
+        credit->replenished_byte_credit = 0;
+        credit->replenished_send_credit = 0;
+    }
+
+    exit_write_criticalsection(&mux->lock);
+}
+
+/*
+ * ProcessSendQueues is responsible for the actual sending of data
+ * from the mux to a linkdriver. Data will be delivered from the lowest
+ * numbered channel first. If the linkdriver returns an error on the
+ * send the mux stops sending and waits for the linkdriver to inform
+ * the mux that it is okay to run again.
+ *
+ * Params:
+ * param -- the pointer to a mux object
+ */
+void ProcessSendQueues (struct work_struct *work)
+{
+    INTERFACEINFORM informdata;
+    CHANNEL**       channels;
+    CHANNELCREDIT*  channelcredits;
+    CHANNELCREDIT*  credit;
+    int32         (*Send) (void*);
+    MUX*            mux;
+    COMMBUFF*       commbuff;
+    int32           result;
+    int32           buffLength;
+    int32           dataLength;
+    int32           numBuffers;
+    int32           ignore_amount = 0;
+    COMMBUFFQUEUE*  currentQ;
+    CHANNEL*        chanlPtr;
+    static int32    chanlNum = 0;
+    int32           startChanlNum = chanlNum;
+    int32           holding_lock = 0;
+
+    DEBUG("ProcessSendQueues(%p)\n", work);
+
+    mux = container_of (work, MUX, send_task.work);
+
+    Send           = mux->Send;
+    channels       = mux->channels;
+    channelcredits = mux->channelcredit;
+
+    credit        = NULL;
+
+    disable_task(&mux->send_task);
+
+    /* tell the interfaces that they can do their send prep work */
+    informdata.inform_type = INFORM_INTERFACE_PREPSEND;
+    informdata.source      = mux;
+    informdata.data        = NULL;
+    BroadcastLibraryInform(&informdata, mux->interface_lib);
+
+    /* pre-set the inform type used when we let the interfaces */
+    /* know that we finished sending their data                */
+    informdata.inform_type = INFORM_INTERFACE_DATA;
+
+    enter_write_criticalsection(&mux->lock);
+    holding_lock = 1;
+
+    /* while there is queued data that we can't ignore, keep trying */
+    /* to send unless the Link Driver tells us to go away           */
+    while (mux->total_queued_amount > ignore_amount)
+    {
+        if(!holding_lock)
+        {
+            enter_write_criticalsection(&mux->lock);
+            holding_lock = 1;
+        }
+
+        currentQ = &(mux->send_queue);
+        chanlPtr = NULL;
+        commbuff = NULL;
+        /* these next assignments make the compiler happier although */
+        /* they do nothing practical for the code                    */
+        numBuffers = 0;
+        buffLength = 0;
+        dataLength = 0;
+
+        /* see whether there is some NetMUX control info to send */
+        if (queue_length(currentQ))
+        {
+            if(mux->send_buffers_available == 0)
+            {
+                exit_write_criticalsection(&mux->lock);
+                enable_task(&mux->send_task);
+                return;
+            }
+            commbuff   = dequeue_commbuff(currentQ);
+            buffLength = commbuff_length(commbuff);
+        }
+        /* otherwise, starting at the top, look for an open channel that */
+        /* has data and the credit to send it                            */
+        else
+        {
+            ignore_amount = 0;
+
+            /* make one pass through the channels looking for something to */
+            /* send                                                        */
+            do
+            {
+                chanlPtr = channels[chanlNum];
+                credit   = &channelcredits[chanlNum];
+
+                /* look for open channels with data on them... */
+                if(chanlPtr && (chanlPtr->state & (SENDING | FLUSHING)))
+                {
+                    currentQ   = &(chanlPtr->send_queue);
+                    commbuff   = queue_frontbuff(currentQ);
+                    buffLength = commbuff_length(commbuff);
+                    dataLength = buffLength - sizeof(DATA_PACKET_HDR);
+
+                    numBuffers  = buffLength / mux->remote_rcv_buffer_size;
+                    if(buffLength % mux->remote_rcv_buffer_size)
+                        numBuffers++;
+
+                    /* look for channels with available credit...  */
+                    if(numBuffers > credit->client_send_credit ||
+                       dataLength > credit->client_byte_credit ||
+                       numBuffers > mux->send_buffers_available)
+                    {
+                        commbuff = NULL;
+                        ignore_amount += chanlPtr->qed_totl_amount;
+                    }
+                    else
+                    {
+                        /* we have a winner! */
+                        commbuff = dequeue_commbuff(currentQ);
+                        break;
+                    }
+                }
+
+                /* increment the loop index with wrap-around */
+                chanlNum++;
+                if (chanlNum == mux->maxchannels)
+                  chanlNum = 0;
+
+            } while(chanlNum != startChanlNum);
+            startChanlNum = chanlNum;
+        }
+
+        /* if we found some data... */
+        if (commbuff)
+        {
+            /* first, log it...                                          */
+            /* to address a BP race condition over the buffer ownership, */
+            /* log the contents here and log whether or not the send     */
+            /* succeeded below */
+            LOGCOMMBUFF_CH(chanlNum, "ProcessSendQueues()-->",
+                           commbuff, buffLength);
+
+            /* ...then try to send it */
+            result = Send((void*)commbuff);
+
+            /* if we were deferred... */
+            if(result == LDP_ERROR_RECOVERABLE)
+            {
+                /* ...re-queue the data */
+                queuefront_commbuff(commbuff, currentQ);
+
+                exit_write_criticalsection(&mux->lock);
+
+                /* indicate that the send is delayed */
+                LOG_TRACE("ProcessSendQueues()-->send delayed, data re-queued\n");
+
+                /* leave without enabling the task so that */
+                /* it can be scheduled if necessary        */
+                return;
+            }
+            else if(result != LDP_ERROR_NONE)
+            {
+                PANIC(netmuxPanicILDFail, "NetMUX Link Driver delivered a fatal error\n");
+            }
+
+            /* indicate that the send succeeded */
+            LOG_TRACE("ProcessSendQueues()-->send succeeded\n");
+
+            // free up the buffer we just sent successfully to the Link Driver
+            deref_commbuff(commbuff);
+
+            /* do the accounting */
+            mux->total_queued_amount    -= buffLength;
+
+            if (chanlPtr != NULL)
+            {
+                chanlPtr->qed_data_amount   -= dataLength;
+                chanlPtr->qed_totl_amount   -= buffLength;
+                credit->client_byte_credit  -= dataLength;
+                credit->client_send_credit  -= numBuffers;
+                mux->send_buffers_available -= numBuffers;
+
+                if (!(chanlPtr->qed_data_amount))
+                {
+                    /* let the interface know that we finished sending its data */
+                    informdata.data = (void*)chanlNum;
+
+                    (void) ExecuteStateTransition(SEND_COMPLETE, mux, chanlNum);
+
+                    holding_lock = 0;
+                    exit_write_criticalsection(&mux->lock);
+
+                    LIBRARY_INFORM(&informdata, chanlPtr->connected_interface->interface_index, mux->interface_lib);
+                }
+
+                /* since we broke from the inner while loop above,       */
+                /* increment the channel index to go to the next channel */
+                chanlNum++;
+            }
+        }
+    }
+
+    if(holding_lock)
+        exit_write_criticalsection(&mux->lock);
+
+	enter_write_criticalsection(&mux->lock);
+	check_all_send_queues_emptiness(mux);
+	exit_write_criticalsection(&mux->lock);
+
+    enable_task(&mux->send_task);
+}
+
+
+/*
+ * ProcessReceiveQueues takes completed data from the receive
+ * queues and delivers it to the appropriate place. If the
+ * data belongs to the mux it is delivered as a command to
+ * be parsed and if it is from a channel it goes to the
+ * respective interface.
+ *
+ * Params:
+ * param -- the mux object
+ */
+void ProcessReceiveQueues (struct work_struct *work)
+{
+    INTERFACEINFORM inform_data;
+    CHANNEL**       channels;
+    MUX*            mux;
+    CHANNEL*        recv_channel;
+    COMMBUFF*       commbuff;
+    COMMBUFFQUEUE*  queue;
+    int32           channel;
+    int32           result;
+    int32           length;
+
+    DEBUG("ProcessReceiveQueues(%p)\n", work);
+
+    mux = container_of (work, MUX, receive_task.work);
+
+    channels           = mux->channels;
+    inform_data.source = mux;
+    queue              = &mux->receive_queue;
+
+    disable_task(&mux->receive_task);
+
+    /* move everything from the mux receive queue to the application queues */
+    while(queue_length(queue))
+    {
+        commbuff = dequeue_commbuff(queue);
+        ReceivePartial(commbuff, mux);
+    }
+
+    enter_write_criticalsection(&mux->lock);
+
+    /* then process the application receive queues */
+    for(channel = 0; channel < mux->maxchannels; channel++)
+    {
+        recv_channel = channels[channel];
+        if(recv_channel)
+        {
+            inform_data.data        = (void*)channel;
+            inform_data.inform_type = recv_channel->connected_interface->param;
+            queue                   = &recv_channel->receive_queue;
+
+            while(queue_length(queue))
+            {
+                commbuff = dequeue_commbuff(queue);
+
+                if(!(recv_channel->state & (OPEN | SENDING)))
+                {
+                    /* if we're not in a position to forward this data */
+                    /* to the interface then we should discard it      */
+                    free_commbuff(commbuff);
+                  continue;
+                }
+
+                length   = commbuff_length(commbuff);
+
+                result = recv_channel->connected_interface->Receive(commbuff, &inform_data);
+                if(result != ERROR_NONE)
+                {
+                    queuefront_commbuff(commbuff, queue);
+
+                    if(result != ERROR_OPERATIONRESTRICTED)
+                        task_schedule(&mux->receive_task);
+
+                    break;
+                }
+            }
+        }
+    }
+
+	check_all_receive_queues_emptiness(mux);
+    exit_write_criticalsection(&mux->lock);
+    enable_task(&mux->receive_task);
+}
+
+/*
+ * ShutdownMUX is called if the linkdriver informs the mux of a
+ * fatal error. This task is scheduled to ensure we are in a safe
+ * context and then the mux gets shutdown.
+ *
+ * Params:
+ * param -- the mux object
+ */
+void ShutdownMUX (struct work_struct *work)
+{
+    INTERFACEINFORM inform_data;
+    MUX*            mux;
+
+    DEBUG("ShutdownMUX(%p)\n", work);
+
+    mux = container_of (work, MUX, shutdown_task.work);
+
+    inform_data.source      = mux;
+    inform_data.inform_type = LDP_INFORM_SHUTDOWN;
+
+    BroadcastLibraryInform(&inform_data, mux->interface_lib);
+    DisableMUX(client_end(COMMAND), mux);
+}
+
+/*
+ * ReceiveFromLink is called whenever data is received from the linkdriver.
+ * The data will be pieced together and routed appropriately.
+ *
+ * Params:
+ * buff -- the data received
+ * param -- the mux object
+ */
+int32 ReceiveFromLink (void* buff, void* param)
+{
+    MUX*      mux;
+    COMMBUFF* commbuff;
+
+    DEBUG("ReceiveFromLink(%p, %p)\n", buff, param);
+
+    /* Acquire NM_receive wakelock */
+    DEBUG("Acquire netmux_receive_wakelock\n");
+    wake_lock(&netmux_receive_wakelock);
+
+    commbuff = (COMMBUFF*)buff;
+    mux      = (MUX*)param;
+
+    if(!commbuff || !mux)
+        return DEBUGLDP(LDP_ERROR_FATAL);
+
+    LOGCOMMBUFF_RECV_LD("ReceiveFromLink()-->", commbuff, commbuff_length(commbuff));
+
+    ref_commbuff(commbuff);
+
+    queue_commbuff(commbuff, &mux->receive_queue);
+    task_schedule(&mux->receive_task);
+
+    return DEBUGLDP(LDP_ERROR_NONE);
+}
+
+/*
+ * ReceivePartial is called to handle data received on the mux receive queue.
+ * The algorithm here depends on the fact that multiple messages will never
+ * cross commbuff boundaries.
+ *
+ * Params:
+ *   commbuff -- the data received
+ *   mux      -- the mux object
+ */
+void ReceivePartial (COMMBUFF* commbuff, MUX* mux)
+{
+    PARTIAL_RECEIVE* part_recv;
+
+    DEBUG("ReceivePartial(%p, %p)\n", commbuff, mux);
+
+    part_recv = &mux->partial_receive;
+
+    if (part_recv->buffer)
+    {
+        /* we're already building up from something previously received */
+        /* so just merge this one into the previous one and update the  */
+        /* stats                                                        */
+        part_recv->buffer = commbuff_merge(part_recv->buffer, commbuff);
+        part_recv->packet.payload = commbuff_data(part_recv->buffer);
+    }
+    else
+    {
+        /* we're starting a new message so start everything over */
+
+        part_recv->buffer         = commbuff;
+        part_recv->packet.payload = commbuff_data(commbuff);
+        part_recv->type           = part_recv->packet.payload[0];
+
+        switch(part_recv->type)
+        {
+            case PACKETTYPE_DATA_HDR:
+            {
+                part_recv->expectedLen = sizeof(DATA_PACKET_HDR);
+            }break;
+
+            case PACKETTYPE_CREDIT:
+            {
+              part_recv->expectedLen = sizeof(CREDIT_PACKET);
+            }break;
+
+            case PACKETTYPE_ENABLEMUX:
+            {
+              part_recv->expectedLen = sizeof(ENABLEMUX_PACKET);
+            }break;
+
+            case PACKETTYPE_DISABLEMUX:
+            {
+              part_recv->expectedLen = sizeof(DISABLEMUX_PACKET);
+            }break;
+
+            case PACKETTYPE_ENABLECHANNEL:
+            {
+              part_recv->expectedLen = sizeof(ENABLECHANNEL_PACKET);
+            }break;
+
+            case PACKETTYPE_DISABLECHANNEL:
+            {
+              part_recv->expectedLen = sizeof(DISABLECHANNEL_PACKET);
+            }break;
+
+            case PACKETTYPE_QUERYINTERFACE:
+            {
+              part_recv->expectedLen = sizeof(QUERYINTERFACE_PACKET);
+            }break;
+
+            case PACKETTYPE_CHANNELSIGNAL:
+            {
+              part_recv->expectedLen = sizeof(CHANNELSIGNAL_PACKET);
+            }break;
+
+            default:
+            {
+                DEBUG("NETMUX ERROR: DISCARDING INVALID PACKET TYPE, type %u\n",
+                       (part_recv->type));
+                free_commbuff(commbuff);
+                PANIC(netmuxPanicPkgFail1, "packet type invalid");
+            }
+        }
+    }
+
+    part_recv->currentLen = commbuff_length(part_recv->buffer);
+
+    if (part_recv->currentLen >= part_recv->expectedLen)
+    {
+        /* make sure that the packet/header is in contiguous memory */
+        /* this is only a cbuf issue at the moment and will only be */
+        /* a real problem if the link driver passes up buffers that */
+        /* are smaller than the largest packet/header size          */
+        if(part_recv->type != PACKETTYPE_DATA_BDY)
+        {
+            commbuff_data_pullup(part_recv->buffer, part_recv->expectedLen);
+        }
+
+        /* we got at least a header so convert the longer-than-one-byte */
+        /* header fields where needed and adjust for the data case...   */
+        switch(part_recv->type)
+        {
+            case PACKETTYPE_DATA_HDR:
+            {
+                part_recv->type = PACKETTYPE_DATA_BDY;
+                convert_word(part_recv->packet.datapacket->len);
+                part_recv->expectedLen += part_recv->packet.datapacket->len;
+            }break;
+
+            case PACKETTYPE_CREDIT:
+            {
+                convert_dword(part_recv->packet.creditpacket->bytecredit);
+                convert_dword(part_recv->packet.creditpacket->sendcredit);
+            }break;
+
+            case PACKETTYPE_ENABLECHANNEL:
+            {
+                convert_dword(part_recv->packet.enablechannel->bytecredit);
+                convert_dword(part_recv->packet.enablechannel->sendcredit);
+            }break;
+
+            /* note that in the PACKETTYPE_CHANNELSIGNAL case we let the */
+            /* tty interface deal with the int32 contained there         */
+        }
+
+        LOG_TRACE("currentLen=%ld expectedLen=%ld\n", part_recv->currentLen, part_recv->expectedLen);
+
+        if (part_recv->currentLen == part_recv->expectedLen)
+        {
+            /* we have it all, pass it on... */
+
+            LOG_PACKETTYPE(part_recv->buffer);
+
+            if (part_recv->type == PACKETTYPE_DATA_BDY)
+            {
+                ReceiveData(mux);
+            }
+            else
+            {
+                ReceiveCommand(mux);
+                free_commbuff(part_recv->buffer);
+            }
+
+            /* now that we've handled this one, clear up the partial */
+            /* so that we can receive a new message                  */
+            memset(part_recv, 0, sizeof(PARTIAL_RECEIVE));
+        }
+        else if (part_recv->currentLen > part_recv->expectedLen)
+        {
+            printk("NETMUX ERROR: data length is over, expectedLen = %ld, currentLen = %ld\n", part_recv->expectedLen, part_recv->currentLen);
+            PANIC(netmuxPanicPkgFail2, "Packet received over length"); 
+        }
+    }
+}
+
+/*
+ * ReceiveCommand is called when a complete command message arrives.
+ * The command will be parsed and processed.
+ *
+ * Params:
+ * commbuff -- the data
+ * mux -- the mux object
+ */
+void ReceiveCommand (MUX* mux)
+{
+    INTERFACEINFORM  inform_data;
+    PARTIAL_RECEIVE* part_recv;
+
+    DEBUG("ReceiveCommand(%p)\n", mux);
+
+    part_recv          = &mux->partial_receive;
+    inform_data.source = mux;
+
+    switch(part_recv->type)
+    {
+        case PACKETTYPE_CREDIT:
+        {
+            AdjustCredit(client_end(COMMAND),
+                         (int8)part_recv->packet.creditpacket->channel,
+                         part_recv->packet.creditpacket->bytecredit,
+                         part_recv->packet.creditpacket->sendcredit,
+                         mux);
+        }break;
+
+
+        case PACKETTYPE_ENABLEMUX:
+        {
+            EnableMUX(part_recv->packet.enablemux->acktype, mux);
+        }break;
+
+
+        case PACKETTYPE_DISABLEMUX:
+        {
+            DisableMUX(part_recv->packet.disablemux->acktype, mux);
+        }break;
+
+
+        case PACKETTYPE_ENABLECHANNEL:
+        {
+            if(part_recv->packet.enablechannel->acktype == client_end(COMMAND))
+            {
+                inform_data.inform_type = INFORM_INTERFACE_ENABLECHANNEL;
+                inform_data.data = (void*)part_recv->packet.enablechannel;
+
+                LIBRARY_INFORM(&inform_data, part_recv->packet.enablechannel->client_interface, mux->interface_lib);
+            }
+            else
+            {
+                EnableChannel(
+                              part_recv->packet.enablechannel->acktype,
+                              part_recv->packet.enablechannel->channel,
+                              0,
+                              0,
+                              part_recv->packet.enablechannel->host_interface,
+                              part_recv->packet.enablechannel->client_interface,
+                              0,
+                              0,
+                              part_recv->packet.enablechannel->bytecredit,
+                              part_recv->packet.enablechannel->sendcredit,
+                              mux
+                             );
+            }
+        }break;
+
+
+        case PACKETTYPE_DISABLECHANNEL:
+        {
+            DisableChannel(part_recv->packet.disablechannel->acktype,
+                           part_recv->packet.disablechannel->channel,
+                           part_recv->packet.disablechannel->host_interface,
+                           part_recv->packet.disablechannel->client_interface,
+                           mux);
+        }break;
+
+
+        case PACKETTYPE_QUERYINTERFACE:
+        {
+            QueryExternalInterface(part_recv->packet.queryinterface->acktype,
+                                   part_recv->packet.queryinterface->host_interface,
+                                   part_recv->packet.queryinterface->result,
+                                   (sint8*)part_recv->packet.queryinterface->name,
+                                   mux);
+        }break;
+
+        case PACKETTYPE_CHANNELSIGNAL:
+        {
+            ChannelSignal(part_recv->packet.channelsignal->acktype,
+                          part_recv->packet.channelsignal->channel,
+                          part_recv->packet.channelsignal->signal,
+                          mux);
+        }break;
+    }
+
+    return;
+}
+
+
+/*
+ * ReceiveData is called to process data being received from the remote NetMUX.
+ * The data has already been pieced together if it was fragmented by the link
+ * driver so now it just needs  delivered to the right interface.
+ *
+ * Params:
+ * commbuff -- the data
+ * mux -- the mux object
+ */
+void ReceiveData (MUX* mux)
+{
+    COMMBUFF* databuffer;
+    CHANNEL*  channel;
+    int8      chanlNum;
+
+    DEBUG("ReceiveData(%p)\n", mux);
+
+    enter_write_criticalsection(&mux->lock);
+
+    databuffer = mux->partial_receive.buffer;
+    chanlNum   = mux->partial_receive.packet.datapacket->channel;
+    channel    = mux->channels[chanlNum];
+
+    if(!channel)
+    {
+        /* we've just received data for a closed channel, let's log it */
+        DEBUG("NETMUX ERROR: DISCARDING DATA RECEIVED FOR CLOSED CHANNEL NUMBER %d\n",
+              chanlNum);
+        free_commbuff(databuffer);
+        exit_write_criticalsection(&mux->lock);
+        return;
+    }
+
+    /* tag before stripping the header so we can account for */
+    /* receive buffers freed when this one is released       */
+    tag_commbuff(databuffer, chanlNum, (void*)mux, &CommBuffReleased);
+
+    /* get rid of the header before it goes on the channel queue */
+    commbuff_remove_front(databuffer, sizeof(DATA_PACKET_HDR));
+
+    queue_commbuff(databuffer, &channel->receive_queue);
+
+    exit_write_criticalsection(&mux->lock);
+}
+
+/*
+ * CreateMUX creates a mux object that can then be used for
+ * communication via assigning interfaces and a linkdriver to it.
+ *
+ * Params:
+ * maxchannels -- the max number of channels for the mux to support
+ * loc_max_rcv_siz -- largest message the local linkdriver will receive
+ * rem_max_rcv_siz -- largest message the remote linkdriver can receive
+ * sendfunction -- the function to send data with
+ * interface_lib -- the interface library to assign the mux to
+ * mux -- a pointer to where to save the mux object
+ */
+int32 CreateMUX (
+                 int32                 maxchannels,
+                 int32                 max_send_buffers,
+                 int32                 loc_max_rcv_siz,
+                 int32                 rem_max_rcv_siz,
+                 int32               (*sendfunction) (void*),
+                 MUXINTERFACE_LIBRARY* interface_lib,
+                 MUX**                 mux
+                )
+{
+    CHANNEL**      newchannels;
+    CHANNELCREDIT* newcredits;
+    MUX*           newmux;
+    int32          size;
+
+    DEBUG(
+          "CreateMUX(%lu, %lu, %lu, %lu, %p, %p, %p)\n",
+          maxchannels,
+          max_send_buffers,
+          loc_max_rcv_siz,
+          rem_max_rcv_siz,
+          sendfunction,
+          interface_lib,
+          mux
+         );
+
+    if(!maxchannels || !sendfunction || !interface_lib || !mux)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    newmux = alloc_mem(sizeof(MUX));
+
+    size        = sizeof(CHANNEL*)*maxchannels;
+    newchannels = alloc_mem(size);
+
+    memset(newchannels, 0, size);
+
+    size       = sizeof(CHANNELCREDIT)*maxchannels;
+    newcredits = alloc_mem(size);
+
+    memset(newcredits, 0, size);
+    memset(newmux, 0, sizeof(MUX));
+
+    newmux->Send                   = sendfunction;
+    newmux->channels               = newchannels;
+    newmux->channelcredit          = newcredits;
+    newmux->maxchannels            = maxchannels;
+    newmux->interface_lib          = interface_lib;
+    newmux->status                 = STATUS_DEFAULT;
+    newmux->local_rcv_buffer_size  = loc_max_rcv_siz;
+    newmux->remote_rcv_buffer_size = rem_max_rcv_siz;
+    newmux->send_buffers_available = max_send_buffers;
+
+    initialize_commbuff_queue(&newmux->send_queue);
+    initialize_commbuff_queue(&newmux->receive_queue);
+
+    initialize_task(&newmux->send_task, &ProcessSendQueues);
+    initialize_task(&newmux->receive_task, &ProcessReceiveQueues);
+    initialize_task(&newmux->shutdown_task, &ShutdownMUX);
+
+    initialize_criticalsection_lock(&newmux->lock);
+
+    disable_task(&newmux->send_task);
+
+    *mux = newmux;
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DestroyMUX will destroy a mux object and any allocated resources.
+ * This call assumes the mux object is not currently in use.
+ *
+ * Params:
+ * mux -- the mux object
+ */
+int32 DestroyMUX (MUX* mux)
+{
+    DEBUG("DestroyMUX(%p)\n", mux);
+
+    if(!mux)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    if(mux->status != STATUS_DEFAULT)
+    {
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    destroy_task(&mux->send_task);
+    destroy_task(&mux->receive_task);
+
+    destroy_commbuff_queue(&mux->send_queue);
+    destroy_commbuff_queue(&mux->receive_queue);
+
+    destroy_criticalsection_lock(&mux->lock);
+
+    free_mem(mux->channels);
+    free_mem(mux->channelcredit);
+    free_mem(mux);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * AdjustCredit is called to send a credit message to the client
+ * mux.
+ *
+ * Params:
+ * acktype -- the direction of the packet
+ * channel -- where the packet belongs
+ * space -- the number of bytes of credit to deliver
+ * mux -- the mux object
+ */
+int32 AdjustCredit (int32 acktype, int32 channel, int32 bytecredit, int32 sendcredit, MUX* mux)
+{
+    CHANNELCREDIT* credit;
+
+    DEBUG("AdjustCredit(%lu, %lu, %lu, %lu, %p)\n", acktype, channel, bytecredit, sendcredit, mux);
+
+    switch(acktype)
+    {
+        case host_end(COMMAND):
+        {
+            TransmitCredit(client_end(COMMAND), (int8)channel, bytecredit, sendcredit, mux);
+        }break;
+
+        case client_end(COMMAND):
+        {
+            enter_write_criticalsection(&mux->lock);
+
+            credit = &mux->channelcredit[channel];
+
+            mux->send_buffers_available += sendcredit;
+
+            credit->client_byte_credit += bytecredit;
+            credit->client_send_credit += sendcredit;
+
+            task_schedule(&mux->send_task);
+
+            exit_write_criticalsection(&mux->lock);
+        }break;
+
+        default:
+        {
+            return DEBUGERROR(ERROR_OPERATIONFAILED);
+        }break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * EnableMUX delivers an enable message to the client mux.
+ *
+ * Params:
+ * acktype -- the direction of the packet
+ * mux -- the mux object
+ */
+int32 EnableMUX (int32 acktype, MUX* mux)
+{
+    ENABLEMUX_PACKET enablemux;
+    INTERFACEINFORM  inform_data;
+
+    DEBUG("EnableMUX(%lu, %p)\n", acktype, mux);
+
+    enablemux.acktype = (int8)acktype;
+    enablemux.type    = PACKETTYPE_ENABLEMUX;
+
+    inform_data.source            = mux;
+    inform_data.inform_type       = INFORM_INTERFACE_ENABLEMUX;
+    inform_data.data              = (void*)&enablemux;
+
+    switch(acktype)
+    {
+        case host_end(COMMAND):
+        {
+            if(!(mux->status&STATUS_DEFAULT))
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            mux->status ^= (STATUS_DEFAULT|STATUS_ENABLE);
+
+            TransmitEnableMUX(client_end(COMMAND), mux);
+            enable_task(&mux->send_task);
+        }break;
+
+        case host_end(SUCCESS):
+        {
+            if(!(mux->status&STATUS_ENABLE))
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            mux->status ^= (STATUS_ENABLE|STATUS_ACTIVE);
+
+            BroadcastLibraryInform(&inform_data, mux->interface_lib);
+        }break;
+
+        case host_end(FAILURE):
+        {
+            if(!(mux->status&STATUS_ENABLE))
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            mux->status ^= (STATUS_ENABLE|STATUS_DEFAULT);
+
+            BroadcastLibraryInform(&inform_data, mux->interface_lib);
+        }break;
+
+        case client_end(COMMAND):
+        {
+            if(!(mux->status&STATUS_DEFAULT))
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            mux->status      ^= (STATUS_DEFAULT|STATUS_ACTIVE);
+            enablemux.acktype = (int8)client_end(SUCCESS);
+
+            TransmitEnableMUX(host_end(SUCCESS), mux);
+            enable_task(&mux->send_task);
+
+            BroadcastLibraryInform(&inform_data, mux->interface_lib);
+        }break;
+
+        default:return DEBUGERROR(ERROR_INVALIDPARAMETER);
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DisableMUX will send a disable mux packet to the client NetMUX.
+ *
+ * Params:
+ * acktype -- the direction of the disable
+ * mux -- the mux object
+ */
+int32 DisableMUX (int32 acktype, MUX* mux)
+{
+    DISABLEMUX_PACKET disablemux;
+    INTERFACEINFORM   informdata;
+    CHANNEL**         channels;
+    int32             index;
+
+    DEBUG("DisableMUX(%lu, %p)\n", acktype, mux);
+
+    disablemux.acktype = (int8)acktype;
+    disablemux.type    = PACKETTYPE_DISABLEMUX;
+
+    informdata.source      = mux;
+    informdata.inform_type = INFORM_INTERFACE_DISABLEMUX;
+    informdata.data        = (void*)&disablemux;
+
+    switch(acktype)
+    {
+        case host_end(COMMAND):
+        {
+            enter_write_criticalsection(&mux->lock);
+
+            if(!(mux->status&STATUS_ACTIVE))
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+
+            TransmitDisableMUX(client_end(COMMAND), mux);
+
+            mux->status         ^= (STATUS_ACTIVE|STATUS_DEFAULT);
+            channels             = mux->channels;
+
+            for(index = 0; index < mux->maxchannels; index++)
+                CloseChannel(index, mux);
+
+            exit_write_criticalsection(&mux->lock);
+
+            BroadcastLibraryInform(&informdata, mux->interface_lib);
+        }break;
+
+        case client_end(COMMAND):
+        {
+            enter_write_criticalsection(&mux->lock);
+
+            if(!(mux->status&STATUS_ACTIVE))
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+
+            mux->status             ^= (STATUS_ACTIVE|STATUS_DEFAULT);
+            mux->total_queued_amount = 0;
+            channels                 = mux->channels;
+
+            empty_commbuff_queue(&mux->send_queue);
+
+            for(index = 0; index < mux->maxchannels; index++)
+                CloseChannel(index, mux);
+
+            exit_write_criticalsection(&mux->lock);
+
+            BroadcastLibraryInform(&informdata, mux->interface_lib);
+        }break;
+
+        default:return DEBUGERROR(ERROR_INVALIDPARAMETER);
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * EnableChannel will deliver an enable channel packet to the client NetMUX.
+ *
+ * Params:
+ * acktype -- the direction of the packet
+ * channel -- the channel to associate the data with
+ * burst_size -- the burst size for the channel
+ * max_data_amount -- the maximum data to be queued
+ * host_interface -- the host interface 
+ * client_interface -- the client interface 
+ * host_credit -- the host's credit
+ * client_credit -- the client's credit
+ * mux -- the mux object
+ */
+int32 EnableChannel (
+                     int32 acktype,
+                     int32 channel,
+                     int32 burst_size,
+                     int32 max_data_amount,
+                     int32 host_interface,
+                     int32 client_interface,
+                     int32 host_byte_credit,
+                     int32 host_send_credit,
+                     int32 client_byte_credit,
+                     int32 client_send_credit,
+                     MUX* mux
+                    )
+{
+    ENABLECHANNEL_PACKET enablechp;
+    INTERFACEINFORM      inform_data;
+    CHANNEL**            channels;
+    CHANNEL*             enable_channel;
+    CHANNELCREDIT*       credit;
+    int32                result;
+
+    DEBUG(
+          "EnableChannel(%lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %p)\n",
+          acktype,
+          channel,
+          burst_size,
+          max_data_amount,
+          host_interface,
+          client_interface,
+          host_byte_credit,
+          host_send_credit,
+          client_byte_credit,
+          client_send_credit,
+          mux
+          );
+
+    switch(acktype)
+    {
+        case host_end(COMMAND):
+        {
+            /* This is a LOCAL_OPEN event in the state machine */
+
+            if(channel >= mux->maxchannels)
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            enter_write_criticalsection(&mux->lock);
+
+            channels       = mux->channels;
+            credit         = &mux->channelcredit[channel];
+            enable_channel = channels[channel];
+
+            // if we're already open, fail
+            if(enable_channel)
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+            }
+            // otherwise, continue
+            else
+            {
+                enable_channel = alloc_mem(sizeof(CHANNEL));
+
+                memset(enable_channel, 0, sizeof(CHANNEL));
+
+                result = ConnectInterface(host_interface, mux->interface_lib, &enable_channel->connected_interface);
+
+                if(result != ERROR_NONE)
+                {
+                    exit_write_criticalsection(&mux->lock);
+
+                    free_mem(enable_channel);
+
+                    return DEBUGERROR(result);
+                }
+
+                initialize_commbuff_queue(&enable_channel->send_queue);
+                initialize_commbuff_queue(&enable_channel->receive_queue);
+
+                if(!credit->initialized)
+                {
+                    credit->max_host_byte_credit = host_byte_credit;
+                    credit->max_host_send_credit = host_send_credit;
+                }
+
+                enable_channel->burst_size      = burst_size;
+                enable_channel->max_data_amount = max_data_amount;
+                enable_channel->state           = OPENING;
+
+                channels[channel] = enable_channel;
+
+                exit_write_criticalsection(&mux->lock);
+
+                TransmitEnableChannel(
+                                      (int8)client_end(COMMAND),
+                                      (int8)channel,
+                                      (int8)host_interface,
+                                      (int8)client_interface,
+                                      host_byte_credit,
+                                      host_send_credit,
+                                      mux
+                                     );
+            }
+        }break;
+
+        case host_end(SUCCESS):
+        {
+            /* This is a OPEN_RESPONSE event in the state machine */
+
+            if(channel >= mux->maxchannels)
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            enter_write_criticalsection(&mux->lock);
+
+            channels       = mux->channels;
+            credit         = &mux->channelcredit[channel];
+            enable_channel = channels[channel];
+
+            if(enable_channel)
+            {
+                if(!(enable_channel->state & OPENING))
+                {
+                    exit_write_criticalsection(&mux->lock);
+
+                    return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+                }
+
+                if(!credit->initialized)
+                {
+                    credit->client_byte_credit      = client_byte_credit;
+                    credit->client_send_credit      = client_send_credit;
+                    credit->replenished_byte_credit = 0;
+                    credit->replenished_send_credit = 0;
+
+                    credit->initialized = 1;
+                }
+
+                enable_channel->state = OPEN;
+            }
+            else
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+
+            enablechp.acktype          = (int8)acktype;
+            enablechp.channel          = (int8)channel;
+            enablechp.client_interface = (int8)client_interface;
+            enablechp.host_interface   = (int8)host_interface;
+            enablechp.bytecredit       = client_byte_credit;
+            enablechp.sendcredit       = client_send_credit;
+            enablechp.type             = PACKETTYPE_ENABLECHANNEL;
+
+            inform_data.source      = mux;
+            inform_data.inform_type = INFORM_INTERFACE_ENABLECHANNEL;
+            inform_data.data        = (void*)&enablechp;
+
+            exit_write_criticalsection(&mux->lock);
+
+            LIBRARY_INFORM(&inform_data, host_interface, mux->interface_lib);
+        }break;
+
+        case host_end(FAILURE):
+        {
+            /* This is a OPEN_RESPONSE event in the state machine */
+
+            if(channel >= mux->maxchannels)
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            enter_write_criticalsection(&mux->lock);
+
+            channels       = mux->channels;
+            enable_channel = channels[channel];
+
+            if(enable_channel)
+            {
+                if(!(enable_channel->state & OPENING))
+                {
+                    exit_write_criticalsection(&mux->lock);
+
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+
+                enablechp.acktype          = (int8)acktype;
+                enablechp.channel          = (int8)channel;
+                enablechp.client_interface = (int8)client_interface;
+                enablechp.host_interface   = (int8)host_interface;
+                enablechp.bytecredit       = client_byte_credit;
+                enablechp.sendcredit       = client_send_credit;
+                enablechp.type             = PACKETTYPE_ENABLECHANNEL;
+
+                inform_data.source      = mux;
+                inform_data.inform_type = INFORM_INTERFACE_ENABLECHANNEL;
+                inform_data.data        = (void*)&enablechp;
+
+                CloseChannel(channel, mux);
+
+                exit_write_criticalsection(&mux->lock);
+
+                LIBRARY_INFORM(&inform_data, host_interface, mux->interface_lib);
+            }
+            else
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+        }break;
+
+        case client_end(COMMAND):
+        {
+            /* This is a REMOTE_OPEN event in the state machine */
+
+            if(channel >= mux->maxchannels)
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            enter_write_criticalsection(&mux->lock);
+
+            channels       = mux->channels;
+            credit         = &mux->channelcredit[channel];
+            enable_channel = channels[channel];
+
+            // if we're already open, fail
+            if(enable_channel)
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+            }
+            // otherwise, continue
+            else
+            {
+                enable_channel = alloc_mem(sizeof(CHANNEL));
+
+                memset(enable_channel, 0, sizeof(CHANNEL));
+
+                result = ConnectInterface(client_interface, mux->interface_lib, &enable_channel->connected_interface);
+
+                if(result != ERROR_NONE)
+                {
+                    exit_write_criticalsection(&mux->lock);
+
+                    free_mem(enable_channel);
+
+                    return DEBUGERROR(result);
+                }
+
+                initialize_commbuff_queue(&enable_channel->send_queue);
+                initialize_commbuff_queue(&enable_channel->receive_queue);
+
+                if(!credit->initialized)
+                {
+                    credit->max_host_byte_credit    = host_byte_credit;
+                    credit->max_host_send_credit    = host_send_credit;
+                    credit->client_byte_credit      = client_byte_credit;
+                    credit->client_send_credit      = client_send_credit;
+                    credit->replenished_byte_credit = 0;
+                    credit->replenished_send_credit = 0;
+
+                    credit->initialized = 1;
+                }
+
+                enable_channel->burst_size      = burst_size;
+                enable_channel->max_data_amount = max_data_amount;
+                enable_channel->state           = OPEN;
+
+                channels[channel] = enable_channel;
+
+                exit_write_criticalsection(&mux->lock);
+
+                TransmitEnableChannel(
+                                      (int8)host_end(SUCCESS),
+                                      (int8)channel,
+                                      (int8)host_interface,
+                                      (int8)client_interface,
+                                      host_byte_credit,
+                                      host_send_credit,
+                                      mux
+                                     );
+            }
+        }break;
+
+        case client_end(FAILURE):
+        {
+            TransmitEnableChannel(
+                                  (int8)host_end(FAILURE),
+                                  (int8)channel,
+                                  (int8)host_interface, 
+                                  (int8)client_interface,
+                                  host_byte_credit,
+                                  host_send_credit,
+                                  mux
+                                 );
+        }break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DisableChannel will deliver a disable channel message to a client NetMUX.
+ *
+ * Params:
+ * acktype -- the direction of the packet
+ * channel -- the channel to associate it with
+ * host_interface -- the host interface 
+ * client_interface -- the client_interface 
+ * mux -- the mux object
+ */
+int32 DisableChannel (int32 acktype, int32 channel, int32 host_interface, int32 client_interface, MUX* mux)
+{
+    CHANNEL**             channels;
+    CHANNEL*              disable_channel;
+    int32                 result;
+    DISABLECHANNEL_PACKET disablechp;
+    INTERFACEINFORM       informdata;
+
+
+    DEBUG("DisableChannel(%lu, %lu, %lu, %lu, %p)\n", acktype, channel, host_interface, client_interface, mux);
+
+    switch(acktype)
+    {
+        case host_end(COMMAND):
+        {
+            /* This is a LOCAL_CLOSE event in the state machine */
+
+            if(channel >= mux->maxchannels)
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            enter_write_criticalsection(&mux->lock);
+
+            channels        = mux->channels;
+            disable_channel = channels[channel];
+
+            if(disable_channel)
+            {
+                disable_channel->client_interface = (int8)client_interface;
+                disable_channel->host_interface = (int8)host_interface;
+
+                if(disable_channel->state &
+                   (OPENING | OPEN | SENDING | REMOTE_CLOSING))
+                {
+                    result = ExecuteStateTransition(LOCAL_CLOSE, mux, channel);
+
+                    exit_write_criticalsection(&mux->lock);
+
+                    if(result != ERROR_NONE)
+                        return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+                else
+                {
+                    exit_write_criticalsection(&mux->lock);
+
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+            else
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+        }break;
+
+        case host_end(SUCCESS):
+        {
+            /* This is a CLOSE_RESPONSE event in the state machine */
+
+             if(channel >= mux->maxchannels)
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            enter_write_criticalsection(&mux->lock);
+
+            channels        = mux->channels;
+            disable_channel = channels[channel];
+
+            if(disable_channel)
+            {
+                disable_channel->client_interface = (int8)client_interface;
+                disable_channel->host_interface = (int8)host_interface;
+
+                if(disable_channel->state & (LOCAL_CLOSING))
+                {
+                    result = ExecuteStateTransition(CLOSE_RESPONSE, mux, channel);
+
+                    if(result != ERROR_NONE)
+                    {
+                        exit_write_criticalsection(&mux->lock);
+                        return DEBUGERROR(ERROR_OPERATIONFAILED);
+                    }
+
+                    disablechp.acktype          = (int8)host_end(SUCCESS);
+                    disablechp.channel          = (int8)channel;
+                    disablechp.client_interface = (int8)client_interface;
+                    disablechp.host_interface   = (int8)host_interface;
+                    disablechp.type             = PACKETTYPE_DISABLECHANNEL;
+
+                    informdata.source      = mux;
+                    informdata.data        = (void*)&disablechp;
+                    informdata.inform_type = INFORM_INTERFACE_DISABLECHANNEL;
+
+                    exit_write_criticalsection(&mux->lock);
+
+                    LIBRARY_INFORM(&informdata, client_interface, mux->interface_lib);
+
+                }
+                else
+                {
+                    exit_write_criticalsection(&mux->lock);
+
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+
+            }
+            else
+            {
+                exit_write_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+        }break;
+
+        case client_end(COMMAND):
+        {
+            /* This is a REMOTE_CLOSE event in the state machine */
+
+            if(channel >= mux->maxchannels)
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+
+            enter_write_criticalsection(&mux->lock);
+
+            channels        = mux->channels;
+            disable_channel = channels[channel];
+
+            if(disable_channel)
+            {
+                disable_channel->client_interface = (int8)client_interface;
+                disable_channel->host_interface = (int8)host_interface;
+
+                if(disable_channel->state &
+                   (OPEN | SENDING | FLUSHING | LOCAL_CLOSING))
+                {
+                    result = ExecuteStateTransition(REMOTE_CLOSE, mux, channel);
+
+                    if(result != ERROR_NONE)
+                    {
+                        exit_write_criticalsection(&mux->lock);
+                        return DEBUGERROR(ERROR_OPERATIONFAILED);
+                    }
+
+                    if(disable_channel->state & (FLUSHING))
+                    {
+                        /* time to close the channel */
+                        CloseChannel(channel, mux);
+
+                        exit_write_criticalsection(&mux->lock);
+                    }
+                    else if(disable_channel->state & (REMOTE_CLOSING))
+                    {
+                        /* the OPEN and SENDING cases both end up here */
+                        disablechp.acktype          = (int8)client_end(COMMAND);
+                        disablechp.channel          = (int8)channel;
+                        disablechp.client_interface = (int8)disable_channel->client_interface;
+                        disablechp.host_interface   = (int8)disable_channel->host_interface;
+                        disablechp.type             = PACKETTYPE_DISABLECHANNEL;
+
+                        informdata.source      = mux;
+                        informdata.data        = (void*)&disablechp;
+                        informdata.inform_type = INFORM_INTERFACE_DISABLECHANNEL;
+
+                        exit_write_criticalsection(&mux->lock);
+
+                        LIBRARY_INFORM(&informdata,
+                                       disable_channel->client_interface,
+                                       mux->interface_lib);
+                    }
+                    else
+                    {
+                        /* this catches the LOCAL_CLOSING case */
+                        exit_write_criticalsection(&mux->lock);
+                    }
+                }
+                else
+                {
+                    exit_write_criticalsection(&mux->lock);
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+                }
+            }
+            else
+            {
+                /* we are closed here but we need to respond anyway */
+                TransmitDisableChannel((int8)host_end(SUCCESS), (int8)channel,
+                                       (int8)host_interface,
+                                       (int8)client_interface, mux);
+
+                exit_write_criticalsection(&mux->lock);
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+        }break;
+
+        default:
+            return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * QueryExternalInterface will query an interfaces id from a client NetMUX.
+ *
+ * Params:
+ * acktype -- the direction of the packet
+ * host_interface -- the host interface
+ * res -- the result of the query (not always used)
+ * name -- the name of the interface to query
+ * mux -- the mux object
+ */
+int32 QueryExternalInterface (int32 acktype, int32 host_interface, int32 res, sint8* name, MUX* mux)
+{
+    QUERYINTERFACE_PACKET queryinterface;
+    INTERFACEINFORM       inform_data;
+    int32                 result;
+    int32                 queried_interface;
+
+    DEBUG("QueryExternalInterface(%lu, %lu, %lu, %p, %p)\n", acktype, host_interface, res, name, mux);
+
+    queried_interface = 0;
+
+    switch(acktype)
+    {
+        case host_end(COMMAND):
+        {
+            TransmitQueryInterface((int8)client_end(COMMAND), (int8)host_interface, (int8)res, name, mux);
+        }break;
+
+        case host_end(SUCCESS):
+        case host_end(FAILURE):
+        {
+            memcpy((void*)queryinterface.name, name, PACKET_MAXNAME_LENGTH);
+
+            queryinterface.acktype        = (int8)acktype;
+            queryinterface.result         = (int8)res;
+            queryinterface.host_interface = (int8)host_interface;
+            queryinterface.type           = PACKETTYPE_QUERYINTERFACE;
+
+            inform_data.source      = mux;
+            inform_data.inform_type = INFORM_INTERFACE_QUERYINTERFACE;
+            inform_data.data        = (void*)&queryinterface;
+
+            LIBRARY_INFORM(&inform_data, host_interface, mux->interface_lib);
+        }break;
+
+        case client_end(COMMAND):
+        {
+            if(!name)
+                return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+            result = QueryInterfaceIndex(name, mux->interface_lib, &queried_interface);
+
+            if(result != ERROR_NONE)
+                TransmitQueryInterface((int8)host_end(FAILURE), (int8)host_interface, (int8)queried_interface, name, mux);
+            else
+                TransmitQueryInterface((int8)host_end(SUCCESS), (int8)host_interface, (int8)queried_interface, name, mux);
+        }break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * ChannelSignal will signal a channel on the client NetMUX.
+ *
+ * acktype -- the direction
+ * signal -- the signal
+ * channel -- where to associate the data
+ * mux -- the mux
+ */
+int32 ChannelSignal (int8 acktype, int32 signal, int32 channel, MUX* mux)
+{
+    CHANNELSIGNAL_PACKET channelsignal;
+    INTERFACEINFORM      inform_data;
+    CHANNEL*             chdat;
+    int32                ifindex;
+
+    DEBUG("ChannelSignal(%u, %lu, %lu, %p)\n", acktype, signal, channel, mux);
+
+    switch(acktype)
+    {
+        case host_end(COMMAND):
+        {
+            TransmitChannelSignal((int8)client_end(COMMAND), (int8)channel, signal, mux);
+        }break;
+
+        case client_end(COMMAND):
+        {
+            enter_read_criticalsection(&mux->lock);
+
+            chdat = mux->channels[channel];
+            if(!chdat)
+            {
+                exit_read_criticalsection(&mux->lock);
+
+                return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+
+            ifindex = chdat->connected_interface->interface_index;
+
+            exit_read_criticalsection(&mux->lock);
+
+            channelsignal.type    = PACKETTYPE_CHANNELSIGNAL;
+            channelsignal.acktype = acktype;
+            channelsignal.channel = (int8)channel;
+            channelsignal.signal  = signal;
+
+            inform_data.inform_type = INFORM_INTERFACE_CHANNELSIGNAL;
+            inform_data.source      = (void*)mux;
+            inform_data.data        = (void*)&channelsignal;
+
+            LIBRARY_INFORM(&inform_data, ifindex, mux->interface_lib);
+        }break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * SendData will deliver data to a particular channel on the client NetMUX.
+ *
+ * IMPORTANT NOTE: the (interface) caller is responsible for guaranteeing
+ * that all buffers sent to this interface contain sufficient room reserved
+ * for the header to be added.  This is especially important to cosider if any
+ * interface expects to be able to re-send a split buffer then it must first
+ * make sure that the buffer being sent has the header reservation.  More
+ * clearly, this function does NOT return split buffers with reserved header
+ * space.  Note further that this caution does not apply to cbufs.
+ *
+ * Params:
+ * channel -- the channel to deliver the data to
+ * commbuff -- the buffer of data
+ * split -- if a split is needed the user pointer is set to the split location
+ * mux -- the mux object
+ */
+int32 SendData (int32 channel, COMMBUFF* commbuff, COMMBUFF** split, MUX* mux)
+{
+    CHANNEL*  send_channel;
+    int32     room;
+    int32     buffer_length;
+
+    DEBUG("SendData(%lu, %p, %p, %p)\n", channel, commbuff, split, mux);
+
+    if(split)
+        *split = 0;
+
+    if((commbuff == 0) || (buffer_length = commbuff_length(commbuff)) == 0)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    enter_write_criticalsection(&mux->lock);
+
+    send_channel = mux->channels[channel];
+
+    if(!send_channel || !(send_channel->state & (OPEN | SENDING)))
+    {
+        /* we're in a state where we shouldn't send data */
+        exit_write_criticalsection(&mux->lock);
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    /* calculate the room left on this channel's send queue */
+    room = send_channel->max_data_amount - send_channel->qed_data_amount;
+
+    /* regardless of how much room there is we'll only */
+    /* take up to the burst size in a single message   */
+    if (room > send_channel->burst_size)
+        room = send_channel->burst_size;
+
+    /* if the message is bigger than that... */
+    if(buffer_length > room)
+    {
+        /* if we can't or shouldn't split the message then */
+        /* the caller will have to try again later         */
+        if((!split) || (room == 0))
+        {
+            exit_write_criticalsection(&mux->lock);
+            return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+        }
+
+        *split = commbuff_split(commbuff, room);
+
+        buffer_length = room;
+    }
+
+    /* Acquire NM_send wakelock */
+    DEBUG("Acquire netmux_send_wakelock\n");
+    wake_lock(&netmux_send_wakelock);
+
+    /* update the queue counters, note that the */
+    /* header is accounted for in ApplyDataHdr  */
+    send_channel->qed_data_amount += buffer_length;
+    send_channel->qed_totl_amount += buffer_length;
+    mux->total_queued_amount      += buffer_length;
+
+    /* add a header to the commbuff */
+    ApplyDataHdr((int8)channel, &commbuff, mux);
+
+    queue_commbuff(commbuff, &send_channel->send_queue);
+
+    /* the channel has data to send, change its state */
+    (void) ExecuteStateTransition(LOCAL_DATA, mux, channel);
+
+    exit_write_criticalsection(&mux->lock);
+
+    enable_task(&mux->send_task);
+    task_schedule(&mux->send_task);
+
+    if(split && (*split))
+        return DEBUGERROR(ERROR_INCOMPLETE);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * SendDataAvailable returns how much data is available to be sent.
+ *
+ * Params:
+ * channel -- the channel we are interested in
+ * mux -- the mux object
+ */
+int32 SendDataAvailable (int32 channel, MUX* mux)
+{
+    CHANNEL* send_channel;
+    int32    available;
+
+    DEBUG("SendDataAvailable(%lu, %p)\n", channel, mux);
+
+    available = 0;
+
+    enter_read_criticalsection(&mux->lock);
+
+    send_channel = mux->channels[channel];
+    if(!send_channel)
+    {
+        exit_read_criticalsection(&mux->lock);
+
+        return 0;
+    }
+
+    available = send_channel->max_data_amount-send_channel->qed_data_amount;
+
+    exit_read_criticalsection(&mux->lock);
+
+    return available;
+}
+
+/*
+ * ReadData is called only by the direct interface to get a buffer from
+ * the queue during a read( ).  If the number of bytes to be read is less
+ * than the number of bytes in the first buffer then that buffer is split.
+ * This function trusts that it will never be called with a 0 count.
+ *
+ * Params:
+ * channel -- the channel to read
+ * mux -- the mux object
+ * commbuff -- the location the data is to be stored at
+ * count -- the amount to read
+ */
+int32 ReadData (int32 channel, MUX* mux, COMMBUFF** commbuff, int32 count)
+{
+    COMMBUFF* split;
+    CHANNEL*  read_channel;
+    int32     length;
+
+    DEBUG("ReadData(%lu, %p, %p, %lu)\n", channel, mux, commbuff, count);
+
+    enter_read_criticalsection(&mux->lock);
+
+    read_channel = mux->channels[channel];
+    if(!read_channel)
+    {
+        exit_read_criticalsection(&mux->lock);
+
+        return DEBUGERROR(ERROR_NONE);
+    }
+
+    if(!(queue_length(&read_channel->receive_queue)))
+    {
+        *commbuff = 0;
+        exit_read_criticalsection(&mux->lock);
+
+        return DEBUGERROR(ERROR_NONE);
+    }
+
+    *commbuff = dequeue_commbuff(&read_channel->receive_queue);
+
+    length = commbuff_length(*commbuff);
+    if(length > count)
+    {
+        split = commbuff_split(*commbuff, count);
+
+        exit_read_criticalsection(&mux->lock);
+        enter_write_criticalsection(&mux->lock);
+
+        read_channel = mux->channels[channel];
+        if(read_channel)
+            queuefront_commbuff(split, &read_channel->receive_queue);
+
+		check_all_receive_queues_emptiness(mux);
+
+        exit_write_criticalsection(&mux->lock);
+
+        return DEBUGERROR(ERROR_NONE);
+    }
+
+	check_all_receive_queues_emptiness(mux);
+
+    exit_read_criticalsection(&mux->lock);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * ReadDataAvailable returns the number of bytes available to be read.
+ *
+ * channel -- the channel we are interested in
+ * mux -- the mux object
+ */
+int32 ReadDataAvailable (int32 channel, MUX* mux)
+{
+    CHANNEL* read_channel;
+    int32    available;
+
+    DEBUG("ReadDataAvailable(%lu, %p)\n", channel, mux);
+
+    available = 0;
+
+    enter_read_criticalsection(&mux->lock);
+
+    read_channel = mux->channels[channel];
+    if(!read_channel)
+    {
+        exit_read_criticalsection(&mux->lock);
+
+        return 0;
+    }
+
+    available = queue_length(&read_channel->receive_queue);
+
+    exit_read_criticalsection(&mux->lock);
+
+    return available;
+}
+
+/*
+ * RunReceive will run the mux's receive task.
+ *
+ * Params:
+ * mux -- the mux object
+ */
+int32 RunReceive (MUX* mux)
+{
+    DEBUG("RunReceive(%p)\n", mux);
+
+    task_schedule(&mux->receive_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * RunSend runs the mux's send task.
+ *
+ * Params:
+ * mux -- the mux object
+ */
+int32 RunSend (MUX* mux)
+{
+    DEBUG("RunSend(%p)\n", mux);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+
+/* MUST be called under critical section */
+void check_all_receive_queues_emptiness(MUX *mux)
+{
+       int32           channel;
+       CHANNEL         *recv_channel;
+       COMMBUFFQUEUE   *queue;
+       CHANNEL         **channels;
+
+       DEBUG("check_all_receive_queues_emptiness\n");
+
+       /* First check netmux receive queue */
+       queue = &mux->receive_queue;
+       if (queue_length(queue) != 0)
+	       return;
+
+       DEBUG("mux receive_queue is empty\n");
+
+       channels = mux->channels;
+
+       /* then process the application receive queues */
+       for (channel = 0; channel < mux->maxchannels; channel++) {
+	       recv_channel = channels[channel];
+	       if (recv_channel) {
+		       queue = &recv_channel->receive_queue;
+		       if (queue_length(queue) != 0) {
+			       DEBUG("Channel %d receive_queue is not empty\n");
+			       return; /* exit wo doing anything */
+		       }
+	       }
+       }
+
+       /* Release NM_receive wakelock */
+       DEBUG("Releasing netmux_receive_wakelock\n");
+       wake_unlock(&netmux_receive_wakelock);
+}
+
+/* MUST be called under critical section */
+void check_all_send_queues_emptiness(MUX *mux)
+{
+       int32           channel;
+       CHANNEL         *send_channel;
+       COMMBUFFQUEUE   *queue;
+       CHANNEL         **channels;
+
+       DEBUG("check_all_send_queues_emptiness\n");
+
+       /* First check netmux send queue */
+       queue = &mux->send_queue;
+       if (queue_length(queue) != 0)
+	       return;
+
+       DEBUG("mux send_queue is empty\n");
+
+       channels = mux->channels;
+
+       /* then process the application receive queues */
+       for (channel = 0; channel < mux->maxchannels; channel++) {
+	       send_channel = channels[channel];
+	       if (send_channel) {
+		       queue = &send_channel->send_queue;
+		       if (queue_length(queue) != 0) {
+			       DEBUG("Channel %d send_queue is not empty\n");
+			       return; /* exit wo doing anything */
+		       }
+	       }
+       }
+
+       /* Release NM_send wakelock */
+       DEBUG("Releasing netmux_send_wakelock\n");
+       wake_unlock(&netmux_send_wakelock);
+}
diff --git a/drivers/misc/netmux/mux.h b/drivers/misc/netmux/mux.h
new file mode 100755
index 0000000..bf60c57
--- /dev/null
+++ b/drivers/misc/netmux/mux.h
@@ -0,0 +1,325 @@
+/******************************************************************************
+ * NetMUX mux.h                                                               *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2007                                           *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ *   2007/12/05  Motorola    Change code as kernel upgrade                    *
+ ******************************************************************************/
+
+/* mux.h defines all the data types and constant values to be used by the     */
+/* mux.c.  The mux is responsible for managing all data that goes across the  */
+/* linkdriver and between interfaces.                                         */
+
+#ifndef _NETMUX_MUX_H_
+#define _NETMUX_MUX_H_
+
+
+#include "shared/ldprotocol.h"
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "packet.h"
+#include "interface.h"
+
+
+/*
+ * Define different status's that apply to the MUX
+ */
+#define STATUS_DEFAULT 0x00000001
+#define STATUS_ENABLE  0x00000002
+#define STATUS_DISABLE 0x00000004
+#define STATUS_ACTIVE  0x00000008
+
+/*
+ * Define different states that channels can be in
+ */
+#define CLOSED         0x00000001
+#define OPENING        0x00000002
+#define OPEN           0x00000004
+#define SENDING        0x00000008
+#define FLUSHING       0x00000010
+#define LOCAL_CLOSING  0x00000020
+#define REMOTE_CLOSING 0x00000040
+
+/*
+ * Define different events that can occur on channels
+ */
+#define LOCAL_OPEN     0x00000001
+#define OPEN_RESPONSE  0x00000002
+#define REMOTE_OPEN    0x00000004
+#define LOCAL_CLOSE    0x00000008
+#define CLOSE_RESPONSE 0x00000010
+#define REMOTE_CLOSE   0x00000020
+#define LOCAL_DATA     0x00000040
+#define SEND_COMPLETE  0x00000080
+#define REMOTE_DATA    0x00000100
+
+/*
+ * Define control packet direction codes
+ */
+#define HOST   0x00000040
+#define CLIENT 0x00000080
+
+#define COMMAND 0x00000001
+#define SUCCESS 0x00000002
+#define FAILURE 0x00000004
+
+#define host_end(type)   (HOST|type)
+#define client_end(type) (CLIENT|type)
+#define strip_end(type)  (type&(~(HOST|CLIENT)))
+
+/*
+ * Define thresholds for sending credit
+ */
+#define MUX_BYTECREDIT_SEND_LIMIT_DIVISOR 4
+#define MUX_SENDCREDIT_SEND_LIMIT_DIVISOR 2
+
+
+/*
+ * Define inform types that can be delivered to MUX interfaces
+ */
+#define INFORM_INTERFACE_ENABLEMUX      1
+#define INFORM_INTERFACE_DISABLEMUX     2
+#define INFORM_INTERFACE_ENABLECHANNEL  3
+#define INFORM_INTERFACE_DISABLECHANNEL 4
+#define INFORM_INTERFACE_QUERYINTERFACE 5
+#define INFORM_INTERFACE_CONFIGPACKET   6
+#define INFORM_INTERFACE_CHANNELSIGNAL  7
+#define INFORM_INTERFACE_DATA           8
+#define INFORM_INTERFACE_PREPSEND       9
+
+
+/*
+ * PARTIAL_RECEIVE stores information about the packet currently being
+ * received from the link.  The description of this structure is:
+ *
+ * type: the type of packet being received
+ * hdr: a pointer to the header within the buffer
+ * expectedLen: the number of bytes we are expecting to receive including
+ *              both the packet header length and the packet data length
+ * currentLen: the number of bytes received so far
+ * packet: a pointer to the commbuff cast available in a variety of types
+ */
+typedef struct PARTIAL_RECEIVE
+{
+    COMMBUFF* buffer;
+    int32 expectedLen;
+    int32 currentLen;
+
+    union
+    {
+        int8*                  payload;
+        DATA_PACKET_HDR*       datapacket;
+        CREDIT_PACKET*         creditpacket;
+        ENABLEMUX_PACKET*      enablemux;
+        DISABLEMUX_PACKET*     disablemux;
+        ENABLECHANNEL_PACKET*  enablechannel;
+        DISABLECHANNEL_PACKET* disablechannel;
+        QUERYINTERFACE_PACKET* queryinterface;
+        CHANNELSIGNAL_PACKET*  channelsignal;
+    }packet;
+
+    int8 type;
+
+}PARTIAL_RECEIVE;
+
+/*
+ * CHANNEL defines a MUX channel. The description is as follows
+ *
+ * connected_interface points to a registered interface associated with the channel
+ * send_queue holds the commbuffs to be sent on this channel
+ * receive_queue holds the commbuffs to be received on this channel
+ * burst_size is the maximum number of bytes allowed to be sent at a time
+ * max_data_amount is the maximum amount of data that can be stored in the send queue
+ * qed_data_amount is the current amount of data stored in the send queue
+ * qed_totl_amount is the current amount of data and header stored in the queue
+ * state represents the state the channel is in
+ * client_interface is the destination interface on the client side for this channel
+ * host_interface is the source interface on the host side for this channel
+ */
+typedef struct CHANNEL
+{
+    MUXINTERFACE* connected_interface;
+
+    COMMBUFFQUEUE send_queue;
+    COMMBUFFQUEUE receive_queue;
+
+    int32 burst_size;
+    int32 max_data_amount;
+    int32 qed_data_amount;
+    int32 qed_totl_amount;
+    int32 state;
+    int32 client_interface;
+    int32 host_interface;
+}CHANNEL;
+
+/*
+ * CHANNELCREDIT defines credit values for channels. The description is as follows
+ *
+ * initialized indicates whether the channel has had its credit values setup
+ * max_host_byte_credit is the maximum amount of data that can ever be received
+ * max_host_send_credit is the maximum amount of sends a channel can perform
+ * client_byte_credit is the current amount of data that can be sent
+ * client_send_credit is the number of sends a channel can perform
+ * replenished_byte_credit is the number of bytes of credit to eventually deliver
+ * replenished_send_credit is the amount of send credit to eventually deliver
+ */
+typedef struct CHANNELCREDIT
+{
+    int32 initialized;
+
+    int32 max_host_byte_credit;
+    int32 max_host_send_credit;
+    int32 client_byte_credit;
+    int32 client_send_credit;
+    int32 replenished_byte_credit;
+    int32 replenished_send_credit;
+}CHANNELCREDIT;
+
+/*
+ * MUX defines an object to manage a set of channels. A brief description
+ * follows.
+ *
+ * channels is the list of channels that can be used
+ * maxchannels is the maximum amount of channels available on the MUX
+ * status states the condition the MUX is in
+ * total_queued_amount is the current amount of data queued in the mux
+ * local_rcv_buffer_size is set by the linkdriver to record the local receive buffer size
+ * remote_rcv_buffer_size is set by the linkdriver to record the remote receive buffer size
+ * send_buffers_available is the current number of sends the mux can perform
+ * interface_lib is a list of registered interfaces
+ * send_queue is used to store control packets to be sent
+ * receive_queue is used to store control packets to be sent
+ * Send is a pointer to a function that will deliver data
+ * send_task defines a task to be enabled when processing send queues
+ * receive_task defines a task to be enabled when processing received data
+ * shutdown_task defines a task to be used when the linkdriver shuts down the mux
+ * partial_receive defines the MUX receiving state
+ * lock synchronizes the mux
+ */
+typedef struct MUX
+{
+    CHANNEL**      channels;
+    CHANNELCREDIT* channelcredit;
+
+    int32     maxchannels;
+    int32     status;
+    int32     total_queued_amount;
+
+    int32 local_rcv_buffer_size;
+    int32 remote_rcv_buffer_size;
+    int32 send_buffers_available;
+
+    MUXINTERFACE_LIBRARY* interface_lib;
+
+    COMMBUFFQUEUE send_queue;
+    COMMBUFFQUEUE receive_queue;
+
+    int32 (*Send) (void*);
+
+    TASKDATA send_task;
+    TASKDATA receive_task;
+    TASKDATA shutdown_task;
+
+    PARTIAL_RECEIVE partial_receive;
+
+    CRITICALSECTION lock;
+}MUX;
+
+
+/*
+ * Decalre functions defined in mux.c
+ */
+
+int32 ExecuteStateTransition (int32, MUX*, int32);
+int32 InformMUX              (void*, void*);
+
+void  CommBuffReleased (int32, int32, void*);
+
+void ProcessSendQueues    (struct work_struct *);
+void ProcessReceiveQueues (struct work_struct *);
+void ShutdownMUX          (struct work_struct *);
+
+
+int32 ReceiveFromLink (void*, void*);
+void  ReceivePartial  (COMMBUFF*, MUX*);
+void  ReceiveData     (MUX*);
+void  ReceiveCommand  (MUX*);
+
+int32 CreateMUX  (
+                  int32,
+                  int32,
+                  int32,
+                  int32,
+                  int32 (*sendfunction)(void*),
+                  MUXINTERFACE_LIBRARY*,
+                  MUX**
+                 );
+int32 DestroyMUX (MUX*);
+
+int32 AdjustCredit(int32, int32, int32, int32, MUX*);
+
+int32 EnableMUX  (int32, MUX*);
+int32 DisableMUX (int32, MUX*);
+
+int32 EnableChannel  (
+                      int32,
+                      int32,
+                      int32,
+                      int32,
+                      int32,
+                      int32,
+                      int32,
+                      int32,
+                      int32,
+                      int32,
+                      MUX*
+                     );
+
+
+int32 DisableChannel (int32, int32, int32, int32, MUX*);
+
+int32 QueryExternalInterface (int32, int32, int32, sint8*, MUX*);
+
+int32 ChannelSignal (int8, int32, int32, MUX*);
+
+int32 SendData          (int32, COMMBUFF*, COMMBUFF**, MUX*);
+int32 SendDataAvailable (int32, MUX*);
+int32 ReadData          (int32, MUX*, COMMBUFF**, int32);
+int32 ReadDataAvailable (int32, MUX*);
+int32 RunReceive        (MUX*);
+int32 RunSend           (MUX*);
+
+#endif
+
diff --git a/drivers/misc/netmux/network.c b/drivers/misc/netmux/network.c
new file mode 100755
index 0000000..7f00db3
--- /dev/null
+++ b/drivers/misc/netmux/network.c
@@ -0,0 +1,590 @@
+/******************************************************************************
+ * NetMUX network.c                                                           *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2008                                           *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ *   2007/02/25  Motorola    Fixed NetworkTransmit related code               *
+ *   2007/12/05  Motorola    Change code as kernel upgrade                    *
+ *   2008/07/09  Motorola    upmerge to kernel 2.6.24 for TI 23.5             *
+ *   2009/04/27  Motorola    Increment receive/transmit packet number         *
+ *   2009/07/23  Motorola    Add wake lock functionality                      *
+ ******************************************************************************/
+
+/* network.c defines an interface between a NetMUX and the Linux networking   */
+/* stack. This code is responsible for assisting application in communication */
+/* with the NetMUX by implementing the standard file operations such as       */
+/* open(), close(), read(), and write().                                      */
+
+#include "network.h"
+#include "config.h"
+#include "debug.h"
+#include <linux/wakelock.h>
+
+extern struct wake_lock netmux_send_wakelock;
+
+/*
+ * NetworkInform is called by the mux (and sometimes the
+ * config interface) to inform the interface that something
+ * important has happened. The network interface listens for
+ * several things of importance.
+ *
+ * First, it listens for config packets. If a config packet
+ * is recieved it processes it and sets up the appropriate
+ * channel.
+ *
+ * Second, it listens for a disable mux event. If such an
+ * event happens all channels are forced closed and no
+ * application can perform any operation on the channel.
+ *
+ * Third, it waits for enable channel messages. If such a
+ * message is ever received it immediately responds with a
+ * failure because the network interface does not support
+ * external open requests.
+ *
+ * Fourth, it waits for a disable channel message. If
+ * one is received the channel is placed into an inoperable
+ * state.
+ *
+ * Fifth, it waits a data message, which signifies that the
+ * channel has successfuly delivered data. The network interface
+ * uses this information push any more data into the mux.
+ *
+ * Params:
+ * param1 -- a custom pointer, in this case an INTERFACEINFORM struct
+ * param2 -- a custom pointer, in this case a NETWORKINTERFACE struct
+ */
+int32 NetworkInform (void* param1, void* param2)
+{
+    NETWORKINTERFACE*     network;
+    NETWORKDEVICE*        netdev;
+    NETWORKDEVICE**       priv_netdev;
+    INTERFACEINFORM*      informdata;
+    CONFIGPACKET*         configpacket;
+    ENABLECHANNEL_PACKET* enablechannel;
+    COMMBUFF*             transmit;
+    int32                 channel_count;
+    int32                 channel;
+    int32                 type;
+    int32                 result;
+
+    DEBUG("NetworkInform(0x%p, 0x%p)\n", param1, param2);
+
+    informdata = (INTERFACEINFORM*)param1;
+    network    = (NETWORKINTERFACE*)param2;
+
+    switch(informdata->inform_type)
+    {
+        case INFORM_INTERFACE_CONFIGPACKET:
+        {
+            channel = ((CONFIGPACKET*)informdata->data)->channel;
+
+            if(channel > network->channel_max || channel < network->channel_min)
+                return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+            netdev       = &network->netdevs[channel-network->channel_min];
+            configpacket = (CONFIGPACKET*)informdata->data;
+
+            netdev->netint           = network;
+            netdev->channel          = channel;
+            netdev->client_interface = configpacket->host_interface;
+            netdev->burstsize        = configpacket->client_burstsize;
+            netdev->maxdata          = configpacket->client_maxdata;
+            netdev->host_byte_credit = configpacket->client_byte_credit;
+            netdev->host_send_credit = configpacket->client_send_credit;
+            netdev->netdevice        = alloc_netdev(sizeof(struct NETWORKDEVICE*), configpacket->channel_name, NetworkInit);
+	    netdev->data_amount      = 0;
+	    netdev->mux_channel_queue_space = configpacket->client_maxdata;
+
+            priv_netdev = netdev_priv(netdev->netdevice);
+            *priv_netdev = netdev;
+            memset(&netdev->stats, 0, sizeof(struct net_device_stats));
+
+            init_waitqueue_head(&netdev->event_wait);
+            initialize_commbuff_queue(&netdev->process_queue);
+            
+            result = register_netdev(netdev->netdevice);
+            if(result)
+            {
+                netdev->state = NETWORK_STATE_DEFAULT;
+                destroy_commbuff_queue(&netdev->process_queue);
+
+                return DEBUGERROR(ERROR_INVALIDPARAMETER);
+            }
+
+            netdev->state = NETWORK_STATE_CONFIGURED;
+        }break;
+
+        case INFORM_INTERFACE_DISABLEMUX:
+        {
+            channel_count = network->channel_max-network->channel_min+1;
+            for(channel = 0; channel < channel_count; channel++)
+            {
+                if(network->netdevs[channel].state)
+                {
+                    wake_up_interruptible(&network->netdevs[channel].event_wait);
+
+                    NetworkClose(network->netdevs[channel].netdevice);
+
+                    unregister_netdev(network->netdevs[channel].netdevice);
+                }
+            }
+        }break;
+
+        case INFORM_INTERFACE_ENABLECHANNEL:
+        {
+            enablechannel = (ENABLECHANNEL_PACKET*)informdata->data;
+            type          = strip_end(enablechannel->acktype);
+
+            if(type == COMMAND)
+            {
+                EnableChannel(
+                              client_end(FAILURE),
+                              enablechannel->channel,
+                              0,
+                              0,
+                              enablechannel->host_interface,
+                              enablechannel->client_interface,
+                              0,
+                              0,
+                              0,
+                              0,
+                              network->mux
+                             );
+            }
+            else if(type == SUCCESS)
+            {
+                channel = enablechannel->channel;
+                netdev  = &network->netdevs[channel-network->channel_min];
+
+                netdev->state = NETWORK_STATE_CONNECTED|NETWORK_STATE_EVENT;
+
+                wake_up_interruptible(&netdev->event_wait);
+            }
+            else if(type == FAILURE)
+            {
+                channel = enablechannel->channel;
+                netdev  = &network->netdevs[channel-network->channel_min];
+
+                netdev->state |= NETWORK_STATE_EVENT;
+
+                wake_up_interruptible(&netdev->event_wait);
+            }
+        }break;
+
+        case INFORM_INTERFACE_DISABLECHANNEL:
+        {
+            channel = ((DISABLECHANNEL_PACKET*)informdata->data)->channel;
+
+            NetworkClose(network->netdevs[channel-network->channel_min].netdevice);
+        }break;
+
+        case INFORM_INTERFACE_PREPSEND:
+        {
+            for(channel = 0; channel < network->channel_max-network->channel_min+1; channel++)
+            {
+                netdev = &network->netdevs[channel];
+
+                enter_write_criticalsection(&network->lock);
+
+                if(netdev->state&NETWORK_STATE_CONNECTED && queue_length(&netdev->process_queue))
+                {
+                    do
+                    {
+                        transmit = dequeue_commbuff(&netdev->process_queue);
+			netdev->data_amount -= commbuff_length(transmit);
+			netdev->mux_channel_queue_space -= commbuff_length(transmit);
+
+                        result = SendData(channel+network->channel_min,
+                                          transmit,
+                                          NULL,
+                                          network->mux);
+                    }while(result == ERROR_NONE && queue_length(&netdev->process_queue));
+
+                    if(result != ERROR_NONE)
+		    {
+                        queuefront_commbuff(transmit, &netdev->process_queue);
+			netdev->data_amount += commbuff_length(transmit);
+			netdev->mux_channel_queue_space += commbuff_length(transmit);
+                    }
+                }
+
+                exit_write_criticalsection(&network->lock);
+            }
+        }break;
+
+        case INFORM_INTERFACE_DATA:
+        {
+            channel = (int32)informdata->data;
+	    result = SendDataAvailable(channel, network->mux);
+
+            enter_write_criticalsection(&network->lock);
+
+            netdev  = &network->netdevs[channel-network->channel_min];
+	    netdev->mux_channel_queue_space = result;
+
+            exit_write_criticalsection(&network->lock);
+
+	    netif_wake_queue(netdev->netdevice);
+
+            if(netdev->state&NETWORK_STATE_CONNECTED && queue_length(&netdev->process_queue))
+                RunSend(network->mux);
+
+        }break;
+
+        default:break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * NetworkReceive is called when a buffer is available for
+ * delivery to an application. The network interface will
+ * simply forward the buffer onto the tcp/ip stack and
+ * let it do the remainder of the work.
+ *
+ * Params:
+ * commbuff -- a pointer to the received data
+ * param -- a custom pointer, in this case an INTERFACEINFORM struct
+ */
+int32 NetworkReceive (COMMBUFF* commbuff, void* param)
+{
+    INTERFACEINFORM*  inform_data;
+    NETWORKINTERFACE* netint;
+    int32             channel;
+
+    DEBUG("NetworkReceive(0x%p, 0x%p)\n", commbuff, param);
+
+    inform_data = (INTERFACEINFORM*)param;
+
+    netint  = (NETWORKINTERFACE*)inform_data->inform_type;
+    channel = (int32)inform_data->data;
+
+    commbuff->dev = netint->netdevs[channel-netint->channel_min].netdevice;
+    commbuff->protocol  = htons(ETH_P_IP);
+    commbuff->ip_summed = CHECKSUM_NONE;
+    commbuff->pkt_type  = PACKET_HOST;
+    commbuff->mac_header = commbuff->data;
+
+    LOGCOMMBUFF_CH(channel, "NetworkReceive()-->", commbuff, commbuff_length(commbuff));
+
+    netint->netdevs[channel-netint->channel_min].stats.rx_bytes += commbuff_length(commbuff);
+    netint->netdevs[channel-netint->channel_min].stats.rx_packets++;
+
+    /*
+     * To fix the behavior of a subpar kernel, we must call the commbuff
+     * destructor here, otherwise the Linux network stack overwrites
+     * the destructor on us.
+     */
+    detag_commbuff(commbuff);
+    netif_rx(commbuff);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * CreateNetworkInterface will create an interface object to be used by
+ * a NetMUX. This object will keep track of all settings required to
+ * communicate with the raw device layer. As such, any network operation
+ * will make reference to this interface object.
+ *
+ * Params:
+ * name -- the name of the interface
+ * channel_min -- the inclusive lower bound of channel numbers assigned to the interface
+ * channel_max -- the inclusive upper bound of channel numbers assigned to the interface
+ * mux -- the mux object this interface is associated with
+ * netint -- a pointer to a pointer to receive the newly created object
+ */
+int32 CreateNetworkInterface (sint8* name, int32 channel_min, int32 channel_max, MUX* mux, NETWORKINTERFACE** netint)
+{
+    NETWORKINTERFACE* newnetint;
+    int32             size;
+    int32             result;
+
+    DEBUG("CreateNetworkInterface(0x%p, %lu, %lu, 0x%p, 0x%p)\n", name, channel_min, channel_max, mux, netint);
+
+    if(!name || !mux || !netint)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    if(channel_min > channel_max)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    if(channel_max >= mux->maxchannels)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    if(strlen(name) >= PACKET_MAXNAME_LENGTH)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    newnetint          = (NETWORKINTERFACE*)alloc_mem(sizeof(NETWORKINTERFACE));
+    size               = (channel_max-channel_min+1)*sizeof(NETWORKDEVICE);
+    newnetint->netdevs = (NETWORKDEVICE*)alloc_mem(size);
+
+    memset(newnetint->netdevs, 0, size);
+
+    newnetint->channel_max = channel_max;
+    newnetint->channel_min = channel_min;
+    newnetint->mux         = mux;
+
+    result = RegisterInterface(name, &NetworkInform, &NetworkReceive, (int32)newnetint, mux->interface_lib);
+    if(result != ERROR_NONE)
+    {
+        free_mem(newnetint->netdevs);
+        free_mem(newnetint);
+
+        return DEBUGERROR(result);
+    }
+
+    QueryInterfaceIndex(name, mux->interface_lib, &newnetint->host_interface);
+    initialize_criticalsection_lock(&newnetint->lock);
+
+    *netint = newnetint;
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DestroyNetworkInterface is invoked when a NetMUX is being destroyed.
+ * The interface object will be 'undone'.
+ *
+ * Params:
+ * netint -- the interface to be destroyed
+ */
+int32 DestroyNetworkInterface (NETWORKINTERFACE* netint)
+{
+    int32 channel;
+    int32 channel_count;
+
+    DEBUG("DestroyNetworkInterface(0x%p)\n", netint);
+
+    channel_count = netint->channel_max-netint->channel_min+1;
+    for(channel = 0; channel < channel_count; channel++)
+    {
+        if(netint->netdevs[channel].state)
+        {
+            NetworkClose(netint->netdevs[channel].netdevice);
+
+            destroy_commbuff_queue(&netint->netdevs[channel].process_queue);
+            unregister_netdev(netint->netdevs[channel].netdevice);
+            free_netdev(netint->netdevs[channel].netdevice);
+        }
+    }
+
+    UnregisterInterface(netint->host_interface, netint->mux->interface_lib);
+    destroy_criticalsection_lock(&netint->lock);
+
+    free_mem(netint->netdevs);
+    free_mem(netint);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * NetworkInit is called by the linux whenever a network interface
+ * needs to be brought online. This function merely establishes
+ * a method of communication between the linux network interface
+ * and the NetMUX
+ *
+ * Params:
+ * netdev -- structure to store the method of communication
+ */
+void NetworkInit (struct net_device* netdev)
+{
+    DEBUG("NetworkInit(0x%p)\n", netdev);
+
+    netdev->hard_header_len = 0;
+    netdev->addr_len        = 0;
+    netdev->mtu             = 1500;
+    netdev->tx_queue_len    = 1000; /* determine appropriate value */
+    netdev->open            = &NetworkOpen;
+    netdev->stop            = &NetworkClose;
+    netdev->hard_start_xmit = &NetworkTransmit;
+    netdev->get_stats       = &NetworkStats;
+
+    netdev->flags             = IFF_NOARP;
+    netdev->type              = ARPHRD_NONE;
+}
+
+/*
+ * NetworkOpen is called by the Linux networking system to connect
+ * a network device. The connection event will cause the enable
+ * channel protocol to commence.
+ *
+ * Params:
+ * netdev -- a pointer to a net device
+ */
+int NetworkOpen (struct net_device* netdev)
+{
+    NETWORKDEVICE*     device;
+    NETWORKDEVICE**    priv_netdev;
+    int32              result;
+
+    DEBUG("NetworkOpen(0x%p)\n", netdev);
+
+    priv_netdev = netdev_priv(netdev);
+    device = *priv_netdev;
+
+    if(!(device->state&NETWORK_STATE_CONFIGURED))
+        return -EADDRNOTAVAIL;
+
+    result = EnableChannel(host_end(COMMAND),
+                           device->channel,
+                           device->burstsize,
+                           device->maxdata,
+                           device->netint->host_interface,
+                           device->client_interface,
+                           device->host_byte_credit,
+                           device->host_send_credit,
+                           0,
+                           0,
+                           device->netint->mux);
+
+    if(result != ERROR_NONE)
+        return -ECONNABORTED;
+
+    /* Wake up when either one of two conditions occur:
+       1 - A response is received from the BP for our open request.
+       2 - The channel is not configured and running properly.
+       In case the latter is true an error will be returned eventually. */
+    wait_event_interruptible(device->event_wait,
+                            (device->state&NETWORK_STATE_EVENT) ||
+                            !(device->state&NETWORK_STATE_CONFIGURED));
+
+    device->state &= ~NETWORK_STATE_EVENT;
+
+    if(!(device->state&NETWORK_STATE_CONNECTED))
+        return -ECONNREFUSED;
+
+    netif_start_queue(netdev);
+
+    return 0;
+}
+
+/*
+ * NetworkClose is called by the Linux networking system to
+ * disconnect a network device. This function will cause the
+ * commencement of the disconnect channel protocol.
+ *
+ * Params:
+ * netdev -- a pointer to a net device
+ */
+int NetworkClose (struct net_device* netdev)
+{
+    NETWORKDEVICE** priv_netdev;
+    NETWORKDEVICE* device;
+    int32          result;
+
+    DEBUG("NetworkClose(0x%p)\n", netdev);
+
+    priv_netdev = netdev_priv(netdev);
+    device = *priv_netdev;
+
+    if(device->state&NETWORK_STATE_CONNECTED)
+    {
+        result = DisableChannel(host_end(COMMAND), device->channel, device->netint->host_interface, device->client_interface, device->netint->mux);
+        if(result != ERROR_NONE)
+            return -EPIPE;
+
+        enter_write_criticalsection(&device->netint->lock);
+
+        device->state = NETWORK_STATE_CONFIGURED;
+        empty_commbuff_queue(&device->process_queue);
+	device->data_amount = 0;
+	device->mux_channel_queue_space = device->maxdata;
+
+        exit_write_criticalsection(&device->netint->lock);
+    }
+    else
+        return -ENOTCONN;
+
+    netif_stop_queue(netdev);
+
+    return 0;
+}
+
+/*
+ * NetworkTransmit is called by the linux networking system when there
+ * is data to be sent over the link. The data will be queued by the network
+ * interface until the mux is ready to send the data. At this time the network
+ * interface must push what is queued onto the mux.
+ *
+ * commbuff -- the data to be sent
+ * netdev -- the device to send the data on
+ */
+int NetworkTransmit (COMMBUFF* commbuff, struct net_device* netdev)
+{
+    NETWORKDEVICE** priv_netdev;
+    NETWORKDEVICE* device;
+    int32 length = commbuff_length(commbuff);
+
+    DEBUG("NetworkTransmit(0x%p, 0x%p)\n", commbuff, netdev);
+
+    /* Acquire NM_send wakelock */
+    DEBUG("Acquire netmux_send_wakelock\n");
+    wake_lock(&netmux_send_wakelock);
+
+    priv_netdev = netdev_priv(netdev);
+    device = *priv_netdev;
+
+    device->stats.tx_bytes += length;
+    device->stats.tx_packets ++;
+
+    queue_commbuff(commbuff, &device->process_queue);
+    device->data_amount += length;
+
+    /* Due to a race condition that exists between the time we decrement and
+     * increment the process_queue length, more data could have been added to
+     * the NetMUX queue than the burst size for the channel. Also, the amount
+     * of combined data in the two queues may surpass the channel queue size. */
+    if ((device->mux_channel_queue_space - device->data_amount) 
+		    < device->burstsize)
+    {
+        netif_stop_queue(netdev);
+    }
+
+    RunSend(device->netint->mux);
+
+    return 0;
+}
+
+struct net_device_stats* NetworkStats (struct net_device* netdev)
+{
+    NETWORKDEVICE** priv_netdev;
+    NETWORKDEVICE* device;
+
+    DEBUG("NetworkStats(0x%p)\n", netdev);
+ 
+    priv_netdev = netdev_priv(netdev);
+    device = *priv_netdev;
+
+    return &device->stats;
+}
diff --git a/drivers/misc/netmux/network.h b/drivers/misc/netmux/network.h
new file mode 100755
index 0000000..6ef6a69
--- /dev/null
+++ b/drivers/misc/netmux/network.h
@@ -0,0 +1,148 @@
+/******************************************************************************
+ * NetMUX network.h                                                           *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2008                                           *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combine header and data into one transfer        *
+ *   2007/02/25  Motorola    Added data_amount and mux_channel_queue_space    *
+ *                           fields to the NETWORKDEVICE structure            *
+ *   2008/07/09  Motorola    upmerge to kernel 2.6.24 for TI 23.5             *
+ ******************************************************************************/
+
+/* network.h is responsible for setting up a method of communication between  */
+/* the NetMUX and user space applications.                                    */
+
+#ifndef _NETMUX_NETWORK_H_
+#define _NETMUX_NETWORK_H_
+
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "mux.h"
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/if_arp.h>
+#include <linux/sockios.h>
+#include <linux/workqueue.h>
+
+
+/*
+ * Definitions for specific states a network device can be in
+ */
+#define NETWORK_STATE_DEFAULT    0
+#define NETWORK_STATE_CONFIGURED 1
+#define NETWORK_STATE_CONNECTED  2
+#define NETWORK_STATE_EVENT      4
+
+
+/*
+ * NETWORKDEVICE defines a network device associated with a channel
+ * A brief description follows.
+ *
+ * netint points to the core network interface
+ * channel declares the channel this network device works on
+ * state defines the network device's state
+ * client_interface is the interface id for the external interface communicated with
+ * burstsize is the maximum amount of data that can be transfered at a time
+ * maxdata is the maximum amount of data the network device can queue
+ * data_amount is the current amount of data stored in the process_queue
+ * host_byte_credit is the maximum amount of data the device can receive
+ * host_send_credit is the maximum amount of sends the device can receive
+ * mux_channel_queue_space is the current amount of space available in the mux channel queue
+ * event_wait defines a structure that network devices can sleep on
+ * process_queue holds a list of commbuffs to be transmitted
+ * netdevice points to the registered network device
+ */
+typedef struct NETWORKDEVICE
+{
+    struct NETWORKINTERFACE* netint;
+
+    int32 channel;
+    int32 state;
+    int32 client_interface;
+    int32 burstsize;
+    int32 maxdata;
+    int32 data_amount;
+    int32 host_byte_credit;
+    int32 host_send_credit;
+    int32 mux_channel_queue_space;
+    struct net_device_stats stats;
+    wait_queue_head_t       event_wait;
+    COMMBUFFQUEUE           process_queue;
+    struct net_device*      netdevice;
+}NETWORKDEVICE;
+
+/*
+ * NETWORKINTERFACE manages a list of network devices. A brief description
+ * follows.
+ *
+ * channel_min is the inclusive lower boundary channel number
+ * channel_max is the inclusive upper boundary channel number
+ * host_interface defines the local interface id
+ * mux points to the mux object associated with this interface
+ * netdevs contains a list of network devices
+ * lock keeps things in synch
+ */
+typedef struct NETWORKINTERFACE
+{
+    int32 channel_min;
+    int32 channel_max;
+    int32 host_interface;
+
+    MUX*           mux;
+    NETWORKDEVICE* netdevs;
+
+    CRITICALSECTION lock;
+}NETWORKINTERFACE;
+
+
+/*
+ * Functions defined in network.c
+ */
+
+int32 NetworkInform  (void*, void*);
+int32 NetworkReceive (COMMBUFF*, void*);
+
+int32 CreateNetworkInterface  (sint8*, int32, int32, MUX*, NETWORKINTERFACE**);
+int32 DestroyNetworkInterface (NETWORKINTERFACE*);
+
+void                     NetworkInit     (struct net_device*);
+int                      NetworkOpen     (struct net_device*);
+int                      NetworkClose    (struct net_device*);
+int                      NetworkTransmit (COMMBUFF*, struct net_device*);
+struct net_device_stats* NetworkStats    (struct net_device*);
+
+
+#endif
diff --git a/drivers/misc/netmux/packet.h b/drivers/misc/netmux/packet.h
new file mode 100755
index 0000000..9826916
--- /dev/null
+++ b/drivers/misc/netmux/packet.h
@@ -0,0 +1,221 @@
+/******************************************************************************
+ * NetMUX packet.h                                                            *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2007                                                *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combined header and data into one transfer       *
+ *                           Align packets on 4 byte boundaries               *
+ *   2007/07/31  Motorola    Add support for larger bytecredit
+ ******************************************************************************/
+
+/* packet.h defines a list of structures to hold each packet type. Each       */
+/* structure must be packed so it can be sent and received without any        */
+/* difference between environments.                                           */
+
+#ifndef _NETMUX_PACKET_H_
+#define _NETMUX_PACKET_H_
+
+
+#include "utility.h"
+
+
+/*
+ * The following define packet type codes
+ */
+#define PACKETTYPE_INVALID        0
+#define PACKETTYPE_DATA_HDR       1
+#define PACKETTYPE_DATA_BDY       2
+#define PACKETTYPE_CREDIT         3
+#define PACKETTYPE_ENABLEMUX      4
+#define PACKETTYPE_DISABLEMUX     5
+#define PACKETTYPE_ENABLECHANNEL  6
+#define PACKETTYPE_DISABLECHANNEL 7
+#define PACKETTYPE_QUERYINTERFACE 8
+#define PACKETTYPE_CHANNELSIGNAL  9
+
+#define PACKET_MAXNAME_LENGTH 16
+
+
+/*
+ * DATA_PACKET_HDR defines the format of a header for a data packet.
+ * A brief description follows.
+ *
+ * type identifies the packet
+ * channel is the channel to which the data belongs
+ * len is the number of data bytes
+ */
+START_PACKED_STRUCT(DATA_PACKET_HDR)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 channel);
+    PACKED_MEMBER(int16 len);
+END_PACKED_STRUCT(DATA_PACKET_HDR)
+
+/*
+ * CREDIT_PACKET defines a credit control packet to change the amount of receive space.
+ * A brief description follows.
+ *
+ * type identifies the packet
+ * acktype defines direction and result of the control packet
+ * channel defines the channel the credit is to be applied to
+ * padding is only used for data alignment
+ * bytecredit is the number of bytes to augment the credit by
+ * sendcredit is the number of sends to augment the credit by
+ */
+START_PACKED_STRUCT(CREDIT_PACKET)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 acktype);
+    PACKED_MEMBER(int8 channel);
+    PACKED_MEMBER(int8 padding);
+    PACKED_MEMBER(int32 bytecredit);
+    PACKED_MEMBER(int32 sendcredit);
+END_PACKED_STRUCT(CREDIT_PACKET)
+
+/*
+ * ENABLEMUX_PACKET defines an enable mux control packet to enable the MUX
+ * A brief description follows.
+ *
+ * type identifies the packet
+ * acktype defines direction and result of the control packet
+ * padding_byte1 is only used for data alignment
+ * padding_byte2 is only used for data alignment
+ */
+START_PACKED_STRUCT(ENABLEMUX_PACKET)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 acktype);
+    PACKED_MEMBER(int8 padding_byte1);
+    PACKED_MEMBER(int8 padding_byte2);
+END_PACKED_STRUCT(ENABLEMUX_PACKET)
+
+/*
+ * DISABLEMUX_PACKET defines a disable mux control packet to disable the MUX
+ * A brief description follows.
+ *
+ * type identifies the packet
+ * acktype defines direction and result of the control packet
+ * padding_byte1 is only used for data alignment
+ * padding_byte2 is only used for data alignment
+ */
+START_PACKED_STRUCT(DISABLEMUX_PACKET)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 acktype);
+    PACKED_MEMBER(int8 padding_byte1);
+    PACKED_MEMBER(int8 padding_byte2);
+END_PACKED_STRUCT(DISABLEMUX_PACKET)
+
+/*
+ * ENABLECHANNEL_PACKET defines a enable channel control packet to enable a specific
+ * channel.  A brief description follows,
+ *
+ * type identifies the packet
+ * acktype defines direction and result of the control packet
+ * channel defines the channel to be enabled
+ * host_interface represents the interface id on the host side
+ * client_interface represents the interface id on the client side
+ * padding is only used for data alignment
+ * bytecredit describes the senders receive space
+ * sendcredit describes the senders send space
+ */
+START_PACKED_STRUCT(ENABLECHANNEL_PACKET)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 acktype);
+    PACKED_MEMBER(int8 channel);
+    PACKED_MEMBER(int8 host_interface);
+    PACKED_MEMBER(int8 client_interface);
+    PACKED_MEMBER(int8 padding_byte1);
+    PACKED_MEMBER(int8 padding_byte2);
+    PACKED_MEMBER(int8 padding_byte3);
+    PACKED_MEMBER(int32 bytecredit);
+    PACKED_MEMBER(int32 sendcredit);
+END_PACKED_STRUCT(ENABLECHANNEL_PACKET)
+
+/*
+ * DISABLECHANNEL_PACKET defines a disable channel control packet to disable a
+ * specific channel. A brief description follows.
+ *
+ * type identifies the packet
+ * acktype defines direction and result of the control packet
+ * channel defines the channel to be disabled
+ * host_interface represents the interface id on the host side
+ * client_interface represents the interface id on the client side
+ * padding_byte1 is only used for data alignment
+ * padding_byte2 is only used for data alignment
+ * padding_byte3 is only used for data alignment
+ */
+START_PACKED_STRUCT(DISABLECHANNEL_PACKET)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 acktype);
+    PACKED_MEMBER(int8 channel);
+    PACKED_MEMBER(int8 host_interface);
+    PACKED_MEMBER(int8 client_interface);
+    PACKED_MEMBER(int8 padding_byte1);
+    PACKED_MEMBER(int8 padding_byte2);
+    PACKED_MEMBER(int8 padding_byte3);
+END_PACKED_STRUCT(DISABLECHANNEL_PACKET)
+
+/*
+ * QUERYINTERFACE_PACKET defines a query interface control packet to retrieve an interface
+ * id.  A brief description follows.
+ *
+ * type identifies the packet
+ * acktype defines direction and result of the control packet
+ * host_interface is the host's interface id
+ * result only applies to a successful query and is the requested interface id
+ * name is the name of the interface queried
+ */
+START_PACKED_STRUCT(QUERYINTERFACE_PACKET)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 acktype);
+    PACKED_MEMBER(int8 host_interface);
+    PACKED_MEMBER(int8 result);
+    PACKED_MEMBER(sint8 name[PACKET_MAXNAME_LENGTH]);
+END_PACKED_STRUCT(QUERYINTERFACE_PACKET)
+
+/*
+ * CHANNELSIGNAL_PACKET defines a channel signal control packet to signal a channel
+ * A brief description follows.
+ *
+ * type identifies the packet
+ * acktype defines direction and result of the control packet
+ * channel identifies the destination
+ * padding is only used for data alignment
+ * signal is the signal to send
+ */
+START_PACKED_STRUCT(CHANNELSIGNAL_PACKET)
+    PACKED_MEMBER(int8 type);
+    PACKED_MEMBER(int8 acktype);
+    PACKED_MEMBER(int8 channel);
+    PACKED_MEMBER(int8 padding);
+    PACKED_MEMBER(int32 signal);
+END_PACKED_STRUCT(CHANNELSIGNAL_PACKET)
+
+
+#endif
diff --git a/drivers/misc/netmux/protocol.c b/drivers/misc/netmux/protocol.c
new file mode 100755
index 0000000..da8bf4c
--- /dev/null
+++ b/drivers/misc/netmux/protocol.c
@@ -0,0 +1,413 @@
+/******************************************************************************
+ * NetMUX protocol.c                                                          *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/01/22  Motorola    Fixed MMU exception in ApplyDataHdr              *
+ *   2007/04/11  Motorola    Reduce memcpys in ApplyDataHdr                   *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ *   2007/08/16  Motorola    Add supprot for larger bytecredit                *
+ ******************************************************************************/
+
+/* protocol.c contains functions used to transmit NetMUX protocol messages    */
+
+#include "protocol.h"
+#include "debug.h"
+
+
+/*
+ * ApplyDataHdr adds a data header to a data buffer
+ *
+ * Params:
+ * channel is the channel to which the data belongs
+ * commbuff is the buffer with the data to be sent
+ * mux is the MUX object the data is to be transmitted through
+ */
+void ApplyDataHdr (int8 channel, COMMBUFF** commbuff, MUX* mux)
+{
+    CHANNEL*         chanlPtr;
+    DATA_PACKET_HDR  packetdatahdr;
+    int16            length;
+    COMMBUFF*        cb = *commbuff;
+
+    DEBUG("ApplyDataHdr(%lu, %p, %p)\n", (int32)channel, commbuff, mux);
+
+    length = (int16)commbuff_length(cb);
+    convert_word(length);
+
+    chanlPtr = mux->channels[channel];
+
+    packetdatahdr.type = PACKETTYPE_DATA_HDR;
+    packetdatahdr.channel = channel;
+    packetdatahdr.len = length;
+
+    commbuff_add_header(cb, &packetdatahdr, sizeof(DATA_PACKET_HDR));
+    *commbuff = cb;
+
+    chanlPtr->qed_totl_amount += sizeof(DATA_PACKET_HDR);
+    mux->total_queued_amount  += sizeof(DATA_PACKET_HDR);
+}
+
+/*
+ * TransmitCredit assembles a control credit packet and initializes the transmit procedure
+ *
+ * Params:
+ * acktype specifies host or client as well as failure or success
+ * channel is the channel the credit should be applied to
+ * bytecredit is the amount the byte credit should be increased
+ * sendcredit is the amount the send credit should be increased
+ * mux is the MUX object the data is to be transmitted through
+ */
+int32 TransmitCredit (int8 acktype, int8 channel, int32 bytecredit, int32 sendcredit, MUX* mux)
+{
+    COMMBUFF*      commbuff;
+    CREDIT_PACKET* packetdata;
+
+    DEBUG(
+          "TransmitCredit(%lu, %lu, %lu, 0x%lu, %p)\n",
+          (int32)acktype,
+          (int32)channel,
+          (int32)bytecredit,
+          (int32)sendcredit,
+          mux
+         );
+
+    commbuff = int_alloc_commbuff(sizeof(CREDIT_PACKET));
+
+    convert_dword(bytecredit);
+    convert_dword(sendcredit);
+
+    packetdata       = (CREDIT_PACKET*)commbuff_data(commbuff);
+    packetdata->type = PACKETTYPE_CREDIT;
+
+    commbuff_copyin_byte(commbuff, offsetof(CREDIT_PACKET, acktype), acktype);
+    commbuff_copyin_byte(commbuff, offsetof(CREDIT_PACKET, channel), channel);
+    commbuff_copyin_dword(commbuff, offsetof(CREDIT_PACKET, bytecredit), bytecredit);
+    commbuff_copyin_dword(commbuff, offsetof(CREDIT_PACKET, sendcredit), sendcredit);
+
+    queue_commbuff(commbuff, &mux->send_queue);
+
+    mux->total_queued_amount += sizeof(CREDIT_PACKET);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TransmitEnableMUX assembles a control enable mux packet and initializes the transmit procedure
+ *
+ * Params:
+ * acktype specifies host or client as well as failure or success
+ * mux is the MUX object the data is to be transmitted through
+ */
+int32 TransmitEnableMUX (int8 acktype, MUX* mux)
+{
+    COMMBUFF*         commbuff;
+    ENABLEMUX_PACKET* packetdata;
+
+    DEBUG("TransmitEnableMUX(%lu, %p)\n", (int32)acktype, mux);
+
+    commbuff = int_alloc_commbuff(sizeof(ENABLEMUX_PACKET));
+
+    packetdata       = (ENABLEMUX_PACKET*)commbuff_data(commbuff);
+    packetdata->type = PACKETTYPE_ENABLEMUX;
+
+    commbuff_copyin_byte(commbuff, offsetof(ENABLEMUX_PACKET, acktype), acktype);
+
+    queue_commbuff(commbuff, &mux->send_queue);
+
+    mux->total_queued_amount += sizeof(ENABLEMUX_PACKET);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TransmitDisableMUX assembles a control disable mux packet and initializes the transmit procedure
+ *
+ * Params:
+ * acktype specifies host or client as well as failure or success
+ * mux is the MUX object the data is to be transmitted through
+ */
+int32 TransmitDisableMUX (int8 acktype, MUX* mux)
+{
+    COMMBUFF*          commbuff;
+    DISABLEMUX_PACKET* packetdata;
+
+    DEBUG("TransmitDisableMUX(%lu, %p)\n", (int32)acktype, mux);
+
+    commbuff = int_alloc_commbuff(sizeof(DISABLEMUX_PACKET));
+
+    packetdata       = (DISABLEMUX_PACKET*)commbuff_data(commbuff);
+    packetdata->type = PACKETTYPE_DISABLEMUX;
+
+    commbuff_copyin_byte(commbuff, offsetof(DISABLEMUX_PACKET, acktype), acktype);
+
+    queue_commbuff(commbuff, &mux->send_queue);
+
+    mux->total_queued_amount += sizeof(DISABLEMUX_PACKET);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TransmitEnableChannel assembles a control enable channel packet and initializes the transmit procedure
+ *
+ * Params:
+ * acktype specifies host or client as well as failure or success
+ * channel is the channel to be enabled
+ * host_interface is the interface which belongs to the host and is requesting the enable
+ * client_interface is the interface which belongs to the client and is responding to the enable
+ * bytecredit is the size of the receive buffer on the senders side
+ * sendcredit is the number of sends available to the senders side
+ * mux is the MUX object the data is to be transmitted through
+ */
+int32 TransmitEnableChannel (
+                             int8  acktype,
+                             int8  channel,
+                             int8  host_interface, 
+                             int8  client_interface, 
+                             int32 bytecredit, 
+                             int32 sendcredit, 
+                             MUX*  mux
+                            )
+{
+    COMMBUFF*             commbuff;
+    ENABLECHANNEL_PACKET* packetdata;
+
+    DEBUG(
+          "TransmitEnableChannel(%lu, %lu, %lu, %lu, %lu, %lu, %p)\n", 
+          (int32)acktype, 
+          (int32)channel, 
+          (int32)host_interface, 
+          (int32)client_interface, 
+          (int32)bytecredit, 
+          (int32)sendcredit, 
+          mux
+         );
+
+    commbuff = int_alloc_commbuff(sizeof(ENABLECHANNEL_PACKET));
+
+    convert_dword(bytecredit);
+    convert_dword(sendcredit);
+
+    packetdata       = (ENABLECHANNEL_PACKET*)commbuff_data(commbuff);
+    packetdata->type = PACKETTYPE_ENABLECHANNEL;
+
+    commbuff_copyin_byte(commbuff, offsetof(ENABLECHANNEL_PACKET, acktype), acktype);
+    commbuff_copyin_byte(commbuff, offsetof(ENABLECHANNEL_PACKET, channel), channel);
+    commbuff_copyin_byte(commbuff, offsetof(ENABLECHANNEL_PACKET, host_interface), host_interface);
+    commbuff_copyin_byte(commbuff, offsetof(ENABLECHANNEL_PACKET, client_interface), client_interface);
+    commbuff_copyin_dword(commbuff, offsetof(ENABLECHANNEL_PACKET, bytecredit), bytecredit);
+    commbuff_copyin_dword(commbuff, offsetof(ENABLECHANNEL_PACKET, sendcredit), sendcredit);
+
+    queue_commbuff(commbuff, &mux->send_queue);
+
+    mux->total_queued_amount += sizeof(ENABLECHANNEL_PACKET);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TransmitDisableChannel assembles a control disable channel packet and initializes the transmit procedure
+ *
+ * Params:
+ * acktype specifies host or client as well as failure or success
+ * channel is the channel to be disabled
+ * host_interface is the interface which belongs to the host and is requesting the disable
+ * client_interface is the interface which belongs to the client and is responding to the disable
+ * mux is the MUX object the data is to be transmitted through
+ */
+int32 TransmitDisableChannel (int8 acktype, int8 channel, int8 host_interface, int8 client_interface, MUX* mux)
+{
+    COMMBUFF*              commbuff;
+    DISABLECHANNEL_PACKET* packetdata;
+
+    DEBUG("TransmitDisableChannel(%lu, %lu, %lu, %lu, %p)\n", (int32)acktype, (int32)channel, (int32)host_interface, (int32)client_interface, mux);
+
+    commbuff = int_alloc_commbuff(sizeof(DISABLECHANNEL_PACKET));
+
+    packetdata       = (DISABLECHANNEL_PACKET*)commbuff_data(commbuff);
+    packetdata->type = PACKETTYPE_DISABLECHANNEL;
+
+    commbuff_copyin_byte(commbuff, offsetof(DISABLECHANNEL_PACKET, acktype), acktype);
+    commbuff_copyin_byte(commbuff, offsetof(DISABLECHANNEL_PACKET, channel), channel);
+    commbuff_copyin_byte(commbuff, offsetof(DISABLECHANNEL_PACKET, host_interface), host_interface);
+    commbuff_copyin_byte(commbuff, offsetof(DISABLECHANNEL_PACKET, client_interface), client_interface);
+
+    queue_commbuff(commbuff, &mux->send_queue);
+
+    mux->total_queued_amount += sizeof(DISABLECHANNEL_PACKET);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TransmitQueryInterface assembles a control query interface packet and initializes the transmit procedure
+ *
+ * Params:
+ * acktype specifies host or client as well as failure or success
+ * host_interface is the interface which belongs to the host of the query
+ * result is the resultant interface id which is relevent only when acktype is host_end(SUCCESS)
+ * mux is the MUX object the data is to be transmitted through
+ */
+int32 TransmitQueryInterface (int8 acktype, int8 host_interface, int8 result, sint8* name, MUX* mux)
+{
+    COMMBUFF*              commbuff;
+    QUERYINTERFACE_PACKET* packetdata;
+    int32                  namesize;
+
+    DEBUG("TransmitQueryInterface(%lu, %lu, %lu, %p, %p)\n", (int32)acktype, (int32)host_interface, (int32)result, name, mux);
+
+    if(name)
+        namesize = strlen((char*)name)+1;
+    else
+        namesize = 0;
+
+    if(namesize > PACKET_MAXNAME_LENGTH)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    commbuff = int_alloc_commbuff(sizeof(QUERYINTERFACE_PACKET));
+
+    packetdata       = (QUERYINTERFACE_PACKET*)commbuff_data(commbuff);
+    packetdata->type = PACKETTYPE_QUERYINTERFACE;
+
+    commbuff_copyin_byte(commbuff, offsetof(QUERYINTERFACE_PACKET, acktype), acktype);
+    commbuff_copyin_byte(commbuff, offsetof(QUERYINTERFACE_PACKET, host_interface), host_interface);
+    commbuff_copyin_byte(commbuff, offsetof(QUERYINTERFACE_PACKET, result), result);
+    commbuff_copyin(commbuff, offsetof(QUERYINTERFACE_PACKET, name), name, namesize);
+
+    queue_commbuff(commbuff, &mux->send_queue);
+
+    mux->total_queued_amount += sizeof(QUERYINTERFACE_PACKET);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TransmitChannelSignal transmits a four int8 value to the channel
+ *
+ * Params:
+ * acktype specifies host or client as well as failure or success
+ * channel is the channel to be signaled
+ * signal is the value to be delivered
+ * mux is the MUX object the data is to be transmitted through
+ */
+int32 TransmitChannelSignal (int8 acktype, int8 channel, int32 signal, MUX* mux)
+{
+    COMMBUFF*             commbuff;
+    CHANNELSIGNAL_PACKET* packetdata;
+
+    DEBUG("TransmitChannelSignal(%lu, %lu, %lu, %p)\n", (int32)acktype, (int32)channel, signal, mux);
+
+    commbuff = int_alloc_commbuff(sizeof(CHANNELSIGNAL_PACKET));
+
+    packetdata       = (CHANNELSIGNAL_PACKET*)commbuff_data(commbuff);
+    packetdata->type = PACKETTYPE_CHANNELSIGNAL;
+
+    commbuff_copyin_byte(commbuff, offsetof(CHANNELSIGNAL_PACKET, acktype), acktype);
+    commbuff_copyin_byte(commbuff, offsetof(CHANNELSIGNAL_PACKET, channel), channel);
+    commbuff_copyin_dword(commbuff, offsetof(CHANNELSIGNAL_PACKET, signal), signal);
+
+    queue_commbuff(commbuff, &mux->send_queue);
+
+    mux->total_queued_amount += sizeof(CHANNELSIGNAL_PACKET);
+
+    task_schedule(&mux->send_task);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * Log protocol messages
+ *
+ * Params:
+ * cb is the commbuff to be logged
+ */
+void log_packettype (COMMBUFF *cb)
+{
+
+    int32 length = 0;
+    int8 *data;
+    int32 msgid = 0;
+
+    if (!cb)
+        return;
+
+    data = commbuff_data(cb);
+    length = commbuff_length(cb);
+
+    switch (data[0]) {
+        case PACKETTYPE_INVALID:
+            msgid = NETMUX_PACKET_INVALID;
+            break;
+        case PACKETTYPE_DATA_HDR:
+            msgid = NETMUX_PACKET_DATA;
+            break;
+        case PACKETTYPE_CREDIT:
+            msgid = NETMUX_PACKET_CREDIT;
+            break;
+        case PACKETTYPE_ENABLEMUX:
+            msgid = NETMUX_PACKET_ENABLEMUX;
+            break;
+        case PACKETTYPE_DISABLEMUX:
+            msgid = NETMUX_PACKET_DISABLEMUX;
+            break;
+        case PACKETTYPE_ENABLECHANNEL:
+            msgid = NETMUX_PACKET_ENABLECHANNEL;
+            break;
+        case PACKETTYPE_DISABLECHANNEL:
+            msgid = NETMUX_PACKET_DISABLECHANNEL;
+            break;
+        case PACKETTYPE_QUERYINTERFACE:
+            msgid = NETMUX_PACKET_QUERYINTERFACE;
+            break;
+        case PACKETTYPE_CHANNELSIGNAL:
+            msgid = NETMUX_PACKET_CHANNELSIGNAL;
+            break;
+        default:
+            return;
+    };
+
+    LOGCOMMBUFF_PROTO(netmux_log_port_handle, msgid, length, cb);
+}
diff --git a/drivers/misc/netmux/protocol.h b/drivers/misc/netmux/protocol.h
new file mode 100755
index 0000000..57dc650
--- /dev/null
+++ b/drivers/misc/netmux/protocol.h
@@ -0,0 +1,66 @@
+/******************************************************************************
+ * NetMUX protocol.h                                                          *
+ *                                                                            *
+ * Copyright Motorola 2006-2007                                                    *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/08/16  Motorola    Add support for larger bytecredit                *
+ ******************************************************************************/
+
+/* protocol.h provides functions for parsing and assembly data to be          */
+/* transmitted over the link.                                                 */
+
+#ifndef _NETMUX_PROTOCOL_H_
+#define _NETMUX_PROTOCOL_H_
+
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "packet.h"
+#include "mux.h"
+
+
+/*
+ * The following functions are declared in protocol.c
+ */
+
+void  ApplyDataHdr           (int8, COMMBUFF**, MUX*);
+int32 TransmitCredit         (int8, int8, int32, int32, MUX*);
+int32 TransmitEnableMUX      (int8, MUX*);
+int32 TransmitDisableMUX     (int8, MUX*);
+int32 TransmitEnableChannel  (int8, int8, int8, int8, int32, int32, MUX*);
+int32 TransmitDisableChannel (int8, int8, int8, int8, MUX*);
+int32 TransmitQueryInterface (int8, int8, int8, sint8*, MUX*);
+int32 TransmitChannelSignal  (int8, int8, int32, MUX*);
+
+
+#endif
diff --git a/drivers/misc/netmux/register.c b/drivers/misc/netmux/register.c
new file mode 100755
index 0000000..1bea0f8
--- /dev/null
+++ b/drivers/misc/netmux/register.c
@@ -0,0 +1,341 @@
+/******************************************************************************
+ * NetMUX register.c                                                          *
+ *                                                                            *
+ * Copyright (C) 2006-2008 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/11/15  Motorola    Fixed shutdown order in DeactivateMUX            *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ *   2008/04/10  Motorola    Add AP Log re-work                               *
+ *   2008/04/15  Motorola    add DeactivateConfigInterface in DeactivateMUX   *
+ *   2008/07/15  Motorola    add NetmuxLogInit for AP config log              *
+ *   2009/07/10  Motorola    Update send buffers number                       *
+ *   2009/08/06  Motorola    Change permission for /proc/netmuxlog to 660     *
+ ******************************************************************************/
+
+/* register.c handles the communication process between a link driver and a   */
+/* NetMUX.                                                                    */
+
+#include "register.h"
+#include "debug.h"
+#include "direct.h"
+#include "network.h"
+#include "tty.h"
+
+
+#define REGISTER_MAX_INTERFACES 4
+#define REGISTER_HOST           1
+#define REGISTER_SEND_BUFFERS   336
+
+#define LOG_COMMAND_LEN            2 
+
+/*Netmux info accessible via the proc interface*/
+static struct proc_dir_entry *proc_netmux_log_entry = NULL;
+char *NetmuxLogState = NULL;
+static int GetNetmuxLogState(char *buf, char**start, off_t offset, int count,int *eof, void *data);
+static int WriteNetmuxLogCommand(struct file* file, const char* buffer, unsigned long count, void* data);
+/*
+ * Declare a list to hold each registered interface
+ */
+INTERFACELIST* interfacelist = 0;
+
+/*
+ * RegisterMUXLink is called by a linkdriver when registration
+ * is required. Registration will setup a valid NetMUX with
+ * connected interfaces and begin the communication routine.
+ *
+ * Params:
+ * linkif -- defines a method of communication with the linkdriver
+ * muxif -- defines a method of communication with a NetMUX
+ */
+int32 RegisterMUXLink (INTERFACELINK* linkif, INTERFACEMUX* muxif)
+{
+    INTERRUPT_STATE       state;
+    MUX*                  mux;
+    MUXINTERFACE_LIBRARY* muxlib;
+    INTERFACELIST**       ilist;
+    int32                 result;
+
+    DEBUG("RegisterMUXLink(%p, %p)\n", linkif, muxif);
+
+    if(!linkif || !muxif)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    result = CreateInterfaceLibrary(REGISTER_MAX_INTERFACES, &muxlib);
+    if(result != ERROR_NONE)
+        return DEBUGERROR(result);
+
+    result = CreateMUX(
+                       REGISTER_MAX_CHANNELS,
+                       REGISTER_SEND_BUFFERS,
+                       linkif->localMaxRcvSize,
+                       linkif->remoteMaxRcvSize,
+                       linkif->LinkSend,
+                       muxlib,
+                       &mux
+                      );
+    if(result != ERROR_NONE)
+    {
+        DestroyInterfaceLibrary(muxlib);
+
+        return DEBUGLDP(LDP_ERROR_FATAL);
+    }
+
+    muxif->MUXReceive      = &ReceiveFromLink;
+    muxif->MUXInform       = &InformMUX;
+    muxif->id              = mux;
+
+    disable_interrupts(state);
+
+    ilist = &interfacelist;
+
+    while(*ilist)
+        ilist = &(*ilist)->next;
+
+    (*ilist) = (INTERFACELIST*)int_alloc_mem(sizeof(INTERFACELIST));
+
+    (*ilist)->next = 0;
+
+    enable_interrupts(state);
+
+    (*ilist)->mux = mux;
+
+    memcpy(&(*ilist)->muxinterface, muxif, sizeof(INTERFACEMUX));
+    memcpy(&(*ilist)->linkinterface, linkif, sizeof(INTERFACELINK));
+
+    result = ActivateMUX(mux, *ilist);
+    if(result != ERROR_NONE)
+    {
+        DestroyMUX(mux);
+        DestroyInterfaceLibrary(muxlib);
+
+        free_mem((*ilist));
+
+        (*ilist) = 0;
+
+        return DEBUGLDP(LDP_ERROR_FATAL);
+    }
+
+    return DEBUGLDP(LDP_ERROR_NONE);
+}
+
+/*
+ * UnregisterMUXLink will unregister a linkdriver from a NetMUX. This
+ * process will causes any NetMUX resources to be released and
+ * any communication in process to be halted. Generally, the link
+ * driver which registered should also be responsible for
+ * unregistering.
+ *
+ * Params --
+ * id -- the value provided to the linkdriver upon registration
+ */
+int32 UnregisterMUXLink (void* id)
+{
+    INTERRUPT_STATE state;
+    INTERFACELIST** ilist;
+    INTERFACELIST*  found;
+
+    DEBUG("UnregisterMUXLink(%p)\n", id);
+
+    ilist = &interfacelist;
+
+    disable_interrupts(state);
+
+    while((*ilist) && (*ilist)->muxinterface.id != id)
+        ilist = &(*ilist)->next;
+
+    if(!(*ilist))
+    {
+        enable_interrupts(state);
+
+        return DEBUGLDP(LDP_ERROR_FATAL);
+    }
+
+    found    = (*ilist);
+    (*ilist) = found->next;
+
+    enable_interrupts(state);
+
+    DeactivateMUX(found);
+
+    return DEBUGLDP(LDP_ERROR_NONE);
+}
+
+/*
+ * ActivateMUX is a helper function to RegisterMUXLink.
+ * This function will work to activate the necessary
+ * interfaces and begin communication.
+ *
+ * Params:
+ * mux -- the mux to be activated
+ * ilist -- the interfacelist to be setup
+ */
+int32 ActivateMUX (MUX* mux, INTERFACELIST* ilist)
+{
+    int32 result;
+
+    DEBUG("ActivateMUX(%p, %p)\n", mux, ilist);
+
+    result = CreateConfigInterface(REGISTER_CONFIG_CHANNEL, mux, REGISTER_CONFIGDATA_COUNT, REGISTER_CONFIGDATA, &ilist->config);
+    if(result != ERROR_NONE)
+        return DEBUGERROR(result);
+
+    result = CreateDirectInterface("direct", "netmux", DIRECT_DYNAMIC_MAJOR_ASSIGNMENT, REGISTER_DIRECT_MINCH, REGISTER_DIRECT_MAXCH, mux, (DIRECTINTERFACE**)&ilist->direct);
+    if(result != ERROR_NONE)
+    {
+        DestroyConfigInterface(ilist->config);
+
+        return DEBUGERROR(result);
+    }
+
+    result = CreateTTYInterface("tty", "netmux", TTY_DYNAMIC_MAJOR_ASSIGNMENT, REGISTER_TTY_MINCH, REGISTER_TTY_MAXCH, mux, (TTYINTERFACE**)&ilist->tty);
+    if(result != ERROR_NONE)
+    {
+        DestroyConfigInterface(ilist->config);
+        DestroyDirectInterface((DIRECTINTERFACE*)ilist->direct);
+
+        return DEBUGERROR(result);
+    }
+
+    result = CreateNetworkInterface("network", REGISTER_NETWORK_MINCH, REGISTER_NETWORK_MAXCH, mux, (NETWORKINTERFACE**)&ilist->network);
+    if(result != ERROR_NONE)
+    {
+        DestroyConfigInterface(ilist->config);
+        DestroyDirectInterface((DIRECTINTERFACE*)ilist->direct);
+        DestroyTTYInterface((TTYINTERFACE*)ilist->tty);
+
+        return DEBUGERROR(result);
+    }
+
+    result = ActivateConfigInterface(REGISTER_HOST, ilist->config);
+    if(result != ERROR_NONE)
+    {
+        DestroyConfigInterface(ilist->config);
+
+        DestroyDirectInterface((DIRECTINTERFACE*)ilist->direct);
+        DestroyNetworkInterface((NETWORKINTERFACE*)ilist->network);
+        DestroyTTYInterface((TTYINTERFACE*)ilist->tty);
+
+        return DEBUGERROR(result);
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DeactivateMUX is a helper function to UnregisterMUXLink. This
+ * function will help release any consumed resources and halt
+ * any communication on a NetMUX.
+ *
+ * Params:
+ * ilist -- the interface to be deactivated
+ */
+void DeactivateMUX (INTERFACELIST* ilist)
+{
+    DEBUG("DeactivateMUX(%p)\n", ilist);
+
+    DestroyDirectInterface((DIRECTINTERFACE*)ilist->direct);
+    DestroyNetworkInterface((NETWORKINTERFACE*)ilist->network);
+    DestroyTTYInterface((TTYINTERFACE*)ilist->tty);
+
+    DeactivateConfigInterface(ilist->config);
+    DestroyConfigInterface(ilist->config);
+
+    ilist->linkinterface.LinkInform((void*)LDP_INFORM_SHUTDOWN, (void*)ilist->muxinterface.id);
+
+    DestroyMUX(ilist->mux);
+
+    free_mem(ilist);
+}
+
+/*
+ * GetNetmuxLogState is a read callback function of proc interface on NetMUX.
+ * 
+ */
+
+static int GetNetmuxLogState(char *buf, char**start, off_t offset, int count,int *eof, void *data)
+{
+    int len;
+    int index;
+    
+    len = LOG_COMMAND_LEN;
+    index = 0;
+
+    len = sprintf(buf,"%s\n", &NetmuxLogState[index]);
+    *eof = 1;
+    return len;
+}
+
+/*
+ * WriteNetmuxLogCommand is a write callback function of proc interface on NetMUX.
+ *
+ */
+                                                                                                                             
+static int WriteNetmuxLogCommand(struct file* file, const char* buffer, unsigned long count, void* data)
+{
+    int len;
+    int index;
+
+    len= count;
+    index = 0;
+    if(len > LOG_COMMAND_LEN)
+    {
+        printk("Error : Netmux log command is invalid\n");
+        return -ENOSPC;
+    }
+    if(copy_from_user(&NetmuxLogState[index], buffer, len)) {
+        return -EFAULT;
+    }
+    NetmuxLogState[LOG_COMMAND_LEN-1] = '\0';
+
+    return len;
+}
+
+void NetmuxLogInit(void)
+{
+    NetmuxLogState = alloc_mem(LOG_COMMAND_LEN);
+    NetmuxLogState[0] = '0';
+    NetmuxLogState[1] = '\0';
+                                                                                                                             
+    proc_netmux_log_entry = create_proc_entry("netmuxlog", 0x660, 0);
+    if ((!proc_netmux_log_entry) || (!NetmuxLogState))
+    {
+        remove_proc_entry("netmuxlog", 0);
+    }
+    else
+    {
+        proc_netmux_log_entry->data =  NetmuxLogState;
+        proc_netmux_log_entry->read_proc =  GetNetmuxLogState;
+        proc_netmux_log_entry->write_proc = WriteNetmuxLogCommand;
+        proc_netmux_log_entry->owner = THIS_MODULE;
+    }
+}
diff --git a/drivers/misc/netmux/register.h b/drivers/misc/netmux/register.h
new file mode 100755
index 0000000..18bb9b2
--- /dev/null
+++ b/drivers/misc/netmux/register.h
@@ -0,0 +1,129 @@
+/******************************************************************************
+ * NetMUX register.h                                                          *
+ *                                                                            *
+ * Copyright (C) 2006-2008 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/04/06  Motorola    Reduced maximum channel numbers and increase     *
+ *                           the number of send buffers                       *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ *   2008/04/10  Motorola    Add proc_fs for AP Log re-work                   *
+ *   2008/07/16  Motorola    Add NetmuxLogInit declaration for AP config log  *
+ ******************************************************************************/
+
+/* register.h defines data types used by register.c. The types may very based */
+/* on the NetMUX environment but the overall usage of the types remains the   */
+/* same.                                                                      */
+
+#ifndef _NETMUX_REGISTER_H_
+#define _NETMUX_REGISTER_H_
+
+
+#include "shared/ldprotocol.h"
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "mux.h"
+#include "config.h"
+#include <linux/proc_fs.h>
+
+/*
+ * Define some magic numbers to be used by the
+ * registration interface.
+ */
+#define REGISTER_MAX_CHANNELS       48
+#define REGISTER_CONFIG_CHANNEL     0
+#define REGISTER_NETWORK_MINCH      1
+#define REGISTER_NETWORK_MAXCH      8
+#define REGISTER_DIRECT_MINCH       9
+#define REGISTER_DIRECT_MAXCH       40
+#define REGISTER_TTY_MINCH          41
+#define REGISTER_TTY_MAXCH          47
+#define REGISTER_CONNECTIVITY_MINCH 1
+#define REGISTER_CONNECTIVITY_MAXCH 47
+/*
+ * The definitions define where to retrieve the NetMUX channel configuration info
+ */
+#define REGISTER_CONFIGDATA_COUNT netmux_configdata_count
+#define REGISTER_CONFIGDATA       netmux_configdata
+
+
+/*
+ * INTERFACELIST holds a list of link drivers that are associated with MUX objects
+ * A brief description follows below.
+ *
+ * muxinterface defines the interface to the MUX
+ * linkinterface defines the interface to the link driver
+ * mux points to a specific MUX object
+ * config points to the config interface for this connection
+ * direct points to a direct interface for this connection
+ * network points to a network interface for this connection
+ * tty points to a tty interface for this connection
+ * connectivity points to a connectivity interface for this connection
+ * next points to the next defined interface
+ */
+typedef struct INTERFACELIST
+{
+    INTERFACEMUX  muxinterface;
+    INTERFACELINK linkinterface;
+    MUX*          mux;
+
+    CONFIGINTERFACE*  config;
+
+    void* direct;
+    void* network;
+    void* tty;
+    void* connectivity;
+
+    struct INTERFACELIST* next;
+}INTERFACELIST;
+
+
+/*
+ * Define variables that must be defined in channelconfig.c
+ */
+extern int32      netmux_configdata_count;
+extern CONFIGDATA netmux_configdata[];
+
+
+/*
+ * Define various functions defined in register.c
+ */
+
+int32 RegisterMUXLink   (INTERFACELINK*, INTERFACEMUX*);
+int32 UnregisterMUXLink (void*);
+int32 ActivateMUX       (MUX*, INTERFACELIST*);
+void  DeactivateMUX     (INTERFACELIST*);
+void  NetmuxLogInit	(void);
+
+#endif
diff --git a/drivers/misc/netmux/shared/ldprotocol.h b/drivers/misc/netmux/shared/ldprotocol.h
new file mode 100755
index 0000000..daaeea9
--- /dev/null
+++ b/drivers/misc/netmux/shared/ldprotocol.h
@@ -0,0 +1,139 @@
+/******************************************************************************
+ * NetMUX ldprotocol.h                                                        *
+ *                                                                            *
+ * Copyright (C) Motorola 2006                                                *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combined header and data into one transfer       *
+ ******************************************************************************/
+
+/* ldprotocol.h is shared between the NetMUX and any participating link       */
+/* driver.  This file defines the necessary data types and constants needed   */
+/* to successfully participate in a link-driver <--> NetMUX protocol          */
+
+
+#ifndef _NETMUX_LDPROTOCOL_H_
+#define _NETMUX_LDPROTOCOL_H_
+
+
+/*
+ * Define a set of error codes that can be used for NetMUX <--> Link driver
+ * communication.
+ *
+ * LDP_ERROR_NONE        -- no error
+ * LDP_ERROR_FATAL       -- an error happend that can not be recovered from
+ * LDP_ERROR_RECOVERABLE -- an error happend that will be fixed
+ */
+#define LDP_ERROR_NONE        0x00000000
+#define LDP_ERROR_FATAL       0x00000001
+#define LDP_ERROR_RECOVERABLE 0x00000002
+
+
+/*
+ * Define the inform types that the NetMUX and Link driver may use to
+ * communicate states between each other.
+ *
+ * LDP_INFORM_SHUTDOWN  -- says the device is being disconnected
+ * LDP_INFORM_RECOVERED -- says an error has been recovered from
+ */
+#define LDP_INFORM_SHUTDOWN  0x00000001
+#define LDP_INFORM_RECOVERED 0x00000002
+
+/*
+ * INTERFACELINK defines the link driver's communication interface.
+ * A brief description follows below.
+ *
+ * LinkSend - points to a function that will physically transmit data.
+ *            The function takes a pointer to a commbuff and returns
+ *            an LDP error code.
+ *
+ * LinkInform - points to an inform function that can be used to configure the link driver
+ *              The first parameter is the inform type and the second is any data
+ *              to be associated with the inform type.
+ *
+ * localMaxRcvSize - the max size that we can receive
+ *
+ * remoteMaxRcvSize - the max size the remote can receive
+ */
+typedef struct INTERFACELINK
+{
+    unsigned long (*LinkSend)   (void*);
+    unsigned long (*LinkInform) (void*, void*);
+
+    unsigned long localMaxRcvSize;
+    unsigned long remoteMaxRcvSize;
+}INTERFACELINK;
+
+
+/*
+ * INTERFACEMUX defines the mux's communication interface. A brief
+ * description follows below.
+ *
+ * MUXReceive - defines a function the link driver can call to give data to the NetMUX.
+ *              The first parameter is the buffer being received, the second is the
+ *              id member of the INTERFACEMUX structure.
+ *
+ * MUXInform - points to a function the link driver can use to configure the NetMUX
+ *             The first parameter is the inform type and the second is any data
+ *             to be associated with the inform type.
+ *
+ * CommBuffRequest - a function pointer provided by the NetMUX that the linkdriver
+ *                   must use to obtain a COMMBUFF to receive into.
+ *
+ * id represents a MUX object specific value to allow for more than one MUX object
+ */
+typedef struct INTERFACEMUX
+{
+    unsigned long (*MUXReceive) (void*, void*);
+    unsigned long (*MUXInform)  (void*, void*);
+
+    void* id;
+}INTERFACEMUX;
+
+
+/*
+ * Define two functions used in registering and unregistering a NetMUX
+ * with a link driver.
+ *
+ * RegisterMUXLink takes a pointer to a completed INTERFACELINK
+ * structure and a pointer to an uninitialized INTERFACEMUX pointer.
+ * The INTERFACEMUX pointer will be filled in with valid values
+ * for the linkdriver to use.
+ *
+ * UnregisterMUXLink takes a single parameter. The parameter is
+ * the 'id' member of the INTERFACEMUX structure. This value
+ * is filled in by the NetMUX upon calling RegisterMUXLink.
+ */
+extern unsigned long RegisterMUXLink   (INTERFACELINK*, INTERFACEMUX*);
+extern unsigned long UnregisterMUXLink (void*);
+
+
+#endif
diff --git a/drivers/misc/netmux/tty.c b/drivers/misc/netmux/tty.c
new file mode 100755
index 0000000..6e39ee3
--- /dev/null
+++ b/drivers/misc/netmux/tty.c
@@ -0,0 +1,842 @@
+/******************************************************************************
+ * NetMUX tty.c                                                               *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/11/15  Motorola    Fixed DestroyTTYInterface disable channel code   *
+ *   2006/12/19  Motorola    Combined header and data into one transfer       *
+ *   2007/01/15  Motorola    Fixed TTYWrite related code                      *
+ *   2007/02/08  Motorola    Added mux_channel_queue_space to fix scheduling  *
+ *                           while atomic bug                                 *
+ *   2007/12/05  Motorola    change code as kernel upgrade                    *
+ *   2007/10/25  Motorola    change code as kernel upgrade                    *
+ ******************************************************************************/
+
+/* tty.c is responsible for setting up a method of communication between the  */
+/* NetMUX and user space applications.                                        */
+
+#include "tty.h"
+#include "protocol.h"
+#include "config.h"
+#include "debug.h"
+
+extern struct class *netmux_class;
+
+static const struct tty_operations tty_ops = {
+	.open = TTYOpen,
+	.close = TTYClose,
+	.write = TTYWrite,
+	.write_room = TTYWriteRoom,
+	.chars_in_buffer = TTYDataInBuffer,
+	.ioctl = TTYIOCtl,
+};
+
+
+/*
+ * TTYInform is called by the mux (and sometimes the
+ * config interface) to inform the interface that something
+ * important has happened. The tty interface listens for 
+ * several things of importance.
+ * 
+ * First, it listens for config packets. If a config packet
+ * is recieved it processes it and sets up the appropriate
+ * channel and entries in /dev/netmux.
+ *
+ * Second, it listens for a disable mux event. If such an
+ * event happens all channels are forced closed and no
+ * application can perform any operation on the channel until
+ * all application accessing that device perform a close().
+ * 
+ * Third, it waits for enable channel messages. If such a
+ * message is ever received it immediately responds with a
+ * failure because the direct interface does not support 
+ * external open requests.
+ *
+ * Fourth, it waits for a disable channel message. If
+ * one is received the channel is placed into an inoperable
+ * state until all applications accessing the device recognize
+ * the closure by performing a close().
+ *
+ * Fifth, it waits for a data message, which signifies that the 
+ * channel has successfuly delivered data. The tty interface
+ * uses this information to wakeup any event waiting to write
+ * data to the channel. Also the mux send task is scheduled if
+ * more data is ready to be sent.
+ *
+ * Sixth, it waits for a channel signal message. This signifies
+ * a change to the modem flags and the signal will be processed
+ * accordingly.
+ * 
+ * Seventh, it waits for a prepare to send message. If one is received
+ * the tty interface will attempt to send any data contained in any
+ * of the tty channel queues.
+ *
+ * Seventh, it waits for a prepare to send message. If one is received
+ * the tty interface will attempt to send any data contained in any
+ * of the tty channel queues.
+ *
+ * Params:
+ * param1 -- a custom pointer, in this case an INTERFACEINFORM struct
+ * param2 -- a custom pointer, in this case a TTYINTERFACE struct
+ */
+int32 TTYInform (void* param1, void* param2)
+{
+    TTYINTERFACE*         ttyif;
+    struct tty_struct*    tty;
+    TTY_CHANNELDATA*      chdat;
+    CONFIGPACKET*         configpacket;
+    ENABLECHANNEL_PACKET* enablechannel;
+    CHANNELSIGNAL_PACKET* channelsignal;
+    INTERFACEINFORM*      informdata;
+    COMMBUFF*             transmit;
+    COMMBUFF*             split;
+    int32                 channel;
+    int32                 type;
+    int32                 result;
+    int16                 xormask;
+    int16                 maskbase;
+    int16                 signal_maskbase;
+    int16                 signal_xormask;
+
+    DEBUG("TTYInform(0x%p, 0x%p)\n", param1, param2);
+
+    informdata = (INTERFACEINFORM*)param1;
+    ttyif      = (TTYINTERFACE*)param2;
+
+    switch(informdata->inform_type)
+    {
+        case INFORM_INTERFACE_CONFIGPACKET:
+        {
+            channel = ((CONFIGPACKET*)informdata->data)->channel;
+
+            if(channel > ttyif->channel_max || channel < ttyif->channel_min)
+                return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+            chdat        = &ttyif->channel_data[channel-ttyif->channel_min];
+            configpacket = (CONFIGPACKET*)informdata->data;
+
+            chdat->commbuff         = 0;
+            chdat->client_interface = configpacket->host_interface;
+            chdat->burstsize        = configpacket->client_burstsize;
+            chdat->maxdata          = configpacket->client_maxdata;
+            chdat->host_byte_credit = configpacket->client_byte_credit;
+            chdat->host_send_credit = configpacket->client_send_credit;
+            chdat->modem_flags      = TTY_DEFAULT_MODEM_FLAGS;
+            chdat->data_amount      = 0;
+            chdat->mux_channel_queue_space = configpacket->client_maxdata;
+
+            initialize_commbuff_queue(&chdat->process_queue);
+
+            memcpy(chdat->device_file, configpacket->channel_name, PACKET_MAXNAME_LENGTH);
+
+            init_waitqueue_head(&chdat->event_wait);
+            init_waitqueue_head(&chdat->close_wait);
+
+            if(netmux_class)
+            {
+                if(IS_ERR(device_create(netmux_class, NULL,
+                          MKDEV(ttyif->driver.major, channel), NULL, 
+			  "%s", 
+			  chdat->device_file)))
+                    return DEBUGERROR(ERROR_OPERATIONFAILED);
+            }
+            else
+            {
+                DEBUGERROR(ERROR_INVALIDPARAMETER);
+            }
+
+            if(chdat->refcount == 0)
+                chdat->state = TTY_STATE_READY;
+        }break;
+
+        case INFORM_INTERFACE_DISABLEMUX:
+        {
+            for(channel = 0; channel < ttyif->channel_max-ttyif->channel_min+1; channel++)
+            {
+                wake_up_interruptible(&ttyif->channel_data[channel].event_wait);
+
+                ttyif->channel_data[channel].state = TTY_STATE_DEFAULT;
+            }
+        }break;
+
+        case INFORM_INTERFACE_ENABLECHANNEL:
+        {
+            enablechannel = (ENABLECHANNEL_PACKET*)informdata->data;
+            type          = strip_end(enablechannel->acktype);
+
+            if(type == COMMAND)
+            {
+                EnableChannel(
+                              client_end(FAILURE),
+                              enablechannel->channel,
+                              0,
+                              0,
+                              enablechannel->host_interface,
+                              enablechannel->client_interface,
+                              0,
+                              0,
+                              0,
+                              0,
+                              ttyif->mux
+                             );
+            }
+            else if(type == SUCCESS)
+            {
+                channel = enablechannel->channel;
+                chdat   = &ttyif->channel_data[channel-ttyif->channel_min];
+
+                chdat->refcount++;
+                chdat->state |= TTY_STATE_EVENT|TTY_STATE_EVENT_SUCCESS;
+
+                wake_up_interruptible(&chdat->event_wait);
+            }
+            else if(type == FAILURE)
+            {
+                channel = enablechannel->channel;
+                chdat   = &ttyif->channel_data[channel-ttyif->channel_min];
+
+                chdat->state |= TTY_STATE_EVENT;
+
+                wake_up_interruptible(&chdat->event_wait);
+            }
+        }break;
+
+        case INFORM_INTERFACE_DISABLECHANNEL:
+        {
+            channel = ((DISABLECHANNEL_PACKET*)informdata->data)->channel;
+            chdat   = &ttyif->channel_data[channel-ttyif->channel_min];
+
+            chdat->refcount--;
+            wake_up_interruptible(&chdat->close_wait);
+        }break;
+
+        case INFORM_INTERFACE_CHANNELSIGNAL:
+        {
+            channelsignal = (CHANNELSIGNAL_PACKET*)informdata->data;
+            channel       = channelsignal->channel;
+
+            enter_write_criticalsection(&ttyif->lock);
+
+            chdat = &ttyif->channel_data[channel-ttyif->channel_min];
+            
+            signal_maskbase = channelsignal->signal>>16;
+            signal_xormask  = channelsignal->signal&0xFFFF;
+            maskbase        = chdat->modem_flags&0xFFFF;
+            xormask         = maskbase^signal_maskbase;
+            xormask         = xormask^signal_xormask;
+
+            chdat->modem_flags =  maskbase^xormask;
+
+            exit_write_criticalsection(&ttyif->lock);
+
+            wake_up_interruptible(&chdat->event_wait);
+        }break;
+
+        case INFORM_INTERFACE_PREPSEND:
+        {
+            for(channel = 0; channel < ttyif->channel_max - 
+                ttyif->channel_min + 1; channel++)
+            {
+                chdat = &ttyif->channel_data[channel];
+                enter_write_criticalsection(&ttyif->lock);
+
+                if(chdat->refcount && queue_length(&chdat->process_queue))
+                {
+                    do
+                    {
+                        transmit = dequeue_commbuff(&chdat->process_queue);
+			chdat->data_amount -= commbuff_length(transmit);
+			chdat->mux_channel_queue_space -= commbuff_length(transmit);
+
+                        result = SendData(channel + ttyif->channel_min,
+                                          transmit, &split, ttyif->mux);
+
+                        if(result == ERROR_INCOMPLETE)
+                        {
+                            queuefront_commbuff(split, &chdat->process_queue);
+			    chdat->data_amount += commbuff_length(split);
+			    chdat->mux_channel_queue_space += commbuff_length(split);
+                        }
+                    } while(((result == ERROR_NONE) ||
+                            (result == ERROR_INCOMPLETE)) && 
+                            queue_length(&chdat->process_queue));
+
+                    if((result != ERROR_NONE) && (result != ERROR_INCOMPLETE))
+                    {
+                        queuefront_commbuff(transmit, &chdat->process_queue);
+			chdat->data_amount += commbuff_length(transmit);
+			chdat->mux_channel_queue_space += commbuff_length(transmit);
+                    }
+                }
+
+                exit_write_criticalsection(&ttyif->lock);
+            }
+        }break;
+
+        case INFORM_INTERFACE_DATA:
+        {
+            channel = (int32)(informdata->data);
+
+            result = SendDataAvailable(channel, ttyif->mux);
+
+            enter_write_criticalsection(&ttyif->lock);
+
+            chdat = &ttyif->channel_data[channel-ttyif->channel_min];
+            chdat->mux_channel_queue_space = result;
+
+            exit_write_criticalsection(&ttyif->lock);
+
+            tty     = ttyif->driver.ttys[channel - ttyif->channel_min];
+            if (tty->ldisc.ops->flags & TTY_DO_WRITE_WAKEUP)
+                tty->ldisc.ops->write_wakeup(tty);
+
+            if(queue_length(&chdat->process_queue))
+                RunSend(ttyif->mux);
+        }break;
+
+        default:break;
+    }
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TTYReceive is called when a buffer is available for
+ * delivery to an application. The tty interface will 
+ * attempt to deliver the buffer to the tty layer,
+ * however, if that is not possible the interface will
+ * poll and try to deliver it again later.
+ *
+ * Params:
+ * commbuff -- a pointer to the received data
+ * param -- a custom pointer, in this case an INTERFACEINFORM struct
+ */
+int32 TTYReceive (COMMBUFF* commbuff, void* param)
+{
+    struct tty_struct* tty;
+    TTYINTERFACE*      ttyif;
+    INTERFACEINFORM*   inform_data;
+    int32              channel;
+
+    DEBUG("TTYReceive(0x%p, 0x%p)\n", commbuff, param);
+
+    inform_data = (INTERFACEINFORM*)param;
+    ttyif       = (TTYINTERFACE*)inform_data->inform_type;
+    channel     = (int32)inform_data->data;
+    tty         = ttyif->driver.ttys[channel-ttyif->channel_min];
+
+    if (commbuff_length(commbuff) <= tty->receive_room)
+	(tty->ldisc.ops->receive_buf)(tty, commbuff_data(commbuff), 0, commbuff_length(commbuff));
+    else
+	return DEBUGERROR(ERROR_INCOMPLETE);
+
+    LOGCOMMBUFF_CH(channel, "TTYReceive()-->", commbuff, commbuff_length(commbuff));
+
+    free_commbuff(commbuff);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * CreateTTYInterface will create an interface object to be used by 
+ * a NetMUX. This object will keep track of all settings required to
+ * communicate with the tty layer. As such, any tty operation
+ * will make reference to this interface object.
+ *
+ * Params:
+ * name -- the name of the interface
+ * path -- the path to create device entries in
+ * major -- the major number for the driver, 0 if it's to be dynamic
+ * channel_min -- the inclusive lower bound of channel numbers assigned to the interface
+ * channel_max -- the inclusive upper bound of channel numbers assigned to the interface
+ * mux -- the mux object this interface is associated with
+ * tty -- a pointer to a pointer to receive the newly created object
+ */
+int32 CreateTTYInterface (sint8* name, sint8* path, int32 major, int32 channel_min, int32 channel_max, MUX* mux, TTYINTERFACE** tty)
+{
+    TTYINTERFACE*    newtty;
+    TTY_CHANNELDATA* channel_data;
+    int32            result;
+    int32            namesize;
+    int32            pathsize;
+    int32            size;
+
+    DEBUG("CreateTTYInterface(0x%p, 0x%p, %lu, %lu, %lu, 0x%p, 0x%p)\n", name, path, major, channel_min, channel_max, mux, tty);
+
+    if(!tty || !name || !path || !mux)
+        return DEBUGERROR(ERROR_INVALIDPARAMETER);
+
+    if(channel_min > channel_max)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    if(channel_max >= mux->maxchannels)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    size = (channel_max-channel_min+1)*sizeof(TTY_CHANNELDATA);
+
+    namesize = strlen(name)+1;
+    if(namesize > PACKET_MAXNAME_LENGTH)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    pathsize = strlen(path)+1;
+    if(pathsize > PACKET_MAXNAME_LENGTH)
+        return DEBUGERROR(ERROR_OPERATIONRESTRICTED);
+
+    channel_data = (TTY_CHANNELDATA*)alloc_mem(size);
+    newtty       = (TTYINTERFACE*)alloc_mem(sizeof(TTYINTERFACE));
+
+    memset(newtty, 0, sizeof(TTYINTERFACE));
+
+    result = RegisterInterface(name, &TTYInform, &TTYReceive, (int32)newtty, mux->interface_lib);
+    if(result != ERROR_NONE)
+    {
+        free_mem(newtty);
+        free_mem(channel_data);
+
+        return DEBUGERROR(result);
+    }
+
+    QueryInterfaceIndex(name, mux->interface_lib, &newtty->host_interface);
+
+    newtty->driver.magic                = TTY_DRIVER_MAGIC;
+    newtty->driver.driver_name          = "netmux";
+    newtty->driver.name                 = "netmux";
+    newtty->driver.major                = TTY_DYNAMIC_MAJOR_ASSIGNMENT;
+    newtty->driver.minor_start          = channel_min;
+    newtty->driver.num                  = channel_max-channel_min+1;
+    newtty->driver.type                 = TTY_DRIVER_TYPE_SERIAL;
+    newtty->driver.subtype              = SERIAL_TYPE_NORMAL;
+    newtty->driver.init_termios         = tty_std_termios;
+    newtty->driver.init_termios.c_iflag = 0;
+    newtty->driver.init_termios.c_oflag = 0;
+    newtty->driver.init_termios.c_cflag = B38400 | CS8 | CREAD;
+    newtty->driver.init_termios.c_lflag = 0;
+    newtty->driver.flags                = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+    newtty->driver.driver_state         = (struct tty_driver*)newtty;
+
+    tty_set_operations(&newtty->driver, &tty_ops);
+    result = tty_register_driver(&newtty->driver);
+    if(result < 0)
+    {
+        UnregisterInterface(newtty->host_interface, mux->interface_lib);
+
+        free_mem(channel_data);
+        free_mem(newtty);
+
+        return DEBUGERROR(ERROR_OPERATIONFAILED);
+    }
+
+    newtty->mux          = mux;
+    newtty->channel_min  = channel_min;
+    newtty->channel_max  = channel_max; 
+    newtty->channel_data = channel_data;
+
+    memcpy(newtty->device_directory, path, pathsize);
+    memcpy(newtty->interface_name, name, namesize);
+    memset(channel_data, 0, size);
+
+    initialize_criticalsection_lock(&newtty->lock);
+
+    *tty = newtty;
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * DestroyTTYInterface is invoked when a NetMUX is being destroyed.
+ * The interface object will be 'undone'.
+ *
+ * Params:
+ * tty -- the interface to be destroyed
+ */
+int32 DestroyTTYInterface (TTYINTERFACE* tty)
+{
+    TTY_CHANNELDATA* chdat;
+    int32            channels;
+    int32            index;
+
+    DEBUG("DestroyTTYInterface(0x%p)\n", tty);
+
+    chdat    = tty->channel_data;
+    channels = tty->channel_max-tty->channel_min+1;
+
+    for(index = 0; index < channels; index++)
+    {
+        if(chdat[index].state&TTY_STATE_READY)
+        {
+            DisableChannel(
+                           host_end(COMMAND), 
+                           index+tty->channel_min, 
+                           tty->host_interface, 
+                           chdat[index].client_interface, 
+                           tty->mux
+                          );
+
+            if(chdat[index].refcount)
+                wait_event_interruptible(chdat[index].close_wait, !(chdat[index].refcount));
+
+            device_destroy(netmux_class, MKDEV(tty->driver.major, index));
+        }
+    }
+
+    tty_unregister_driver(&tty->driver);
+    UnregisterInterface(tty->host_interface, tty->mux->interface_lib);
+    destroy_criticalsection_lock(&tty->lock);
+
+    free_mem(tty->channel_data);
+    free_mem(tty);
+
+    return DEBUGERROR(ERROR_NONE);
+}
+
+/*
+ * TTYOpen is called by the linux file system whenever an open
+ * is performed on a device belonging to this interface. The open 
+ * will send an enable request to a client netmux and wait for a
+ * reply. If any errors occurr the device will not be open.
+ *
+ * Params:
+ * tty-- used to let us fetch the major/minor of the device
+ * filp -- some private data is set within this structure
+ */
+int TTYOpen (struct tty_struct* tty, struct file* filp)
+{
+    TTYINTERFACE*      ttyif;
+    TTY_CHANNELDATA*   chdat;
+    int32              minor;    
+    int32              result;
+
+    DEBUG("TTYOpen(0x%p, 0x%p)\n", tty, filp);
+
+    ttyif = (TTYINTERFACE*)tty->driver->driver_state;
+    minor = tty->index+ttyif->channel_min;
+
+    if(minor < ttyif->channel_min || minor > ttyif->channel_max)
+        return -EADDRNOTAVAIL;
+
+    chdat = &ttyif->channel_data[minor-ttyif->channel_min];
+    if(!(chdat->state&TTY_STATE_READY))
+        return -EADDRNOTAVAIL;
+
+    if(chdat->refcount > 0)
+        return -EBUSY;
+
+    result = EnableChannel(
+                           host_end(COMMAND), 
+                           minor, 
+                           chdat->burstsize, 
+                           chdat->maxdata, 
+                           ttyif->host_interface, 
+                           chdat->client_interface, 
+                           chdat->host_byte_credit, 
+                           chdat->host_send_credit, 
+                           0, 
+                           0, 
+                           ttyif->mux
+                          );
+
+    if(result != ERROR_NONE)
+        return -ECONNABORTED;
+
+    /* Wake up when either one of two conditions occur:
+       1 - A response is received from the BP for our open request.
+       2 - The channel is not configured and running properly.
+       In case the latter is true an error will be returned eventually. */
+    wait_event_interruptible(chdat->event_wait,
+                            (chdat->state&TTY_STATE_EVENT) ||
+                            !(chdat->state&TTY_STATE_READY));
+                
+    chdat->state &= ~TTY_STATE_EVENT;
+
+    if(!(chdat->state&TTY_STATE_EVENT_SUCCESS))
+        return -ECONNREFUSED;
+
+    chdat->state &= ~TTY_STATE_EVENT_SUCCESS;
+
+    ttyif->driver.ttys[minor-ttyif->channel_min] = tty;
+
+    return 0;
+}
+
+/*
+ * TTYClose is called by the file system whenever a close is
+ * performed on an open device. A disable is sent to the client
+ * NetMUX but no response is expected or required. If there is
+ * an error with the device being closed an error will be
+ * returned.
+ * 
+ * Params:
+ * tty -- used to fetch the minor number of the device
+ * filp -- stores some private data which we use to fetch the tty
+ *         interface structure
+ */
+void TTYClose (struct tty_struct* tty, struct file* filp)
+{
+    TTYINTERFACE*    ttyif;
+    TTY_CHANNELDATA* chdat;
+    int32            minor;
+    int32            result;
+
+    DEBUG("TTYClose(0x%p, 0x%p)\n", tty, filp);
+
+    ttyif = (TTYINTERFACE*)tty->driver->driver_state;
+    minor = tty->index+ttyif->channel_min;
+
+    if(minor < ttyif->channel_min || minor > ttyif->channel_max)
+        return;
+
+    chdat = &ttyif->channel_data[minor-ttyif->channel_min];
+
+    if(chdat->refcount)
+    {
+        result = DisableChannel(host_end(COMMAND), minor, ttyif->host_interface, chdat->client_interface, ttyif->mux);
+        if(result != ERROR_NONE)
+        {
+            ttyif->driver.ttys[minor-ttyif->channel_min] = 0;
+
+            return;
+        }
+
+        chdat->state = TTY_STATE_READY;
+        wait_event_interruptible(chdat->close_wait, !chdat->refcount);
+    }
+    else
+    {
+        (void)DisableChannel(host_end(COMMAND), minor, ttyif->host_interface, chdat->client_interface, ttyif->mux);
+    }
+
+    return;
+}
+
+/*
+ * TTYWrite is called whenever the user tries to write data
+ * to a device. If the device cannot take the data or there
+ * is some other error the user will be notified. The data
+ * to be delivered is copied out of the user supplied buffer
+ * and into an allocated commbuff.
+ *
+ * Params:
+ * tty -- used to get the direct interface and the minor number
+ * buf -- a pointer to the data to be copied
+ * count -- the number of bytes to be copied
+ */
+ssize_t TTYWrite (struct tty_struct* tty, const unsigned char* buf, int count)
+{
+    COMMBUFF*        commbuff;
+    TTYINTERFACE*    ttyif;
+    TTY_CHANNELDATA* chdat;
+    int32            minor;
+    sint32	     amount_written;
+
+    DEBUG("TTYWrite(0x%p, 0x%p, %d)\n", tty, buf, count);
+
+    /* This function can be called in an atomic context so we shouldn't call
+       any APIs that can sleep */
+
+    ttyif = (TTYINTERFACE*)tty->driver->driver_state;
+    minor = tty->index+ttyif->channel_min;
+
+    chdat = &ttyif->channel_data[minor-ttyif->channel_min];
+    if(!(chdat->state&TTY_STATE_READY) || chdat->refcount == 0)
+        return -ENOTCONN;
+
+    /* In some instances, we might add more data to the NetMUX queue than the
+     * burst size for the channel. Also, the amount of combined data in the two
+     * queues may surpass the channel queue size. */
+    amount_written = chdat->mux_channel_queue_space - chdat->data_amount;
+
+    if (count < amount_written)
+        amount_written = count;
+
+    if (amount_written > 0)
+    {
+        commbuff = alloc_commbuff(amount_written, sizeof(DATA_PACKET_HDR));
+        memcpy(commbuff_data(commbuff), buf, amount_written);
+        queue_commbuff(commbuff, &chdat->process_queue);
+	chdat->data_amount += commbuff_length(commbuff);
+        RunSend(ttyif->mux);
+    }
+    else
+    {
+        amount_written = 0;
+    }
+
+    return amount_written;
+}
+
+/*
+ * TTYWriteRoom is used to determine if there is any available
+ * space in the write buffers. The value returned is the
+ * number of bytes available.
+ *
+ * Params:
+ * tty -- used to get the devices minor number
+ */
+int TTYWriteRoom (struct tty_struct* tty)
+{
+    TTYINTERFACE*    ttyif;
+    TTY_CHANNELDATA* chdat;
+    int32            minor;
+    sint32           result;
+
+    DEBUG("TTYWriteRoom(0x%p)\n", tty);
+
+    ttyif = (TTYINTERFACE*)tty->driver->driver_state;
+    minor = tty->index+ttyif->channel_min;
+
+    chdat = &ttyif->channel_data[minor-ttyif->channel_min];
+    if(!(chdat->state&TTY_STATE_READY) || chdat->refcount == 0)
+        return -ENOTCONN;
+
+    result = chdat->mux_channel_queue_space - chdat->data_amount;
+
+    return (result < 0 ? 0 : result);
+}
+
+/*
+ * TTYDataInBuffer is used to determine if there is any 
+ * data available in the read buffers to be read by a
+ * device.
+ *
+ * Params:
+ * tty -- used to get the devices minor number
+ */
+int TTYDataInBuffer (struct tty_struct* tty)
+{
+    TTYINTERFACE*    ttyif;
+    TTY_CHANNELDATA* chdat;
+    int32            minor;
+    int32            result;
+
+    DEBUG("TTYDataInBuffer(0x%p)\n", tty);
+
+    ttyif = (TTYINTERFACE*)tty->driver->driver_state;
+    minor = tty->index+ttyif->channel_min;
+
+    chdat = &ttyif->channel_data[minor-ttyif->channel_min];
+    if(!(chdat->state&TTY_STATE_READY) || chdat->refcount == 0)
+        return -ENOTCONN;    
+
+    result = ReadDataAvailable(minor, ttyif->mux);
+
+    return result;
+}
+
+/*
+ * TTYIOCtl is used to get and set the modem flags of a
+ * particular device. Any application can modify the 
+ * modem flags and expect the result to be delivered to
+ * the client NetMUX. The user can also tell the function
+ * to block until a certain modem signal changed.
+ *
+ * Params:
+ * tty -- used to get the devices minor number
+ * cmd -- the IOCtl type
+ * arg -- the argument to the IOCtl
+ */
+int TTYIOCtl (struct tty_struct* tty, struct file* file, unsigned int cmd, unsigned long arg)
+{
+    wait_queue_head_t* queue;
+    TTYINTERFACE*      ttyif;
+    TTY_CHANNELDATA*   chdat;
+    int32              minor;
+    int16              newflags;
+    int16              xormask;
+    int32              signal;
+    int32              change;
+    int32              original_flags;
+    int32              wait_flags;
+
+    DEBUG("TTYIOCtl(0x%p, 0x%p, %d, %lu)\n", tty, file, cmd, arg);
+
+    ttyif = (TTYINTERFACE*)tty->driver->driver_state;
+    minor = tty->index+ttyif->channel_min;
+
+    chdat = &ttyif->channel_data[minor-ttyif->channel_min];
+    if(!(chdat->state&TTY_STATE_READY) || chdat->refcount == 0)
+        return -ENOTCONN;
+
+    switch(cmd)
+    {
+        case TIOCMGET:
+        {
+            original_flags = chdat->modem_flags;
+
+            if(copy_to_user((unsigned int*)arg, &original_flags, sizeof(int16)))
+                return -EFAULT; 
+
+            return 0;
+        }break;
+
+        case TIOCMSET:
+        {
+            if(copy_from_user(&newflags, (unsigned int*)arg, sizeof(int16)))
+                return -EFAULT;
+
+            enter_write_criticalsection(&ttyif->lock);
+
+            xormask             = newflags^chdat->modem_flags;
+            signal              = (chdat->modem_flags<<16)|(xormask);
+            chdat->modem_flags ^= xormask;
+
+            exit_write_criticalsection(&ttyif->lock);
+
+            ChannelSignal(host_end(COMMAND), signal, minor, ttyif->mux);
+
+            return 0;
+        }break;
+
+        case TIOCMIWAIT:
+        {
+            change         = 0;
+            original_flags = chdat->modem_flags;
+            queue          = &chdat->event_wait;
+
+            if(copy_from_user(&wait_flags, (unsigned int*)arg, sizeof(unsigned int)))
+                return -EFAULT;
+
+            if(!wait_flags)
+                return 0;
+
+            while(!(wait_flags&change))
+            {
+                interruptible_sleep_on(queue);
+
+                change = chdat->modem_flags^original_flags;
+            }
+
+            return 0;
+        }break;
+    }
+
+    return -ENOIOCTLCMD;
+}
diff --git a/drivers/misc/netmux/tty.h b/drivers/misc/netmux/tty.h
new file mode 100755
index 0000000..804cf72
--- /dev/null
+++ b/drivers/misc/netmux/tty.h
@@ -0,0 +1,172 @@
+/******************************************************************************
+ * NetMUX tty.h                                                               *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2007                                           *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combined header and data into one transfer       *
+ *   2007/01/15  Motorola    Removed able_to_send flag and added data_amount  *
+ *                           field to the TTY_CHANNELDATA structure           *
+ *   2007/02/01  Motorola    Added mux_channel_queue_space                    *
+ *   2007/12/05  Motorola    Change kernel file as kernel upgrade             *
+ ******************************************************************************/
+
+/* tty.h is responsible for setting up a method of communication between the  */
+/* NetMUX and user space applications.                                        */
+
+#ifndef _NETMUX_TTY_H_
+#define _NETMUX_TTY_H_
+
+
+#include "types.h"
+#include "errorcodes.h"
+#include "utility.h"
+#include "mux.h"
+
+#include <linux/device.h>
+
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <asm/uaccess.h>
+
+
+/*
+ * Defined to allow for dynamic major assignment upon driver registration
+ */
+#define TTY_DYNAMIC_MAJOR_ASSIGNMENT 0
+
+#define TTY_DEFAULT_MODEM_FLAGS 0
+
+/*
+ * Declares different states a tty channel can be placed in
+ */
+#define TTY_STATE_DEFAULT       0
+#define TTY_STATE_READY         1
+#define TTY_STATE_EVENT         2
+#define TTY_STATE_EVENT_SUCCESS 4
+
+
+/*
+ * TTY_CHANNELDATA defines a structure to bind channels to a certain configuration
+ * A brief description is provided below.
+ *
+ * commbuff represents a commbuff currently being received
+ * refcount is the total number of times the channel has been enabled
+ * state represents the current state of this channel
+ * client_interface is the interface id of the external interface
+ * burstsize is the default maximum amount of data to be sent at a time
+ * maxdata is the default maximum amount of data to be queued
+ * data_amount is the current amount of data stored in the process_queue
+ * host_byte_credit is the default number of bytes that can be received
+ * host_send_credit is the default number of sends that can be received
+ * modem_flags is modified on an ioctl
+ * mux_channel_queue_space is the current amount of space available in the mux channel queue
+ * process_queue holds a list of commbuffs to be transmitted
+ * event_wait defines a structure that a tty device can sleep on
+ * close_wait defines a structure that a close operation can sleep on
+ * device_file is the name of the file entry in /dev
+ */
+typedef struct TTY_CHANNELDATA
+{
+    COMMBUFF* commbuff;
+
+    int32 refcount;
+    int32 state;
+    int32 client_interface;
+    int32 burstsize;
+    int32 maxdata;
+    int32 data_amount;
+    int32 host_byte_credit;
+    int32 host_send_credit;
+    int32 modem_flags;
+    int32 mux_channel_queue_space;
+
+    COMMBUFFQUEUE process_queue;
+
+    wait_queue_head_t event_wait;
+    wait_queue_head_t close_wait;
+
+    sint8 device_file[PACKET_MAXNAME_LENGTH];
+}TTY_CHANNELDATA;
+
+/*
+ * TTY_INTERFACE declares a structure to manage tty channel data pointers
+ * A brief description is provided below.
+ *
+ * channel_min is the inclusive lower boundary of channel numbers
+ * channel_max is the inclusive upper boundary of channel numbers
+ * host_interface is the interface id for the local interface
+ * channel_data is a list of structures bound to specific channels
+ * mux points to the MUX object associated with this tty interface
+ * device_directory is the directory within /dev to create devices
+ * interface_name is the name of this interface
+ */
+typedef struct TTYINTERFACE
+{
+    int32 channel_min;
+    int32 channel_max;
+    int32 host_interface;
+
+    TTY_CHANNELDATA* channel_data;
+    MUX*             mux;
+    CRITICALSECTION  lock;
+
+    sint8  device_directory[PACKET_MAXNAME_LENGTH];
+    sint8  interface_name[PACKET_MAXNAME_LENGTH];
+
+    struct tty_driver driver;
+}TTYINTERFACE;
+
+
+/*
+ * Define various functions used by the tty interface
+ */
+
+int32 TTYInform  (void*, void*);
+int32 TTYReceive (COMMBUFF*, void*);
+
+int32 CreateTTYInterface  (sint8*, sint8*, int32, int32, int32, MUX*, TTYINTERFACE**);
+int32 DestroyTTYInterface (TTYINTERFACE*);
+
+int          TTYOpen         (struct tty_struct*, struct file*);
+void         TTYClose        (struct tty_struct*, struct file*);
+ssize_t      TTYWrite        (struct tty_struct*, const unsigned char*, int);
+int          TTYDataInBuffer (struct tty_struct*);
+int          TTYWriteRoom    (struct tty_struct*);
+int          TTYIOCtl        (struct tty_struct*, struct file*, unsigned int, unsigned long);
+
+
+#endif
diff --git a/drivers/misc/netmux/types.h b/drivers/misc/netmux/types.h
new file mode 100755
index 0000000..8ef70cc
--- /dev/null
+++ b/drivers/misc/netmux/types.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ * NetMUX types.h                                                             *
+ *                                                                            *
+ * Copyright Motorola 2006                                                    *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ ******************************************************************************/
+
+
+/* types.h defines standard data sizes for use by the NetMUX.                 */
+
+#ifndef _NETMUX_TYPES_H_
+#define _NETMUX_TYPES_H_
+
+
+/* 
+ * int32 is always an unsigned 4 bytes 
+ */
+typedef unsigned long int32; 
+
+/* 
+ * int16 is always an unsigned 2 bytes 
+ */
+typedef unsigned short int16;
+
+/* 
+ * int8 is always an unsigned byte 
+ */
+typedef unsigned char int8;
+
+/* 
+ * sint32 is always a signed 4 bytes 
+ */
+typedef signed long sint32;
+
+/* 
+ * sint16 is always a signed 2 bytes 
+ */
+typedef signed short sint16;
+
+/* 
+ * sint8 is always a signed byte 
+ */
+typedef signed char sint8;
+
+/* 
+ * real4 represents a 4 byte floating point value 
+ */
+typedef float real4;
+
+/* 
+ * real8 represents an 8 byte floating point value 
+ */
+typedef double real8;
+
+
+#endif
diff --git a/drivers/misc/netmux/utility.c b/drivers/misc/netmux/utility.c
new file mode 100755
index 0000000..0772b4c
--- /dev/null
+++ b/drivers/misc/netmux/utility.c
@@ -0,0 +1,437 @@
+/******************************************************************************
+ * NetMUX utility.c                                                           *
+ *                                                                            *
+ * Copyright (C) 2006-2008 Motorola, Inc.                                     * 
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/12/19  Motorola    Combined header and data into one transfer       *
+ *   2007/02/25  Motorola    Renamed kfree to kfree_skb inside commbuff_merge *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ *   2007/12/05  Motorola    Change codes as INIT_WORK changes in kernel      *
+ *   2008/04/10  Motorola    Add AP Debug log re-work                         *
+ ******************************************************************************/
+
+
+/* utility.c is responsible for defining a platform independent API to the    */
+/* NetMUX.  The API is responsible for all common OS functions such as memory */
+/* allocation and task scheduling.                                            */
+
+#include "utility.h"
+#include "packet.h"
+#include "debug.h"
+
+
+#define COMMBUFF_TAG_INDEX_COUNT         4
+#define GET_COMMBUFF_TAG_INDEX(commbuff) (((int32)(commbuff)>>5)&(COMMBUFF_TAG_INDEX_COUNT-1))
+
+#define LOG_COMMAND_ALL_WORK 49
+#define LOG_COMMAND_BUFFER 50
+#define LOG_COMMAND_FUNCTION 51
+
+typedef struct LOCALTASK
+{
+    TASKDATA releasetask;
+    void* released_tagged_commbuffs;
+} LOCALTASK;
+
+static COMMBUFFTAG* commbuff_tags[COMMBUFF_TAG_INDEX_COUNT] = {0};
+static COMMBUFFTAG* released_tagged_commbuffs               = 0;
+
+static LOCALTASK tagged_commbuff_release_task;
+
+void ProcessReleasedCommBuffs (struct work_struct*);
+
+extern char * NetmuxLogState;
+
+void initialize_utilities (void)
+{
+     tagged_commbuff_release_task.released_tagged_commbuffs = (void *)(&released_tagged_commbuffs);
+     initialize_task(&tagged_commbuff_release_task.releasetask, &ProcessReleasedCommBuffs);
+}
+
+void shutdown_utilities (void)
+{
+    destroy_task(&tagged_commbuff_release_task.releasetask);
+}
+
+/*
+ * int_alloc_mem allocates memory inside of an interrupt context
+ * size is the size of the memory to allocate
+ */
+void* int_alloc_mem (int32 size)
+{
+    void* ret;
+
+    ret = kmalloc(size, GFP_ATOMIC);
+    if(!ret)
+        PANIC(netmuxPanicMemFail1, "NetMUX PANIC: Unable to allocate memory\n");
+
+    return ret;
+}
+
+/*
+ * alloc_mem allocates memory
+ * size is the size of the memory to allocate
+ */
+void* alloc_mem (int32 size)
+{
+    void* ret;
+
+    ret = kmalloc(size, GFP_KERNEL);
+    if(!ret)
+        PANIC(netmuxPanicMemFail2, "NetMUX PANIC: Unable to allocate memory\n");
+
+    return ret;
+}
+
+void ProcessReleasedCommBuffs (struct work_struct *work)
+{
+    INTERRUPT_STATE state;
+    COMMBUFFTAG*    taginfo;
+    COMMBUFFTAG*    freetag;
+    LOCALTASK*      localtask;
+
+    disable_interrupts(state);
+
+    /* grab a local copy of released_tagged_commbuffs */
+    /* and clear the global list                      */
+    localtask = container_of (work, LOCALTASK, releasetask.work);
+    taginfo = *((COMMBUFFTAG**)localtask->released_tagged_commbuffs);
+     *((COMMBUFFTAG**)localtask->released_tagged_commbuffs) = NULL;
+
+    enable_interrupts(state);
+
+    /* then process the local list */
+    while(taginfo)
+    {
+        taginfo->CommBuffRelease(
+                                 taginfo->channel,
+                                 taginfo->size,
+                                 taginfo->param
+                                );
+
+        freetag = taginfo;
+        taginfo = taginfo->next_tag;
+
+        free_mem(freetag);
+    }
+}
+
+void FreeCommBuffData (COMMBUFF* commbuff)
+{
+    INTERRUPT_STATE state;
+    COMMBUFFTAG**   tags;
+    COMMBUFFTAG*    freetag;
+    int32           index;
+
+    index = GET_COMMBUFF_TAG_INDEX(commbuff);
+    tags  = &commbuff_tags[index];
+
+    disable_interrupts(state);
+
+    while(*tags)
+    {
+        if((*tags)->commbuff == commbuff)
+        {
+            freetag = *tags;
+            *tags   = freetag->next_tag;
+
+            freetag->next_tag         = released_tagged_commbuffs;
+            released_tagged_commbuffs = freetag;
+
+            enable_interrupts(state);
+
+            task_schedule(&tagged_commbuff_release_task.releasetask);
+
+            return;
+        }
+
+        tags = &(*tags)->next_tag;
+    }
+
+    enable_interrupts(state);
+}
+
+/*
+ * int_alloc_commbuff allocates a commbuff inside of an interrupt context
+ * size is the size of the commbuff to allocate
+ */
+COMMBUFF* int_alloc_commbuff (int32 size)
+{
+    COMMBUFF* newcommbuff;
+
+    newcommbuff = alloc_skb(size, GFP_ATOMIC);
+    if(!newcommbuff)
+        PANIC(netmuxPanicSKBFail1,
+              "NetMUX PANIC: Unable to allocate commbuff\n");
+
+    skb_put(newcommbuff, size);
+
+    return newcommbuff;
+}
+
+/*
+ * alloc_commbuff allocates a commbuff outside of interrupt context
+ * size is the data size needed in the commbuff
+ * headroom is the size needed to add a header in front of the data
+ */
+COMMBUFF* alloc_commbuff (int32 size, int32 headroom)
+{
+    COMMBUFF* newcommbuff;
+    int32 totalSize = size + headroom;
+
+    newcommbuff = alloc_skb(totalSize, GFP_KERNEL);
+    if(!newcommbuff)
+        PANIC(netmuxPanicSKBFail2,
+              "NetMUX PANIC: Unable to allocate commbuff\n");
+
+    skb_reserve(newcommbuff, headroom);
+
+    skb_put(newcommbuff, size);
+
+    return newcommbuff;
+}
+
+
+/*
+ * commbuff_split takes a commbuff and splits it at an offset
+ * orig is the commbuff to be split
+ * off is the offset at which the split is to occur
+ * split is the resultant 'end partition' of the split
+ */
+COMMBUFF* commbuff_split (COMMBUFF* orig, int32 off)
+{
+    COMMBUFF* splitbuff;
+
+    if(!off || off >= orig->len)
+        return 0;
+
+    splitbuff = skb_clone(orig, GFP_ATOMIC);
+    if(!splitbuff)
+        PANIC(netmuxPanicSKBFail3,
+              "NetMUX PANIC: Unable to allocate commbuff\n");
+
+    skb_trim(orig, off);
+    skb_pull(splitbuff, off);
+
+    return splitbuff;
+}
+
+/*
+ * commbuff_merge merges two commbuffs together
+ * focus is where source is being merged to
+ * source is what is being merged into focus
+ */
+COMMBUFF* commbuff_merge (COMMBUFF* focus, COMMBUFF* source)
+{
+    COMMBUFF* newcommbuff;
+    sint8*     data;
+
+    if(skb_tailroom(focus) >= source->len)
+    {
+        data = skb_put(focus, source->len);
+
+        memcpy(data, source->data, source->len);
+        kfree_skb(source);
+
+        return focus;
+    }
+
+    newcommbuff = alloc_skb(focus->len+source->len, GFP_ATOMIC);
+    if(!newcommbuff)
+        PANIC(netmuxPanicSKBFail4,
+              "NetMUX PANIC: Unable to allocate commbuff\n");
+
+    data = skb_put(newcommbuff, focus->len);
+    memcpy(data, focus->data, focus->len);
+
+    data = skb_put(newcommbuff, source->len);
+    memcpy(data, source->data, source->len);
+
+    kfree_skb(focus);
+    kfree_skb(source);
+
+    return newcommbuff;
+}
+
+void tag_commbuff (COMMBUFF* commbuff, int32 channel, void* param, void (*release)(int32, int32, void*))
+{
+    INTERRUPT_STATE state;
+    COMMBUFFTAG*    newtag;
+    int32           index;
+
+    index = GET_COMMBUFF_TAG_INDEX(commbuff);
+
+    newtag = (COMMBUFFTAG*)int_alloc_mem(sizeof(COMMBUFFTAG));
+
+    newtag->channel         = channel;
+    newtag->commbuff        = commbuff;
+    newtag->param           = param;
+    newtag->size            = commbuff_length(commbuff);
+    newtag->CommBuffRelease = release;
+
+    commbuff->destructor = &FreeCommBuffData;
+
+    disable_interrupts(state);
+
+    newtag->next_tag     = commbuff_tags[index];
+    commbuff_tags[index] = newtag;
+
+    enable_interrupts(state);
+}
+
+void detag_commbuff (COMMBUFF* commbuff)
+{
+    FreeCommBuffData(commbuff);
+
+    commbuff->destructor = 0;
+}
+
+void queue_commbuff (COMMBUFF* commbuff, COMMBUFFQUEUE* queue)
+{
+    INTERRUPT_STATE state;
+
+    disable_interrupts(state);
+    skb_queue_tail(queue, commbuff);
+    enable_interrupts(state);
+}
+
+void queuefront_commbuff (COMMBUFF* commbuff, COMMBUFFQUEUE* queue)
+{
+    INTERRUPT_STATE state;
+
+    disable_interrupts(state);
+    skb_queue_head(queue, commbuff);
+    enable_interrupts(state);
+}
+
+COMMBUFF* dequeue_commbuff (COMMBUFFQUEUE* queue)
+{
+    INTERRUPT_STATE state;
+    COMMBUFF*       ret;
+
+    disable_interrupts(state);
+    ret = skb_dequeue(queue);
+    enable_interrupts(state);
+
+    return ret;
+}
+
+void empty_commbuff_queue (COMMBUFFQUEUE* queue)
+{
+    INTERRUPT_STATE state;
+
+    disable_interrupts(state);
+    skb_queue_purge(queue);
+    enable_interrupts(state);
+}
+
+void output (SU_PORT_HANDLE port, int32 msgid, sint8* fmt, ...)
+{
+#if defined(_DEBUG_) || defined(_LOG_)
+    va_list args;
+    va_start(args, fmt);
+    vprintk(fmt, args);
+    va_end(args);
+#endif /* _DEBUG_ || _LOG_ */
+    if(NetmuxLogState){
+        if ((NetmuxLogState[0] == LOG_COMMAND_ALL_WORK) || (NetmuxLogState[0] == LOG_COMMAND_FUNCTION)){
+            va_list args;
+            va_start(args, fmt);
+            vprintk(fmt, args);
+            va_end(args);
+       }
+   }
+}
+
+/*
+ * log_commbuff logs all important data from a commbuff. This includes
+ * the contents of the commbuff, the address of the commbuff, and the
+ * length of the content. 
+ *
+ * Params:
+ * msgid -- A 4 byte message id, used for logging purposes
+ * header -- A prefix to output prior to logging of the commbuff
+ * cb -- a pointer to the commbuff to be logged
+ * length -- the length of the commbuff
+ */
+void log_commbuff (int32 msgid, sint8* header, COMMBUFF* cb, int32 length)
+{
+#ifdef _LOG_
+    static sint8 text[256];
+    int32        index;
+    int32        value;
+
+    value  = 0;
+
+    sprintf(text, "%s: Commbuff: 0x%p   Length: %lu   Data:", header, cb, length);
+    printk(text);
+
+    for(index = 0; index < length; index++)
+    {
+        if(!(index&0x0F))
+            printk("\nNETMUX: ");
+
+        commbuff_copyout(&value, cb, index, sizeof(int8));
+        
+        sprintf(text, " 0x%02x", (unsigned int)value);
+        printk(text);
+    }
+
+    printk("\n");
+#endif /* _LOG_ */
+    if ((NetmuxLogState) && ((NetmuxLogState[0] == LOG_COMMAND_ALL_WORK) || (NetmuxLogState[0] == LOG_COMMAND_BUFFER)))
+    {
+    static sint8 text[256];
+    int32        index;
+    int32        value;
+                                                                                                                             
+    value  = 0;
+                                                                                                                             
+    sprintf(text, "%s: Commbuff: 0x%p   Length: %lu   Data:", header, cb, length);
+    printk(text);
+                                                                                                                             
+    for(index = 0; index < length; index++)
+    {
+        if(!(index&0x0F))
+            printk("\nNETMUX: ");
+                                                                                                                             
+        commbuff_copyout(&value, cb, index, sizeof(int8));
+                                                                                                                             
+        sprintf(text, " 0x%02x", (unsigned int)value);
+        printk(text);
+    }
+                                                                                                                             
+    printk("\n");
+   }
+}
+
diff --git a/drivers/misc/netmux/utility.h b/drivers/misc/netmux/utility.h
new file mode 100755
index 0000000..e04fab7
--- /dev/null
+++ b/drivers/misc/netmux/utility.h
@@ -0,0 +1,52 @@
+/******************************************************************************
+ * NetMUX utility.h                                                           *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/05/01  Motorola    Change codes to ensure "shared" netmux           *
+ *                           code is identical between AP and BP.             *
+ ******************************************************************************/
+
+
+/* utility.h is responsible for defining a platform independent API to the    */
+/* NetMUX. The API is responsible for all common OS functions such as memory  */
+/* allocation and task scheduling.                                            */
+
+#ifndef _NETMUX_UTILITY_H_
+#define _NETMUX_UTILITY_H_
+
+
+#include "utility_host.h"
+#include "utility_client.h"
+
+
+#endif
diff --git a/drivers/misc/netmux/utility_client.h b/drivers/misc/netmux/utility_client.h
new file mode 100755
index 0000000..df96c40
--- /dev/null
+++ b/drivers/misc/netmux/utility_client.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ * NetMUX utility_client.h                                                    *
+ *                                                                            *
+ * Copyright (C) 2006-2007 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/06/25  Motorola    Modified Copyright                               *
+ ******************************************************************************/
+
+#ifndef _NETMUX_UTILITY_CLIENT_H_
+#define _NETMUX_UTILITY_CLIENT_H_
+
+#endif
diff --git a/drivers/misc/netmux/utility_host.h b/drivers/misc/netmux/utility_host.h
new file mode 100755
index 0000000..ef09467
--- /dev/null
+++ b/drivers/misc/netmux/utility_host.h
@@ -0,0 +1,248 @@
+/******************************************************************************
+ * NetMUX utility_host.h                                                      *
+ *                                                                            *
+ * Copyright (C) 2006-2010 Motorola, Inc.                                     *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2007/04/11  Motorola    Modified commbuff_add_* to take header pointer   *
+ *   2007/11/02  Motorola    Safely disable and enable interrupts             *
+ *   2007/12/05  Motorola    Change initialize_task as INIT_WOKR changes in   *
+ *                           kernel                                           *
+ *   2008/10/25  Motorola    update  kernel to TI 25.1                        *
+ *   2009/10/02  Motorola    replace down_interruptible() with down()         *
+ ******************************************************************************/
+
+
+/* utility_host.h is responsible for defining a platform independent API to   */
+/* the NetMUX. The API is responsible for all common OS functions such as     */
+/* memory allocation and task scheduling.                                     */
+
+#ifndef _NETMUX_UTILITY_HOST_H_
+#define _NETMUX_UTILITY_HOST_H_
+
+
+#include "types.h"
+#include "errorcodes.h"
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#include <asm/irq.h>
+
+
+void initialize_utilities (void);
+void shutdown_utilities   (void);
+
+/*
+ * PANIC macro to halt everything
+ */
+#define PANIC(id, text) \
+  {                                                 \
+    char panicStr[128];                             \
+    snprintf(panicStr, 128, "0x%x %s\n", id, text); \
+    panic(panicStr);                                \
+  }
+
+/*
+ * Macros to align data to 1 int8. These ease compiling the NetMUX with
+ * different compilers
+ */
+#define START_PACKED_STRUCT(name) typedef struct name {
+#define END_PACKED_STRUCT(name)   } __attribute__((packed)) name;
+#define PACKED_MEMBER(member)     member
+
+/*
+ * Used to convert a value to little endian
+ */
+#define convert_word(value)  {}
+#define convert_dword(value) {}
+
+/*
+ * Methods for allocating and freeing kernel space memory
+ */
+#define free_mem(ptr)       kfree(ptr)
+
+void* int_alloc_mem (int32 size);
+void* alloc_mem     (int32 size);
+
+/*
+ * The NetMUX refers to a data type called a 'COMMBUFF' for transmitting and
+ * receiving data
+ */
+typedef struct sk_buff COMMBUFF;
+
+typedef struct COMMBUFFTAG
+{
+    COMMBUFF* commbuff;
+
+    int32 channel;
+    int32 size;
+    void* param;
+
+    void (*CommBuffRelease) (int32, int32, void*);
+
+    struct COMMBUFFTAG* next_tag;
+}COMMBUFFTAG;
+
+/*
+ * The following declare routines for manipulating data inside a COMMBUFF
+ */
+COMMBUFF* int_alloc_commbuff (int32);
+COMMBUFF* alloc_commbuff     (int32, int32);
+
+#define free_commbuff(ptr)                   kfree_skb(ptr)
+#define ref_commbuff(ptr)                    skb_get(ptr)
+#define deref_commbuff(ptr)                  kfree_skb(ptr)
+#define commbuff_length(ptr)                 (ptr)->len
+#define commbuff_data(ptr)                   (ptr)->data
+#define commbuff_copyout(dst, cb, off, len)  memcpy(dst, ((cb)->data)+off, len)
+#define commbuff_remove_front(ptr, amount)   skb_pull(ptr, amount)
+/* the memcopys work because the skbuff is in contiguous memory */
+#define commbuff_add_header(ptr, hdr, amount)  { \
+                                                  skb_push(ptr, amount); \
+                                                  memcpy((ptr)->data, hdr, amount); \
+                                                }
+#define commbuff_copyin(cb, off, src, len)   memcpy((cb)->data+(off), src, len);
+#define commbuff_copyin_byte(ptr, off, val)  *((ptr)->data+off) = val
+#define commbuff_copyin_word(ptr, off, val)  *(int16*)((ptr)->data+off) = val
+#define commbuff_copyin_dword(ptr, off, val) *(int32*)((ptr)->data+off) = val
+#define commbuff_data_pullup(ptr, len)
+
+COMMBUFF* commbuff_split  (COMMBUFF*, int32);
+COMMBUFF* commbuff_merge  (COMMBUFF*, COMMBUFF*);
+void      tag_commbuff    (COMMBUFF*, int32, void*, void (*__cdecl)(int32, int32, void*));
+void      detag_commbuff  (COMMBUFF*);
+
+/*
+ * The NetMUX uses a data type called a COMMBUFFQUEUE to store COMMBUFF's
+ */
+typedef struct sk_buff_head COMMBUFFQUEUE;
+
+/*
+ * The following are routines to manipulate COMMBUFFQUEUE's
+ */
+#define initialize_commbuff_queue(queue) skb_queue_head_init(queue)
+#define destroy_commbuff_queue(queue)    {}
+#define queue_length(queue)              skb_queue_len(queue)
+#define queue_frontbuff(queue) queue->next
+
+void      queue_commbuff            (COMMBUFF*, COMMBUFFQUEUE*);
+void      queuefront_commbuff       (COMMBUFF*, COMMBUFFQUEUE*);
+COMMBUFF* dequeue_commbuff          (COMMBUFFQUEUE*);
+void      empty_commbuff_queue      (COMMBUFFQUEUE*);
+
+/*
+ * TASKDATA defines a routine that can be manipulated like a Linux tasklet
+ */
+typedef struct TASKDATA
+{
+    struct work_struct work;
+    int8               state;
+}TASKDATA;
+
+#define initialize_task(task, function) { \
+                                    unsigned long flags; \
+                                    local_irq_save(flags); \
+                                    INIT_WORK(&(task)->work, function); \
+                                    (task)->state = 0; \
+                                    local_irq_restore(flags); \
+                                  }
+
+#define destroy_task(task)        {}
+
+#define enable_task(task)         { \
+                                    unsigned long flags; \
+                                    local_irq_save(flags); \
+                                    (task)->state &= ~0x01; \
+                                    if((task)->state) \
+                                    { \
+                                        schedule_work(&(task)->work); \
+                                        (task)->state = 0; \
+                                    } \
+                                    local_irq_restore(flags); \
+                                  }
+
+#define disable_task(task)        { \
+                                    unsigned long flags; \
+                                    local_irq_save(flags); \
+                                    (task)->state |= 0x01; \
+                                    local_irq_restore(flags); \
+                                  }
+
+#define task_schedule(task)       { \
+                                    unsigned long flags; \
+                                    local_irq_save(flags); \
+                                    if(!(task)->state) \
+                                        schedule_work(&(task)->work); \
+                                    else \
+                                        (task)->state |= 0x02; \
+                                    local_irq_restore(flags); \
+                                  }
+
+#define global_tasklet() {}
+
+/*
+ * CRITICALSECTION defines a locking mechanism for critical sections of code
+ */
+typedef struct semaphore CRITICALSECTION;
+
+/*
+ * The following are routines to control a critical section
+ */
+#define initialize_criticalsection_lock(lock) init_MUTEX(lock)
+#define destroy_criticalsection_lock(lock)    {}
+
+#define enter_read_criticalsection(lock)      down(lock)
+
+// Keep this implementation for further investigation;
+//#define enter_read_criticalsection(lock)     if(down_interruptible(lock)){ \
+//					          panic("kernel error in netmux:down_interruptible\n");}
+
+#define exit_read_criticalsection(lock)       up(lock)
+
+#define enter_write_criticalsection(lock)     down(lock)
+
+// Keep this implementation for further investigation;
+//#define enter_write_criticalsection(lock)     if(down_interruptible(lock)){ \
+//					          panic("kernel erro in netmux: down_interruptible\n");}
+
+#define exit_write_criticalsection(lock)      up(lock)
+
+typedef unsigned long INTERRUPT_STATE;
+
+#define disable_interrupts(state) local_irq_save(state)
+#define enable_interrupts(state)  local_irq_restore(state)
+
+#endif
diff --git a/drivers/misc/netmux_linkdriver/Kconfig b/drivers/misc/netmux_linkdriver/Kconfig
new file mode 100644
index 0000000..3d6e54e
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/Kconfig
@@ -0,0 +1,11 @@
+#
+# Netmux configuration
+#
+
+menu "Motorola netmux link driver"
+
+config NETMUX_LINKDRIVER
+        tristate
+        default m
+
+endmenu
diff --git a/drivers/misc/netmux_linkdriver/LICENSE b/drivers/misc/netmux_linkdriver/LICENSE
new file mode 100755
index 0000000..5004b6f
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/LICENSE
@@ -0,0 +1,28 @@
+Copyright Motorola 2006
+
+This program is licensed under a BSD license with the following terms:
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+o Redistributions of source code must retain the above copyright notice,
+  this list of conditions and the following disclaimer.
+o Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+o Neither the name of Motorola nor the names of its contributors may be
+  used to endorse or promote products derived from this software without
+  specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/drivers/misc/netmux_linkdriver/Makefile b/drivers/misc/netmux_linkdriver/Makefile
new file mode 100644
index 0000000..2a5b7f3
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the netmux drivers.
+#
+
+obj-m +=  usb/
diff --git a/drivers/misc/netmux_linkdriver/usb/Kconfig b/drivers/misc/netmux_linkdriver/usb/Kconfig
new file mode 100644
index 0000000..78d7fbb
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/Kconfig
@@ -0,0 +1,25 @@
+# Kconfig - Netmux Linkdriver configuration options
+#
+# Copyright 2008 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+
+config NETMUX_LINKDRIVER_SOFTERROR
+        boolean "Turn panics in the linkdriver to printks"
+        default n
+        help
+                All invocations of panic in the netmux linkdriver will be
+                replaced with printks.
diff --git a/drivers/misc/netmux_linkdriver/usb/Makefile b/drivers/misc/netmux_linkdriver/usb/Makefile
new file mode 100755
index 0000000..6f61e36
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/Makefile
@@ -0,0 +1,52 @@
+##############################################################################
+# IPC Link Driver Kbuild                                                     #
+#                                                                            #
+# Copyright Motorola 2006-2008                                               #
+#                                                                            #
+# Redistribution and use in source and binary forms, with or without         #
+# modification, are permitted provided that the following conditions are     #
+# met:                                                                       #
+#                                                                            #
+# o Redistributions of source code must retain the above copyright notice,   #
+#   this list of conditions and the following disclaimer.                    #
+# o Redistributions in binary form must reproduce the above copyright        #
+#   notice, this list of conditions and the following disclaimer in the      #
+#   documentation and/or other materials provided with the distribution.     #
+# o Neither the name of Motorola nor the names of its contributors may be    #
+#   used to endorse or promote products derived from this software without   #
+#   specific prior written permission.                                       #
+#                                                                            #
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    #
+# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  #
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     #
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           #
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      #
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        #
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         #
+# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     #
+# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       #
+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         #
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               #
+#                                                                            #
+##############################################################################
+#   DATE        OWNER       COMMENT                                          #
+#   ----------  ----------  -----------------------------------------------  #
+#   2006/09/28  Motorola    Initial version                                  #
+##############################################################################
+
+MODULE_NAME = netmux_linkdriver
+
+EXTRA_CFLAGS +=  -Idrivers/misc/netmux/shared 
+
+#-I$(STD_INCPATH)
+
+ifeq ($(DEBUG), true)
+	CFLAGS += -D_DEBUG_
+endif
+
+ifeq ($(LOG), true)
+	CFLAGS += -D_LOG_
+endif
+
+obj-m := $(MODULE_NAME).o
+$(MODULE_NAME)-objs := netmux_usb_linkdriver.o
diff --git a/drivers/misc/netmux_linkdriver/usb/Makefile.back b/drivers/misc/netmux_linkdriver/usb/Makefile.back
new file mode 100644
index 0000000..ec04e8a
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/Makefile.back
@@ -0,0 +1,62 @@
+###############################################################################
+# IPC Link Driver Makefile                                                    #
+#                                                                             #
+# Copyright Motorola 2007-2008                                                #
+#                                                                             #
+# Redistribution and use in source and binary forms, with or without          #
+# modification, are permitted provided that the following conditions are met: #
+#                                                                             #
+# o Redistributions of source code must retain the above copyright notice,    #
+#   this list of conditions and the following disclaimer.                     #
+# o Redistributions in binary form must reproduce the above copyright notice, #
+#   this list of conditions and the following disclaimer in the documentation #
+#   and/or other materials provided with the distribution.                    #
+# o Neither the name of Motorola nor the names of its contributors may be     #
+#   used to endorse or promote products derived from this software without    #
+#   specific prior written permission.                                        #
+#                                                                             #
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   #
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  #
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    #
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         #
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF        #
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    #
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     #
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)     #
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  #
+# POSSIBILITY OF SUCH DAMAGE.                                                 #
+#                                                                             #
+###############################################################################
+#   DATE        OWNER       COMMENT                                           #
+#   ----------  ----------  ------------------------------------------------  #
+#   2007/01/25  Motorola    Initial version                                   #
+#   2007/06/27  Motorola    Enable GCOV                                       #
+#   2008/09/30  Motorola    Add ModKconfig support
+###############################################################################
+
+# Source in the PROPFILES being generated by the top-level Makefile
+include $(PROPFILES)
+# Source in the CKbuild build system to achieve clearmake compliance
+include ${STD_DIRPATH}/ckbuild/ckbuild.mk
+include ${STD_DIRPATH}/ckbuild/modkconfig.mk
+
+CONFIG_H	      = $(shell $(MODKCONFIG) path config_header)
+
+CKBUILD_EXTRA_CONFIG  = $(shell $(MODKCONFIG) path config)
+
+CKBUILD_EXTRA_CFLAGS  = -DMODKCONFIG -I$(dir $(CONFIG_H))
+CKBUILD_EXTRA_CFLAGS += -include $(CONFIG_H)
+
+ifeq($(TEST_COVERAGE),1)
+GCOV_FLAGS      = -fprofile-arcs -ftest-coverage
+CKBUILD_EXTRA_CFLAGS += $(GCOV_FLAGS)
+endif
+
+
+KMODULES_DIR=$(BUILDTOP)
+
+CKBUILD_EXTRA_ARGS  = INSTALL_MOD_PATH=$(BUILDTOP)
+CKBUILD_EXTRA_ARGS += STD_INCPATH=$(STD_INCPATH)
+CKBUILD_EXTRA_ARGS += DEBUG=$(DEBUG)
+CKBUILD_EXTRA_ARGS += LOG=$(LOG)
diff --git a/drivers/misc/netmux_linkdriver/usb/ModKconfig b/drivers/misc/netmux_linkdriver/usb/ModKconfig
new file mode 100644
index 0000000..1dd3790
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/ModKconfig
@@ -0,0 +1,26 @@
+# ModKconfig - Netmux Linkdriver module config file
+#
+# Copyright 2008 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+
+title = netmux_linkdriver
+obj_tree = 
+depends = 
+kconfig = Kconfig
+config = .config
+autoconf_header = modkconfig/autoconf.h
+config_header = modkconfig/config.h
diff --git a/drivers/misc/netmux_linkdriver/usb/arch/arm/defconfig b/drivers/misc/netmux_linkdriver/usb/arch/arm/defconfig
new file mode 100644
index 0000000..77439cf
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/arch/arm/defconfig
@@ -0,0 +1,20 @@
+# defconfig - Netmux Linkdriver default config for arm architecture
+#
+# Copyright 2008 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+#
+
+CONFIG_NETMUX_LINKDRIVER_SOFTERROR=y
diff --git a/drivers/misc/netmux_linkdriver/usb/modkconfig/autoconf.h b/drivers/misc/netmux_linkdriver/usb/modkconfig/autoconf.h
new file mode 100644
index 0000000..954065a
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/modkconfig/autoconf.h
@@ -0,0 +1,483 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 
+ * Tue Dec 23 10:53:49 2008
+ */
+#define CONFIG_USB_MUSB_HDRC_MODULE 1
+#define CONFIG_VIDEO_V4L1_COMPAT 1
+#define CONFIG_OMAP_MCBSP 1
+#define CONFIG_FRAME_WARN 1024
+#define CONFIG_COMPAT_BRK 1
+#define CONFIG_JFFS2_CMODE_PRIORITY 1
+#define CONFIG_USER_SCHED 1
+#define CONFIG_VIDEO_V4L2_COMMON 1
+#define CONFIG_GPIOLIB 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_FLATMEM 1
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_DEVKMEM 1
+#define CONFIG_CRYPTO_ECB_MODULE 1
+#define CONFIG_SERIAL_8250_SHARE_IRQ 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_MEDIA_TUNER_XC5000 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_BROKEN_ON_SMP 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
+#define CONFIG_MOT_FEAT_MEM_TIMING_API 1
+#define CONFIG_MOT_FEAT_DEVICE_TREE 1
+#define CONFIG_FB_VIRTUAL 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define CONFIG_MOT_SPECIFIC_CODE 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_MEDIA_TUNER_XC2028 1
+#define CONFIG_FB_OMAP 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_CPU_TLB_V7 1
+#define CONFIG_SPI_SPIDEV 1
+#define CONFIG_NETDEV_10000 1
+#define CONFIG_BLK_DEV 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_MOT_FEAT_PANIC_ON_SCHED_ATOMIC 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_MOT_FEAT_NAND_RDDIST 1
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define CONFIG_JFFS2_FS_DEBUG 0
+#define CONFIG_MODULES 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_VIDEO_OMAP24XX_TVOUT 1
+#define CONFIG_I2C_CHARDEV 1
+#define CONFIG_USB_ACM 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_TOUCHSCREEN_MOT_QUANTUM 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_OMAP_32K_TIMER 1
+#define CONFIG_MOT_FEAT_SPIRAWACCESS_DEBUG 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_OMAP_32K_TIMER_HZ 128
+#define CONFIG_USB_HID 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_MOT_FEAT_UART_HW_FLOW_CONTROL 1
+#define CONFIG_ANDROID_LOGGER 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_DETECT_SOFTLOCKUP 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define CONFIG_SLAB 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define CONFIG_NET_PCI 1
+#define CONFIG_MTD_NAND_OMAP2 1
+#define CONFIG_FLATMEM_MANUAL 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_SND_ARM 1
+#define CONFIG_DEVPORT 1
+#define CONFIG_USB_IPC 1
+#define CONFIG_SUNRPC_GSS 1
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_MTD_CMDLINE_PARTS 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_SLHC 1
+#define CONFIG_EMBEDDED 1
+#define CONFIG_KMOD 1
+#define CONFIG_KEYBOARD_MOT_OMAP 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_SCHED_DEBUG 1
+#define CONFIG_MMC_UNSAFE_RESUME 1
+#define CONFIG_SND_USB 1
+#define CONFIG_OMAP_TICK_GPTIMER 1
+#define CONFIG_MOT_FEAT_BOOTINFO 1
+#define CONFIG_NET_KEY 1
+#define CONFIG_SND_SPI 1
+#define CONFIG_INET 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_LOGO 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_USB_MON 1
+#define CONFIG_SERIAL_8250_RSA 1
+#define CONFIG_MOT_FEAT_KERNEL_CAM_UPDATES 1
+#define CONFIG_ALIGNMENT_TRAP 1
+#define CONFIG_VIDEO_OMAP3 1
+#define CONFIG_VIDEO_MEDIA 1
+#define CONFIG_WATCHDOG_NOWAYOUT 1
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+#define CONFIG_MOT_FEAT_GPIO_API 1
+#define CONFIG_ANDROID_PARANOID_NETWORK 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_MOT_FEAT_BUG_MESG 1
+#define CONFIG_MOT_FEAT_PPP_EZX_COMPAT 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_HAVE_FTRACE 1
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define CONFIG_PAGEFLAGS_EXTENDED 1
+#define CONFIG_MOT_FEAT_GCC_WERR 1
+#define CONFIG_JFFS2_RTIME 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_SWAP 1
+#define CONFIG_XFRM 1
+#define CONFIG_CPU_CACHE_VIPT 1
+#define CONFIG_CRC32 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_OABI_COMPAT 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_CPU_CP15 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_CPU_PABRT_IFAR 1
+#define CONFIG_VIDEO_DW9710 1
+#define CONFIG_NETFILTER_ADVANCED 1
+#define CONFIG_UNIX 1
+#define CONFIG_VIDEO_OUTPUT_CONTROL_MODULE 1
+#define CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE 14
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_UID16 1
+#define CONFIG_I2C_OMAP 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_CLASSIC_RCU 1
+#define CONFIG_IP_FIB_HASH 1
+#define CONFIG_MEDIA_TUNER 1
+#define CONFIG_W1_SLAVE_BQ27000 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_ANDROID_BINDER_IPC 1
+#define CONFIG_LOGO_LINUX_CLUT224 1
+#define CONFIG_MTD_BLKDEVS 1
+#define CONFIG_MOT_FEAT_LTT_LITE 1
+#define CONFIG_SND_MOT_OMAP3430_CPCAP 1
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_WATCHDOG 1
+#define CONFIG_SERIAL_8250_DETECT_IRQ 1
+#define CONFIG_MTD_PARTITIONS 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_AEABI 1
+#define CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ 1
+#define CONFIG_JFFS2_FS 1
+#define CONFIG_GROUP_SCHED 1
+#define CONFIG_MOT_FEAT_NOHZ_FIX 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_LIBCRC32C 1
+#define CONFIG_MEDIA_TUNER_TDA8290 1
+#define CONFIG_CRYPTO_PCBC_MODULE 1
+#define CONFIG_MEDIA_TUNER_TEA5761 1
+#define CONFIG_CPU_32v7 1
+#define CONFIG_MTD_NAND_OMAP_OOB_ECC 1
+#define CONFIG_HAVE_CLK 1
+#define CONFIG_DEBUG_LL 1
+#define CONFIG_MEDIA_TUNER_TEA5767 1
+#define CONFIG_MEDIA_TUNER_MT20XX 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 4
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_NETMUX_LINKDRIVER_SOFTERROR 1
+#define CONFIG_SERIAL_8250_CONSOLE 1
+#define CONFIG_ANDROID_TIMED_GPIO 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_MTD_CHAR 1
+#define CONFIG_MOT_FEAT_CHIPS_I2C 1
+#define CONFIG_MMC_OMAP_HS 1
+#define CONFIG_SND_DRIVERS 1
+#define CONFIG_DEFAULT_IOSCHED "anticipatory"
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_IP_PNP_DHCP 1
+#define CONFIG_SOUND_PRIME 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_MEDIA_TUNER_TDA9887 1
+#define CONFIG_MTD_NAND 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_VIDEO_CAPTURE_DRIVERS 1
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_MOT_FEAT_MT9P012_FIXES 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_BLOCK 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_LOCKD 1
+#define CONFIG_CPU_COPY_V6 1
+#define CONFIG_ZONE_DMA 1
+#define CONFIG_ENABLE_WARN_DEPRECATED 1
+#define CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE 3
+#define CONFIG_SQUASHFS 1
+#define CONFIG_YAFFS_SHORT_NAMES_IN_RAM 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_YAFFS_FS 1
+#define CONFIG_MOT_FEAT_CPCAP_MMC 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_OMAP_EHCI_TLL_MODE 1
+#define CONFIG_ARCH_OMAP3430 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_MEDIA_TUNER_SIMPLE 1
+#define CONFIG_SERIAL_8250_MANY_PORTS 1
+#define CONFIG_IP_PNP_RARP 1
+#define CONFIG_SHMEM 1
+#define CONFIG_MOT_FEAT_GPIODEV_DEVICE_TREE 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_EPOLL 1
+#define CONFIG_FB_SYS_FOPS 1
+#define CONFIG_VIDEO_OMAP34XX_ISP_PREVIEWER 1
+#define CONFIG_MOT_FEAT_MM_SKARDA 1
+#define CONFIG_MSDOS_FS 1
+#define CONFIG_FONT_8x8 1
+#define CONFIG_VIDEOBUF_DMA_SG 1
+#define CONFIG_RPCSEC_GSS_KRB5 1
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define CONFIG_MOT_FEAT_SPI_CPCAP 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_YAFFS_YAFFS1 1
+#define CONFIG_UEVENT_HELPER_PATH ""
+#define CONFIG_YAFFS_YAFFS2 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_MOT_FEAT_KPANIC 1
+#define CONFIG_ZLIB_DEFLATE 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL 1
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_SND_VERBOSE_PROCFS 1
+#define CONFIG_CPU_CACHE_V7 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define CONFIG_ANDROID_POWER_STAT 1
+#define CONFIG_FB 1
+#define CONFIG_W1 1
+#define CONFIG_USB_TEST 1
+#define CONFIG_SOUND 1
+#define CONFIG_ROOT_NFS 1
+#define CONFIG_TMPFS 1
+#define CONFIG_FONTS 1
+#define CONFIG_GENERIC_TIME 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_PLIST 1
+#define CONFIG_FUTEX 1
+#define CONFIG_VIDEOBUF_GEN 1
+#define CONFIG_SPI_OMAP24XX 1
+#define CONFIG_MISC_DEVICES 1
+#define CONFIG_CPU_CP15_MMU 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_INPUT 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_MOT_FEAT_POWERUP_LOGO 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_DISABLE_BRIDGE_DVFS 1
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_VIDEO_MT9P012 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_HDQ_MASTER_OMAP 1
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_MTD_NAND_BBM 1
+#define CONFIG_VFPv3 1
+#define CONFIG_JFFS2_COMPRESSION_OPTIONS 1
+#define CONFIG_FRAMEBUFFER_CONSOLE 1
+#define CONFIG_ARCH_FLATMEM_HAS_HOLES 1
+#define CONFIG_SYSFS 1
+#define CONFIG_FB_SYS_COPYAREA 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_MOT_FEAT_SPIDEV 1
+#define CONFIG_MOT_FEAT_CHKSUM 1
+#define CONFIG_FB_SYS_FILLRECT 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_USB_BELCARRA_MUSB_HDRC 1
+#define CONFIG_HIGH_RES_TIMERS 1
+#define CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define CONFIG_MOT_FEAT_ALLOW_MEM_ACCESS 1
+#define CONFIG_PM 1
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_SERIAL_8250_EXTENDED 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_NO_HZ 1
+#define CONFIG_MOT_FEAT_YAFFS_PARSE_MOUNT_OPTIONS 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define CONFIG_CPU_ABRT_EV7 1
+#define CONFIG_TOUCHSCREEN_MOT_TSC2005 1
+#define CONFIG_HZ 128
+#define CONFIG_MOT_FEAT_KERNEL_NAND_INIT 1
+#define CONFIG_CPU_32v6K 1
+#define CONFIG_CPU_HAS_ASID 1
+#define CONFIG_MTD_NAND_IDS 1
+#define CONFIG_INET_DIAG 1
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_ARCH_SUPPORTS_AOUT 1
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_MMC_BLOCK 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_VT 1
+#define CONFIG_ARCH_OMAP 1
+#define CONFIG_TICK_ONESHOT 1
+#define CONFIG_MOT_FEAT_MTD_FS 1
+#define CONFIG_CPU_32 1
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_MOT_CSR_OMAPS00190282 1
+#define CONFIG_FONT_8x16 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_CRC_CCITT 1
+#define CONFIG_MOT_CSR_OMAPS00188133 1
+#define CONFIG_MTD_BLOCK 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_SYSFS_DEPRECATED_V2 1
+#define CONFIG_CS89x0 1
+#define CONFIG_USB_DEBUG 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_MOT_CSR_OMAPS00191862 1
+#define CONFIG_SPI_DEBUG 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_MOT_CSR_OMAPS00188038 1
+#define CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 0
+#define CONFIG_VIDEO_DEV 1
+#define CONFIG_MOT_FEAT_KERNEL_OFFSET 1
+#define CONFIG_MOT_FEAT_CS8900A_ETH 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_LOGO_LINUX_MONO 1
+#define CONFIG_PACKET 1
+#define CONFIG_OMAP_LL_DEBUG_UART3 1
+#define CONFIG_ANDROID_POWER_ALARM 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_MTD_NAND_OMAP_HWECC 1
+#define CONFIG_FPE_NWFPE 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_ASHMEM 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_MOT_FEAT_PMIC_CPCAP 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_DEVMEM 1
+#define CONFIG_I2C 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_ARM_THUMB 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_MTD_NAND_BBM_DBG 1
+#define CONFIG_ARCH_OMAP34XX 1
+#define CONFIG_MMC_BLOCK_BOUNCE 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_USB_IPC_TEST 1
+#define CONFIG_USB_MUSB_SOC 1
+#define CONFIG_LOGO_LINUX_VGA16 1
+#define CONFIG_VIDEO_OMAP24XX_VIDEOLIB 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_SYSFS_DEPRECATED 1
+#define CONFIG_MOT_FEAT_CDC_ACM 1
+#define CONFIG_IP_PNP_BOOTP 1
+#define CONFIG_USB_MUSB_PERIPHERAL 1
+#define CONFIG_MOT_CSR00181055 1
+#define CONFIG_MOT_FEAT_CKBUILD 1
+#define CONFIG_PPP_ASYNC 1
+#define CONFIG_MOT_CSR00179330 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_INET_XFRM_MODE_BEET 1
+#define CONFIG_NFS_V4 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_MOT_FEAT_UART_DEBUG 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_SWITCH 1
+#define CONFIG_FIRMWARE_EDID 1
+#define CONFIG_MOT_WFN440 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_FB_SYS_IMAGEBLIT 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_CPU_V7 1
+#define CONFIG_FAIR_GROUP_SCHED 1
+#define CONFIG_MOT_WFN424 1
+#define CONFIG_HID 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_PRINTK 1
+#define CONFIG_MOT_WFN419 1
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_MOT_FEAT_SECURE_MTD 1
+#define CONFIG_SUNRPC 1
+#define CONFIG_SERIAL_8250_NR_UARTS 32
+#define CONFIG_MOT_FEAT_GPIODEV 1
+#define CONFIG_OMAP_WATCHDOG 1
+#define CONFIG_MMC 1
+#define CONFIG_ARCH_OMAP3 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_ISA 1
+#define CONFIG_VIDEO_V4L2 1
+#define CONFIG_BUG 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_NFS_FS 1
+#define CONFIG_MII 1
+#define CONFIG_ARM 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_USB_INVENTRA_DMA 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_SND 1
+#define CONFIG_MTD 1
+#define CONFIG_NETDEV_1000 1
+#define CONFIG_IP_PNP 1
+#define CONFIG_ZONE_DMA_FLAG 1
+#define CONFIG_VIDEO_OMAP24XX_VIDEOOUT 1
+#define CONFIG_OMAP_BOOT_REASON 1
+#define CONFIG_NET 1
+#define CONFIG_VIDEO_OMAP34XX_ISP_RESIZER 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_MACH_OMAP3430PHONE 1
+#define CONFIG_KALLSYMS_EXTRA_PASS 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_USB 1
+#define CONFIG_INET_TCP_DIAG 1
+#define CONFIG_MOT_FEAT_SET_MAC 1
+#define CONFIG_JFFS2_ZLIB 1
+#define CONFIG_FRAME_POINTER 1
+#define CONFIG_SPI 1
+#define CONFIG_VFP 1
+#define CONFIG_NLS 1
+#define CONFIG_ANDROID_POWER 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_MTD_CFI_I1 1
+#define CONFIG_MMU 1
+#define CONFIG_BLK_DEV_RAM_SIZE 16384
+#define CONFIG_MTD_CFI_I2 1
+#define CONFIG_PPP 1
+#define CONFIG_DEBUG_MUTEXES 1
+#define CONFIG_PANIC_TIMEOUT 0
+#define CONFIG_DEBUG_INFO 1
+#define CONFIG_IOSCHED_AS 1
+#define CONFIG_ARCH_OMAP_OTG 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_SQUASHFS_EMBEDDED 1
+#define CONFIG_JFFS2_FS_WRITEBUFFER 1
+#define CONFIG_MOT_FEAT_YAFFS_SHREDDER 1
+#define CONFIG_SND_SUPPORT_OLD_API 1
+#define CONFIG_DEFAULT_AS 1
+#define CONFIG_BITREVERSE 1
+#define CONFIG_OMAP_BOOT_TAG 1
+#define CONFIG_LOG_BUF_SHIFT 14
+#define CONFIG_DISABLE_BRIDGE_PM 1
+#define CONFIG_MTD_CONCAT 1
+#define CONFIG_CMDLINE "console=ttyS2,115200n8 rw mem=128M@0x80000000 init=/linuxrc root=/dev/mtdblock/root rootfstype=squashfs mtdparts=nand0:1152k@896k(pds),128k@2176k(logo_cli),128k(panel_script)ro,128k(device_tree)ro,128k(setup),256k(logo),128k(secure),2m(kern),384k(initramfs),256k@9472k(ho_data),256k(fota_ua),384k(ua_temp),256k(ua_backup),49m(root),9m(user),9728k(lang),18m(resrc),6m(fota_up),151936k(mass_storage),128k(kpanic),5760k(rsv)"
+#define CONFIG_OMAP_DM_TIMER 1
+#define CONFIG_MPU_BRIDGE 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_ARCH_REQUIRE_GPIOLIB 1
diff --git a/drivers/misc/netmux_linkdriver/usb/modkconfig/config.h b/drivers/misc/netmux_linkdriver/usb/modkconfig/config.h
new file mode 100644
index 0000000..954065a
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/modkconfig/config.h
@@ -0,0 +1,483 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 
+ * Tue Dec 23 10:53:49 2008
+ */
+#define CONFIG_USB_MUSB_HDRC_MODULE 1
+#define CONFIG_VIDEO_V4L1_COMPAT 1
+#define CONFIG_OMAP_MCBSP 1
+#define CONFIG_FRAME_WARN 1024
+#define CONFIG_COMPAT_BRK 1
+#define CONFIG_JFFS2_CMODE_PRIORITY 1
+#define CONFIG_USER_SCHED 1
+#define CONFIG_VIDEO_V4L2_COMMON 1
+#define CONFIG_GPIOLIB 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_FLATMEM 1
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_DEVKMEM 1
+#define CONFIG_CRYPTO_ECB_MODULE 1
+#define CONFIG_SERIAL_8250_SHARE_IRQ 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_MEDIA_TUNER_XC5000 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_BROKEN_ON_SMP 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
+#define CONFIG_MOT_FEAT_MEM_TIMING_API 1
+#define CONFIG_MOT_FEAT_DEVICE_TREE 1
+#define CONFIG_FB_VIRTUAL 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define CONFIG_MOT_SPECIFIC_CODE 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_MEDIA_TUNER_XC2028 1
+#define CONFIG_FB_OMAP 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_CPU_TLB_V7 1
+#define CONFIG_SPI_SPIDEV 1
+#define CONFIG_NETDEV_10000 1
+#define CONFIG_BLK_DEV 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_MOT_FEAT_PANIC_ON_SCHED_ATOMIC 1
+#define CONFIG_HAS_IOPORT 1
+#define CONFIG_MOT_FEAT_NAND_RDDIST 1
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define CONFIG_JFFS2_FS_DEBUG 0
+#define CONFIG_MODULES 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_VIDEO_OMAP24XX_TVOUT 1
+#define CONFIG_I2C_CHARDEV 1
+#define CONFIG_USB_ACM 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_TOUCHSCREEN_MOT_QUANTUM 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_OMAP_32K_TIMER 1
+#define CONFIG_MOT_FEAT_SPIRAWACCESS_DEBUG 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_OMAP_32K_TIMER_HZ 128
+#define CONFIG_USB_HID 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_MOT_FEAT_UART_HW_FLOW_CONTROL 1
+#define CONFIG_ANDROID_LOGGER 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_DETECT_SOFTLOCKUP 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define CONFIG_SLAB 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define CONFIG_NET_PCI 1
+#define CONFIG_MTD_NAND_OMAP2 1
+#define CONFIG_FLATMEM_MANUAL 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_SND_ARM 1
+#define CONFIG_DEVPORT 1
+#define CONFIG_USB_IPC 1
+#define CONFIG_SUNRPC_GSS 1
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_MTD_CMDLINE_PARTS 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_SLHC 1
+#define CONFIG_EMBEDDED 1
+#define CONFIG_KMOD 1
+#define CONFIG_KEYBOARD_MOT_OMAP 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_SCHED_DEBUG 1
+#define CONFIG_MMC_UNSAFE_RESUME 1
+#define CONFIG_SND_USB 1
+#define CONFIG_OMAP_TICK_GPTIMER 1
+#define CONFIG_MOT_FEAT_BOOTINFO 1
+#define CONFIG_NET_KEY 1
+#define CONFIG_SND_SPI 1
+#define CONFIG_INET 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_LOGO 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_USB_MON 1
+#define CONFIG_SERIAL_8250_RSA 1
+#define CONFIG_MOT_FEAT_KERNEL_CAM_UPDATES 1
+#define CONFIG_ALIGNMENT_TRAP 1
+#define CONFIG_VIDEO_OMAP3 1
+#define CONFIG_VIDEO_MEDIA 1
+#define CONFIG_WATCHDOG_NOWAYOUT 1
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+#define CONFIG_MOT_FEAT_GPIO_API 1
+#define CONFIG_ANDROID_PARANOID_NETWORK 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_MOT_FEAT_BUG_MESG 1
+#define CONFIG_MOT_FEAT_PPP_EZX_COMPAT 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_HAVE_FTRACE 1
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define CONFIG_PAGEFLAGS_EXTENDED 1
+#define CONFIG_MOT_FEAT_GCC_WERR 1
+#define CONFIG_JFFS2_RTIME 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_SWAP 1
+#define CONFIG_XFRM 1
+#define CONFIG_CPU_CACHE_VIPT 1
+#define CONFIG_CRC32 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_OABI_COMPAT 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_CPU_CP15 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_CPU_PABRT_IFAR 1
+#define CONFIG_VIDEO_DW9710 1
+#define CONFIG_NETFILTER_ADVANCED 1
+#define CONFIG_UNIX 1
+#define CONFIG_VIDEO_OUTPUT_CONTROL_MODULE 1
+#define CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE 14
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_UID16 1
+#define CONFIG_I2C_OMAP 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_CLASSIC_RCU 1
+#define CONFIG_IP_FIB_HASH 1
+#define CONFIG_MEDIA_TUNER 1
+#define CONFIG_W1_SLAVE_BQ27000 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_SLABINFO 1
+#define CONFIG_ANDROID_BINDER_IPC 1
+#define CONFIG_LOGO_LINUX_CLUT224 1
+#define CONFIG_MTD_BLKDEVS 1
+#define CONFIG_MOT_FEAT_LTT_LITE 1
+#define CONFIG_SND_MOT_OMAP3430_CPCAP 1
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_WATCHDOG 1
+#define CONFIG_SERIAL_8250_DETECT_IRQ 1
+#define CONFIG_MTD_PARTITIONS 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_AEABI 1
+#define CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ 1
+#define CONFIG_JFFS2_FS 1
+#define CONFIG_GROUP_SCHED 1
+#define CONFIG_MOT_FEAT_NOHZ_FIX 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_LIBCRC32C 1
+#define CONFIG_MEDIA_TUNER_TDA8290 1
+#define CONFIG_CRYPTO_PCBC_MODULE 1
+#define CONFIG_MEDIA_TUNER_TEA5761 1
+#define CONFIG_CPU_32v7 1
+#define CONFIG_MTD_NAND_OMAP_OOB_ECC 1
+#define CONFIG_HAVE_CLK 1
+#define CONFIG_DEBUG_LL 1
+#define CONFIG_MEDIA_TUNER_TEA5767 1
+#define CONFIG_MEDIA_TUNER_MT20XX 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 4
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_NETMUX_LINKDRIVER_SOFTERROR 1
+#define CONFIG_SERIAL_8250_CONSOLE 1
+#define CONFIG_ANDROID_TIMED_GPIO 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_MTD_CHAR 1
+#define CONFIG_MOT_FEAT_CHIPS_I2C 1
+#define CONFIG_MMC_OMAP_HS 1
+#define CONFIG_SND_DRIVERS 1
+#define CONFIG_DEFAULT_IOSCHED "anticipatory"
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_IP_PNP_DHCP 1
+#define CONFIG_SOUND_PRIME 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_MEDIA_TUNER_TDA9887 1
+#define CONFIG_MTD_NAND 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_VIDEO_CAPTURE_DRIVERS 1
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_MOT_FEAT_MT9P012_FIXES 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_BLOCK 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_LOCKD 1
+#define CONFIG_CPU_COPY_V6 1
+#define CONFIG_ZONE_DMA 1
+#define CONFIG_ENABLE_WARN_DEPRECATED 1
+#define CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE 3
+#define CONFIG_SQUASHFS 1
+#define CONFIG_YAFFS_SHORT_NAMES_IN_RAM 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_YAFFS_FS 1
+#define CONFIG_MOT_FEAT_CPCAP_MMC 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_OMAP_EHCI_TLL_MODE 1
+#define CONFIG_ARCH_OMAP3430 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_MEDIA_TUNER_SIMPLE 1
+#define CONFIG_SERIAL_8250_MANY_PORTS 1
+#define CONFIG_IP_PNP_RARP 1
+#define CONFIG_SHMEM 1
+#define CONFIG_MOT_FEAT_GPIODEV_DEVICE_TREE 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_EPOLL 1
+#define CONFIG_FB_SYS_FOPS 1
+#define CONFIG_VIDEO_OMAP34XX_ISP_PREVIEWER 1
+#define CONFIG_MOT_FEAT_MM_SKARDA 1
+#define CONFIG_MSDOS_FS 1
+#define CONFIG_FONT_8x8 1
+#define CONFIG_VIDEOBUF_DMA_SG 1
+#define CONFIG_RPCSEC_GSS_KRB5 1
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define CONFIG_MOT_FEAT_SPI_CPCAP 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_YAFFS_YAFFS1 1
+#define CONFIG_UEVENT_HELPER_PATH ""
+#define CONFIG_YAFFS_YAFFS2 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_MOT_FEAT_KPANIC 1
+#define CONFIG_ZLIB_DEFLATE 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL 1
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_SND_VERBOSE_PROCFS 1
+#define CONFIG_CPU_CACHE_V7 1
+#define CONFIG_DEBUG_KERNEL 1
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define CONFIG_ANDROID_POWER_STAT 1
+#define CONFIG_FB 1
+#define CONFIG_W1 1
+#define CONFIG_USB_TEST 1
+#define CONFIG_SOUND 1
+#define CONFIG_ROOT_NFS 1
+#define CONFIG_TMPFS 1
+#define CONFIG_FONTS 1
+#define CONFIG_GENERIC_TIME 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_PLIST 1
+#define CONFIG_FUTEX 1
+#define CONFIG_VIDEOBUF_GEN 1
+#define CONFIG_SPI_OMAP24XX 1
+#define CONFIG_MISC_DEVICES 1
+#define CONFIG_CPU_CP15_MMU 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_INPUT 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_MOT_FEAT_POWERUP_LOGO 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_DISABLE_BRIDGE_DVFS 1
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_VIDEO_MT9P012 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_HDQ_MASTER_OMAP 1
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_MTD_NAND_BBM 1
+#define CONFIG_VFPv3 1
+#define CONFIG_JFFS2_COMPRESSION_OPTIONS 1
+#define CONFIG_FRAMEBUFFER_CONSOLE 1
+#define CONFIG_ARCH_FLATMEM_HAS_HOLES 1
+#define CONFIG_SYSFS 1
+#define CONFIG_FB_SYS_COPYAREA 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_MOT_FEAT_SPIDEV 1
+#define CONFIG_MOT_FEAT_CHKSUM 1
+#define CONFIG_FB_SYS_FILLRECT 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_USB_BELCARRA_MUSB_HDRC 1
+#define CONFIG_HIGH_RES_TIMERS 1
+#define CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define CONFIG_MOT_FEAT_ALLOW_MEM_ACCESS 1
+#define CONFIG_PM 1
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_SERIAL_8250_EXTENDED 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_NO_HZ 1
+#define CONFIG_MOT_FEAT_YAFFS_PARSE_MOUNT_OPTIONS 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define CONFIG_CPU_ABRT_EV7 1
+#define CONFIG_TOUCHSCREEN_MOT_TSC2005 1
+#define CONFIG_HZ 128
+#define CONFIG_MOT_FEAT_KERNEL_NAND_INIT 1
+#define CONFIG_CPU_32v6K 1
+#define CONFIG_CPU_HAS_ASID 1
+#define CONFIG_MTD_NAND_IDS 1
+#define CONFIG_INET_DIAG 1
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_ARCH_SUPPORTS_AOUT 1
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_MMC_BLOCK 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_VT 1
+#define CONFIG_ARCH_OMAP 1
+#define CONFIG_TICK_ONESHOT 1
+#define CONFIG_MOT_FEAT_MTD_FS 1
+#define CONFIG_CPU_32 1
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_MOT_CSR_OMAPS00190282 1
+#define CONFIG_FONT_8x16 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_CRC_CCITT 1
+#define CONFIG_MOT_CSR_OMAPS00188133 1
+#define CONFIG_MTD_BLOCK 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_SYSFS_DEPRECATED_V2 1
+#define CONFIG_CS89x0 1
+#define CONFIG_USB_DEBUG 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_MOT_CSR_OMAPS00191862 1
+#define CONFIG_SPI_DEBUG 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_MOT_CSR_OMAPS00188038 1
+#define CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE 0
+#define CONFIG_VIDEO_DEV 1
+#define CONFIG_MOT_FEAT_KERNEL_OFFSET 1
+#define CONFIG_MOT_FEAT_CS8900A_ETH 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_LOGO_LINUX_MONO 1
+#define CONFIG_PACKET 1
+#define CONFIG_OMAP_LL_DEBUG_UART3 1
+#define CONFIG_ANDROID_POWER_ALARM 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_MTD_NAND_OMAP_HWECC 1
+#define CONFIG_FPE_NWFPE 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_ASHMEM 1
+#define CONFIG_BOUNCE 1
+#define CONFIG_MOT_FEAT_PMIC_CPCAP 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_DEVMEM 1
+#define CONFIG_I2C 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_ARM_THUMB 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_MTD_NAND_BBM_DBG 1
+#define CONFIG_ARCH_OMAP34XX 1
+#define CONFIG_MMC_BLOCK_BOUNCE 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_USB_IPC_TEST 1
+#define CONFIG_USB_MUSB_SOC 1
+#define CONFIG_LOGO_LINUX_VGA16 1
+#define CONFIG_VIDEO_OMAP24XX_VIDEOLIB 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_SYSFS_DEPRECATED 1
+#define CONFIG_MOT_FEAT_CDC_ACM 1
+#define CONFIG_IP_PNP_BOOTP 1
+#define CONFIG_USB_MUSB_PERIPHERAL 1
+#define CONFIG_MOT_CSR00181055 1
+#define CONFIG_MOT_FEAT_CKBUILD 1
+#define CONFIG_PPP_ASYNC 1
+#define CONFIG_MOT_CSR00179330 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_INET_XFRM_MODE_BEET 1
+#define CONFIG_NFS_V4 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_MOT_FEAT_UART_DEBUG 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_SWITCH 1
+#define CONFIG_FIRMWARE_EDID 1
+#define CONFIG_MOT_WFN440 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_FB_SYS_IMAGEBLIT 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_CPU_V7 1
+#define CONFIG_FAIR_GROUP_SCHED 1
+#define CONFIG_MOT_WFN424 1
+#define CONFIG_HID 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_PRINTK 1
+#define CONFIG_MOT_WFN419 1
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_MOT_FEAT_SECURE_MTD 1
+#define CONFIG_SUNRPC 1
+#define CONFIG_SERIAL_8250_NR_UARTS 32
+#define CONFIG_MOT_FEAT_GPIODEV 1
+#define CONFIG_OMAP_WATCHDOG 1
+#define CONFIG_MMC 1
+#define CONFIG_ARCH_OMAP3 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_ISA 1
+#define CONFIG_VIDEO_V4L2 1
+#define CONFIG_BUG 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_NFS_FS 1
+#define CONFIG_MII 1
+#define CONFIG_ARM 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_USB_INVENTRA_DMA 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_SND 1
+#define CONFIG_MTD 1
+#define CONFIG_NETDEV_1000 1
+#define CONFIG_IP_PNP 1
+#define CONFIG_ZONE_DMA_FLAG 1
+#define CONFIG_VIDEO_OMAP24XX_VIDEOOUT 1
+#define CONFIG_OMAP_BOOT_REASON 1
+#define CONFIG_NET 1
+#define CONFIG_VIDEO_OMAP34XX_ISP_RESIZER 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_MACH_OMAP3430PHONE 1
+#define CONFIG_KALLSYMS_EXTRA_PASS 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_USB 1
+#define CONFIG_INET_TCP_DIAG 1
+#define CONFIG_MOT_FEAT_SET_MAC 1
+#define CONFIG_JFFS2_ZLIB 1
+#define CONFIG_FRAME_POINTER 1
+#define CONFIG_SPI 1
+#define CONFIG_VFP 1
+#define CONFIG_NLS 1
+#define CONFIG_ANDROID_POWER 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_MTD_CFI_I1 1
+#define CONFIG_MMU 1
+#define CONFIG_BLK_DEV_RAM_SIZE 16384
+#define CONFIG_MTD_CFI_I2 1
+#define CONFIG_PPP 1
+#define CONFIG_DEBUG_MUTEXES 1
+#define CONFIG_PANIC_TIMEOUT 0
+#define CONFIG_DEBUG_INFO 1
+#define CONFIG_IOSCHED_AS 1
+#define CONFIG_ARCH_OMAP_OTG 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_SQUASHFS_EMBEDDED 1
+#define CONFIG_JFFS2_FS_WRITEBUFFER 1
+#define CONFIG_MOT_FEAT_YAFFS_SHREDDER 1
+#define CONFIG_SND_SUPPORT_OLD_API 1
+#define CONFIG_DEFAULT_AS 1
+#define CONFIG_BITREVERSE 1
+#define CONFIG_OMAP_BOOT_TAG 1
+#define CONFIG_LOG_BUF_SHIFT 14
+#define CONFIG_DISABLE_BRIDGE_PM 1
+#define CONFIG_MTD_CONCAT 1
+#define CONFIG_CMDLINE "console=ttyS2,115200n8 rw mem=128M@0x80000000 init=/linuxrc root=/dev/mtdblock/root rootfstype=squashfs mtdparts=nand0:1152k@896k(pds),128k@2176k(logo_cli),128k(panel_script)ro,128k(device_tree)ro,128k(setup),256k(logo),128k(secure),2m(kern),384k(initramfs),256k@9472k(ho_data),256k(fota_ua),384k(ua_temp),256k(ua_backup),49m(root),9m(user),9728k(lang),18m(resrc),6m(fota_up),151936k(mass_storage),128k(kpanic),5760k(rsv)"
+#define CONFIG_OMAP_DM_TIMER 1
+#define CONFIG_MPU_BRIDGE 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_ARCH_REQUIRE_GPIOLIB 1
diff --git a/drivers/misc/netmux_linkdriver/usb/netmux_linkdriver.sh b/drivers/misc/netmux_linkdriver/usb/netmux_linkdriver.sh
new file mode 100755
index 0000000..27516ba
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/netmux_linkdriver.sh
@@ -0,0 +1,2 @@
+/system/bin/toolbox insmod /system/lib/modules/netmux.ko
+/system/bin/toolbox insmod /system/lib/modules/netmux_linkdriver.ko
diff --git a/drivers/misc/netmux_linkdriver/usb/netmux_usb_linkdriver.c b/drivers/misc/netmux_linkdriver/usb/netmux_usb_linkdriver.c
new file mode 100644
index 0000000..eaa1434
--- /dev/null
+++ b/drivers/misc/netmux_linkdriver/usb/netmux_usb_linkdriver.c
@@ -0,0 +1,899 @@
+/******************************************************************************
+ * IPC Link Driver netmux_usb_linkdriver.c                                   *
+ *                                                                            *
+ * Copyright (C) Motorola 2006-2008                                           *
+ *                                                                            *
+ * Redistribution and use in source and binary forms, with or without         *
+ * modification, are permitted provided that the following conditions are     *
+ * met:                                                                       *
+ *                                                                            *
+ * o Redistributions of source code must retain the above copyright notice,   *
+ *   this list of conditions and the following disclaimer.                    *
+ * o Redistributions in binary form must reproduce the above copyright        *
+ *   notice, this list of conditions and the following disclaimer in the      *
+ *   documentation and/or other materials provided with the distribution.     *
+ * o Neither the name of Motorola nor the names of its contributors may be    *
+ *   used to endorse or promote products derived from this software without   *
+ *   specific prior written permission.                                       *
+ *                                                                            *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS    *
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     *
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR           *
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,      *
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,        *
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR         *
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF     *
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING       *
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS         *
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.               *
+ *                                                                            *
+ ******************************************************************************/
+/*   DATE        OWNER       COMMENT                                          *
+ *   ----------  ----------  -----------------------------------------------  *
+ *   2006/09/28  Motorola    Initial version                                  *
+ *   2006/10/19  Motorola    Fixed scheduling while atomic issues             *
+ *   2006/12/26  Motorola    Check bd status when mxc_dma_get_config() returns*
+ *   2007/01/05  Motorola    Fixed race conditions that existed between USB  *
+ *                           and MU tasklets                                  *
+ *   2007/01/24  Motorola    Change Linkdriver to utilize IPC V2              *
+ *   2007/04/04  Motorola    Handle error when MU write fails.                *
+ *                           Add proc interface for debugging.                *
+ *   2007/04/11  Motorola    Increased LOC_MAX_RCV_SIZ and REM_MAX_RCV_SIZ to *
+ *                           1552                                             *
+ *   2007/07/17  Motorola    Treat SUSPEND_ACK like SUSPEND_REQ               *
+ *   2007/12/05  Motorola    Change code as kernel upgrade, sdma ipc not used *
+ *                           in OMAP, usb ipc used instead                    *
+ *   2008/04/10  Motorola    split large package before transmit to ipc       *
+ *   2008/06/04  Motorola    add macro to choose phaseI or phaseII            *
+ *   2008/07/09  Motorola    upmerge to kernel 2.6.24 to support TI 23.5      *
+ *                           make phaseI and phaseII same behavior            *
+ *   2008/09/30  Motorola    Turn panics into printks                         *
+ *   2008/10/30  Motorola    Add dynamic log for linkdriver                   *
+ *   2008/12/25  Motorola    change init_module, call IPC register func       *
+ *   2009/05/20  Motorola    Add mini trace functionality                     *
+ *   2009/07/23  Motorola    Add wake lock functionality                      *
+ *   2009/08/06  Motorola    Change permissions for /proc/linkdriver to 660   *
+ *   2009/08/07  Motorola    Fix minitrace functionality                      *
+ *   2009/09/16  Motorola    Comment out cleanup_module() since linkdriver    *
+ *                           should not be removed and causes rmmod to panic  *
+ ******************************************************************************/
+ 
+/* netmux_usb_linkdriver.c is responsible for communicating with the NetMUX  *
+ * above and with the physical link driver below.  A usb data channel is     *
+ * used to send and receive NetMUX data over the IPC link.                   */
+                                                
+/* Note that this driver employs the defined asynchronous read and write      *
+ * mechanism of the IPC driver, which buffers this driver from the usb driver,*
+ * below.  Since it is not guaranteed that reads and/or writes will not occur *
+ * immediately upon being set up, this driver can not count on the fact that  *
+ * the operations are completed until the callbacks are invoked.              */
+
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/fcntl.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/netdevice.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/ipc_api.h> 
+#include <linux/wakelock.h>
+
+#include <asm/io.h>
+
+#include <ldprotocol.h>
+
+/*
+ * Define our module
+ */
+MODULE_DESCRIPTION("NetMUX Link driver for Linux");
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+/*
+ * If debugging or logging is turned on setup the appropriate
+ * macros.
+ */
+#if defined(CONFIG_NETMUX_LINKDRIVER_SOFTERROR)
+    #define NETMUX_FAIL(args...)    printk(args)
+#else
+    #define NETMUX_FAIL(args...)    printk(args)
+#endif
+
+#define DEBUG(args...) LDOutput("IPC Link Driver: " args) 
+#define LOG(args...)   LOGOutput(args)
+
+#define DEFAULT_PROC_DATA_SIZE 4096
+
+/* Linkdriver info accessible via the proc interface */
+#define LDLOG_COMMAND_ALL_WORK   49 /* ASCII 1 */
+#define LDLOG_COMMAND_BUFFER     50 /* ASCII 2 */
+#define LDLOG_COMMAND_FUNCTION   51 /* ASCII 3 */
+#define LDLOG_COMMAND_MINI_TRACE 52 /* ASCII 4 */
+
+#define LDLOG_COMMAND_LEN 2
+
+static char* ld_info;
+static char LDLogState[LDLOG_COMMAND_LEN];
+
+/*
+ * Define the receive buffer sizes.  Note that the remote receive buffer size
+ * will be reset by the remote IPC Link Driver so don't depend on this
+ * definition.
+ */
+
+#define LOC_MAX_RCV_SIZ  MAX_FRAME_SIZE/*1552*/
+#define REM_MAX_RCV_SIZ  MAX_FRAME_SIZE/*1552*/
+#define USB_CHANNEL  0
+
+#define IOI_OFF 0
+#define IOI_ON  1
+
+#define END_BIT  NODE_DESCRIPTOR_END_BIT/*0x4000*/
+#define LAST_BIT NODE_DESCRIPTOR_LAST_BIT/*0x8000*/
+#define DONE_BIT NODE_DESCRIPTOR_DONE_BIT/*0x2000*/
+
+/* To keep things simple, let's have just one lock that we can use to protect
+ * the critical areas of the IPC Link Driver.  The two classes of code that need
+ * protection are operations involving the nm_ld_pm_state and operations
+ * involving synchronization between the ipc_transmitting flag and the
+ * mux_deferred flag.
+ */
+spinlock_t ild_lock = SPIN_LOCK_UNLOCKED;
+
+/*
+ * Define all the globals required.
+ */
+/* Define a place to hold the remote receive buffer size */
+static unsigned int remMaxRcvSiz = REM_MAX_RCV_SIZ;
+
+static int processed_queue_length=0;
+
+static struct INTERFACELINK iflink;
+static struct INTERFACEMUX  ifmux;
+
+static struct tasklet_struct write_callback;
+static struct tasklet_struct read_callback;
+
+static struct sk_buff_head send_queue;
+#define SEND_QUEUE_MAX_SIZE     10
+#define SEND_QUEUE_LOW_MARK	((SEND_QUEUE_MAX_SIZE / 2) + 1)
+#define SEND_QUEUE_LEN		(skb_queue_len(&send_queue))
+#define SEND_QUEUE_ISEMPTY	(skb_queue_empty(&send_queue))
+// the reference count for the commbuff is incremented before
+// it is added to the send_queue
+#define SEND_QUEUE_ADD(buf)	skb_get(buf); \
+                                skb_queue_tail(&send_queue, buf)
+// after removing the commbuff from the send_queue, its reference
+// count will be decremented
+#define SEND_QUEUE_REMOVE	(kfree_skb(skb_dequeue(&send_queue)))
+#define SEND_QUEUE_GET_HEAD	(skb_peek(&send_queue))
+#define SEND_QUEUE_PROCESSED    (processed_queue_length)
+#define INCR_SEND_QUEUE_PROCESSED    (processed_queue_length++)
+
+// Get next send_queue element 
+#define SEND_QUEUE_NEXT(buf)     ((buf)->next)
+
+#define RECEIVE_LIST_MAX_SIZE MAX_FRAME_NUM // This should depend on the BP transmitting side
+
+typedef struct LD_MINI_TRACE {
+    unsigned long function_index;
+    unsigned long param;
+    unsigned long mux_deferred;
+    unsigned long time_stamp;
+}LD_MINI_TRACE;
+
+#define LD_MINI_TRACE_LENGTH 100
+static int LD_MINI_TRACE_INDEX  = 0;
+static LD_MINI_TRACE LD_MINI_TRACE_TABLE[LD_MINI_TRACE_LENGTH];
+
+static struct sk_buff* receive_commbuff[RECEIVE_LIST_MAX_SIZE];
+static HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T ipc_readbuff[RECEIVE_LIST_MAX_SIZE];
+static unsigned long   mux_deferred;
+
+static HW_CTRL_IPC_OPEN_T ipc_channel_desc;
+static HW_CTRL_IPC_CHANNEL_T *ipc_channel_handle;
+
+static struct proc_dir_entry *proc_linkdriver_entry = NULL;
+
+static void          MUXTransmitComplete  (unsigned long nb_bytes);
+static void          MUXReceiveComplete   (unsigned long arg);
+static void          USBReadCallback     (HW_CTRL_IPC_READ_STATUS_T *read_status);
+static void          USBWriteCallback    (HW_CTRL_IPC_WRITE_STATUS_T *write_status);
+static void          USBTransmit         (void);
+static unsigned long USBQueue            (void* commbuff);
+static unsigned long USBInform           (void* param1, void* param2);
+
+HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T write_buff[SEND_QUEUE_MAX_SIZE];
+
+struct wake_lock netmux_to_usb;
+struct wake_lock usb_to_netmux;
+
+void TRACE(unsigned long function_index, unsigned long param)
+{
+    if (LDLogState[0] == LDLOG_COMMAND_MINI_TRACE)
+    {
+        LD_MINI_TRACE_TABLE[LD_MINI_TRACE_INDEX].function_index    = function_index;
+	LD_MINI_TRACE_TABLE[LD_MINI_TRACE_INDEX].param             = param;
+        LD_MINI_TRACE_TABLE[LD_MINI_TRACE_INDEX].mux_deferred      = mux_deferred;
+        LD_MINI_TRACE_TABLE[LD_MINI_TRACE_INDEX].time_stamp        = jiffies;
+    
+        LD_MINI_TRACE_INDEX = (LD_MINI_TRACE_INDEX+1)%LD_MINI_TRACE_LENGTH;
+    }
+}
+
+/*
+ * LDOutput is used to printk function log on NetMUX LD.
+ *
+ */
+
+void LDOutput (const char *fmt, ...)
+{
+#ifdef _DEBUG_
+    printk(fmt);
+#endif /* _DEBUG_ */
+
+   if ((LDLogState[0] == LDLOG_COMMAND_ALL_WORK) || (LDLogState[0] == LDLOG_COMMAND_FUNCTION)){
+        printk(fmt);
+   }
+}
+
+/*
+ * LOGOutput is used to printk buffer log on NetMUX LD.
+ *
+ */
+
+void LOGOutput (const char *fmt, ...)
+{
+#ifdef _LOG_
+    printk(fmt);
+#endif
+    if ((LDLogState[0] == LDLOG_COMMAND_ALL_WORK) || (LDLogState[0] == LDLOG_COMMAND_BUFFER)){
+        printk(fmt);
+    }
+}
+
+
+/*
+ * LDPutBuffer is used to printk buffer on NetMUX LD.
+ *
+ */
+
+void LDPutBuffer(struct sk_buff* skb)
+{
+    int index;
+                                                                                                                             
+    printk("Commbuff: 0x%p  Length: %d  Data:", skb, skb->len);
+    for (index = 0; index < skb->len; index++)
+    {
+        if (!(index&0x0F))
+           printk("\n");
+                                                                                                                             
+        printk("0x%x ", skb->data[index]);
+    }
+                                                                                                                             
+    printk("\n");
+}
+
+
+void LOGSKBUFF(struct sk_buff* skb)
+{
+#ifdef _LOG_
+    LDPutBuffer(skb);
+#endif
+    if ((LDLogState[0] == LDLOG_COMMAND_ALL_WORK) || (LDLogState[0] == LDLOG_COMMAND_BUFFER)){
+        LDPutBuffer(skb);
+    }
+}
+
+
+/*
+ * MUXTransmitComplete is triggered by the write callback and
+ * runs in a non-interrupt, tasklet context. This function frees
+ * the transmitted buffer and lets the NetMUX know that it is safe
+ * to send again (if needed).
+ *
+ * Params:
+ * nb_bytes -- no. of bytes transferred
+ */
+static void MUXTransmitComplete (unsigned long nb_bytes)
+{
+    int queue_index;
+
+    DEBUG("%s(%lu)\n", __FUNCTION__, nb_bytes);
+    TRACE(3, nb_bytes);
+
+    spin_lock_bh(&ild_lock);
+
+    // Remove all the buffers from the Q which are sent to BP
+    for(queue_index=0; queue_index< SEND_QUEUE_PROCESSED; queue_index++)
+    { 
+        SEND_QUEUE_REMOVE;
+    }
+
+    DEBUG("%s(%u)\n", __FUNCTION__, SEND_QUEUE_LEN);
+    DEBUG("%s(%d)\n", __FUNCTION__, SEND_QUEUE_PROCESSED);
+    
+    /* Reset the send queue length processed */
+    processed_queue_length =0;
+    
+
+    if (mux_deferred)
+    {
+        if (SEND_QUEUE_LEN <= SEND_QUEUE_LOW_MARK)
+	{
+            mux_deferred = 0;
+	    ifmux.MUXInform((void*)LDP_INFORM_RECOVERED, ifmux.id);
+	}
+    }
+
+    // we are guaranteed that currently there is no USB transfer in
+    // progress
+    if (!SEND_QUEUE_ISEMPTY)
+    {
+        spin_unlock_bh(&ild_lock);
+        USBTransmit();
+    }
+    else {
+        spin_unlock_bh(&ild_lock);
+
+	/* Remove netmux_to_usb wakelock */
+	DEBUG("Releasing netmux_to_usb\n");
+	wake_unlock(&netmux_to_usb);
+    }
+}
+
+/*
+ * MUXReceiveComplete is triggered by the read callback and runs
+ * in a non-interrupt, tasklet context. This function passes the
+ * received data up to the NetMUX, allocates a new receive buffer,
+ * and starts the next USB read.
+ *
+ * Params:
+ * arg -- not used.
+ */
+static void MUXReceiveComplete (unsigned long arg)
+{
+    unsigned int comand;
+    HW_CTRL_IPC_STATUS_T status;
+    int index;
+
+    DEBUG("%s(%lu)\n", __FUNCTION__, arg);
+    TRACE(6, 0);
+    LOG("MUXReceiveComplete()-->\n");
+
+    for(index = 0;index < RECEIVE_LIST_MAX_SIZE;index++)
+    {
+        comand = ipc_readbuff[index].comand;
+
+        // if D bit not set break
+        if(!(comand & DONE_BIT))
+        {
+           NETMUX_FAIL("An error occurred on the IPC channel: D bit not set");
+        }
+
+        if(ipc_readbuff[index].length > MAX_FRAME_SIZE)
+        {
+            panic("An error occurred on the IPC packet length");
+        }
+
+        skb_put(receive_commbuff[index], ipc_readbuff[index].length);
+
+	/* Send buffers to MUX without checking for L bit */
+	DEBUG("Calling ifmux.MUXReceive\n");
+        ifmux.MUXReceive((void*)receive_commbuff[index], ifmux.id);
+       
+        LOGSKBUFF(receive_commbuff[index]); 
+        
+        // note that this kfree call only decrements our reference
+        dev_kfree_skb(receive_commbuff[index]);
+
+        // Allocate new buffer and update ipc_readbuff
+        receive_commbuff[index] = dev_alloc_skb(LOC_MAX_RCV_SIZ);
+        if (!receive_commbuff[index])
+            NETMUX_FAIL("IPC Link Driver failed to obtain receive skbuff\n");
+        ipc_readbuff[index].comand = 0;
+        ipc_readbuff[index].length = LOC_MAX_RCV_SIZ;
+        
+        ipc_readbuff[index].data_ptr = (char*)(receive_commbuff[index]->data);
+
+        // invalidate the cache before starting the next read
+        // note that performance may be better if DMA_FROM_DEVICE is used but
+        // that change will require taking care of possible cache line crossings
+        dma_cache_maint(receive_commbuff[index]->data, LOC_MAX_RCV_SIZ,
+                        DMA_BIDIRECTIONAL);
+        // if E bit set stop reading
+        if(comand & END_BIT)
+           break;
+    }
+    // Assuming that ipc_readbuff[index+1] to ipc_readbuff[RECEIVE_LIST_MAX_SIZE -1]
+    // remains same and so initialisation of its fields are not required
+    ipc_readbuff[RECEIVE_LIST_MAX_SIZE -1].comand = END_BIT;
+
+    /* Release usb_to_netmux wakelock */
+    /* This is done here before the driver read as just after IT can be raised
+       which will then acquire the wakelock. This is a possible race condition
+       that is avoided by design if wakelock is released before calliing drive */
+    DEBUG("Releasing usb_to_netmux\n");
+    wake_unlock(&usb_to_netmux);
+
+    status = hw_ctrl_ipc_read_ex2(ipc_channel_handle, ipc_readbuff);
+
+    if (status != HW_CTRL_IPC_STATUS_OK) 
+    {
+        for(index = 0; index < RECEIVE_LIST_MAX_SIZE;index++)
+        {
+            dev_kfree_skb(receive_commbuff[index]);
+        }
+        NETMUX_FAIL("IPC link driver failed to setup IPC receive request: %d\n",
+              status);
+    }
+}
+
+/*
+ * USBReadCallback is the read callback for the ipc.
+ * All we do here is let the PM code know that an interesting
+ * interrupt has occurred and jump out of interrupt context to
+ * let the bottom half do the rest of the work.
+ *
+ * Params:
+ * arg -- the channel number
+ */
+static void USBReadCallback (HW_CTRL_IPC_READ_STATUS_T *read_status)
+{
+    DEBUG("%s(0x%p)\n", __FUNCTION__, read_status);
+    TRACE(5, read_status->nb_bytes);
+
+    /* Acquire usb_to_netmux wakelock */
+    /* Acquire it as soon as we are notified that data are available
+       in the usb driver */
+    DEBUG("Acquire usb_to_netmux\n");
+    wake_lock(&usb_to_netmux);
+
+    tasklet_schedule(&read_callback);
+}
+
+/*
+ * USBWriteCallback is the write callback for the ipc.
+ * All we do here is jump out of interrupt context and let
+ * the bottom half do all the work.
+ *
+ * Params:
+ * arg -- the channel
+ */
+static void USBWriteCallback (HW_CTRL_IPC_WRITE_STATUS_T* write_status)
+{
+    DEBUG("%s(0x%p)\n", __FUNCTION__, write_status);
+    TRACE(2, write_status->nb_bytes);
+    // copy nb_bytes 
+    write_callback.data = write_status->nb_bytes;
+    tasklet_schedule(&write_callback);
+}
+
+/* 
+ * USBNotifyCallback informs us of any error on the USB channel
+ */
+static void USBNotifyCallback (HW_CTRL_IPC_NOTIFY_STATUS_T* status)
+{
+    DEBUG("%s(0x%p)\n", __FUNCTION__, status);
+
+    printk("An error occurred on the IPC channel: %d, %d\n", status->status,
+           status->channel->channel_nb);
+}
+
+/*
+ * USBTransmit is called whenever data needs to be pushed to
+ * the USB, from the send_queue. The ild_lock must not be held
+ * when invoking this function. It is assumed that this function
+ * will only be invoked when the send_queue is not empty.
+ */
+static void USBTransmit (void)
+{
+    struct sk_buff* transmit_commbuff = NULL;
+    int index = 0;
+    int buff_index = 0; 
+    int buff_len = 0;
+    int frame_num = 0;
+    HW_CTRL_IPC_STATUS_T status;
+
+    DEBUG("%s\n", __FUNCTION__);
+
+    spin_lock_bh(&ild_lock);
+
+    LOG("USBTransmit()-->\n");
+
+    // the head element is _not_ removed from the list and the
+    // ref count is unchanged
+    transmit_commbuff = SEND_QUEUE_GET_HEAD;
+
+    // Get all the buffers in the Queue
+    for(index = 0; index < SEND_QUEUE_LEN;index++)
+    {
+       frame_num = (transmit_commbuff->len - 1) / remMaxRcvSiz + 1;
+       if (frame_num > SEND_QUEUE_MAX_SIZE)
+       {
+          NETMUX_FAIL("size too big, can\'t send, discard the package\n");
+       }
+       else if (buff_index + frame_num > SEND_QUEUE_MAX_SIZE)
+       {
+          LOG("send queue full\n");
+          break;
+       }
+
+       INCR_SEND_QUEUE_PROCESSED;
+       buff_len = 0;
+       while (transmit_commbuff->len - buff_len > remMaxRcvSiz) 
+       {
+          write_buff[buff_index].length = remMaxRcvSiz;      
+          write_buff[buff_index].comand = LAST_BIT; 
+          write_buff[buff_index].data_ptr = (char*)(transmit_commbuff->data + buff_len);
+          buff_index ++;
+          buff_len += remMaxRcvSiz;
+       }
+       write_buff[buff_index].comand = LAST_BIT;
+       write_buff[buff_index].length = transmit_commbuff->len - buff_len;
+       write_buff[buff_index].data_ptr = (char*)(transmit_commbuff->data + buff_len);
+       buff_index ++;
+
+       // invalidate the cache before starting the next write
+        // note that performance may be better if DMA_FROM_DEVICE is used but
+        // that change will require taking care of possible cache line crossings
+        dma_cache_maint(transmit_commbuff->data,  transmit_commbuff->len,
+                        DMA_BIDIRECTIONAL);
+       LOGSKBUFF(transmit_commbuff);
+
+       transmit_commbuff = SEND_QUEUE_NEXT(transmit_commbuff);
+    }
+    // Set the E bit in the last buffer
+    // if(buff_index != 0), this can't be the case so not needed 
+    write_buff[buff_index - 1].comand |= END_BIT;
+    spin_unlock_bh(&ild_lock);
+
+    TRACE(1, SEND_QUEUE_LEN);
+    status = hw_ctrl_ipc_write_ex2(ipc_channel_handle, write_buff);
+
+    if (status != HW_CTRL_IPC_STATUS_OK)
+         NETMUX_FAIL("IPC Link Driver failed to send data to IPC: %d\n", status);
+}
+
+/*
+ * USBQueue is called by the NetMUX to send data. If the send_queue is not
+ * full, data will be added to it, transmission will be started (if the USB
+ * was free), and ERROR_NONE will be returned to the NetMUX; otherwise the
+ * NetMUX will be deferred and asked to contact us later.
+ *
+ * Params:
+ * param -- the data to be sent.
+ */
+static unsigned long USBQueue (void* param)
+{
+
+    spin_lock_bh(&ild_lock);
+
+    /* acquire netmux_to_usb wakelock */
+    DEBUG("Acquire netmux_to_usb\n");
+    wake_lock(&netmux_to_usb);
+
+
+    /* tell NetMUX to wait since the queue is full */
+    if (SEND_QUEUE_LEN == SEND_QUEUE_MAX_SIZE)
+    {
+        mux_deferred = 1;
+        spin_unlock_bh(&ild_lock);
+        return LDP_ERROR_RECOVERABLE;
+    }
+
+    SEND_QUEUE_ADD((struct sk_buff*)param);
+
+    // if the queue was empty before our addition above, then
+    // the USB was free and therefore we can begin the next
+    // transmission
+    if (SEND_QUEUE_LEN - 1 == 0)
+    {
+        spin_unlock_bh(&ild_lock);
+        /* we're going to send a packet */
+        USBTransmit();
+    }
+    else
+    {
+        spin_unlock_bh(&ild_lock);
+    }
+
+    return LDP_ERROR_NONE;
+}
+
+/*
+ * USBInform is not used currently. Theoretically the NetMUX can use
+ * this function to communicate with the USB.
+ *
+ * Params:
+ * param1 -- type?
+ * param2 -- data?
+ */
+static unsigned long USBInform (void* param1, void* param2)
+{
+    DEBUG("%s(0x%p, 0x%p)\n", __FUNCTION__, param1, param2);
+
+    switch((unsigned long)param1)
+    {
+        case LDP_INFORM_SHUTDOWN:
+        {
+        }break;
+
+        default:break;
+    }
+
+    return LDP_ERROR_NONE;
+}
+
+/*
+ * GetLinkdriverInfo is a read callback function of proc interface on NetMUX LD.
+ *
+ */
+
+static int GetLinkdriverInfo(char *buf, char**start, off_t offset, int count,
+                              int *eof, void *data)
+{
+    int len = 0;
+    int index, index_offset;
+    
+    if(offset)
+    {
+        len -= offset;
+        if(len < 0)
+        {
+            *eof = 1;
+            return 0;
+        }
+
+        if(len > count)
+        {
+            len = count;
+        }
+        memcpy(buf, &ld_info[offset], len);
+        *start = buf;
+        return len;
+    }
+
+    len = 0;
+
+    len += sprintf(&ld_info[len], "Linkdriver Status:\n");
+    len += sprintf(&ld_info[len], "\tmux_deferred:      %lu\n", mux_deferred);
+    len += sprintf(&ld_info[len], "\tqueue_len: %d\n", SEND_QUEUE_LEN);
+    len += sprintf(&ld_info[len], "\tlinkdriver log status: %s\n", LDLogState);
+    
+    if (LDLogState[0] == LDLOG_COMMAND_MINI_TRACE)
+    {
+        len += sprintf(&ld_info[len], "\nLinkdriver Mini Trace:\n");
+        index_offset = LD_MINI_TRACE_INDEX;
+        for (index = 0; index < LD_MINI_TRACE_LENGTH; index++)
+        {
+            len += sprintf(&ld_info[len], "\t%lu \t%lu \t%lu \t%lu\n", LD_MINI_TRACE_TABLE[index_offset].function_index,
+	                                                         LD_MINI_TRACE_TABLE[index_offset].param,
+	                                                         LD_MINI_TRACE_TABLE[index_offset].mux_deferred, 
+		       				                 LD_MINI_TRACE_TABLE[index_offset].time_stamp);
+						       
+	    index_offset = (index_offset+1)%LD_MINI_TRACE_LENGTH;
+        }
+    }
+
+    if (len > count) {
+	    len = count;
+    }
+    memcpy(buf, &ld_info[offset], len);
+    *start = buf;
+
+    return len;
+}
+
+/*
+ * WriteLDLogCommand is a write callback function of proc interface on NetMUX LD.
+ *
+ */
+
+static int WriteLDLogCommand(struct file* file, const char* buffer, unsigned long count, void* data)
+{
+    int len;
+    int index;
+                                                                                                                             
+    len= count;
+    index = 0;
+    if(len > LDLOG_COMMAND_LEN)
+    {
+        printk("Error : LD log command is invalid\n");
+        return -ENOSPC;
+    }
+    if(copy_from_user(&LDLogState[index], buffer, len)) {
+        return -EFAULT;
+    }
+    LDLogState[LDLOG_COMMAND_LEN-1] = '\0';
+                                                                                                                             
+    return len;
+}
+
+/*
+ * LDProcCleanup is a exit function of proc interface on NetMUX LD.
+ *
+ */
+
+static void LDProcCleanup(void)
+{
+     remove_proc_entry("linkdriver", 0);
+     kfree(ld_info);
+}
+
+/*
+ * LDInit, initialize everything.
+ */
+void LDInit(void)
+{
+    HW_CTRL_IPC_STATUS_T status;
+    int index;
+    int                result = -1;
+
+    DEBUG("%s()\n", __FUNCTION__);
+
+    tasklet_init(&write_callback, &MUXTransmitComplete, 0);
+    tasklet_init(&read_callback, &MUXReceiveComplete, 0);
+    skb_queue_head_init(&send_queue);
+
+    wake_lock_init(&netmux_to_usb, WAKE_LOCK_SUSPEND, "LD_netmux_to_usb");
+    wake_lock_init(&usb_to_netmux, WAKE_LOCK_SUSPEND, "LD_usb_to_netmux");
+
+    LDLogState[0] = '0';
+    LDLogState[1] = '\0';
+                                                                                                                             
+    proc_linkdriver_entry = create_proc_entry("linkdriver", 0x660, 0);
+    if (!proc_linkdriver_entry)
+    {
+        remove_proc_entry("linkdriver", 0);
+    }
+    else
+    {
+        proc_linkdriver_entry->read_proc =  GetLinkdriverInfo;
+        proc_linkdriver_entry->write_proc = WriteLDLogCommand;
+        proc_linkdriver_entry->owner = THIS_MODULE;
+    }
+
+    ld_info = kmalloc(DEFAULT_PROC_DATA_SIZE, GFP_KERNEL);
+    if(!ld_info)
+    {
+        remove_proc_entry("linkdriver", 0);
+        goto unregDev;
+    }
+
+    // Populate channel desc and open USB channel for data transfer
+    ipc_channel_desc.type = HW_CTRL_IPC_PACKET_DATA;
+    ipc_channel_desc.index = USB_CHANNEL;
+    ipc_channel_desc.read_callback = &USBReadCallback;
+    ipc_channel_desc.write_callback = &USBWriteCallback;
+    ipc_channel_desc.notify_callback = &USBNotifyCallback;
+
+    ipc_channel_handle = hw_ctrl_ipc_open(&ipc_channel_desc);
+    if (ipc_channel_handle == NULL)
+    {
+        printk("IPC link driver: failed to obtain IPC channel\n");
+        goto unregDev;
+    }
+
+    iflink.LinkSend   = &USBQueue;
+    iflink.LinkInform = &USBInform;
+    iflink.localMaxRcvSize  = LOC_MAX_RCV_SIZ;
+    iflink.remoteMaxRcvSize = remMaxRcvSiz;
+    mux_deferred      = 0;
+
+    result = RegisterMUXLink(&iflink, &ifmux);
+    if (result != LDP_ERROR_NONE)
+    {
+        printk("IPC link driver: failed to register with NetMUX: %d\n", result);
+        goto closeUSBChan;
+    }
+    
+    // Start the first read
+    for(index = 0; index < RECEIVE_LIST_MAX_SIZE;index++)
+    {
+        receive_commbuff[index] = dev_alloc_skb(LOC_MAX_RCV_SIZ);
+        if (!receive_commbuff[index])
+        {
+           // free allocated buffers
+            while(index)
+            {
+                dev_kfree_skb(receive_commbuff[index - 1]);
+                index--;
+            } 
+            printk("IPC link driver: failed to allocate receive buffer\n");
+            goto unregMux;
+        }
+        ipc_readbuff[index].comand = 0;
+        ipc_readbuff[index].length = LOC_MAX_RCV_SIZ;
+
+        ipc_readbuff[index].data_ptr = (char*)(receive_commbuff[index]->data);
+
+        // invalidate the cache before starting the next read
+        // note that performance may be better if DMA_FROM_DEVICE is used but
+        // that change will require taking care of possible cache line crossings
+        dma_cache_maint(receive_commbuff[index]->data, LOC_MAX_RCV_SIZ,
+                        DMA_BIDIRECTIONAL);
+    }
+
+    ipc_readbuff[RECEIVE_LIST_MAX_SIZE - 1].comand = END_BIT; 
+
+    status = hw_ctrl_ipc_read_ex2(ipc_channel_handle, ipc_readbuff);
+    if (status != HW_CTRL_IPC_STATUS_OK)
+    {
+        printk("IPC link driver: failed to post ipc read buffer: %d\n", status);
+
+        goto freeDataBuf;
+    }
+
+    /* return good status */
+    return;
+
+freeDataBuf:
+for(index = 0; index < RECEIVE_LIST_MAX_SIZE;index++)
+{
+    dev_kfree_skb(receive_commbuff[index]);
+}
+unregMux:
+    UnregisterMUXLink(ifmux.id);
+closeUSBChan:
+    hw_ctrl_ipc_close(ipc_channel_handle);
+unregDev:
+    /* return a failure status */
+    return;
+}
+
+/*
+ * init_module, register init function to IPC.
+ */
+int init_module (void)
+{
+    hw_ctrl_ipc_register(LDInit);
+    return 0;
+}
+
+
+/*
+ * cleanup_module cleans up everything.
+ *
+ * NOTE: commented out at this time since LD should not be removed
+ *       Maybe reinstated later
+ */
+/*
+void cleanup_module (void)
+{
+    int index;
+    HW_CTRL_IPC_STATUS_T status;
+
+    DEBUG("%s()\n", __FUNCTION__);
+
+    UnregisterMUXLink(ifmux.id);
+
+    LDProcCleanup();
+
+    status = hw_ctrl_ipc_close(ipc_channel_handle);
+    if (status != HW_CTRL_IPC_STATUS_OK)
+        printk("ipc close error, status = %d\n", status);
+    else 
+        printk("ipc close OK\n");
+
+    skb_queue_purge(&send_queue);
+
+    for(index =0;index < RECEIVE_LIST_MAX_SIZE;index++)
+    {
+        if (receive_commbuff[index])
+            dev_kfree_skb(receive_commbuff[index]);
+    }
+
+    wake_lock_destroy(&netmux_to_usb);
+    wake_lock_destroy(&usb_to_netmux);
+
+
+}
+*/
diff --git a/drivers/misc/sec/Kconfig b/drivers/misc/sec/Kconfig
new file mode 100644
index 0000000..5364e2d
--- /dev/null
+++ b/drivers/misc/sec/Kconfig
@@ -0,0 +1,11 @@
+#
+# Sec configuration
+#
+
+menu "Motorola sec driver"
+
+config SEC_DRIVER
+	tristate "Motorola sec driver"
+	default m
+
+endmenu
diff --git a/drivers/misc/sec/Makefile b/drivers/misc/sec/Makefile
new file mode 100644
index 0000000..f7642c5
--- /dev/null
+++ b/drivers/misc/sec/Makefile
@@ -0,0 +1,24 @@
+#
+# Copyright (C) 2009 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307, USA
+#
+# Motorola 2009-Mar-13 - Initial Creation
+#
+MODULE_NAME = sec
+
+obj-$(CONFIG_SEC_DRIVER) += $(MODULE_NAME).o
+
+$(MODULE_NAME)-objs := sec_core.o bridge_pub2sec.o
diff --git a/drivers/misc/sec/bridge_pub2sec.S b/drivers/misc/sec/bridge_pub2sec.S
new file mode 100644
index 0000000..131816d
--- /dev/null
+++ b/drivers/misc/sec/bridge_pub2sec.S
@@ -0,0 +1,192 @@
+/*
+ * Copyright (c) 2006-2008 Trusted Logic S.A.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+.text
+
+#define SMICODEPUB_IRQ_END   0xFE
+#define SMICODEPUB_FIQ_END   0xFD
+#define SMICODEPUB_RPC_END   0xFC
+
+pub2sec_bridge_entry:
+   .global pub2sec_bridge_entry
+
+      PUSH     {R4-R12, LR}
+      // Copy the Secure Service ID in R12
+      MOV      R6, #0xFF
+      MOV      R12, R0   // not needed on ES_2_0
+
+      MCR      p15, 0, R0, c7, c5, 4   // Prefetch Buffer flush
+      MCR      p15, 0, R0, c7, c10, 4  // Data Synchro Barrier
+
+      SMC      1
+      B        service_end
+      NOP
+      BL       v7_flush_kern_cache_all
+      MOV      R12, #SMICODEPUB_IRQ_END
+      SMC      1
+
+service_end:
+      POP      {R4-R12, LR}
+      BX       LR
+
+
+//rpc_handler:
+ //   .global rpc_handler
+  // CPSIE i   //enable IRQs
+     // BL       SCXLNXSMCommRPCHandler
+     // MOV      R12, #SMICODEPUB_RPC_END
+     //` SMC      1
+
+
+//----------------------------------------------------------------------------
+// The following functions have been extracted from the kernel in:
+//    > arch\arm\mm\cache-v7.S
+//----------------------------------------------------------------------------
+
+//
+// v7_flush_dcache_all()
+//
+// Flush the whole D-cache.
+//
+// Corrupted registers: r0-r5, r7, r9-r11
+//
+// - mm    - mm_struct describing address space
+//
+v7_flush_dcache_all:
+   .global v7_flush_dcache_all
+   mrc   p15, 1, r0, c0, c0, 1   // read clidr
+   ands  r3, r0, #0x7000000      // extract loc from clidr
+   mov   r3, r3, lsr #23         // left align loc bit field
+   beq   finished                // if loc is 0, then no need to clean
+   mov   r10, #0                 // start clean at cache level 0
+loop1:
+   add   r2, r10, r10, lsr #1    // work out 3x current cache level
+   mov   r1, r0, lsr r2          // extract cache type bits from clidr
+   and   r1, r1, #7              // mask of the bits for current cache only
+   cmp   r1, #2                  // see what cache we have at this level
+   blt   skip                    // skip if no cache, or just i-cache
+   mcr   p15, 2, r10, c0, c0, 0  // select current cache level in cssr
+   isb                           // isb to sych the new cssr&csidr
+   mrc   p15, 1, r1, c0, c0, 0   // read the new csidr
+   and   r2, r1, #7              // extract the length of the cache lines
+   add   r2, r2, #4              // add 4 (line length offset)
+   ldr   r4, =0x3ff
+   ands  r4, r4, r1, lsr #3      // find maximum number on the way size
+   clz   r5, r4                  // find bit position of way size increment
+   ldr   r7, =0x7fff
+   ands  r7, r7, r1, lsr #13     // extract max number of the index size
+loop2:
+   mov   r9, r4                  // create working copy of max way size
+loop3:
+   orr   r11, r10, r9, lsl r5    // factor way and cache number into r11
+   orr   r11, r11, r7, lsl r2    // factor index number into r11
+   mcr   p15, 0, r11, c7, c14, 2 // clean & invalidate by set/way
+   subs  r9, r9, #1              // decrement the way
+   bge   loop3
+   subs  r7, r7, #1              // decrement the index
+   bge   loop2
+skip:
+   add   r10, r10, #2            // increment cache number
+   cmp   r3, r10
+   bgt   loop1
+finished:
+   mov   r10, #0                 // swith back to cache level 0
+   mcr   p15, 2, r10, c0, c0, 0  // select current cache level in cssr
+   isb
+   mov   pc, lr
+
+// v7_flush_cache_all()
+//
+// Flush the entire cache system.
+//  The data cache flush is now achieved using atomic clean / invalidates
+//  working outwards from L1 cache. This is done using Set/Way based cache
+//  maintainance instructions.
+//  The instruction cache can still be invalidated back to the point of
+//  unification in a single instruction.
+//
+v7_flush_kern_cache_all:
+   .global v7_flush_kern_cache_all
+   stmfd sp!, {r4-r5, r7, r9-r11, lr}
+   bl v7_flush_dcache_all
+   mov   r0, #0
+   mcr   p15, 0, r0, c7, c5, 0         // I+BTB cache invalidate
+   ldmfd sp!, {r4-r5, r7, r9-r11, lr}
+   mov   pc, lr
+
+
+/*
+ * cache_line_size - get the cache line size from the CSIDR register
+ * (available on ARMv7+). It assumes that the CSSR register was configured
+ * to access the L1 data cache CSIDR.
+ */
+   .macro   dcache_line_size, reg, tmp
+   mrc   p15, 1, \tmp, c0, c0, 0    @ read CSIDR
+   and   \tmp, \tmp, #7       @ cache line size encoding
+   mov   \reg, #16         @ size offset
+   mov   \reg, \reg, lsl \tmp    @ actual cache line size
+   .endm
+
+
+/*
+ * v7_dma_flush_range(start,end)
+ * - start   - virtual start address of region
+ * - end     - virtual end address of region
+ */
+v7_dma_flush_range:
+   .global v7_dma_flush_range
+   dcache_line_size r2, r3
+   sub   r3, r2, #1
+   bic   r0, r0, r3
+1:
+   mcr   p15, 0, r0, c7, c14, 1     @ clean & invalidate D / U line
+   add   r0, r0, r2
+   cmp   r0, r1
+   blo   1b
+   dsb
+   mov   pc, lr
+
+
+/*
+ * v7_dma_inv_range(start,end)
+ *
+ * Invalidate the data cache within the specified region; we will
+ * be performing a DMA operation in this region and we want to
+ * purge old data in the cache.
+ *
+ * - start   - virtual start address of region
+ * - end     - virtual end address of region
+ */
+v7_dma_inv_range:
+   .global v7_dma_inv_range
+   dcache_line_size r2, r3
+   sub   r3, r2, #1
+   tst   r0, r3
+   bic   r0, r0, r3
+   mcrne p15, 0, r0, c7, c14, 1     @ clean & invalidate D / U line
+
+   tst   r1, r3
+   bic   r1, r1, r3
+   mcrne p15, 0, r1, c7, c14, 1     @ clean & invalidate D / U line
+1:
+   mcr   p15, 0, r0, c7, c6, 1      @ invalidate D / U line
+   add   r0, r0, r2
+   cmp   r0, r1
+   blo   1b
+   dsb
+   mov   pc, lr
diff --git a/drivers/misc/sec/sec_core.c b/drivers/misc/sec/sec_core.c
new file mode 100644
index 0000000..158f688
--- /dev/null
+++ b/drivers/misc/sec/sec_core.c
@@ -0,0 +1,481 @@
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "sec_core.h"
+#include "sec_ks_external.h"
+#include <linux/kernel.h>
+#include <linux/regulator/consumer.h>
+
+
+static void SecGetModelId(void *data);
+
+static void SecGetSWRV(void *data);
+
+static void SecGetProcID(void *data);
+
+
+static void SecRaiseVfuse(void);
+
+static void SecLowerVfuse(void);
+
+static int SecProvisionModelID(unsigned int model_id);
+
+static u32
+SEC_ENTRY_pub2sec_dispatcher(u32 appl_id, u32 proc_ID, u32 flag, ...);
+
+static int SecBSDis(void);
+
+static int SecVfuseOff(void);
+static int SecVfuseOn(void);
+static int SecFuseInit(void);
+
+static struct regulator *sec_efuse_regulator;
+
+
+/* Structure that declares the usual file */
+/* access functions */
+const struct file_operations sec_fops = {
+	.read = sec_read,
+	.open = sec_open,
+	.release = sec_release,
+	.ioctl = sec_ioctl
+};
+
+/* Mapping of the module init and exit functions */
+module_init(sec_init);
+module_exit(sec_exit);
+
+static struct miscdevice sec_dev = {
+	MISC_DYNAMIC_MINOR,
+	"sec",
+	&sec_fops
+};
+
+/******************************************************************************/
+/*   KERNEL DRIVER APIs, ONLY IOCTL RESPONDS BACK TO USER SPACE REQUESTS      */
+/******************************************************************************/
+int sec_init(void)
+{
+	int result;
+
+	result = misc_register(&sec_dev);
+
+	if (result) {
+		printk(KERN_ERR "sec: cannot obtain major number \n");
+		return result;
+	}
+
+	printk(KERN_INFO "Inserting sec module\n");
+	return 0;
+}
+
+void sec_exit(void)
+{
+	/* Freeing the major number */
+	misc_deregister(&sec_dev);
+}
+
+int sec_open(struct inode *inode, struct file *filp)
+{
+	/* Not supported, return Success */
+	return 0;
+}
+
+int sec_release(struct inode *inode, struct file *filp)
+{
+
+	/* Not supported, return Success */
+	return 0;
+}
+
+ssize_t sec_read(struct file *filp, char *buf,
+		 size_t count, loff_t *f_pos)
+{
+	/* Not supported, return Success */
+	return 0;
+}
+
+ssize_t sec_write(struct file *filp, char *buf,
+		  size_t count, loff_t *f_pos)
+{
+	/* Not supported, return Success */
+	return 0;
+}
+
+int sec_ioctl(struct inode *inode, struct file *file,
+	      unsigned int ioctl_num, unsigned long ioctl_param)
+{
+	unsigned long count = 0xDEADBEEF;
+	void *sec_buffer = NULL;
+	int ret_val = 99;
+
+	switch (ioctl_num) {
+	case SEC_IOCTL_MODEL:
+		sec_buffer = kmalloc(SIZE_OF_MODEL_ID, GFP_KERNEL);
+		if (sec_buffer != NULL) {
+			SecGetModelId(sec_buffer);
+			count =
+			    copy_to_user((void __user *) ioctl_param,
+					 (const void *) sec_buffer,
+					 SIZE_OF_MODEL_ID);
+			kfree(sec_buffer);
+			ret_val = 0;
+		}
+
+		break;
+
+	case SEC_IOCTL_MODELID_PROV:
+		ret_val = SecProvisionModelID(ioctl_param);
+
+		break;
+
+
+	case SEC_IOCTL_SWRV:
+
+		sec_buffer = kmalloc(SIZE_OF_SWRV, GFP_KERNEL);
+
+		if (sec_buffer != NULL) {
+			SecGetSWRV(sec_buffer);
+			count =
+			    copy_to_user((void __user *) ioctl_param,
+					 (const void *) sec_buffer,
+					 SIZE_OF_SWRV);
+			kfree(sec_buffer);
+			ret_val = 0;
+		}
+		break;
+
+	case SEC_IOCTL_PROC_ID:
+		sec_buffer = kmalloc(SIZE_OF_PROC_ID, GFP_KERNEL);
+		if (sec_buffer != NULL) {
+			SecGetProcID(sec_buffer);
+			count =
+			    copy_to_user((void __user *) ioctl_param,
+					 (const void *) sec_buffer,
+					 SIZE_OF_PROC_ID);
+			kfree(sec_buffer);
+			ret_val = 0;
+		}
+		break;
+
+	case SEC_IOCTL_EFUSE_RAISE:
+		SecRaiseVfuse();
+		ret_val = 0;
+		break;
+
+	case SEC_IOCTL_EFUSE_LOWER:
+		SecLowerVfuse();
+		ret_val = 0;
+		break;
+
+	case SEC_IOCTL_BS_DIS:
+		ret_val = SecBSDis();
+		break;
+
+	default:
+		printk("sec ioctl called with bad cmd : %d ", ioctl_num);
+		break;
+	}
+
+	if (count != 0) {
+		printk("sec ioctl operation : %d failed, \
+			copy_to_user returned: 0x%lX", ioctl_num, count);
+	}
+
+	return ret_val;
+}
+
+static void SecGetModelId(void *data)
+{
+	volatile unsigned int *fuse_ptr = NULL;
+	volatile unsigned int fuse_value = 0;
+	memset(data, 0xFF, SIZE_OF_MODEL_ID);
+	fuse_ptr = (unsigned int *) IO_ADDRESS(REGISTER_ADDRESS_MSV);
+	fuse_value = *fuse_ptr;
+	memcpy(data, (void *) &fuse_value, sizeof(unsigned int));
+
+	return;
+}
+
+static void SecGetSWRV(void *data)
+{
+	int ret_val = 99;
+
+	memset(data, 0xFF, SIZE_OF_SWRV);
+	ret_val = SEC_ENTRY_pub2sec_dispatcher(API_HAL_MOT_EFUSE_READ,
+					       0,
+					       FLAG_IRQ_ENABLE |
+					       FLAG_FIQ_ENABLE |
+					       FLAG_START_HAL_CRITICAL, 1,
+					       __pa(data));
+
+	if (ret_val != 0) {
+		memset(data, 0xFF, SIZE_OF_SWRV);
+	}
+	return;
+}
+
+static void SecGetProcID(void *data)
+{
+	int i = 0;
+	volatile unsigned int *fuse_ptr = NULL;
+	volatile unsigned int fuse_value = 0;
+	memset(data, 0xFF, SIZE_OF_PROC_ID);
+	fuse_ptr = (unsigned int *) IO_ADDRESS(REGISTER_ADDRESS_DIE_ID);
+	for (i = 0; i < 4; i++) {
+		fuse_value = *(fuse_ptr - i);
+		memcpy(data + (4 * i), (void *) &fuse_value,
+		       sizeof(unsigned int));
+	}
+	return;
+}
+
+static void SecRaiseVfuse(void)
+{
+	int ret_value = 99;
+
+	if (sec_efuse_regulator == NULL) {
+		ret_value = SecFuseInit();
+		if (ret_value != 0) {
+			printk
+			    ("Registration regulator framework failed:%d",
+			     ret_value);
+		}
+	}
+
+	if (ret_value == 0 || ret_value == 99)
+		ret_value = SecVfuseOn();
+
+	return;
+
+}
+
+static void SecLowerVfuse(void)
+{
+	int ret_value = 99;
+
+	ret_value = SecVfuseOff();
+	if (ret_value != 0)
+		printk(" Efuse voltage lowering failed : %d", ret_value);
+	return;
+}
+
+static int SecProvisionModelID(unsigned int model_id)
+{
+	unsigned int result = 99;
+	int ret_val = 99;
+	SEC_PA_PARAMS ns_efuse_params;
+
+	ns_efuse_params.component = SEC_MODEL_ID;
+	ns_efuse_params.efuse_value = model_id;
+
+	ns_efuse_params.bch_value = 99;
+
+	result = SEC_ENTRY_pub2sec_dispatcher(API_HAL_MOT_EFUSE,
+					      0,
+					      FLAG_IRQFIQ_MASK |
+					      FLAG_START_HAL_CRITICAL, 1,
+					      (void *)
+					      __pa(&ns_efuse_params));
+	if ((result == 0))
+		ret_val = 0;
+
+	return ret_val;
+}
+
+static int SecBSDis()
+{
+	unsigned int result = 99;
+	int ret_val = 99;
+	SEC_PA_PARAMS ns_efuse_params;
+
+	ns_efuse_params.component = SEC_BS_DIS;
+	ns_efuse_params.efuse_value = 0x01;
+	ns_efuse_params.bch_value = 99;
+	result = SEC_ENTRY_pub2sec_dispatcher(API_HAL_MOT_EFUSE,
+					      0,
+					      FLAG_IRQFIQ_MASK |
+					      FLAG_START_HAL_CRITICAL, 1,
+					      (void *)
+					      __pa(&ns_efuse_params));
+	if (result == 0)
+		ret_val = 0;
+
+	return ret_val;
+
+}
+
+/*----------------------------------------------------------------------------
+ * Function responsible for formatting the parameters to pass
+ * from NS-World to S-World.
+ *----------------------------------------------------------------------------*/
+u32 SEC_ENTRY_pub2sec_dispatcher(u32 appl_id, u32 proc_ID, u32 flag, ...)
+{
+	u32 return_value = 0;
+	u32 *pArgs = NULL;
+
+	va_list args;
+	int temp_counter;
+
+	/*
+	 * We need a physically contiguous buffer to pass parameters to the SE
+	 */
+	pArgs = (u32 *) kmalloc(sizeof(u32) * 5, GFP_KERNEL);
+	if (pArgs == NULL)
+		return -ENOMEM;
+
+	va_start(args, flag);
+
+	for (temp_counter = 0; temp_counter < 5; temp_counter++)
+		pArgs[temp_counter] = va_arg(args, int);
+
+	va_end(args);
+
+
+	/*
+	 * OMAP3430 Secure ROM Code Functional Specification:
+	 *    L2 Cache is not used by SW which runs in Secure Mode.
+	 *    Thus, the non-Secure World's software must ensure that any data
+	 *    in L2 Cache are coherent with memory before feeding such data to the
+	 *    Secure World for processing.
+	 */
+	v7_flush_kern_cache_all();
+
+	return_value =
+	    pub2sec_bridge_entry(appl_id, proc_ID, flag,
+				 (char *) __pa(pArgs));
+
+	kfree(pArgs);
+
+	return return_value;
+}
+
+
+static int SecFuseInit(void)
+{
+	int ret_value = 99;
+	struct regulator *reg;
+
+	reg = regulator_get(NULL, "vfuse");
+	if (reg)
+		sec_efuse_regulator = reg;
+
+	return ret_value;
+
+}
+
+
+static int SecVfuseOn(void)
+{
+	int ret_value = 99;
+
+	if (sec_efuse_regulator == NULL)
+		return 99;
+	regulator_set_voltage(sec_efuse_regulator, 1900000, 1900000);
+	ret_value = regulator_enable(sec_efuse_regulator);
+	return ret_value;
+
+}
+
+static int SecVfuseOff(void)
+{
+	int ret_value = 99;
+
+	if (sec_efuse_regulator == NULL)
+		return 99;
+	ret_value = regulator_disable(sec_efuse_regulator);
+	return ret_value;
+
+}
+
+/******************************************************************************/
+/*Functions exported to Kernel for other kernel services                      */
+/******************************************************************************/
+SEC_STAT_T SecProcessorID(unsigned char *buffer, int length)
+{
+	int counter = 0;
+	volatile unsigned int *fuse_ptr = NULL;
+	volatile unsigned int fuse_value = 0;
+	if (length < SIZE_OF_PROC_ID)
+		return SEC_FAIL;
+
+	memset(buffer, 0xFF, length);
+	fuse_ptr = (unsigned int *) IO_ADDRESS(REGISTER_ADDRESS_DIE_ID);
+
+	for (counter = 0; counter < 4; counter++) {
+		fuse_value = *(fuse_ptr - counter);
+		memcpy(buffer + (4 * counter), (void *) &fuse_value,
+		       sizeof(unsigned int));
+	}
+	return SEC_SUCCESS;
+}
+
+EXPORT_SYMBOL(SecProcessorID);
+
+SEC_STAT_T SecModelID(unsigned char *buffer, int length)
+{
+	volatile unsigned int *fuse_ptr = NULL;
+	volatile unsigned int fuse_value = 0;
+
+	if (length < SIZE_OF_MODEL_ID)
+		return SEC_FAIL;
+	memset(buffer, 0xFF, length);
+	fuse_ptr = (unsigned int *) IO_ADDRESS(REGISTER_ADDRESS_MSV);
+	fuse_value = *fuse_ptr;
+	memcpy(buffer, (void *) &fuse_value, sizeof(unsigned int));
+	return SEC_SUCCESS;
+
+}
+
+EXPORT_SYMBOL(SecModelID);
+
+SEC_MODE_T SecProcessorType(void)
+{
+	SEC_MODE_T ret_val = SEC_PRODUCTION;
+	/* UINT16 : unsigned short int */
+	u32 *iterator = NULL;
+	u32 *data = (u32 *) kmalloc(SIZE_OF_SWRV, GFP_KERNEL);
+
+	memset(data, 0xFF, SIZE_OF_SWRV);
+	SEC_ENTRY_pub2sec_dispatcher(API_HAL_MOT_EFUSE_READ, 0,
+				     FLAG_IRQFIQ_MASK |
+				     FLAG_START_HAL_CRITICAL, 1,
+				     (void *) __pa(data));
+	if (ret_val != 0)
+		memset(data, 0xFF, SIZE_OF_SWRV);
+
+	iterator = data + 4;
+
+	/*HAB_ENG : 13, HAB_PROD : 14 */
+	/*Engineering only if engineering blown and production not */
+	if (((*iterator) & (0x3 << 13)) == (0x1 << 13))
+		ret_val = SEC_ENGINEERING;
+
+	return ret_val;
+
+}
+
+EXPORT_SYMBOL(SecProcessorType);
+
+
+
+/******************************************************************************/
+/*Kernel Module License Information                                           */
+/******************************************************************************/
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("MOTOROLA");
diff --git a/drivers/misc/sec/sec_core.h b/drivers/misc/sec/sec_core.h
new file mode 100644
index 0000000..d1f680f
--- /dev/null
+++ b/drivers/misc/sec/sec_core.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Necessary includes for device drivers */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>	/* printk() */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/fs.h>
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/proc_fs.h>
+#include <linux/fcntl.h>
+#include <asm/system.h>		/* cli(), *_flags */
+#include <linux/uaccess.h>	/* copy_from/to_user */
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+
+#define SIZE_OF_MODEL_ID 4
+#define SIZE_OF_SWRV     (20)
+#define SIZE_OF_PROC_ID   16
+
+#define LARGER_OF_TWO (n, m) (n > m ? n : m)
+#define LARGER_OF_THREE (x, y, z) \
+	(x > (LARGER_OF_TWO(y, z)) ? x : LARGER_OF_TWO(y, z))
+
+#define API_HAL_KM_SOFTWAREREVISION_READ          33
+
+#define FLAG_IRQFIQ_MASK            0x3
+#define FLAG_START_HAL_CRITICAL     0x4
+#define FLAG_IRQ_ENABLE             0x2
+#define FLAG_FIQ_ENABLE             0x1
+
+#define SMICODEPUB_IRQ_END   0xFE
+#define SMICODEPUB_FIQ_END   0xFD
+#define SMICODEPUB_RPC_END   0xFC
+
+#define REGISTER_ADDRESS_DIE_ID  0x4830A218
+#define REGISTER_ADDRESS_MSV 0x480023B4
+
+#define SEC_IOCTL_MODEL _IOWR(0x99, 100, int*)
+#define SEC_IOCTL_SWRV _IOWR(0x99, 101, int*)
+#define SEC_IOCTL_PROC_ID _IOWR(0x99, 102, int*)
+#define SEC_IOCTL_EFUSE_RAISE _IOWR(0x99, 103, int*)
+#define SEC_IOCTL_EFUSE_LOWER _IOWR(0x99, 104, int*)
+#define SEC_IOCTL_MODELID_PROV _IOWR(0x99, 105, int)
+#define SEC_IOCTL_BS_DIS   _IOWR(0x99, 106, int)
+
+#define API_HAL_NB_MAX_SVC         39
+#define API_HAL_MOT_EFUSE            (API_HAL_NB_MAX_SVC + 10)
+#define API_HAL_MOT_EFUSE_READ       (API_HAL_NB_MAX_SVC + 15)
+
+/*===========================*
+   struct SEC_PA_PARAMS
+*============================*/
+typedef struct {
+	unsigned int component;
+	unsigned int efuse_value;
+	unsigned int bch_value;
+} SEC_PA_PARAMS;
+
+/*============================
+   enum SEC_SV_COMPONENT_T
+*============================*/
+typedef enum {
+	/*Starting with random non zero value for component type */
+	SEC_AP_PA_PPA = 0x00000065,
+	SEC_BP_PPA,
+	SEC_BP_PA,
+	SEC_ML_PBRDL,
+	SEC_MBM,
+	SEC_RRDL_BRDL,
+	SEC_BPL,
+	SEC_AP_OS,
+	SEC_BP_OS,
+	SEC_BS_DIS,
+	SEC_ENG,
+	SEC_PROD,
+	SEC_CUST_CODE,
+	SEC_PKC,
+	SEC_MODEL_ID,
+	SEC_MAX
+} SEC_SV_COMPONENT_T;
+
+
+/* Declaration of sec.c functions */
+int sec_open(struct inode *inode, struct file *filp);
+int sec_release(struct inode *inode, struct file *filp);
+ssize_t sec_read(struct file *filp, char *buf, size_t count,
+		loff_t *f_pos);
+ssize_t sec_write(struct file *filp, char *buf, size_t count,
+		loff_t *f_pos);
+int sec_ioctl(struct inode *inode, struct file *file,
+	      unsigned int ioctl_num, unsigned long ioctl_param);
+
+
+
+extern u32 pub2sec_bridge_entry(u32 appl_id, u32 proc_ID, u32 flag,
+				char *ptr);
+extern u32 rpc_handler(u32 p1, u32 p2, u32 p3, u32 p4);
+extern u32 v7_flush_kern_cache_all(void);
+
+void sec_exit(void);
+
+int sec_init(void);
+
+static void SecGetModelId(void *);
+
+static void SecGetSWRV(void *);
+
+static void SecGetProcID(void *);
diff --git a/drivers/misc/sec/sec_ks_external.h b/drivers/misc/sec/sec_ks_external.h
new file mode 100644
index 0000000..71a6904
--- /dev/null
+++ b/drivers/misc/sec/sec_ks_external.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Date         Author          Comment
+ * ===========  ==============  ==============================================
+ * 16-Apr-2009  Motorola        Initial revision.
+ *
+ */
+
+/*Header for external kernel space SecAPIs*/
+
+#define SEC_PROC_ID_SIZE 16
+#define MODEL_ID_SIZE 4
+
+
+typedef enum {
+	SEC_ENGINEERING = 0x77,
+	SEC_PRODUCTION = 0x44
+} SEC_MODE_T;
+
+
+typedef enum {
+	SEC_SUCCESS = 0x33,
+	SEC_FAIL = 0x00
+} SEC_STAT_T;
+
+SEC_STAT_T SecProcessorID(unsigned char *buffer, int length);
+
+SEC_STAT_T SecModelID(unsigned char *buffer, int length);
+
+SEC_MODE_T SecProcessorType(void);
diff --git a/drivers/misc/syspanic.c b/drivers/misc/syspanic.c
new file mode 100644
index 0000000..14f2c36
--- /dev/null
+++ b/drivers/misc/syspanic.c
@@ -0,0 +1,430 @@
+/**  \file syspanic.c
+
+     \brief This file contains the source to the syspanic kernel driver
+
+      \if INCLUDE_LICENSE_SECTION
+      * Copyright (C) 2009 Motorola, Inc.
+      * This program is free software; you can redistribute it
+      * and/or modify it under the terms of the GNU General
+      * Public License as published by the Free Software
+      * Foundation; either version 2 of the License, or (at
+      * your option) any later version.  You should have
+      * received a copy of the GNU General Public License
+      * along with this program; if not, write to the Free
+      * Software Foundation 51 Franklin Street, Fifth Floor
+      * Boston, MA 02110-1301 USA
+      \endif
+
+
+\if MOTOROLA_CONFIDENTIAL_PROPRIETARY
+
+====================================================================================================
+
+                              Motorola Confidential Proprietary
+                                    Template version 1.1
+                       Copyright 2009 Motorola, Inc.  All Rights Reserved.
+
+Internal Revision History:
+                            Modification     Tracking
+Author                          Date          Number     Description of Changes
+-------------------------   ------------    ----------   -------------------------------------------
+Falempe Jocelyn              18/02/2009     LIBss12162    initial creation
+LIU Peng - a22543            24/08/2009     LIBtt10246   Syspanic need to prevent suspend when BP panic happen
+
+\endif
+
+
+<tt>
+
+External Revision History:
+
+Modification Date | Release ID | Description of Changes \n
+----------------- | ---------- | -------------------------------- \n
+-- 2009-02-18 --- | Version_01 | Initial Creation
+-- 2009-08-24 --- | Version_02 | To prevent suspend when BP panic happen
+
+
+</tt>
+*/
+
+/*=============================================================================
+................................INCLUDE FILES
+=============================================================================*/
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/poll.h>
+#include <mach/irqs.h>
+#include <linux/sched.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/timer.h>
+#include <asm/delay.h>
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+/*=============================================================================
+                                LOCAL CONSTANTS
+=============================================================================*/
+
+/**
+ * Identifier of the driver. Used in all kernel APIs requiring a text
+ * string to identify the driver, and in creating the devfs entry
+ */
+#define SYSPANIC_ID    "syspanic"
+
+/* #define SYSPDEBUG 1 */
+#ifdef SYSPDEBUG
+#  define DPRINTK(fmt, args...) printk(KERN_INFO "%s: " fmt, __FUNCTION__ ,\
+									## args)
+#else
+#  define DPRINTK(fmt, args...)
+#endif
+/*=============================================================================
+                                LOCAL MACROS
+=============================================================================*/
+
+/*=============================================================================
+                        LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
+=============================================================================*/
+
+typedef enum {
+	SYSP_IDLE,
+	SYSP_WAIT,
+	SYSP_CLEAR,
+	SYSP_PANIC,
+	SYSP_MEMORY_PANIC
+} sysp_state;
+
+/**
+ * Internal representation of the syspanic driver.
+ */
+typedef struct {
+	struct semaphore sem;		/**< Semaphore used to serialize I/O operations */
+	unsigned char openFlag;		/**< Bit indicating the driver is being used by
+                                             user-space */
+	wait_queue_head_t waitQueue;	/**< Wait queue used for sleeping */
+	struct timer_list timerList;
+#ifdef CONFIG_HAS_WAKELOCK
+    struct wake_lock syspanic_wake_lock;
+#endif
+	atomic_t state;
+
+} SysPanicDriverType;
+
+/*=============================================================================
+                              LOCAL FUNCTION PROTOTYPES
+=============================================================================*/
+
+/**
+ * \brief Initializes the syspanic module when it's loaded into kernel
+ *
+ * \param None
+ *
+ * \return Return Type \n
+ * - Zero - Success. \n
+ * - Non-Zero - An error has occurred while initializing the driver. \n
+ */
+static int __init syspanicInit(void);
+
+/**
+ * \brief Cleans up the syspanic module when it's unloaded from kernel
+ *
+ * \param None
+ *
+ * \return None
+ *
+ */
+static void __exit syspanicExit(void);
+
+static void syspTimeout(unsigned long ptr);
+
+/**
+ * \brief Interrupt handler called when IRQ is received from BP syspanic
+ *
+ * \param irq   - Interrupt number
+ * \param data  - Private data
+ *
+ * \return Return Type \n
+ * - IRQ_HANDLED - Interrupt has been handled
+ * - IRQ_NONE    - No real interrupt occurred
+ */
+static irqreturn_t irqHandler(int irq, void *data);
+
+/**
+ * \brief Callback function when user-space invokes open()
+ *
+ * \param inode     - Pointer to inode structure
+ * \param filp      - Pointer to open file structure
+ *
+ * \return Return Type \n
+ * - Zero     - Success
+ * - Non-Zero - An error has occurred
+ */
+static int syspanicOpen(struct inode *inode, struct file *filp);
+
+/**
+ * \brief Callback function when user-space invokes close()
+ *
+ * \param inode     - Pointer to inode structure
+ * \param filp      - Pointer to open file structure
+ *
+ * \return Return Type \n
+ * - Zero     - Success
+ * - Non-Zero - An error has occurred
+ */
+static int syspanicRelease(struct inode *inode, struct file *filp);
+
+
+/**
+ * \brief Callback function when user-space invokes select()
+ *
+ * \param filp      - Pointer to open file structure
+ * \param wait      - Opaque structure passed to kernel
+ *
+ * \return Return Type \n
+ * - POLLIN - Data available for read
+ * - 0 - No data available
+ */
+static unsigned int syspanicPoll(struct file *filp, poll_table * wait);
+
+/**
+ * \brief Wrapper function to request for interrupt
+ */
+static int syspanicRequestIRQ(void);
+
+/**
+ * \brief Wrapper function to free interrupt
+ */
+static void syspanicFreeIRQ(void);
+
+/*=============================================================================
+                                GLOBAL VARIABLES
+=============================================================================*/
+
+/**
+ * This structure exposes the available I/O
+ * operations of this driver to the kernel.
+ * Each member points to a corresponding function
+ */
+static struct file_operations syspanicFops = {
+	.owner = THIS_MODULE,
+	.open = syspanicOpen,
+	.release = syspanicRelease,
+	.poll = syspanicPoll,
+};
+
+static struct class *syspanic_class;
+struct device *syspanic_device_class;
+static int major_syspanic;
+static SysPanicDriverType sysp;	/**< Internal structure of syspanic driver */
+
+/*=============================================================================
+                                LOCAL FUNCTIONS
+=============================================================================*/
+static int __init syspanicInit(void)
+{
+	int ret;
+	/* Allocate a major number for the character device */
+	major_syspanic = register_chrdev(0, "syspanic", &syspanicFops);
+	if (major_syspanic < 0) {
+		printk(KERN_INFO "Unable to get a major for syspanic\n");
+		return major_syspanic;
+	}
+
+	syspanic_class = class_create(THIS_MODULE, "syspanic");
+	if (IS_ERR(syspanic_class)) {
+		printk(KERN_INFO "Not able to do the class_create\n");
+		unregister_chrdev(major_syspanic, "syspanic");
+		return (int) syspanic_class;
+	}
+
+	syspanic_device_class =
+	    device_create(syspanic_class, NULL, MKDEV(major_syspanic, 0),
+			  NULL, "syspanic");
+	if (IS_ERR(syspanic_device_class)) {
+		class_destroy(syspanic_class);
+		unregister_chrdev(major_syspanic, "syspanic");
+		printk(KERN_INFO
+		       "Not able to do the class_device_create\n");
+		return (int) syspanic_device_class;
+	}
+
+	/* Initialize internal structures */
+	init_MUTEX(&sysp.sem);
+
+	sysp.openFlag = 0;
+	init_waitqueue_head(&sysp.waitQueue);
+
+	init_timer(&sysp.timerList);
+	sysp.timerList.data = 0;
+	sysp.timerList.function = syspTimeout;
+
+	atomic_set(&sysp.state, SYSP_IDLE);
+	printk(KERN_INFO "Loaded SysPanic device driver\n");
+
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&sysp.syspanic_wake_lock,
+		       WAKE_LOCK_SUSPEND,
+		       "syspanic");
+#endif
+
+	/* Request for an interrupt from kernel */
+	if ((ret = syspanicRequestIRQ()) < 0) {
+		printk(KERN_ERR "Cannot request IRQ from kernel\n");
+		syspanicFreeIRQ();
+		return ret;
+	}
+	return 0;
+}
+
+static void __exit syspanicExit(void)
+{
+	if (major_syspanic >= 0) {
+		device_destroy(syspanic_class, MKDEV(major_syspanic, 0));
+		class_destroy(syspanic_class);
+		unregister_chrdev(major_syspanic, "syspanic");
+	}
+	/* Free the requested IRQ */
+	syspanicFreeIRQ();
+
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_destroy(&sysp.syspanic_wake_lock);
+#endif
+
+	printk(KERN_INFO "Unloaded SysPanic device driver\n");
+}
+
+static int syspanicOpen(struct inode *inode, struct file *filp)
+{
+	/* Hold the semaphore */
+	if (down_interruptible(&sysp.sem)) {
+		return -ERESTARTSYS;
+	}
+
+	/* Checks if device is already opened */
+	if (sysp.openFlag) {
+		up(&sysp.sem);
+		return -EBUSY;
+	}
+	DPRINTK("syspanic opened\n");
+	/* Sets the flag to open */
+	sysp.openFlag = 1;
+
+	/* Release the semaphore and return */
+	up(&sysp.sem);
+
+	return 0;
+}
+
+static int syspanicRelease(struct inode *inode, struct file *filp)
+{
+#ifdef CONFIG_HAS_WAKELOCK
+    wake_unlock(&sysp.syspanic_wake_lock);
+#endif
+
+	/* Hold the semaphore */
+	if (down_interruptible(&sysp.sem)) {
+		return -ERESTARTSYS;
+	}
+	DPRINTK("syspanic closed\n");
+	/* Clears open flag */
+	sysp.openFlag = 0;
+
+	/* Release the semaphore and return */
+	up(&sysp.sem);
+	return 0;
+}
+
+static void syspTimeout(unsigned long ptr)
+{
+	if (atomic_read(&sysp.state) == SYSP_WAIT
+	    || atomic_read(&sysp.state) == SYSP_CLEAR) {
+		atomic_set(&sysp.state, SYSP_MEMORY_PANIC);
+		disable_irq(88);
+		DPRINTK("Syspanic Memory Panic\n");
+		/* wake up panic daemon */
+		wake_up_interruptible(&sysp.waitQueue);
+	}
+}
+
+static irqreturn_t irqHandler(int irq, void *data)
+{
+#ifdef CONFIG_HAS_WAKELOCK
+    wake_lock(&sysp.syspanic_wake_lock);
+#endif
+
+	switch (atomic_read(&sysp.state)) {
+	case SYSP_IDLE:
+		atomic_set(&sysp.state, SYSP_WAIT);
+		sysp.timerList.expires = jiffies + (HZ / 10);	// timeout 100ms
+		add_timer(&sysp.timerList);
+		DPRINTK("Syspanic first irq Panic\n");
+		udelay(1000);
+		break;
+	case SYSP_WAIT:
+		atomic_set(&sysp.state, SYSP_CLEAR);
+		udelay(1000);
+		break;
+	case SYSP_CLEAR:
+		atomic_set(&sysp.state, SYSP_PANIC);
+		del_timer(&sysp.timerList);
+		disable_irq(88);
+		/* wake up panic daemon */
+		DPRINTK("Syspanic Standard BP Panic\n");
+		wake_up_interruptible(&sysp.waitQueue);
+		break;
+	default:
+		/* irq should be disabled */
+		disable_irq(88);
+		break;
+	}
+	return IRQ_HANDLED;
+}
+
+static unsigned int syspanicPoll(struct file *filp, poll_table * wait)
+{
+	poll_wait(filp, &sysp.waitQueue, wait);
+	switch (atomic_read(&sysp.state)) {
+	case SYSP_PANIC:
+		return POLLIN;
+	case SYSP_MEMORY_PANIC:
+		return POLLRDNORM;
+	case SYSP_IDLE:
+	case SYSP_WAIT:
+	case SYSP_CLEAR:
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int syspanicRequestIRQ(void)
+{
+	int retval;
+	retval =
+	    request_irq(88, irqHandler, IRQF_DISABLED, SYSPANIC_ID, NULL);
+	if (retval < 0) {
+		printk("\nCan't get SysPanic IRQ\n");
+		return retval;
+	}
+	enable_irq_wake(88);
+	return 0;
+}
+
+static void syspanicFreeIRQ(void)
+{
+	free_irq(88, NULL);
+	return;
+}
+
+module_init(syspanicInit);
+module_exit(syspanicExit);
+
+MODULE_AUTHOR("Falempe Jocelyn");
+MODULE_DESCRIPTION("Syspanic Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 7f83636..4231da8 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -201,13 +201,8 @@ void mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)
 	mrq->done = mmc_wait_done;
 
 	mmc_start_request(host, mrq);
-	if (!wait_for_completion_timeout(&complete, HZ * 10)) {
-		printk(KERN_EMERG "%s: Timed out waiting for completion\n",
-		       mmc_hostname(host));
-		printk(KERN_EMERG "%s: cmd 0x%x\n", mmc_hostname(host),
-		       mrq->cmd->opcode);
-		panic("Timed out waiting for mmc completion");
-	}
+
+	wait_for_completion(&complete);
 }
 
 EXPORT_SYMBOL(mmc_wait_for_req);
@@ -875,7 +870,7 @@ void mmc_rescan(struct work_struct *work)
 
 	/* if there is a card registered, check whether it is still present */
 	if ((host->bus_ops != NULL) &&
-            host->bus_ops->detect && !host->bus_dead) {
+		host->bus_ops->detect && !host->bus_dead) {
 		host->bus_ops->detect(host);
 		/* If the card was removed the bus will be marked
 		 * as dead - extend the wakelock so userspace
@@ -1000,7 +995,7 @@ void mmc_stop_host(struct mmc_host *host)
  */
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
-	if (mmc_bus_needs_resume(host))
+	if (mmc_bus_needs_resume(host) || !(host->bus_resume_flags))
 		return 0;
 
 	cancel_delayed_work(&host->detect);
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
index 610dbd1..fcd1a80 100644
--- a/drivers/mmc/core/debugfs.c
+++ b/drivers/mmc/core/debugfs.c
@@ -289,4 +289,5 @@ err:
 void mmc_remove_card_debugfs(struct mmc_card *card)
 {
 	debugfs_remove_recursive(card->debugfs_root);
+	card->debugfs_root = NULL;
 }
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 992b7fa..beac4dc 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -235,3 +235,11 @@ config MMC_TMIO
 	help
 	  This provides support for the SD/MMC cell found in TC6393XB,
 	  T7L66XB and also ipaq ASIC3
+
+config MMC_TST
+    bool "MMC insert/removal auto test support"
+    default n
+    help
+           This flag controls Motorola specific changes that allows to
+           simulate MMC card insert/removal in software way instead of
+           doing it manually.
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index edd99b7..f91b209 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -10,6 +10,8 @@
  *	Madhusudhan		<madhu.cr@ti.com>
  *	Mohit Jalori		<mjalori@ti.com>
  *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
  * This file is licensed under the terms of the GNU General Public License
  * version 2. This program is licensed "as is" without any warranty of any
  * kind, whether express or implied.
@@ -32,6 +34,7 @@
 #include <mach/board.h>
 #include <mach/mmc.h>
 #include <mach/cpu.h>
+#include <mach/control.h>
 
 /* OMAP HSMMC Host Controller Registers */
 #define OMAP_HSMMC_SYSCONFIG	0x0010
@@ -150,6 +153,7 @@ struct mmc_omap_host {
 	int			slot_id;
 	int			dbclk_enabled;
 	int 			clks_enabled;
+	/* Clocks lock to prevent race condition */
 	spinlock_t		clk_lock;
 	struct timer_list	inact_timer;
 	struct	omap_mmc_platform_data	*pdata;
@@ -407,10 +411,7 @@ omap_hsmmc_inact_timer(unsigned long data)
 {
 	struct mmc_omap_host *host = (struct mmc_omap_host *) data;
 
-	if (host->mrq)
-		mod_timer(&host->inact_timer, jiffies + msecs_to_jiffies(1000));
-	else
-		omap_hsmmc_disable_clks(host);
+	omap_hsmmc_disable_clks(host);
 }
 
 /*
@@ -561,6 +562,9 @@ static irqreturn_t mmc_omap_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+
+
+
 /*
  * Switch MMC interface voltage ... only relevant for MMC1.
  *
@@ -575,7 +579,6 @@ static int omap_mmc_switch_opcond(struct mmc_omap_host *host, int vdd)
 
 	if (host->id != OMAP_MMC1_DEVID)
 		return 0;
-
 	/* Disable the clocks */
 	omap_hsmmc_disable_clks(host);
 
@@ -1027,6 +1030,19 @@ static struct mmc_host_ops mmc_omap_ops = {
 	/* NYET -- enable_sdio_irq */
 };
 
+#ifdef CONFIG_MMC_TST
+
+static struct mmc_omap_host *hsmmc_host;
+
+void hsmmc_schedule_4test(int carddetect)
+{
+      printk(KERN_ERR"carddetect=%d\n", carddetect);
+      hsmmc_host->carddetect = carddetect;
+      schedule_work(&hsmmc_host->mmc_carddetect_work);
+}
+EXPORT_SYMBOL(hsmmc_schedule_4test);
+#endif
+
 static int __init omap_mmc_probe(struct platform_device *pdev)
 {
 	struct omap_mmc_platform_data *pdata = pdev->dev.platform_data;
@@ -1213,6 +1229,10 @@ static int __init omap_mmc_probe(struct platform_device *pdev)
 		if (ret < 0)
 			goto err_cover_switch;
 	}
+#ifdef CONFIG_MMC_TST
+		if (host->id == OMAP_MMC1_DEVID)
+			hsmmc_host = host;
+#endif
 
 	return 0;
 
@@ -1275,6 +1295,7 @@ static int omap_mmc_remove(struct platform_device *pdev)
 	return 0;
 }
 
+
 #ifdef CONFIG_PM
 static int omap_mmc_suspend(struct platform_device *pdev, pm_message_t state)
 {
@@ -1355,6 +1376,7 @@ static int omap_mmc_resume(struct platform_device *pdev)
 #define omap_mmc_resume		NULL
 #endif
 
+
 static struct platform_driver omap_mmc_driver = {
 	.probe		= omap_mmc_probe,
 	.remove		= omap_mmc_remove,
diff --git a/drivers/mtd/mtdoops.c b/drivers/mtd/mtdoops.c
index 1a6b3be..ce547c3 100644
--- a/drivers/mtd/mtdoops.c
+++ b/drivers/mtd/mtdoops.c
@@ -335,7 +335,7 @@ static void mtdoops_console_sync(void)
 		/* Interrupt context, we're going to panic so try and log */
 		mtdoops_write(cxt, 1);
 	else
-		schedule_work(&cxt->work_write);
+		mtdoops_write(cxt, 0);
 }
 
 static void
@@ -375,7 +375,7 @@ mtdoops_console_write(struct console *co, const char *s, unsigned int count)
 
 	spin_unlock_irqrestore(&cxt->writecount_lock, flags);
 
-	if (cxt->writecount == OOPS_PAGE_SIZE)
+	if ((cxt->writecount == OOPS_PAGE_SIZE) && !in_interrupt())
 		mtdoops_console_sync();
 }
 
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index a0e8e0e..c5c6399 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -88,6 +88,13 @@ config MTD_NAND_OMAP_HWECC
           The ECC compuatation for the data to be written/read can be either by
           software or omap has Hw ecc engine which calculates it.
 
+config MTD_NAND_OMAP_PREFETCH
+	bool "MTD NAND OMAP PREFETCH"
+	depends on MTD_NAND && MTD_NAND_OMAP2
+	default n
+	help
+	 The NAND device can be accessed for Read/Write using GPMC PREFETCH engine
+	 to improve the performance.
 config MTD_NAND_OMAP
 	tristate "NAND Flash device on OMAP H3/H2/P2 boards"
 	depends on ARM && ARCH_OMAP1 && MTD_NAND && (MACH_OMAP_H2 || MACH_OMAP_H3 || MACH_OMAP_PERSEUS2)
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 412df7c..e855898 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -722,11 +722,10 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 	 * any case on any machine. */
 	ndelay(100);
 
-	if (!(chip->dev_ready))
-		if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
-			chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
-		else
-			chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
+		chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
+	else
+		chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
 
 	while (time_before(jiffies, timeo)) {
 		if (chip->dev_ready) {
@@ -740,11 +739,6 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 	}
 	led_trigger_event(nand_led_trigger, LED_OFF);
 
-	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
-		chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
-	else
-		chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
-
 	status = (int)chip->read_byte(mtd);
 	return status;
 }
@@ -2029,6 +2023,15 @@ int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 	DEBUG(MTD_DEBUG_LEVEL3, "nand_erase: start = 0x%012llx, len = %llu\n",
 	      (unsigned long long)instr->addr, (unsigned long long)instr->len);
 
+	/* if attempt to erase nand flash physical block# 0,
+	 * dump stack and panic the phone ...
+	*/
+	if (!(instr->addr)) {
+		dump_stack();
+		panic("%s: nand flash physical block: 0x%12llx\n", __func__,
+		  (unsigned long long)instr->addr);
+	}
+
 	/* Start address must align on block boundary */
 	if (instr->addr & ((1 << chip->phys_erase_shift) - 1)) {
 		DEBUG(MTD_DEBUG_LEVEL0, "nand_erase: Unaligned address\n");
diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c
index ca3baac..42d22d8 100644
--- a/drivers/mtd/nand/omap2.c
+++ b/drivers/mtd/nand/omap2.c
@@ -125,6 +125,9 @@ struct omap_nand_info {
 	unsigned long			phys_base;
 	void __iomem			*gpmc_cs_baseaddr;
 	void __iomem			*gpmc_baseaddr;
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+	void __iomem			*nand_pref_fifo_add;
+#endif
 	bool				wait_for_rb;
 };
 
@@ -244,6 +247,82 @@ static void omap_write_buf16(struct mtd_info *mtd, const u_char * buf, int len)
 						GPMC_STATUS) & GPMC_BUF_FULL));
 	}
 }
+
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+/*
+ * omap_read_buf_pref - read data from NAND controller into buffer
+ * @mtd: MTD device structure
+ * @buf: buffer to store date
+ * @len: number of bytes to read
+ */
+static void omap_read_buf_pref(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct omap_nand_info *info = container_of(mtd,
+						struct omap_nand_info, mtd);
+	uint32_t prefetch_status = 0, read_count = 0;
+	u32 *p = (u32 *)buf;
+
+	/* take care of subpage reads */
+	for (; len % 4 != 0; ) {
+		*buf++ = __raw_readb(info->nand.IO_ADDR_R);
+		len--;
+	}
+	p = (u32 *) buf;
+
+	/* configure and start prefetch transfer */
+	gpmc_prefetch_start(info->gpmc_cs, 0x0, len, 0x0);
+
+	do {
+		prefetch_status = gpmc_prefetch_status();
+		read_count = ((prefetch_status >> 24) & 0x7F) >> 2;
+		__raw_readsl(info->nand_pref_fifo_add, p,
+						read_count);
+		p += read_count;
+		len -= read_count << 2;
+	} while (len);
+
+	/* disable and stop the PFPW engine */
+	gpmc_prefetch_stop();
+}
+
+/*
+ * omap_write_buf_pref - write buffer to NAND controller
+ * @mtd: MTD device structure
+ * @buf: data buffer
+ * @len: number of bytes to write
+ */
+static void omap_write_buf_pref(struct mtd_info *mtd,
+					const u_char *buf, int len)
+{
+	struct omap_nand_info *info = container_of(mtd,
+						struct omap_nand_info, mtd);
+	uint32_t prefetch_status = 0, write_count = 0;
+	int i = 0;
+	u16 *p = (u16 *) buf;
+
+
+	/* take care of subpage writes */
+	if (len % 2 != 0) {
+		writeb(*buf, info->nand.IO_ADDR_R);
+		p = (u16 *)(buf + 1);
+		len--;
+	}
+
+	/*  configure and start prefetch transfer */
+	gpmc_prefetch_start(info->gpmc_cs, 0x0, len, 0x1);
+
+	prefetch_status = gpmc_prefetch_status();
+	while (prefetch_status & 0x3FFF) {
+		write_count = ((prefetch_status >> 24) & 0x7F) >> 1;
+		for (i = 0; (i < write_count) && len; i++, len -= 2)
+			__raw_writew(*p++, info->nand_pref_fifo_add);
+			prefetch_status = gpmc_prefetch_status();
+	}
+
+	/* disable and stop the PFPW engine */
+	gpmc_prefetch_stop();
+}
+#endif /* CONFIG_MTD_NAND_OMAP_PREFETCH */
 /*
  * omap_verify_buf - Verify chip data against buffer
  * @mtd: MTD device structure
@@ -588,7 +667,7 @@ static int omap_dev_ready(struct mtd_info *mtd)
 	do {
 		now = jiffies;
 		ret = __raw_readl(info->gpmc_baseaddr + GPMC_IRQSTATUS) & 0x100;
-	} while(!ret && time_before_eq(now, timeout));
+	} while (!ret && time_before_eq(now, timeout));
 
 	if (ret) {
 		__raw_writel(0x100, info->gpmc_baseaddr + GPMC_IRQSTATUS);
@@ -664,17 +743,23 @@ static int __devinit omap_nand_probe(struct platform_device *pdev)
 		err = -ENOMEM;
 		goto out_release_mem_region;
 	}
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+		info->nand_pref_fifo_add = info->nand.IO_ADDR_R;
+#endif
 	info->nand.controller = &info->controller;
 
 	info->nand.IO_ADDR_W = info->nand.IO_ADDR_R;
 	info->nand.cmd_ctrl  = omap_hwcontrol;
 
 	/* REVISIT:  only supports 16-bit NAND flash */
-
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+	info->nand.read_buf   = omap_read_buf_pref;
+	info->nand.write_buf  = omap_write_buf_pref;
+#else
 	info->nand.read_buf   = omap_read_buf16;
 	info->nand.write_buf  = omap_write_buf16;
+#endif
 	info->nand.verify_buf = omap_verify_buf;
-
 	/*
 	* If RDY/BSY line is connected to OMAP then use the omap ready funcrtion
 	* and the generic nand_wait function which reads the status register
@@ -752,7 +837,11 @@ static int omap_nand_remove(struct platform_device *pdev)
 	platform_set_drvdata(pdev, NULL);
 	/* Release NAND device, its internal structures and partitions */
 	nand_release(&info->mtd);
+#ifdef CONFIG_MTD_NAND_OMAP_PREFETCH
+	iounmap(info->nand_pref_fifo_add);
+#else
 	iounmap(info->nand.IO_ADDR_R);
+#endif
 	kfree(&info->mtd);
 	return 0;
 }
diff --git a/drivers/net/pppolac.c b/drivers/net/pppolac.c
index b4d879d..af3202a 100644
--- a/drivers/net/pppolac.c
+++ b/drivers/net/pppolac.c
@@ -3,7 +3,6 @@
  * Driver for PPP on L2TP Access Concentrator / PPPoLAC Socket (RFC 2661)
  *
  * Copyright (C) 2009 Google, Inc.
- * Author: Chia-chi Yeh <chiachi@android.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -22,8 +21,10 @@
  * only works on IPv4 due to the lack of UDP encapsulation support in IPv6. */
 
 #include <linux/module.h>
+#include <linux/workqueue.h>
 #include <linux/skbuff.h>
 #include <linux/file.h>
+#include <linux/netdevice.h>
 #include <linux/net.h>
 #include <linux/udp.h>
 #include <linux/ppp_defs.h>
@@ -31,6 +32,7 @@
 #include <linux/if_pppox.h>
 #include <linux/ppp_channel.h>
 #include <net/tcp_states.h>
+#include <asm/uaccess.h>
 
 #define L2TP_CONTROL_BIT	0x80
 #define L2TP_LENGTH_BIT		0x40
@@ -51,10 +53,10 @@ static inline union unaligned *unaligned(void *ptr)
 	return (union unaligned *)ptr;
 }
 
-static int pppolac_recv(struct sock *sk_udp, struct sk_buff *skb)
+static int pppolac_recv_core(struct sock *sk_udp, struct sk_buff *skb)
 {
-	struct sock *sk;
-	struct pppolac_opt *opt;
+	struct sock *sk = (struct sock *)sk_udp->sk_user_data;
+	struct pppolac_opt *opt = &pppox_sk(sk)->proto.lac;
 	__u8 bits;
 	__u8 *ptr;
 
@@ -64,9 +66,9 @@ static int pppolac_recv(struct sock *sk_udp, struct sk_buff *skb)
 
 	/* Put it back if it is a control packet. */
 	if (skb->data[sizeof(struct udphdr)] & L2TP_CONTROL_BIT)
-		return 1;
+		return opt->backlog_rcv(sk_udp, skb);
 
-	/* Now the packet is ours. Skip UDP header. */
+	/* Skip UDP header. */
 	skb_pull(skb, sizeof(struct udphdr));
 
 	/* Check the version. */
@@ -93,26 +95,12 @@ static int pppolac_recv(struct sock *sk_udp, struct sk_buff *skb)
 			!skb_pull(skb, skb->data[-2] << 8 | skb->data[-1]))
 		goto drop;
 
-	/* Now ptr is pointing to the tunnel and skb is pointing to the payload.
-	 * We have to lock sk_udp to prevent sk from being closed. */
-	lock_sock(sk_udp);
-	sk = sk_udp->sk_user_data;
-	if (!sk) {
-		release_sock(sk_udp);
-		goto drop;
-	}
-	sock_hold(sk);
-	release_sock(sk_udp);
-	opt = &pppox_sk(sk)->proto.lac;
-
 	/* Check the tunnel and the session. */
-	if (unaligned(ptr)->u32 != opt->local) {
-		sock_put(sk);
+	if (unaligned(ptr)->u32 != opt->local)
 		goto drop;
-	}
 
-	/* Check the sequence if it is present. According to RFC 2661 page 10
-	 * and 43, the only thing to do is updating opt->sequencing. */
+	/* Check the sequence if it is present. According to RFC 2661 section
+	 * 5.4, the only thing to do is to update opt->sequencing. */
 	opt->sequencing = bits & L2TP_SEQUENCE_BIT;
 
 	/* Skip PPP address and control if they are present. */
@@ -124,26 +112,50 @@ static int pppolac_recv(struct sock *sk_udp, struct sk_buff *skb)
 	if (skb->len >= 1 && skb->data[0] & 1)
 		skb_push(skb, 1)[0] = 0;
 
-	/* Finally, deliver the packet to PPP channel. We have to lock sk to
-	 * prevent another thread from calling pppox_unbind_sock(). */
+	/* Finally, deliver the packet to PPP channel. */
 	skb_orphan(skb);
-	lock_sock(sk);
 	ppp_input(&pppox_sk(sk)->chan, skb);
-	release_sock(sk);
-	sock_put(sk);
-	return 0;
-
+	return NET_RX_SUCCESS;
 drop:
 	kfree_skb(skb);
+	return NET_RX_DROP;
+}
+
+static int pppolac_recv(struct sock *sk_udp, struct sk_buff *skb)
+{
+	sock_hold(sk_udp);
+	sk_receive_skb(sk_udp, skb, 0);
 	return 0;
 }
 
+static struct sk_buff_head delivery_queue;
+
+static void pppolac_xmit_core(struct work_struct *delivery_work)
+{
+	mm_segment_t old_fs = get_fs();
+	struct sk_buff *skb;
+
+	set_fs(KERNEL_DS);
+	while ((skb = skb_dequeue(&delivery_queue))) {
+		struct sock *sk_udp = skb->sk;
+		struct kvec iov = {.iov_base = skb->data, .iov_len = skb->len};
+		struct msghdr msg = {
+			.msg_iov = (struct iovec *)&iov,
+			.msg_iovlen = 1,
+			.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT,
+		};
+		sk_udp->sk_prot->sendmsg(NULL, sk_udp, &msg, skb->len);
+		kfree_skb(skb);
+	}
+	set_fs(old_fs);
+}
+
+static DECLARE_WORK(delivery_work, pppolac_xmit_core);
+
 static int pppolac_xmit(struct ppp_channel *chan, struct sk_buff *skb)
 {
 	struct sock *sk_udp = (struct sock *)chan->private;
 	struct pppolac_opt *opt = &pppox_sk(sk_udp->sk_user_data)->proto.lac;
-	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT};
-	struct kvec iov;
 
 	/* Install PPP address and control. */
 	skb_push(skb, 2);
@@ -166,11 +178,10 @@ static int pppolac_xmit(struct ppp_channel *chan, struct sk_buff *skb)
 	skb->data[1] = L2TP_VERSION;
 	unaligned(&skb->data[2])->u32 = opt->remote;
 
-	/* Now send the packet via UDP socket. */
-	iov.iov_base = skb->data;
-	iov.iov_len = skb->len;
-	kernel_sendmsg(sk_udp->sk_socket, &msg, &iov, 1, skb->len);
-	kfree_skb(skb);
+	/* Now send the packet via the delivery queue. */
+	skb_set_owner_w(skb, sk_udp);
+	skb_queue_tail(&delivery_queue, skb);
+	schedule_work(&delivery_work);
 	return 1;
 }
 
@@ -235,6 +246,7 @@ static int pppolac_connect(struct socket *sock, struct sockaddr *useraddr,
 	po->chan.mtu = PPP_MTU - 80;
 	po->proto.lac.local = unaligned(&addr->local)->u32;
 	po->proto.lac.remote = unaligned(&addr->remote)->u32;
+	po->proto.lac.backlog_rcv = sk_udp->sk_backlog_rcv;
 
 	error = ppp_register_channel(&po->chan);
 	if (error)
@@ -243,8 +255,8 @@ static int pppolac_connect(struct socket *sock, struct sockaddr *useraddr,
 	sk->sk_state = PPPOX_CONNECTED;
 	udp_sk(sk_udp)->encap_type = UDP_ENCAP_L2TPINUDP;
 	udp_sk(sk_udp)->encap_rcv = pppolac_recv;
+	sk_udp->sk_backlog_rcv = pppolac_recv_core;
 	sk_udp->sk_user_data = sk;
-
 out:
 	if (sock_udp) {
 		release_sock(sk_udp);
@@ -270,12 +282,12 @@ static int pppolac_release(struct socket *sock)
 
 	if (sk->sk_state != PPPOX_NONE) {
 		struct sock *sk_udp = (struct sock *)pppox_sk(sk)->chan.private;
-		pppox_unbind_sock(sk);
-
 		lock_sock(sk_udp);
-		sk_udp->sk_user_data = NULL;
+		pppox_unbind_sock(sk);
 		udp_sk(sk_udp)->encap_type = 0;
 		udp_sk(sk_udp)->encap_rcv = NULL;
+		sk_udp->sk_backlog_rcv = pppox_sk(sk)->proto.lac.backlog_rcv;
+		sk_udp->sk_user_data = NULL;
 		release_sock(sk_udp);
 		sockfd_put(sk_udp->sk_socket);
 	}
@@ -349,6 +361,8 @@ static int __init pppolac_init(void)
 	error = register_pppox_proto(PX_PROTO_OLAC, &pppolac_pppox_proto);
 	if (error)
 		proto_unregister(&pppolac_proto);
+	else
+		skb_queue_head_init(&delivery_queue);
 	return error;
 }
 
diff --git a/drivers/net/pppopns.c b/drivers/net/pppopns.c
index eae4bda..2980971 100644
--- a/drivers/net/pppopns.c
+++ b/drivers/net/pppopns.c
@@ -3,7 +3,6 @@
  * Driver for PPP on PPTP Network Server / PPPoPNS Socket (RFC 2637)
  *
  * Copyright (C) 2009 Google, Inc.
- * Author: Chia-chi Yeh <chiachi@android.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -22,14 +21,17 @@
  * and IPv6. */
 
 #include <linux/module.h>
+#include <linux/workqueue.h>
 #include <linux/skbuff.h>
 #include <linux/file.h>
+#include <linux/netdevice.h>
 #include <linux/net.h>
 #include <linux/ppp_defs.h>
 #include <linux/if.h>
 #include <linux/if_ppp.h>
 #include <linux/if_pppox.h>
 #include <linux/ppp_channel.h>
+#include <asm/uaccess.h>
 
 #define GRE_HEADER_SIZE		8
 
@@ -50,76 +52,90 @@ struct header {
 	__u32	sequence;
 } __attribute__((packed));
 
-static void pppopns_recv(struct sock *sk_raw, int length)
+static int pppopns_recv_core(struct sock *sk_raw, struct sk_buff *skb)
 {
-	struct sock *sk;
-	struct pppopns_opt *opt;
-	struct sk_buff *skb;
+	struct sock *sk = (struct sock *)sk_raw->sk_user_data;
+	struct pppopns_opt *opt = &pppox_sk(sk)->proto.pns;
 	struct header *hdr;
 
-	/* Lock sk_raw to prevent sk from being closed. */
-	lock_sock(sk_raw);
-	sk = (struct sock *)sk_raw->sk_user_data;
-	if (!sk) {
-		release_sock(sk_raw);
-		return;
-	}
-	sock_hold(sk);
-	release_sock(sk_raw);
-	opt = &pppox_sk(sk)->proto.pns;
-
-	/* Process packets from the receive queue. */
-	while ((skb = skb_dequeue(&sk_raw->sk_receive_queue))) {
-		skb_pull(skb, skb_transport_header(skb) - skb->data);
+	/* Skip transport header */
+	skb_pull(skb, skb_transport_header(skb) - skb->data);
 
-		/* Drop the packet if it is too short. */
-		if (skb->len < GRE_HEADER_SIZE)
-			goto drop;
+	/* Drop the packet if it is too short. */
+	if (skb->len < GRE_HEADER_SIZE)
+		goto drop;
 
-		/* Check the header. */
-		hdr = (struct header *)skb->data;
-		if (hdr->type != PPTP_GRE_TYPE || hdr->call != opt->local ||
+	/* Check the header. */
+	hdr = (struct header *)skb->data;
+	if (hdr->type != PPTP_GRE_TYPE || hdr->call != opt->local ||
 			(hdr->bits & PPTP_GRE_BITS_MASK) != PPTP_GRE_BITS)
-			goto drop;
-
-		/* Skip all fields including optional ones. */
-		if (!skb_pull(skb, GRE_HEADER_SIZE +
-				(hdr->bits & PPTP_GRE_SEQ_BIT ? 4 : 0) +
-				(hdr->bits & PPTP_GRE_ACK_BIT ? 4 : 0)))
-			goto drop;
-
-		/* Check the length. */
-		if (skb->len != ntohs(hdr->length))
-			goto drop;
-
-		/* Skip PPP address and control if they are present. */
-		if (skb->len >= 2 && skb->data[0] == PPP_ADDR &&
-				skb->data[1] == PPP_CTRL)
-			skb_pull(skb, 2);
-
-		/* Fix PPP protocol if it is compressed. */
-		if (skb->len >= 1 && skb->data[0] & 1)
-			skb_push(skb, 1)[0] = 0;
-
-		/* Deliver the packet to PPP channel. We have to lock sk to
-		 * prevent another thread from calling pppox_unbind_sock(). */
-		skb_orphan(skb);
-		lock_sock(sk);
-		ppp_input(&pppox_sk(sk)->chan, skb);
-		release_sock(sk);
-		continue;
+		goto drop;
+
+	/* Skip all fields including optional ones. */
+	if (!skb_pull(skb, GRE_HEADER_SIZE +
+			(hdr->bits & PPTP_GRE_SEQ_BIT ? 4 : 0) +
+			(hdr->bits & PPTP_GRE_ACK_BIT ? 4 : 0)))
+		goto drop;
+
+	/* Check the length. */
+	if (skb->len != ntohs(hdr->length))
+		goto drop;
+
+	/* Skip PPP address and control if they are present. */
+	if (skb->len >= 2 && skb->data[0] == PPP_ADDR &&
+			skb->data[1] == PPP_CTRL)
+		skb_pull(skb, 2);
+
+	/* Fix PPP protocol if it is compressed. */
+	if (skb->len >= 1 && skb->data[0] & 1)
+		skb_push(skb, 1)[0] = 0;
+
+	/* Finally, deliver the packet to PPP channel. */
+	skb_orphan(skb);
+	ppp_input(&pppox_sk(sk)->chan, skb);
+	return NET_RX_SUCCESS;
 drop:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
+
+static void pppopns_recv(struct sock *sk_raw, int length)
+{
+	struct sk_buff *skb;
+	while ((skb = skb_dequeue(&sk_raw->sk_receive_queue))) {
+		sock_hold(sk_raw);
+		sk_receive_skb(sk_raw, skb, 0);
+	}
+}
+
+static struct sk_buff_head delivery_queue;
+
+static void pppopns_xmit_core(struct work_struct *delivery_work)
+{
+	mm_segment_t old_fs = get_fs();
+	struct sk_buff *skb;
+
+	set_fs(KERNEL_DS);
+	while ((skb = skb_dequeue(&delivery_queue))) {
+		struct sock *sk_raw = skb->sk;
+		struct kvec iov = {.iov_base = skb->data, .iov_len = skb->len};
+		struct msghdr msg = {
+			.msg_iov = (struct iovec *)&iov,
+			.msg_iovlen = 1,
+			.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT,
+		};
+		sk_raw->sk_prot->sendmsg(NULL, sk_raw, &msg, skb->len);
 		kfree_skb(skb);
 	}
-	sock_put(sk);
+	set_fs(old_fs);
 }
 
+static DECLARE_WORK(delivery_work, pppopns_xmit_core);
+
 static int pppopns_xmit(struct ppp_channel *chan, struct sk_buff *skb)
 {
 	struct sock *sk_raw = (struct sock *)chan->private;
 	struct pppopns_opt *opt = &pppox_sk(sk_raw->sk_user_data)->proto.pns;
-	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT};
-	struct kvec iov;
 	struct header *hdr;
 	__u16 length;
 
@@ -138,11 +154,10 @@ static int pppopns_xmit(struct ppp_channel *chan, struct sk_buff *skb)
 	hdr->sequence = htonl(opt->sequence);
 	opt->sequence++;
 
-	/* Now send the packet via RAW socket. */
-	iov.iov_base = skb->data;
-	iov.iov_len = skb->len;
-	kernel_sendmsg(sk_raw->sk_socket, &msg, &iov, 1, skb->len);
-	kfree_skb(skb);
+	/* Now send the packet via the delivery queue. */
+	skb_set_owner_w(skb, sk_raw);
+	skb_queue_tail(&delivery_queue, skb);
+	schedule_work(&delivery_work);
 	return 1;
 }
 
@@ -208,15 +223,19 @@ static int pppopns_connect(struct socket *sock, struct sockaddr *useraddr,
 	po->chan.mtu = PPP_MTU - 80;
 	po->proto.pns.local = addr->local;
 	po->proto.pns.remote = addr->remote;
+	po->proto.pns.data_ready = sk_raw->sk_data_ready;
+	po->proto.pns.backlog_rcv = sk_raw->sk_backlog_rcv;
 
 	error = ppp_register_channel(&po->chan);
 	if (error)
 		goto out;
 
 	sk->sk_state = PPPOX_CONNECTED;
-	sk_raw->sk_user_data = sk;
+	lock_sock(sk_raw);
 	sk_raw->sk_data_ready = pppopns_recv;
-
+	sk_raw->sk_backlog_rcv = pppopns_recv_core;
+	sk_raw->sk_user_data = sk;
+	release_sock(sk_raw);
 out:
 	if (sock_tcp)
 		sockfd_put(sock_tcp);
@@ -241,8 +260,10 @@ static int pppopns_release(struct socket *sock)
 
 	if (sk->sk_state != PPPOX_NONE) {
 		struct sock *sk_raw = (struct sock *)pppox_sk(sk)->chan.private;
-		pppox_unbind_sock(sk);
 		lock_sock(sk_raw);
+		pppox_unbind_sock(sk);
+		sk_raw->sk_data_ready = pppox_sk(sk)->proto.pns.data_ready;
+		sk_raw->sk_backlog_rcv = pppox_sk(sk)->proto.pns.backlog_rcv;
 		sk_raw->sk_user_data = NULL;
 		release_sock(sk_raw);
 		sock_release(sk_raw->sk_socket);
@@ -317,6 +338,8 @@ static int __init pppopns_init(void)
 	error = register_pppox_proto(PX_PROTO_OPNS, &pppopns_pppox_proto);
 	if (error)
 		proto_unregister(&pppopns_proto);
+	else
+		skb_queue_head_init(&delivery_queue);
 	return error;
 }
 
diff --git a/drivers/power/cpcap-battery.c b/drivers/power/cpcap-battery.c
index 94092e8..19954c3 100644
--- a/drivers/power/cpcap-battery.c
+++ b/drivers/power/cpcap-battery.c
@@ -16,6 +16,7 @@
  * 02111-1307, USA
  */
 
+#include <asm/div64.h>
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/init.h>
@@ -25,10 +26,12 @@
 #include <linux/poll.h>
 #include <linux/power_supply.h>
 #include <linux/types.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/spi/cpcap.h>
 #include <linux/spi/cpcap-regbits.h>
 #include <linux/spi/spi.h>
+#include <linux/time.h>
 #include <linux/miscdevice.h>
 
 #define CPCAP_BATT_IRQ_BATTDET 0x01
@@ -47,6 +50,7 @@ static ssize_t cpcap_batt_read(struct file *file, char *buf, size_t count,
 			       loff_t *ppos);
 static int cpcap_batt_probe(struct platform_device *pdev);
 static int cpcap_batt_remove(struct platform_device *pdev);
+static int cpcap_batt_resume(struct platform_device *pdev);
 
 struct cpcap_batt_ps {
 	struct power_supply batt;
@@ -62,6 +66,7 @@ struct cpcap_batt_ps {
 	char data_pending;
 	wait_queue_head_t wait;
 	char async_req_pending;
+	unsigned long last_run_time;
 };
 
 static const struct file_operations batt_fops = {
@@ -103,6 +108,7 @@ static enum power_supply_property cpcap_batt_usb_props[] =
 static struct platform_driver cpcap_batt_driver = {
 	.probe		= cpcap_batt_probe,
 	.remove		= cpcap_batt_remove,
+	.resume		= cpcap_batt_resume,
 	.driver		= {
 		.name	= "cpcap_battery",
 		.owner	= THIS_MODULE,
@@ -116,7 +122,7 @@ void cpcap_batt_irq_hdlr(enum cpcap_irqs irq, void *data)
 	struct cpcap_batt_ps *sply = data;
 
 	mutex_lock(&sply->lock);
-
+printk(KERN_ERR "cpcap_batt_irq_hdlr: irq = %d\n", irq);
 	sply->data_pending = 1;
 
 	switch (irq) {
@@ -191,6 +197,7 @@ static ssize_t cpcap_batt_read(struct file *file,
 {
 	struct cpcap_batt_ps *sply = file->private_data;
 	int ret = -EFBIG;
+	unsigned long long temp;
 
 	if (count >= sizeof(char)) {
 		mutex_lock(&sply->lock);
@@ -200,6 +207,10 @@ static ssize_t cpcap_batt_read(struct file *file,
 		else
 			ret = -EFAULT;
 		sply->data_pending = 0;
+		temp = sched_clock();
+		do_div(temp, NSEC_PER_SEC);
+		sply->last_run_time = (unsigned long)temp;
+
 		sply->irq_status = 0;
 		mutex_unlock(&sply->lock);
 	}
@@ -560,6 +571,32 @@ static int cpcap_batt_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int cpcap_batt_resume(struct platform_device *pdev)
+{
+	struct cpcap_batt_ps *sply = platform_get_drvdata(pdev);
+	unsigned long cur_time;
+	unsigned long long temp;
+
+	temp = sched_clock();
+	do_div(temp, NSEC_PER_SEC);
+	cur_time = ((unsigned long)temp);
+	if ((cur_time - sply->last_run_time) < 0)
+		sply->last_run_time = 0;
+
+	if ((cur_time - sply->last_run_time) > 50) {
+		mutex_lock(&sply->lock);
+printk(KERN_ERR "cpcap_batt_resume: Wakeup! \n");
+		sply->data_pending = 1;
+		sply->irq_status |= CPCAP_BATT_IRQ_MACRO;
+
+		mutex_unlock(&sply->lock);
+
+		wake_up_interruptible(&sply->wait);
+	}
+
+	return 0;
+}
+
 void cpcap_batt_set_ac_prop(struct cpcap_device *cpcap, int online)
 {
 	struct cpcap_batt_ps *sply = cpcap->battdata;
diff --git a/drivers/regulator/cpcap-regulator.c b/drivers/regulator/cpcap-regulator.c
index 443cccc..6f318e8 100644
--- a/drivers/regulator/cpcap-regulator.c
+++ b/drivers/regulator/cpcap-regulator.c
@@ -70,50 +70,240 @@ static struct {
 	const unsigned short volt_mask;
 	const unsigned char volt_shft;
 	unsigned short mode_val;
+	unsigned short off_mode_val;
 	const int val_tbl_sz;
 	const int *val_tbl;
 	unsigned int mode_cntr;
 	const unsigned int volt_trans_time; /* in micro seconds */
 	const unsigned int turn_on_time; /* in micro seconds */
 } cpcap_regltr_data[CPCAP_NUM_REGULATORS] = {
-	[CPCAP_SW5]      = {CPCAP_REG_S5C, 0x002A, 0x0000, 0, 0x0000,
-		ARRAY_SIZE(sw5_val_tbl), sw5_val_tbl, 0, 0, 1500},
-	[CPCAP_VCAM]     = {CPCAP_REG_VCAMC, 0x0087, 0x0030, 4, 0x0000,
-		ARRAY_SIZE(vcam_val_tbl), vcam_val_tbl, 0, 420, 1000},
-	[CPCAP_VCSI]     = {CPCAP_REG_VCSIC, 0x0047, 0x0010, 4, 0x0000,
-		ARRAY_SIZE(vcsi_val_tbl), vcsi_val_tbl, 0, 350, 1000},
-	[CPCAP_VDAC]     = {CPCAP_REG_VDACC, 0x0087, 0x0030, 4, 0x0000,
-		ARRAY_SIZE(vdac_val_tbl), vdac_val_tbl, 0, 420, 1000},
-	[CPCAP_VDIG]     = {CPCAP_REG_VDIGC, 0x0087, 0x0030, 4, 0x0000,
-		ARRAY_SIZE(vdig_val_tbl), vdig_val_tbl, 0, 420, 1000},
-	[CPCAP_VFUSE]    = {CPCAP_REG_VFUSEC, 0x0080, 0x000F, 0, 0x0000,
-		ARRAY_SIZE(vfuse_val_tbl), vfuse_val_tbl, 0, 420, 1000},
-	[CPCAP_VHVIO]    = {CPCAP_REG_VHVIOC, 0x0017, 0x0000, 0, 0x0000,
-		ARRAY_SIZE(vhvio_val_tbl), vhvio_val_tbl, 0, 0, 1000},
-	[CPCAP_VSDIO]    = {CPCAP_REG_VSDIOC, 0x0087, 0x0038, 3, 0x0000,
-		ARRAY_SIZE(vsdio_val_tbl), vsdio_val_tbl, 0, 420, 1000},
-	[CPCAP_VPLL]     = {CPCAP_REG_VPLLC, 0x0043, 0x0018, 3, 0x0000,
-		ARRAY_SIZE(vpll_val_tbl), vpll_val_tbl, 0, 420, 100},
-	[CPCAP_VRF1]     = {CPCAP_REG_VRF1C, 0x008C, 0x0020, 5, 0x0000,
-		ARRAY_SIZE(vrf1_val_tbl), vrf1_val_tbl, 0, 10, 1000},
-	[CPCAP_VRF2]     = {CPCAP_REG_VRF2C, 0x0023, 0x0008, 3, 0x0000,
-		ARRAY_SIZE(vrf2_val_tbl), vrf2_val_tbl, 0, 10, 1000},
-	[CPCAP_VRFREF]   = {CPCAP_REG_VRFREFC, 0x0023, 0x0008, 3, 0x0000,
-		ARRAY_SIZE(vrfref_val_tbl), vrfref_val_tbl, 0, 420, 100},
-	[CPCAP_VWLAN1]   = {CPCAP_REG_VWLAN1C, 0x0047, 0x0010, 4, 0x0000,
-		ARRAY_SIZE(vwlan1_val_tbl), vwlan1_val_tbl, 0, 420, 1000},
-	[CPCAP_VWLAN2]   = {CPCAP_REG_VWLAN2C, 0x020C, 0x00C0, 6, 0x0000,
-		ARRAY_SIZE(vwlan2_val_tbl), vwlan2_val_tbl, 0, 420, 1000},
-	[CPCAP_VSIM]     = {CPCAP_REG_VSIMC, 0x0023, 0x0008, 3, 0x0000,
-		ARRAY_SIZE(vsim_val_tbl), vsim_val_tbl, 0, 420, 1000},
-	[CPCAP_VSIMCARD] = {CPCAP_REG_VSIMC, 0x1E80, 0x0008, 3, 0x0000,
-		ARRAY_SIZE(vsimcard_val_tbl), vsimcard_val_tbl, 0, 420, 1000},
-	[CPCAP_VVIB]     = {CPCAP_REG_VVIBC, 0x0001, 0x000C, 2, 0x0000,
-		ARRAY_SIZE(vvib_val_tbl), vvib_val_tbl, 0, 500, 500},
-	[CPCAP_VUSB]     = {CPCAP_REG_VUSBC, 0x011C, 0x0040, 6, 0x0000,
-		ARRAY_SIZE(vusb_val_tbl), vusb_val_tbl, 0, 0, 1000},
-	[CPCAP_VAUDIO]   = {CPCAP_REG_VAUDIOC, 0x0016, 0x0001, 0, 0x0000,
-		ARRAY_SIZE(vaudio_val_tbl), vaudio_val_tbl, 0, 0, 1000},
+	[CPCAP_SW5]      = {CPCAP_REG_S5C,
+			    0x002A,
+			    0x0000,
+			    0,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(sw5_val_tbl),
+			    sw5_val_tbl,
+			    0,
+			    0,
+			    1500},
+
+	[CPCAP_VCAM]     = {CPCAP_REG_VCAMC,
+			    0x0087,
+			    0x0030,
+			    4,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vcam_val_tbl),
+			    vcam_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VCSI]     = {CPCAP_REG_VCSIC,
+			    0x0047,
+			    0x0010,
+			    4,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vcsi_val_tbl),
+			    vcsi_val_tbl,
+			    0,
+			    350,
+			    1000},
+
+	[CPCAP_VDAC]     = {CPCAP_REG_VDACC,
+			    0x0087,
+			    0x0030,
+			    4,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vdac_val_tbl),
+			    vdac_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VDIG]     = {CPCAP_REG_VDIGC,
+			    0x0087,
+			    0x0030,
+			    4,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vdig_val_tbl),
+			    vdig_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VFUSE]    = {CPCAP_REG_VFUSEC,
+			    0x0080,
+			    0x000F,
+			    0,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vfuse_val_tbl),
+			    vfuse_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VHVIO]    = {CPCAP_REG_VHVIOC,
+			    0x0017,
+			    0x0000,
+			    0,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vhvio_val_tbl),
+			    vhvio_val_tbl,
+			    0,
+			    0,
+			    1000},
+
+	[CPCAP_VSDIO]    = {CPCAP_REG_VSDIOC,
+			    0x0087,
+			    0x0038,
+			    3,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vsdio_val_tbl),
+			    vsdio_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VPLL]     = {CPCAP_REG_VPLLC,
+			    0x0043,
+			    0x0018,
+			    3,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vpll_val_tbl),
+			    vpll_val_tbl,
+			    0,
+			    420,
+			    100},
+
+	[CPCAP_VRF1]     = {CPCAP_REG_VRF1C,
+			    0x00AC,
+			    0x0002,
+			    1,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vrf1_val_tbl),
+			    vrf1_val_tbl,
+			    0,
+			    10,
+			    1000},
+
+	[CPCAP_VRF2]     = {CPCAP_REG_VRF2C,
+			    0x0023,
+			    0x0008,
+			    3,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vrf2_val_tbl),
+			    vrf2_val_tbl,
+			    0,
+			    10,
+			    1000},
+
+	[CPCAP_VRFREF]   = {CPCAP_REG_VRFREFC,
+			    0x0023,
+			    0x0008,
+			    3,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vrfref_val_tbl),
+			    vrfref_val_tbl,
+			    0,
+			    420,
+			    100},
+
+	[CPCAP_VWLAN1]   = {CPCAP_REG_VWLAN1C,
+			    0x0047,
+			    0x0010,
+			    4,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vwlan1_val_tbl),
+			    vwlan1_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VWLAN2]   = {CPCAP_REG_VWLAN2C,
+			    0x020C,
+			    0x00C0,
+			    6,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vwlan2_val_tbl),
+			    vwlan2_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VSIM]     = {CPCAP_REG_VSIMC,
+			    0x0023,
+			    0x0008,
+			    3,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vsim_val_tbl),
+			    vsim_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VSIMCARD] = {CPCAP_REG_VSIMC,
+			    0x1E80,
+			    0x0008,
+			    3,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vsimcard_val_tbl),
+			    vsimcard_val_tbl,
+			    0,
+			    420,
+			    1000},
+
+	[CPCAP_VVIB]     = {CPCAP_REG_VVIBC,
+			    0x0001,
+			    0x000C,
+			    2,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vvib_val_tbl),
+			    vvib_val_tbl,
+			    0,
+			    500,
+			    500},
+
+	[CPCAP_VUSB]     = {CPCAP_REG_VUSBC,
+			    0x011C,
+			    0x0040,
+			    6,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vusb_val_tbl),
+			    vusb_val_tbl,
+			    0,
+			    0,
+			    1000},
+
+	[CPCAP_VAUDIO]   = {CPCAP_REG_VAUDIOC,
+			    0x0016,
+			    0x0001,
+			    0,
+			    0x0000,
+			    0x0000,
+			    ARRAY_SIZE(vaudio_val_tbl),
+			    vaudio_val_tbl,
+			    0,
+			    0,
+			    1000},
 };
 
 static int cpcap_regulator_set_voltage(struct regulator_dev *rdev,
@@ -221,7 +411,8 @@ static int cpcap_regulator_disable(struct regulator_dev *rdev)
 
 	regnr = cpcap_regltr_data[regltr_id].reg;
 
-	return cpcap_regacc_write(cpcap, regnr, 0,
+	return cpcap_regacc_write(cpcap, regnr,
+				  cpcap_regltr_data[regltr_id].off_mode_val,
 				  cpcap_regltr_data[regltr_id].mode_mask);
 }
 
@@ -324,8 +515,11 @@ static int __devinit cpcap_regulator_probe(struct platform_device *pdev)
 	cpcap = platform_get_drvdata(pdev);
 	data = cpcap->spi->controller_data;
 
-	for (i = 0; i <= CPCAP_NUM_REGULATORS; i++)
+	for (i = 0; i < CPCAP_NUM_REGULATORS; i++) {
 		cpcap_regltr_data[i].mode_val = data->regulator_mode_values[i];
+		cpcap_regltr_data[i].off_mode_val =
+			data->regulator_off_mode_values[i];
+	}
 
 	rdev = regulator_register(&regulators[pdev->id], &pdev->dev, cpcap);
 	if (IS_ERR(rdev))
diff --git a/drivers/rtc/alarm.c b/drivers/rtc/alarm.c
index 9f6134b..0200f47 100644
--- a/drivers/rtc/alarm.c
+++ b/drivers/rtc/alarm.c
@@ -383,7 +383,6 @@ int alarm_suspend(struct platform_device *pdev, pm_message_t state)
 		if (rtc_current_time + 1 >= rtc_alarm_time) {
 			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
 					      "alarm about to go off\n");
-			memset(&rtc_alarm, 0, sizeof(rtc_alarm));
 			rtc_alarm.enabled = 0;
 			rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
 
@@ -404,13 +403,13 @@ err1:
 
 int alarm_resume(struct platform_device *pdev)
 {
-	struct rtc_wkalrm alarm;
+	struct rtc_wkalrm rtc_alarm;
 	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
 			      "alarm_resume(%p)\n", pdev);
 	if (alarm_enabled & ANDROID_ALARM_WAKEUP_MASK) {
-		memset(&alarm, 0, sizeof(alarm));
-		alarm.enabled = 0;
-		rtc_set_alarm(alarm_rtc_dev, &alarm);
+		rtc_read_alarm(alarm_rtc_dev, &rtc_alarm);
+		rtc_alarm.enabled = 0;
+		rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
 		alarm_start_hrtimer(ANDROID_ALARM_RTC_WAKEUP);
 		alarm_start_hrtimer(ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP);
 	}
diff --git a/drivers/rtc/rtc-cpcap.c b/drivers/rtc/rtc-cpcap.c
index 206de89..eba143c 100644
--- a/drivers/rtc/rtc-cpcap.c
+++ b/drivers/rtc/rtc-cpcap.c
@@ -29,6 +29,8 @@
 #define TOD1_MASK 0x00FF
 #define TOD2_MASK 0x01FF
 
+#define SET_DEFAULT_YEAR_BOOTUP 2000
+
 struct cpcap_time {
 	unsigned short day;
 	unsigned short tod1;
@@ -207,16 +209,13 @@ static int cpcap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 {
 	struct cpcap_rtc *rtc;
 	struct cpcap_time cpcap_tm;
-	int alarm_masked;
 	int ret;
 
 	rtc = dev_get_drvdata(dev);
 
 	rtc2cpcap_time(&cpcap_tm, &alrm->time);
 
-	alarm_masked = cpcap_irq_mask_get(rtc->cpcap, CPCAP_IRQ_TODA);
-
-	if (!alarm_masked)
+	if (rtc->alarm_enabled)
 		cpcap_irq_mask(rtc->cpcap, CPCAP_IRQ_TODA);
 
 	ret = cpcap_regacc_write(rtc->cpcap, CPCAP_REG_DAYA, cpcap_tm.day,
@@ -226,8 +225,7 @@ static int cpcap_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 	ret |= cpcap_regacc_write(rtc->cpcap, CPCAP_REG_TODA1, cpcap_tm.tod1,
 				  TOD1_MASK);
 
-	if (!alarm_masked)
-		cpcap_irq_unmask(rtc->cpcap, CPCAP_IRQ_TODA);
+	ret |= cpcap_rtc_alarm_irq_enable(dev, alrm->enabled);
 
 	return ret;
 }
@@ -260,6 +258,10 @@ static void cpcap_rtc_irq(enum cpcap_irqs irq, void *data)
 static int __devinit cpcap_rtc_probe(struct platform_device *pdev)
 {
 	struct cpcap_rtc *rtc;
+#ifdef SET_DEFAULT_YEAR_BOOTUP
+	struct rtc_time tm;
+	int err;
+#endif
 
 	rtc = kzalloc(sizeof(*rtc), GFP_KERNEL);
 	if (!rtc)
@@ -281,7 +283,23 @@ static int __devinit cpcap_rtc_probe(struct platform_device *pdev)
 	cpcap_irq_clear(rtc->cpcap, CPCAP_IRQ_1HZ);
 	cpcap_irq_register(rtc->cpcap, CPCAP_IRQ_1HZ, cpcap_rtc_irq, rtc);
 	cpcap_irq_mask(rtc->cpcap, CPCAP_IRQ_1HZ);
-
+#ifdef SET_DEFAULT_YEAR_BOOTUP
+	err = cpcap_rtc_read_time(&pdev->dev, &tm);
+	if (err == 0) {
+		if (tm.tm_year < (SET_DEFAULT_YEAR_BOOTUP - 1900)) {
+			tm.tm_year = SET_DEFAULT_YEAR_BOOTUP - 1900;
+			tm.tm_mon = 0;
+			tm.tm_mday = 1;
+			tm.tm_hour = 0;
+			tm.tm_min = 0;
+			tm.tm_sec = 0;
+			err = cpcap_rtc_set_time(&pdev->dev, &tm);
+		}
+	}
+	if (err)
+		printk(KERN_WARNING "CPCAP Date/time setting failed. %d.\n",
+			err);
+#endif
 	return 0;
 }
 
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 730dd9f..c1b649d 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -6,6 +6,7 @@
  *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
  *
  *  Copyright (C) 2001 Russell King.
+ *  Copyright (C) 2009 Motorola, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -153,6 +154,10 @@ struct uart_8250_port {
 	 */
 	void			(*pm)(struct uart_port *port,
 				      unsigned int state, unsigned int old);
+
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+	unsigned char		autortscts;	/* bit0 for rts; bit1 for cts */
+#endif
 };
 
 struct irq_info {
@@ -640,13 +645,17 @@ static void serial8250_set_sleep(struct uart_8250_port *p, int sleep)
 	if (p->capabilities & UART_CAP_SLEEP) {
 		if (p->capabilities & UART_CAP_EFR) {
 			serial_outp(p, UART_LCR, 0xBF);
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 			serial_outp(p, UART_EFR, UART_EFR_ECB);
+#endif
 			serial_outp(p, UART_LCR, 0);
 		}
 		serial_outp(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
 		if (p->capabilities & UART_CAP_EFR) {
 			serial_outp(p, UART_LCR, 0xBF);
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 			serial_outp(p, UART_EFR, 0);
+#endif
 			serial_outp(p, UART_LCR, 0);
 		}
 	}
@@ -823,7 +832,9 @@ static void autoconfig_has_efr(struct uart_8250_port *up)
 	 */
 	up->acr = 0;
 	serial_out(up, UART_LCR, 0xBF);
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 	serial_out(up, UART_EFR, UART_EFR_ECB);
+#endif
 	serial_out(up, UART_LCR, 0x00);
 	id1 = serial_icr_read(up, UART_ID1);
 	id2 = serial_icr_read(up, UART_ID2);
@@ -1161,7 +1172,9 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	 * EFR occupies the same register location as the FCR and IIR.
 	 */
 	serial_outp(up, UART_LCR, 0xBF);
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 	serial_outp(up, UART_EFR, 0);
+#endif
 	serial_outp(up, UART_LCR, 0);
 
 	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
@@ -1948,12 +1961,16 @@ static int serial8250_startup(struct uart_port *port)
 		/* Wake up and initialize UART */
 		up->acr = 0;
 		serial_outp(up, UART_LCR, 0xBF);
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 		serial_outp(up, UART_EFR, UART_EFR_ECB);
+#endif
 		serial_outp(up, UART_IER, 0);
 		serial_outp(up, UART_LCR, 0);
 		serial_icr_write(up, UART_CSR, 0); /* Reset the UART */
 		serial_outp(up, UART_LCR, 0xBF);
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 		serial_outp(up, UART_EFR, UART_EFR_ECB);
+#endif
 		serial_outp(up, UART_LCR, 0);
 	}
 
@@ -2226,6 +2243,93 @@ static unsigned int serial8250_get_divisor(struct uart_port *port, unsigned int
 	return quot;
 }
 
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+void serial8250_set_autortscts(struct uart_8250_port *port, int set)
+{
+	u32 lcr_val = 0, mcr_val = 0, efr_val = 0;
+	u32 lcr_backup = 0, mcr_backup = 0, efr_backup = 0;
+
+	if (port->autortscts == 0)
+		return ;
+
+	/* Step 1
+	 * Switch to register configuration mode A to access the
+	 * UARTi.MCR_REG register
+	 */
+	lcr_val = serial_in(port, UART_LCR);
+	lcr_backup = lcr_val;
+	serial_out(port, UART_LCR, 0x80);
+
+	/* Step 2
+	 * Enable register submode TCR_TLR to access the
+	 * UARTi.TCR_REG register
+	 */
+	mcr_val = serial_in(port, UART_MCR);
+	mcr_backup = mcr_val;
+	serial_out(port, UART_MCR, mcr_val | 0x40);
+
+	/* Step 3
+	 * Switch to register configuration mode B to access the
+	 * UARTi.EFR_REG register
+	 */
+	serial_out(port, UART_LCR, 0xBF);
+
+	/* Step 4
+	 * Enable register submode TCR_TLR to access the
+	 * UARTi.TCR_REG register
+	 */
+	efr_val = serial_in(port, UART_EFR);
+	efr_backup = efr_val;
+	serial_out(port, UART_EFR, efr_val | 0x10);
+
+	/* Step 5
+	 * Load the new start and halt trigger values for HW
+	 * flow control:
+	 * 0x06 is the offset of the TCR_REG
+	 * UARTi.TCR_REG[7:4] = 0x5		AUTO_RTS_START
+	 * UARTi.TCR_REG[3:0] = 0xF		AUTO_RTS_HALT
+	 */
+	serial_out(port, 0x06, 0x5F);
+
+	/* Step 6
+	 * Set UARTi auto HW flow control mode
+	 * The bit0 and bit1 of the port->autortscts is the
+	 * auto-rts and auto-cts settings, in the EFR_REG,
+	 * bit7 is the auto-cts enable bit, bit6 is the auto-rts
+	 * enable bit. So the port->autortscts should shift
+	 * left six bits.
+	 */
+	efr_val = serial_in(port, UART_EFR);
+	if (set)
+		serial_out(port, UART_EFR,
+			(efr_val & (~0x00C0)) | ((port->autortscts) << 6));
+	else
+		serial_out(port, UART_EFR, (efr_val & (~0x00C0)));
+
+	/* Restore the UARTi.EFR_REG[4] ENHANCED_EN value saved in step 4. */
+	efr_val = serial_in(port, UART_EFR);
+	serial_out(port, UART_EFR,
+				(efr_val & (~0x0010)) | (efr_backup & 0x0010));
+
+	/* Step 7
+	 * Switch to register configuration mode A to access UARTi.MCR_REG
+	 */
+	serial_out(port, UART_LCR, 0x80);
+
+	/* Step 8
+	 * Restore the UARTi.MCR_REG[6] TCR_TLR value saved in step 2.
+	 */
+	mcr_val = serial_in(port, UART_MCR);
+	serial_out(port, UART_MCR,
+				(mcr_val & (~0x0040)) | (mcr_backup & 0x0040));
+
+	/* Step 9
+	 * Restore the UARTi.LCR_REG value saved in step 1.
+	 */
+	serial_out(port, UART_LCR, lcr_backup);
+}
+#endif
+
 static void
 serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		       struct ktermios *old)
@@ -2347,17 +2451,29 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 	serial_out(up, UART_IER, up->ier);
 
 	if (up->capabilities & UART_CAP_EFR) {
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 		unsigned char efr = 0;
+#else
+		int set = 0;
+#endif
 		/*
 		 * TI16C752/Startech hardware flow control.  FIXME:
 		 * - TI16C752 requires control thresholds to be set.
 		 * - UART_MCR_RTS is ineffective if auto-RTS mode is enabled.
 		 */
 		if (termios->c_cflag & CRTSCTS)
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 			efr |= UART_EFR_CTS;
+#else
+			set = 1;
+#endif
 
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 		serial_outp(up, UART_LCR, 0xBF);
 		serial_outp(up, UART_EFR, efr);
+#else
+		serial8250_set_autortscts(up, set);
+#endif
 	}
 
 #ifdef CONFIG_ARCH_OMAP
@@ -2400,11 +2516,15 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		 * possible TX fifo settings. */
 		if (uart_config[up->port.type].flags & UART_CAP_EFR) {
 			serial_outp(up, UART_LCR, 0xbf);	/* Access EFR */
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 			serial_outp(up, UART_EFR, UART_EFR_ECB);
+#endif
 			serial_outp(up, UART_LCR, 0x0);		/* Access FCR */
 			serial_outp(up, UART_FCR, fcr);
 			serial_outp(up, UART_LCR, 0xbf);	/* Access EFR */
+#ifndef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
 			serial_outp(up, UART_EFR, 0);
+#endif
 			serial_outp(up, UART_LCR, cval);	/* Access FCR */
         } else
 		serial_outp(up, UART_FCR, fcr);		/* set fcr */
@@ -2951,6 +3071,9 @@ static int __devinit serial8250_probe(struct platform_device *dev)
 		port.serial_in		= p->serial_in;
 		port.serial_out		= p->serial_out;
 		port.dev		= &dev->dev;
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+		port.unused1	= p->rtscts;
+#endif
 		if (share_irqs)
 			port.flags |= UPF_SHARE_IRQ;
 		ret = serial8250_register_port(&port);
@@ -3101,6 +3224,9 @@ int serial8250_register_port(struct uart_port *port)
 		uart->port.flags        = port->flags | UPF_BOOT_AUTOCONF;
 		uart->port.mapbase      = port->mapbase;
 		uart->port.private_data = port->private_data;
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+		uart->autortscts    = port->unused1;
+#endif
 		if (port->dev)
 			uart->port.dev = port->dev;
 
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 30f0c2d..48ae961 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -1504,4 +1504,11 @@ config SPORT_BAUD_RATE
 	default 19200 if (SERIAL_SPORT_BAUD_RATE_19200)
 	default 9600 if (SERIAL_SPORT_BAUD_RATE_9600)
 
+config SERIAL_OMAP3430_HW_FLOW_CONTROL
+    bool "Support OMAP3430 uart HW flow control"
+    default n
+    help
+      This option make the application have a chance to enable the uart working in
+      the hardware flow control mode.
+
 endmenu
diff --git a/drivers/serial/omap-serial.c b/drivers/serial/omap-serial.c
index e032116..af899a1 100644
--- a/drivers/serial/omap-serial.c
+++ b/drivers/serial/omap-serial.c
@@ -486,7 +486,17 @@ static unsigned int check_modem_status(struct uart_omap_port *up)
 static inline irqreturn_t serial_omap_irq(int irq, void *dev_id)
 {
 	struct uart_omap_port *up = dev_id;
-	unsigned int iir, lsr;
+	unsigned int iir, lsr, ssr;
+
+#if 0
+	ssr = serial_in(up, UART_OMAP_SSR);
+	if (ssr & (1 << 2)) {
+		unsigned int scr;
+		scr = serial_in(up, UART_OMAP_SCR);
+		scr |= (1<<4);
+		serial_out(up, UART_OMAP_SCR, scr);
+	}
+#endif
 
 	iir = serial_in(up, UART_IIR);
 	if (iir & UART_IIR_NO_INT)
@@ -766,6 +776,7 @@ static void serial_omap_shutdown(struct uart_port *port)
 	u8 lcr, efr;
 
 	DPRINTK("serial_omap_shutdown+%d\n", up->pdev->id);
+
 	/* 
 	 * If we're using auto-rts then disable it.
 	 */
@@ -795,6 +806,14 @@ static void serial_omap_shutdown(struct uart_port *port)
 	serial_omap_set_mctrl(&up->port, (up->port.mctrl & ~TIOCM_RTS));
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
+	if (up->pdev->id == 1) {
+		serial_out(up, UART_LCR, UART_LCR_DLAB);
+		serial_out(up, UART_DLL, 0);
+		serial_out(up, UART_DLM, 0);
+		serial_out(up, UART_LCR, 0);
+		serial_out(up, UART_OMAP_MDR1, OMAP_MDR1_DISABLE);
+	}
+
 	/*
 	 * Disable break condition and FIFOs
 	 */
@@ -838,6 +857,7 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
 	unsigned char efr = 0;
 	unsigned long flags;
 	unsigned int baud, quot;
+	unsigned int scr;
 
 	serial_out(up, UART_LCR, UART_LCR_DLAB);
 	serial_out(up, UART_DLL, 0);
@@ -926,9 +946,13 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
 		up->ier |= UART_IER_MSI;
 	serial_out(up, UART_IER, up->ier);
 
-	if (termios->c_cflag & CRTSCTS) {
+	if (termios->c_cflag & CRTSCTS)
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+		efr |= (((port->unused1 << 6) & UART_EFR_CTS) |
+				(up->restore_autorts ? 0 : UART_EFR_RTS));
+#else
 		efr |= (UART_EFR_CTS | (up->restore_autorts ? 0 : UART_EFR_RTS));
-	}
+#endif
 
 	serial_out(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	serial_out(up, UART_DLL, quot & 0xff);		/* LS of divisor */
@@ -937,7 +961,8 @@ serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
 	serial_out(up, UART_LCR, cval);		/* reset DLAB */
 	up->lcr = cval;				/* Save LCR */
 	if (up->use_dma)
-		serial_out(up, UART_OMAP_SCR  , ((1 << 6) | (1 << 7)));
+		serial_out(up, UART_OMAP_SCR, ((1<<6) | (1<<7)));
+
 
 	serial_out(up, UART_LCR, 0xbf);	/* Access EFR */
 	serial_out(up, UART_EFR, UART_EFR_ECB);
@@ -1416,6 +1441,9 @@ static int serial_omap_probe(struct platform_device *pdev)
 		up->port.flags = pdata->flags;
 		up->port.uartclk = 48000000;
 		up->port.regshift = 2;
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+		up->port.unused1 = pdata->rtscts;
+#endif
 	}
 
 
diff --git a/drivers/sim/Kconfig b/drivers/sim/Kconfig
new file mode 100644
index 0000000..375649e
--- /dev/null
+++ b/drivers/sim/Kconfig
@@ -0,0 +1,4 @@
+menuconfig SIM
+	tristate "SIM support"
+	help
+	  Say Y here to enable SIM support.
diff --git a/drivers/sim/Makefile b/drivers/sim/Makefile
new file mode 100644
index 0000000..5f67a6b
--- /dev/null
+++ b/drivers/sim/Makefile
@@ -0,0 +1,21 @@
+#
+# Copyright (C) 2009 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307, USA
+#
+#
+
+obj-y		+= sim_core.o
+
diff --git a/drivers/sim/sim_core.c b/drivers/sim/sim_core.c
new file mode 100644
index 0000000..38dcac9
--- /dev/null
+++ b/drivers/sim/sim_core.c
@@ -0,0 +1,2649 @@
+/*
+ * Copyright (C) 2005-2010 Motorola, Inc.
+ */
+
+/* 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  
+ * 02111-1307, USA
+ *
+ */
+
+/*
+ * This file includes all of the initialization and tear-down code for the SIM
+ * low-level driver and the basic user-mode interface (open(), close(), ioctl(), etc.).
+ */
+
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/uaccess.h>
+#include <linux/types.h>
+#include <mach/dma.h>
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irqflags.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <linux/pm.h>
+#include <linux/quickwakeup.h>
+#include <linux/wakeup_timer_kernel.h>
+
+#include <linux/regulator/consumer.h>
+
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <mach/prcm.h>
+#include <mach/resource.h>
+#include <mach/omap-pm.h>
+
+#include "smart_card.h"
+#include "smart_card_kernel.h"
+
+/******************************************************************************
+ * Global Variables
+ *****************************************************************************/
+
+/* OMAP Clock Framework */
+static struct clk *usim_fck;
+static struct clk *usim_ick;
+static struct clk *omap_96m_fck;
+static struct clk *omap_120m_fck;
+
+/******************************************************************************
+* Constants
+******************************************************************************/
+/*
+  H/W BASE VIRTUAL ADDRESSES
+  
+  IMPORTANT NOTE(S) :
+  
+  1) each S/W platform may have their own memory map be careful
+     to use the proper virtual address, as the virtual memory may not be contiguous
+     like the physical memory is. 
+*/
+#define CM_BASE		 (L4_34XX_BASE + 0x4000)
+#define CM_AUTOIDLE_WK IO_ADDRESS(CM_BASE + 0x0C30)
+#define CM_CLKSEL_WK IO_ADDRESS(CM_BASE + 0x0C40)
+#define PBIAS_CONTROL_LITE IO_ADDRESS(0x48002520)
+#define DMA_SYSCONFIG IO_ADDRESS(0x4805602C)
+#define INTCPS_ITR1 IO_ADDRESS(0x482000A0)
+#define	WP_TPIR	(1 << 5)
+/*
+  OFFSET TO DMA REGISTER
+  This is required to keep DMA from going to sleep on us as the lat APIs don't seem to work
+*/
+
+#define DMA_MIDLE 0x3000
+
+/*
+  OFFSETS TO PBIAS LITE REGISTERS
+
+  IMPORTANT NOTE(S) :
+
+  1) using direct register writes for PBIAS settings is not the prefferred method to do this. an API
+     function should be provided to handle this, but i cannot find one as of yet. 
+*/
+#define PBIASVMODE1	0x0100
+#define PBIASPWRDNZ1       0x0200
+#define PBIASSPEEDCNTL1    0x0400
+#define PBIASVMODEERROR1   0x0800
+
+/*
+  SIM SOURCE CLOCK SELECTION
+
+  IMPORTANT NOTE(S) :
+  None
+*/
+#define SIM_CLK_SEL_MASK   0x0078
+#define SIM_CLK_120_DIV16  0x0048
+#define SIM_CLK_96_DIV10   0x0030
+#define SIM_CLK_SYSCLOCK   0x0008
+
+#define SIM_ICLK_AUTOIDLE  0x0200
+
+/*
+  SIM MODULE CONSTANTS
+
+  IMPORTANT NOTE(S) :
+  None
+
+*/
+#define NO_OF_SIM_REGS     (sizeof(SIM_MODULE_REGISTER_BANK) / sizeof(UINT32))
+#define SIM_REMOVED 0
+#define SIM_PRESENT 1
+#define SIM_MODULE_FREQUENCY_4  3750000
+#define SIM_MODULE_FREQUENCY_5 4800000
+#define SIM_MODULE_NACK_THRESHOLD 4
+#define SIM_MODULE_RX_DMA_REQ     79
+
+#define CMD_PARAMETER_SIZE_1 (sizeof(UINT32))
+#define CMD_PARAMETER_SIZE_2 (2 * sizeof(UINT32))
+#define CMD_PARAMETER_SIZE_3 (3 * sizeof(UINT32))
+#define CMD_PARAMETER_SIZE_4 (4 * sizeof(UINT32))
+#define CMD_PARAMETER_SIZE_5 (5 * sizeof(UINT32))
+
+/*
+  SIM MODULE OMAP CLOCK FRAMEWORK CONSTANTS
+
+  IMPORTANT NOTE(S) :
+  None
+
+*/
+#define USIM_FCK "usim_fck"
+#define USIM_ICK "usim_ick"
+#define OMAP_96M_FCK "omap_96m_fck"
+#define OMAP_120M_FCK "dpll5_m2_ck"
+
+/*
+  SIM CARD TYPE CONSTANTS
+
+  IMPORTANT NOTE(S) :
+  These variables must match the values from user space.
+*/
+#define UNKNOWN_CARD 0x04
+#define GSM_SIM      0x09
+#define UICC	     0x0A
+
+UINT8 uicc_status[5] = {0x80, 0xF2, 0x00, 0x0C, 0x00};
+UINT8 gsm_status[5]  = {0xA0, 0xF2, 0x00, 0x00, 0x16};
+
+#define SIM_NULL_PROC_BYTE 0x60
+#define SIM_STATUS_INS 0xF2
+#define SIM_ACK_ONE_MASK 0xFF
+
+/******************************************************************************
+ * Local Macros
+ *****************************************************************************/
+/*
+  SIM MODULE TRACEMSG MACRO
+
+  IMPORTANT NOTE(S) :
+
+  Do not enable logging by default. Only use this for debug purposes.
+*/
+#if 0
+#define tracemsg(fmt,args...)  printk(fmt,##args)
+#else
+#define tracemsg(fmt,args...)
+#endif
+
+
+
+/*
+  SIM MODULE REGISTER ACCESS MACROS
+
+  IMPORTANT NOTE(S) :
+
+  1) to be used only for SIM module register access
+*/
+
+#define read_reg(reg)		   (*(reg))
+#define write_reg(reg, value)	   (*(reg) = (value))
+#define write_reg_bits(reg, mask, bits) (*(reg) = ( *(reg) & ~(mask)) | (bits));
+
+#define SIM_STATUS_ACK_ALL(byte)       ((SIM_STATUS_INS ^ byte) == 0)
+#define SIM_STATUS_ACK_ONE(byte)       (((SIM_STATUS_INS ^ byte) & SIM_ACK_ONE_MASK) \
+					 == SIM_ACK_ONE_MASK)
+
+#define expected_status_data(sim_card) (sim_card == UICC ? 2 : 24)
+
+/******************************************************************************
+* Local type definitions
+******************************************************************************/
+
+typedef struct {
+	UINT16 buffer_index;
+	UINT16 rx_last_index;
+	UINT16 tx_length;
+	UINT8 error_flag;
+	UINT8 *buffer;
+	dma_addr_t dma_buffer;
+} SIM_MODULE_BUFFER_DATA;
+
+/******************************************************************************
+* Global function prototypes
+******************************************************************************/
+
+/******************************************************************************
+* Local function prototypes
+******************************************************************************/
+static int sim_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg);
+static int sim_open(struct inode *inode, struct file *file);
+static int sim_free(struct inode *inode, struct file *file);
+static unsigned int sim_poll(struct file *file, poll_table * wait);
+static int sim_suspend(struct platform_device *pdev, pm_message_t state);
+static int sim_resume(struct platform_device *pdev);
+static irqreturn_t sim_module_int_irq_1(int irq, void *dev_id);
+
+static void sim_module_int_reset_detect(UINT8 reader_id);
+static void sim_module_int_rx(UINT8 reader_id);
+static void sim_module_init_rx_mode(UINT8 reader_id);
+static void sim_module_int_tx(UINT8 reader_id);
+static void sim_module_set_voltage_level(SIM_MODULE_VOLTAGE_LEVEL level);
+static void sim_module_set_clock_rate(UINT8 reader_id,
+				      SIM_MODULE_CLOCK_RATE rate);
+
+static int sim_probe(struct platform_device *pdev);
+static int sim_remove(struct platform_device *pdev);
+static int sim_slim_status_handler(void);
+static BOOL sim_mutex_update(UINT8 mutex_request);
+static void sim_module_dma_callback(INT32 lch, UINT16 ch_status,
+				    void *data);
+static int sim_qw_callback(void);
+static int sim_qw_check(void);
+static int regulator_enabled_flag;
+
+/******************************************************************************
+* Local Structures
+******************************************************************************/
+
+/* Platform driver structure for the SIM driver */
+static struct platform_driver sim_driver = {
+	.driver = {
+		   .name = SIM_DEV_NAME,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = sim_probe,
+	.remove = sim_remove,
+	.suspend = sim_suspend,
+	.resume = sim_resume,
+};
+
+/* Platform device structure for the SIM driver */
+static struct platform_device sim_device = {
+	.name = SIM_DEV_NAME,
+	.id = 1,
+};
+
+/*This structure defines the file operations for the SIM device */
+static struct file_operations sim_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = sim_ioctl,
+	.open = sim_open,
+	.release = sim_free,
+	.poll = sim_poll,
+};
+
+/* Used for the timer call back */
+static struct quickwakeup_ops sim_qw_ops = {
+	.qw_callback = sim_qw_callback,
+	.qw_check = sim_qw_check
+};
+
+/******************************************************************************
+* Local variables
+******************************************************************************/
+static int sim_module_major;
+static int sim_module_dma_channel = 0;
+
+static spinlock_t sim_module_lock = SPIN_LOCK_UNLOCKED;
+static spinlock_t sim_status_lock = SPIN_LOCK_UNLOCKED;
+
+static UINT32 sim_module_clock_frequency = SIM_MODULE_FREQUENCY_4;
+
+static wait_queue_head_t sim_module_wait =
+__WAIT_QUEUE_HEAD_INITIALIZER(sim_module_wait);
+
+static struct class *sim_class;
+
+static UINT32 sim_module_rx_event = SIM_MODULE_EVENT_NONE;
+
+static BOOLEAN sim_module_all_tx_data_sent = FALSE;
+
+static UINT8 sim_module_current_pd_state_sim1 = SIM_REMOVED;
+static UINT8 sim_module_nack_counter = 0;
+static UINT8 sim_module_opens = 0;
+
+static BOOLEAN sim_low_power_enabled = FALSE;
+
+static SIM_MODULE_INTERRUPT_MODE sim_module_interrupt_mode =
+    SIM_MODULE_RX_MODE;
+static SIM_MODULE_BUFFER_DATA sim_module_card_data[NUM_SIM_MODULES];
+
+static volatile SIM_MODULE_REGISTER_BANK *sim_registers[NUM_SIM_MODULES] = {
+	((volatile SIM_MODULE_REGISTER_BANK *) IO_ADDRESS(SIM1_BASE_ADDR))
+};
+
+static volatile SIM_MODULE_REGISTER_BANK
+    *sim_phys_registers[NUM_SIM_MODULES] = {
+	(volatile SIM_MODULE_REGISTER_BANK *) SIM1_BASE_ADDR
+};
+
+struct regulator *vsim_regulator;
+struct regulator *vsimcard_regulator;
+
+static UINT16 card_type = UNKNOWN_CARD;
+static BOOL preforming_status_command = FALSE;
+static BOOL status_slow_card = FALSE;
+static BOOL currently_in_call = FALSE;
+static BOOL proc_bytes_done = FALSE;
+
+static BOOL all_data_received = FALSE;
+static UINT16 bytes_recieved = 0;
+
+static UINT8 sim_mutex_locked_by_id = 0;
+static UINT8 sim_mutex_requested_by_id = 0;
+
+static UINT32 sim_poll_interval = 0;
+static UINT8 last_byte_checked = 0;
+static UINT16 null_byte_counter = 0;
+static UINT8 ack_counter = 0;
+
+static struct timer_cascade_root * sim_timer = NULL;
+
+/******************************************************************************
+* Local Functions
+******************************************************************************/
+
+/* DESCRIPTION:
+       The IOCTL handler for the SIM device
+ 
+   INPUTS:
+       inode       inode pointer
+       file	file pointer
+       cmd	 the ioctl() command
+       arg	 the ioctl() argument
+
+   OUTPUTS:
+       Returns 0 if successful.
+
+   IMPORTANT NOTES:
+       None.   
+*/
+
+static int sim_ioctl(struct inode *inode, struct file *file,
+		     unsigned int cmd, unsigned long arg)
+{
+	int status = 0;
+
+	UINT32 args_kernel[CMD_PARAMETER_SIZE_5] = { 0, 0, 0, 0, 0 };
+	volatile UINT32 *sim_module_register_ptr = NULL;
+
+	unsigned long flags;
+
+	UINT8 tx_index;
+	UINT8 length;
+	int error;
+
+	tracemsg("SIM KERNEL IOCTL -> %X \n", cmd);
+	/*
+	   These IO control requests must only be used by the protocol layer in user space.
+	   Any deviation from this rule WILL cause problems.
+	 */
+
+	switch (cmd) {
+	case SIM_IOCTL_CONFIGURE_GPIO:
+
+		/* enable the interface clock */
+		clk_enable(usim_ick);
+
+		/* enable auto idle mode for the interface clock */
+		write_reg_bits((volatile UINT32 *) CM_AUTOIDLE_WK,
+			       SIM_ICLK_AUTOIDLE, SIM_ICLK_AUTOIDLE);
+
+		/* enable the functional clock */
+		clk_enable(usim_fck);
+
+		/* sleep some time waiting for clocks to stabalize */
+		msleep(1);
+
+		/* now that we've got the interface clock configured, reset the SIM module */
+		write_reg_bits(&(sim_registers[(UINT8) arg]->sysconfig),
+			       SOFTRESET_MASK, SOFTRESET_MASK);
+
+		tracemsg("SIM Module: soft reset SIM module\n\n");
+
+		/* block while the module is in reset ... */
+		while ((read_reg(&(sim_registers[(UINT8) arg]->sysstatus))
+			& RESETDONE_MASK) == 0) {
+			/* yield the processor one time per iteration */
+			msleep(1);
+			tracemsg
+			    ("SIM Module: soft reset not complete yet\n\n");
+		}
+
+		/* set the internal SIM clock divider to divide by 2 to obtain
+		   a SIM clock of 3.75 MHz */
+		write_reg_bits(&(sim_registers[(UINT8) arg]->usimconf2),
+			       CONFSCLKDIV_MASK, 0);
+
+		sim_module_set_clock_rate((UINT8) arg, SIM_MODULE_CLOCK_4);
+
+		/* turn the clock back off for now */
+		clk_disable(usim_fck);
+
+		break;
+	case SIM_IOCTL_READ_DATA_BUFFER:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_4);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg
+			    ("buffer_index(read data buffer): %X offset: %X rx_length: %X\n",
+			     sim_module_card_data[args_kernel[0]].
+			     buffer_index, args_kernel[2], args_kernel[3]);
+
+			if (copy_to_user
+			    ((UINT8 *) args_kernel[1],
+			     (&
+			      (sim_module_card_data[args_kernel[0]].
+			       buffer[args_kernel[2]])), args_kernel[3])) {
+				tracemsg
+				    ("Warning: failed to copy data to user-space while retrieving SIM card reader data for module 2\n");
+				status = -EFAULT;
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_UPDATE_DATA_BUFFER:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_3);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			status =
+			    copy_from_user(sim_module_card_data
+					   [args_kernel[0]].buffer,
+					   (UINT8 *) args_kernel[1],
+					   args_kernel[2]);
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_INTERRUPT_INIT:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_3);
+
+		if ((UINT8) args_kernel[0] == SIM_MODULE_1) {
+			free_irq(INT_SIM_GENERAL, NULL);
+			status =
+			    request_irq(INT_SIM_GENERAL,
+					sim_module_int_irq_1,
+					(IRQF_DISABLED | IRQF_NOBALANCING),
+					SIM_DEV_NAME, 0);
+
+			if (status != 0) {
+				tracemsg
+				    ("Warning: the SIM driver failed to request an IRQ. IRQ -> %X Error -> %X\n",
+				     INT_SIM_GENERAL, status);
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_INTERRUPT_MODE:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if ((UINT8) args_kernel[0] == SIM_MODULE_1) {
+			tracemsg("Set SIM interrupt mode -> arg1: %X\n",
+				 args_kernel[1]);
+
+			switch (args_kernel[1]) {
+			case SIM_MODULE_RX_MODE:
+				tracemsg("SIM Module: RX mode \n\n");
+				sim_module_interrupt_mode =
+				    SIM_MODULE_RX_MODE;
+
+				if (sim_module_dma_channel != 0) {
+					omap_free_dma
+					    (sim_module_dma_channel);
+					sim_module_dma_channel = 0;
+				}
+				/* request a DMA logical channel */
+				error =
+				    omap_request_dma(OMAP34XX_DMA_USIM_RX,
+						     SIM_DEV_NAME,
+						     sim_module_dma_callback,
+						     (void *)
+						     sim_module_card_data
+						     [args_kernel[0]].
+						     dma_buffer,
+						     &sim_module_dma_channel);
+				if (error == 0) {
+					/* configure the DMA parameters */
+					omap_set_dma_transfer_params
+					    (sim_module_dma_channel,
+					     OMAP_DMA_DATA_TYPE_S8, 1,
+					     SIM_MODULE_MAX_DATA,
+					     OMAP_DMA_SYNC_ELEMENT,
+					     OMAP34XX_DMA_USIM_RX,
+					     OMAP_DMA_SRC_SYNC);
+					omap_set_dma_src_params
+					    (sim_module_dma_channel, 0,
+					     OMAP_DMA_AMODE_CONSTANT,
+					     (unsigned
+					      long) (&(sim_phys_registers
+						       [args_kernel[0]]->
+						       usim_drx)), 0, 0);
+					omap_set_dma_dest_params
+					    (sim_module_dma_channel, 0,
+					     OMAP_DMA_AMODE_POST_INC,
+					     (unsigned long)
+					     sim_module_card_data
+					     [args_kernel[0]].dma_buffer,
+					     0, 0);
+
+
+
+					omap_start_dma
+					    (sim_module_dma_channel);
+				}
+
+				if (error != 0) {
+					tracemsg
+					    ("SIM MODULE DMA CONFIGURATION ERROR -> %X \n",
+					     error);
+				}
+
+				break;
+			case SIM_MODULE_TX_MODE:
+				tracemsg("SIM Module: TX mode \n\n");
+				sim_module_interrupt_mode =
+				    SIM_MODULE_TX_MODE;
+				break;
+			case SIM_MODULE_RESET_DETECT_MODE:
+				tracemsg("SIM Module: reset detect \n\n");
+
+				sim_module_card_data[args_kernel[0]].
+				    buffer_index = 0;
+
+				if (sim_module_dma_channel != 0) {
+					omap_free_dma
+					    (sim_module_dma_channel);
+					sim_module_dma_channel = 0;
+				}
+
+				sim_module_interrupt_mode =
+				    SIM_MODULE_RESET_DETECT_MODE;
+				break;
+			default:
+				tracemsg
+				    ("Warning: Invalid SIM interrupt mode. \n");
+				break;
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_WRITE_SIM_REG_DATA:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_3);
+
+		tracemsg
+		    ("Write SIM module register data -> reader ID: %X register: %X data: %X\n",
+		     args_kernel[0], args_kernel[1], args_kernel[2]);
+
+		if (args_kernel[1] <= sizeof(SIM_MODULE_REGISTER_BANK)) {
+			if (args_kernel[0] < NUM_SIM_MODULES) {
+				sim_module_register_ptr =
+				    (UINT32 *) ((UINT32)
+						sim_registers[args_kernel
+							      [0]] +
+						(UINT32) args_kernel[1]);
+			} else {
+				tracemsg
+				    ("Warning: Invalid reader ID in SIM driver request.\n");
+				status = -EFAULT;
+			}
+
+			if (sim_module_register_ptr != NULL) {
+				write_reg(sim_module_register_ptr,
+					  args_kernel[2]);
+
+				/* if writing to the transmit FIFO increment the buffer index */
+				if (args_kernel[1] == 0x0000003C) {
+					sim_module_card_data[args_kernel
+							     [0]].
+					    buffer_index++;
+				}
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid register address in the SIM driver.\n");
+			status = -EFAULT;
+		}
+
+		sim_module_register_ptr = NULL;
+		break;
+	case SIM_IOCTL_READ_SIM_REG_DATA:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_3);
+		tracemsg
+		    ("Read SIM register data -> Reader ID: %X, register: %X \n",
+		     args_kernel[0], args_kernel[1]);
+		if (args_kernel[1] <= sizeof(SIM_MODULE_REGISTER_BANK)) {
+			if (args_kernel[0] < NUM_SIM_MODULES) {
+				sim_module_register_ptr =
+				    (UINT32 *) ((UINT32)
+						sim_registers[args_kernel
+							      [0]] +
+						(UINT32) args_kernel[1]);
+			} else {
+				tracemsg
+				    ("Warning: Invalid reader ID in SIM driver request.\n");
+				status = -EFAULT;
+			}
+
+			if (sim_module_register_ptr != NULL) {
+				args_kernel[2] =
+				    read_reg(sim_module_register_ptr);
+
+				if (copy_to_user
+				    ((UINT32 *) arg, args_kernel,
+				     CMD_PARAMETER_SIZE_3)) {
+					tracemsg
+					    ("Warning: failed to copy data to user-space while reading SIM module register data.\n");
+					status = -EFAULT;
+				}
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid register address in the SIM driver.\n");
+			status = -EFAULT;
+		}
+
+		sim_module_register_ptr = NULL;
+		break;
+	case SIM_IOCTL_WRITE_SIM_REG_BIT:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_4);
+
+		tracemsg
+		    ("Write SIM register bits -> reader ID: %X register: %X bits: %X mask: %X\n",
+		     args_kernel[0], args_kernel[2], args_kernel[3],
+		     args_kernel[1]);
+
+		if (args_kernel[2] <= sizeof(SIM_MODULE_REGISTER_BANK)) {
+			if (args_kernel[0] < NUM_SIM_MODULES) {
+				sim_module_register_ptr =
+				    (UINT32 *) ((UINT32)
+						sim_registers[args_kernel
+							      [0]] +
+						(UINT32) args_kernel[2]);
+			} else {
+				tracemsg
+				    ("Warning: Invalid reader ID in SIM driver request.\n");
+				status = -EFAULT;
+			}
+
+			if (sim_module_register_ptr != NULL) {
+				write_reg_bits(sim_module_register_ptr,
+					       args_kernel[1],
+					       args_kernel[3]);
+
+				/* if writing to the transmit FIFO increment the buffer index */
+				if (args_kernel[2] == 0x0000003C) {
+					sim_module_card_data[args_kernel
+							     [0]].
+					    buffer_index++;
+				}
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid register address in the SIM driver.\n");
+			status = -EFAULT;
+		}
+
+		sim_module_register_ptr = NULL;
+		break;
+	case SIM_IOCTL_SET_SIM_CLOCK_RATE:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		tracemsg
+		    ("Set SIM clock rate, reader id -> %X, rate -> %X\n",
+		     args_kernel[0], args_kernel[1]);
+
+		sim_module_set_clock_rate(args_kernel[0], args_kernel[1]);
+		break;
+	case SIM_IOCTL_READ_RX_EVENT:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			args_kernel[1] = sim_module_rx_event;
+			if (copy_to_user
+			    ((UINT32 *) arg, args_kernel,
+			     CMD_PARAMETER_SIZE_2)) {
+				tracemsg
+				    ("Warning: failed to copy data to user-space while reading SIM RX event type.\n");
+				status = -EFAULT;
+			}
+
+			sim_module_rx_event = SIM_MODULE_EVENT_NONE;
+		}
+
+		else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+
+		break;
+
+	case SIM_IOCTL_SET_VOLTAGE_LEVEL:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			sim_module_set_voltage_level(args_kernel[1]);
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_READ_BUFFER_INDEX:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg("SIM reader buffer index\n");
+			if (sim_module_dma_channel != 0) {
+				/* if a DMA transfer already started ... */
+				if (omap_get_dma_dst_pos
+				    (sim_module_dma_channel) != 0) {
+					/* set the number of characters received via DMA */
+					args_kernel[1] =
+					    (UINT32) (omap_get_dma_dst_pos
+						      (sim_module_dma_channel)
+						      -
+						      sim_module_card_data
+						      [args_kernel[0]].
+						      dma_buffer);
+				}
+
+				/* else, DMA has not yet started ... */
+				else {
+					/* set the number of characters received via DMA to 0 */
+					args_kernel[1] = 0;
+				}
+			}
+
+			else {
+				args_kernel[1] =
+				    sim_module_card_data[args_kernel[0]].
+				    buffer_index;
+			}
+
+			if (copy_to_user
+			    ((UINT32 *) arg, args_kernel,
+			     CMD_PARAMETER_SIZE_2)) {
+				tracemsg
+				    ("Warning: failed to copy data to user-space during buffer index retrieval\n");
+				status = -EFAULT;
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+
+		break;
+	case SIM_IOCTL_RESET_CARD_READER_DATA:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_5);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			sim_module_card_data[args_kernel[0]].buffer_index =
+			    args_kernel[1];
+			sim_module_card_data[args_kernel[0]].
+			    rx_last_index = args_kernel[2];
+			sim_module_card_data[args_kernel[0]].tx_length =
+			    args_kernel[3];
+			sim_module_card_data[args_kernel[0]].error_flag =
+			    args_kernel[4];
+			preforming_status_command = FALSE;
+			status_slow_card = FALSE;
+			all_data_received = FALSE;
+			bytes_recieved = 0;
+			last_byte_checked = 0;
+			null_byte_counter = 0;
+			ack_counter = 0;
+                        proc_bytes_done = FALSE;
+
+			tracemsg
+			    ("reset card reader data -> buffer_index: %X rx_last_index: %X tx_length: %X error_flag: %X\n",
+			     args_kernel[1], args_kernel[2],
+			     args_kernel[3], args_kernel[4]);
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+
+		break;
+	case SIM_IOCTL_UPDATE_RX_LAST_INDEX:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg("SIM update RX last index, index -> %X\n",
+				 args_kernel[1]);
+			sim_module_card_data[args_kernel[0]].
+			    rx_last_index = args_kernel[1];
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_UPDATE_BUFFER_INDEX:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg("SIM update buffer index, index -> %X\n",
+				 args_kernel[1]);
+			sim_module_card_data[args_kernel[0]].buffer_index =
+			    args_kernel[1];
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_ALL_TX_DATA_SENT:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg("SIM read all TX data sent\n");
+			args_kernel[1] = sim_module_all_tx_data_sent;
+
+			if (copy_to_user
+			    ((UINT32 *) arg, args_kernel,
+			     CMD_PARAMETER_SIZE_2)) {
+				tracemsg
+				    ("Warning: failed to copy data to user-space during card reader data retrieval\n");
+				status = -EFAULT;
+			}
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+	case SIM_IOCTL_RESET_ALL_TX_DATA_SENT:
+		if (arg < NUM_SIM_MODULES) {
+			tracemsg("SIM reset all TX data sent\n");
+			sim_module_all_tx_data_sent = FALSE;
+		} else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+		break;
+
+	case SIM_IOCTL_DATA_TX:
+
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg("SIM data TX\n");
+			length = (UINT8) args_kernel[1];
+
+			sim_module_card_data[args_kernel[0]].buffer_index =
+			    0;
+
+			/* Enable DMA mode */
+			write_reg_bits(&
+				       (sim_registers[args_kernel[0]]->
+					usim_fifos), SIM_DMA_MODE_MASK,
+				       SIM_DMA_MODE_MASK);
+
+			if (sim_module_dma_channel != 0) {
+				omap_free_dma(sim_module_dma_channel);
+				sim_module_dma_channel = 0;
+			}
+
+			/* request a DMA logical channel */
+			error =
+			    omap_request_dma(OMAP34XX_DMA_USIM_RX,
+					     SIM_DEV_NAME,
+					     sim_module_dma_callback,
+					     (void *)
+					     sim_module_card_data
+					     [args_kernel[0]].dma_buffer,
+					     &sim_module_dma_channel);
+			if (error == 0) {
+
+				/* configure the DMA parameters */
+				omap_set_dma_transfer_params
+				    (sim_module_dma_channel,
+				     OMAP_DMA_DATA_TYPE_S8, 1,
+				     SIM_MODULE_MAX_DATA,
+				     OMAP_DMA_SYNC_ELEMENT,
+				     OMAP34XX_DMA_USIM_RX,
+				     OMAP_DMA_SRC_SYNC);
+				omap_set_dma_src_params
+				    (sim_module_dma_channel, 0,
+				     OMAP_DMA_AMODE_CONSTANT,
+				     (unsigned
+				      long) (&(sim_phys_registers
+					       [args_kernel[0]]->
+					       usim_drx)), 0, 0);
+				omap_set_dma_dest_params
+				    (sim_module_dma_channel, 0,
+				     OMAP_DMA_AMODE_POST_INC,
+				     (unsigned long)
+				     sim_module_card_data[args_kernel[0]].
+				     dma_buffer, 0, 0);
+
+				omap_start_dma(sim_module_dma_channel);
+			}
+
+			local_irq_save(flags);
+
+			/* for each character to transmit ... */
+			for (tx_index = 0; tx_index < length; tx_index++) {
+				/* copy the byte to the TX FIFO */
+				write_reg(&
+					  (sim_registers[args_kernel[0]]->
+					   usim_dtx),
+					  sim_module_card_data[args_kernel
+							       [0]].
+					  buffer[sim_module_card_data
+						 [args_kernel[0]].
+						 buffer_index++]);
+			}
+
+			/* setup the TX threshold value to write more data into the FIFO */
+			write_reg_bits(&
+				       (sim_registers[args_kernel[0]]->
+					usim_fifos), FIFO_TX_TRIGGER_MASK,
+				       (SIM_MODULE_TX_FIFO_SIZE - 1) << 2);
+
+			/* clear the transmit complete interrupt */
+			write_reg_bits(&
+				       (sim_registers[args_kernel[0]]->
+					irqstatus), USIM_TX_MASK,
+				       USIM_TX_MASK);
+
+			/* enable the transmit complete interrupt */
+			write_reg_bits(&
+				       (sim_registers[args_kernel[0]]->
+					irqenable), USIM_TX_EN_MASK,
+				       USIM_TX_EN_MASK);
+
+			/* enable the transmitter */
+			write_reg_bits(&
+				       (sim_registers[args_kernel[0]]->
+					usimconf2), TXNRX_MASK,
+				       TXNRX_MASK);
+
+			/* if there is just one block of data to send ... */
+			if (sim_module_card_data[args_kernel[0]].
+			    tx_length <= SIM_MODULE_TX_FIFO_SIZE) {
+				sim_module_card_data[args_kernel[0]].
+				    buffer_index = 0;
+
+				/* enable the receiver right away */
+				write_reg_bits(&
+					       (sim_registers
+						[args_kernel[0]]->
+						usimconf2), TXNRX_MASK, 0);
+
+				/* indicate this is the last block */
+				sim_module_all_tx_data_sent = TRUE;
+
+				/* initialize rx mode */
+				sim_module_init_rx_mode(args_kernel[0]);
+
+			}
+
+			local_irq_restore(flags);
+		}
+
+		break;
+
+	case SIM_IOCTL_GET_SIM_CLOCK_FREQ:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg("SIM get SIM clock frequency\n");
+			args_kernel[1] = sim_module_clock_frequency;
+			if (copy_to_user
+			    ((UINT32 *) arg, args_kernel,
+			     CMD_PARAMETER_SIZE_2)) {
+				tracemsg
+				    ("Warning: failed to copy data to user-space for get frequency\n");
+				status = -EFAULT;
+			}
+		}
+
+		else {
+			tracemsg
+			    ("Warning: Invalid reader ID in SIM driver request.\n");
+			status = -EFAULT;
+		}
+
+		break;
+
+	case SIM_IOCTL_LOW_POWER_STATE:
+		status =
+		    copy_from_user(args_kernel, (UINT32 *) arg,
+				   CMD_PARAMETER_SIZE_2);
+
+		if (args_kernel[0] < NUM_SIM_MODULES) {
+			tracemsg("SIM set constraint, state -> %X\n",
+				 args_kernel[1]);
+			/*  if we are active ...  */
+			if ((BOOL) args_kernel[1] == FALSE) {
+				/* Stop DMA from AKC'ing idle requests */
+				write_reg_bits((volatile UINT32 *)DMA_SYSCONFIG,DMA_MIDLE, 
+				    DMA_SYSCONFIG_MIDLEMODE(1));
+
+				/* Request the latency constraint */
+				omap_pm_set_max_mpu_wakeup_lat(&sim_device.
+							       dev, 10);
+
+				/* enable the SIM FCLK */
+				clk_enable(usim_fck);
+
+				/* wait for the clock to settle */
+				msleep(1);
+			}
+
+			/* else, we are inactive ... */
+			else {
+				/* Allow DMA to ACK idle requests */
+				write_reg_bits((volatile UINT32 *)DMA_SYSCONFIG,DMA_MIDLE, 
+				    DMA_SYSCONFIG_MIDLEMODE(2));
+
+				/* Disable DMA mode for low power mode */
+				write_reg_bits(&
+					       (sim_registers
+						[args_kernel[0]]->
+						usim_fifos),
+					       SIM_DMA_MODE_MASK, 0);
+
+				/* disable the SIM FCLK */
+				clk_disable(usim_fck);
+
+				/* Release the latency constraint */
+				omap_pm_set_max_mpu_wakeup_lat(&sim_device.
+							       dev, -1);
+			}
+
+			sim_low_power_enabled = (BOOL) args_kernel[1];
+		}
+		break;
+
+	case SIM_IOCTL_SLEEP:
+		msleep(arg);
+		break;
+
+	case SIM_IOCTL_CARD_TYPE:
+		if(copy_from_user(args_kernel, (UINT32 *) arg, CMD_PARAMETER_SIZE_2)){
+			tracemsg("Warning: failed to copy data from user-space for card type\n");
+			status = -EFAULT;
+		}
+		else {
+			if (args_kernel[0] < NUM_SIM_MODULES) {
+				if((args_kernel[1] == UICC) ||(args_kernel[1] == GSM_SIM)){
+					card_type = args_kernel[1];
+				}
+				else {
+					card_type = UNKNOWN_CARD;
+				}
+			}
+			else {
+				tracemsg("Warning: Invalid reader ID in SIM driver request.\n");
+				status = -EFAULT;
+			}
+		}
+		break;
+
+	case SIM_IOCTL_MUTEX_UPDATE:
+		if(copy_from_user(args_kernel, (UINT32 *) arg, CMD_PARAMETER_SIZE_3)){
+			tracemsg("Warning: failed to copy data from user-space for mutex update\n");
+			status = -EFAULT;
+		}
+		else {
+    
+			if (args_kernel[0] < NUM_SIM_MODULES) {
+				args_kernel[2] = sim_mutex_update(args_kernel[1]);
+
+				if (copy_to_user((UINT32 *) arg, args_kernel,CMD_PARAMETER_SIZE_3)) {
+					tracemsg("Warning: failed to copy data to user-space for get mutex update\n");
+					status = -EFAULT;
+				}
+			}
+			else {
+				tracemsg("Warning: Invalid reader ID in SIM driver request.\n");
+				status = -EFAULT;
+			}
+		}
+		break;
+
+	case SIM_IOCTL_POLL_INTERVAL:
+		if(copy_from_user(args_kernel, (UINT32 *) arg, CMD_PARAMETER_SIZE_2)) {
+			tracemsg("Warning: failed to copy data from user-space for poll interval\n");
+			status = -EFAULT;
+		}
+		else {
+
+			if (args_kernel[0] < NUM_SIM_MODULES) {
+				sim_poll_interval = args_kernel[1];
+			} 
+			else {
+				tracemsg("Warning: Invalid reader ID in SIM driver request.\n");
+				status = -EFAULT;
+			} 
+		} 
+		break;
+
+	case SIM_IOCTL_CALL_STATUS:
+		if(copy_from_user(args_kernel, (UINT32 *) arg, CMD_PARAMETER_SIZE_2)) {
+			tracemsg("Warning: failed to copy data from user-space for call status\n");
+			status = -EFAULT;
+		}
+		else {
+
+			if (args_kernel[0] < NUM_SIM_MODULES) {
+				currently_in_call = args_kernel[1];
+			}
+			else {
+				tracemsg("Warning: Invalid reader ID in SIM driver request.\n");
+				status = -EFAULT;
+			}
+		}
+		break;
+
+	case SIM_IOCTL_START_TIMER:
+	        wakeup_start_status_timer(sim_timer, arg);
+	        break;
+
+	case SIM_IOCTL_STOP_TIMER:
+	        wakeup_stop_status_timer(sim_timer);
+	        break;
+
+	default:
+		tracemsg
+		    ("Warning: Invalid request sent to the SIM driver.\n");
+		status = -ENOTTY;
+		break;
+	}
+
+	return status;
+}
+
+/* DESCRIPTION:
+       The open() handler for the SIM device.
+ 
+   INPUTS:
+       inode       inode pointer
+       file	file pointer
+
+   OUTPUTS:
+       Returns 0 if successful.
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static int sim_open(struct inode *inode, struct file *file)
+{
+	int status = 0;
+
+	spin_lock(&sim_module_lock);
+
+	/* only allow 1 open */
+	if (sim_module_opens > 0) {
+		spin_unlock(&sim_module_lock);
+
+		status = -ENODEV;
+	}
+
+	if (status == 0) {
+		sim_module_opens++;
+		spin_unlock(&sim_module_lock);
+
+		/* allocate non-bufferable, or cacheable memory for DMA */
+		sim_module_card_data[SIM_MODULE_1].buffer =
+		    (UINT8 *) dma_alloc_coherent(NULL, SIM_MODULE_MAX_DATA,
+						 &(sim_module_card_data
+						   [SIM_MODULE_1].
+						   dma_buffer), 0);
+
+		/* if there is not a valid buffer */
+		if ((sim_module_card_data[SIM_MODULE_1].buffer == NULL) ||
+		    (sim_module_card_data[SIM_MODULE_1].dma_buffer == 0)) {
+			tracemsg
+			    ("The data buffer was not allocated buffer -> %X, dma_buffer -> %X\n",
+			     (unsigned int)
+			     sim_module_card_data[SIM_MODULE_1].buffer,
+			     (unsigned int)
+			     sim_module_card_data[SIM_MODULE_1].
+			     dma_buffer);
+			status = -EFAULT;
+		}
+	}
+
+	if (status == 0) {
+		/* initialize the dma channel to 0 */
+		sim_module_dma_channel = 0;
+
+	}
+
+	tracemsg("sim : sim_open, status -> %X\n", status);
+
+	return status;
+}
+
+/* DESCRIPTION:
+       The close() handler for the SIM device
+ 
+   INPUTS:
+       inode       inode pointer
+       file	file pointer
+
+   OUTPUTS:
+       Returns 0 if successful.
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static int sim_free(struct inode *inode, struct file *file)
+{
+	tracemsg("sim : sim_free()\n");
+	spin_lock(&sim_module_lock);
+	sim_module_opens--;
+	spin_unlock(&sim_module_lock);
+	return 0;
+}
+
+/* DESCRIPTION:
+       The poll() handler for the SIM driver
+ 
+   INPUTS:
+       file	file pointer
+       wait	poll table for this poll()
+
+   OUTPUTS:
+       Returns 0 if no data to read or POLLIN if data available.
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static unsigned int sim_poll(struct file *file, poll_table * wait)
+{
+	unsigned int retval = 0;
+
+	if (sim_module_rx_event == SIM_MODULE_EVENT_NONE) {
+		/* Add our wait queue to the poll table */
+		poll_wait(file, &sim_module_wait, wait);
+	}
+
+	if (sim_module_rx_event != SIM_MODULE_EVENT_NONE) {
+		retval = POLLIN;
+	}
+
+	return retval;
+}
+
+/*
+
+DESCRIPTION:
+    This function is the interrupt handler SIM receive data.
+
+INPUTS:
+    UINT8 reader_id: the card reader ID of the interrupt to handle
+
+OUTPUT:
+    None
+
+IMPORTANT NOTES:
+    None
+
+*/
+static void sim_module_int_rx(UINT8 reader_id)
+{
+	UINT8 new_byte = 0;
+	UINT8 i = 0;
+	BOOL next_is_data_byte = FALSE;
+	if(preforming_status_command == FALSE){
+
+		/* notify user space that data was received */
+		sim_module_rx_event |= SIM_MODULE_EVENT_RX_A;
+
+		if((status_slow_card == TRUE) && (all_data_received == FALSE)) {
+			sim_module_rx_event |= SIM_MODULE_EVENT_INCOMPLETE_SLIM_STATUS;
+		}
+	}
+	else{
+		bytes_recieved = ((UINT16)(omap_get_dma_dst_pos(sim_module_dma_channel) -
+					sim_module_card_data[0].dma_buffer));
+
+		if(proc_bytes_done == FALSE){
+			for(i = last_byte_checked; i < bytes_recieved; i++) {
+				new_byte = sim_module_card_data[0].buffer[i];
+				if(SIM_STATUS_ACK_ALL(new_byte)) {
+					ack_counter++;
+					proc_bytes_done = TRUE;
+					break;
+				}
+				else if(new_byte == SIM_NULL_PROC_BYTE) {
+					null_byte_counter++;
+				}
+				else if(SIM_STATUS_ACK_ONE(new_byte)) {
+					ack_counter++;
+					/* skip over the next (data) byte */
+					i++;
+					/* if we ended on an ACK, the next byte should be data (so skip it) */
+					if(i >= bytes_recieved){
+						next_is_data_byte = TRUE;
+					}
+				}
+				else {
+					proc_bytes_done = TRUE;
+					break;
+				}
+			}
+
+			last_byte_checked = bytes_recieved;
+			/* preemptively skip the next (data) byte if we ended on an ACK (in the ACK ONE case) */
+			if(next_is_data_byte == TRUE){
+				last_byte_checked++;
+			}
+		}
+
+		if(bytes_recieved >= (expected_status_data(card_type) + null_byte_counter + ack_counter)){
+			all_data_received = TRUE;
+		}
+	
+		if(all_data_received == TRUE){
+			preforming_status_command = FALSE;
+		}
+	}
+	write_reg(&(sim_registers[reader_id]->irqstatus), USIM_RX_MASK);
+	return;
+}
+
+/*
+
+DESCRIPTION:
+    This function handles the SIM TX interrupt.  In cases where the TX data exceeds the TX FIFO
+    length, it refills the TX FIFO on TX threshold interrupts.  On TX complete, it switches the
+    system into receive mode.
+
+INPUTS:
+    UINT8 reader_id: the card reader ID of the interrupt to handle
+
+OUTPUT:
+    None
+
+IMPORTANT NOTES:
+    None
+
+*/
+static void sim_module_int_tx(UINT8 reader_id)
+{
+    UINT16 bytes_remaining = 0;
+    UINT8 tx_index = 0;
+    BOOL last_block = FALSE;
+
+    /* disable the transmit complete interrupt */
+    write_reg_bits(&(sim_registers[reader_id]->irqenable), USIM_TX_EN_MASK, 0);
+
+    /* disable the transmitter */
+    write_reg_bits(&(sim_registers[reader_id]->usimconf2), TXNRX_MASK, 0);
+
+    if(preforming_status_command == FALSE){
+
+	/* determine remaining number of bytes to transmit */
+	bytes_remaining = sim_module_card_data[reader_id].tx_length -
+	    sim_module_card_data[reader_id].buffer_index;
+
+	/* if the number of bytes remaining exceeds the FIFO size ... */
+	if (bytes_remaining > SIM_MODULE_TX_FIFO_SIZE) {
+		/* only transmit the free TX FIFO size */
+		bytes_remaining = SIM_MODULE_TX_FIFO_SIZE;
+	} else {
+		last_block = TRUE;
+	}
+
+	/* for each byte of data to transmit ... */
+	for (tx_index = 0; tx_index < bytes_remaining; tx_index++) {
+		/* write the character to the TX FIFO */
+		write_reg(&(sim_registers[reader_id]->usim_dtx),
+			  sim_module_card_data[reader_id].
+			  buffer[sim_module_card_data[reader_id].
+				 buffer_index++]);
+
+	}
+
+	/* setup the TX threshold value to write more data into the FIFO */
+	write_reg_bits(&(sim_registers[reader_id]->usim_fifos),
+		       FIFO_TX_TRIGGER_MASK,
+		       (SIM_MODULE_TX_FIFO_SIZE - 1) << 2);
+
+	/* clear the transmit complete interrupt */
+	write_reg_bits(&(sim_registers[reader_id]->irqstatus),
+		       USIM_TX_MASK, USIM_TX_MASK);
+
+	/* enable the transmit complete interrupt */
+	write_reg_bits(&(sim_registers[reader_id]->irqenable),
+		       USIM_TX_EN_MASK, USIM_TX_EN_MASK);
+
+	/* enable the transmitter */
+	write_reg_bits(&(sim_registers[reader_id]->usimconf2), TXNRX_MASK,
+		       TXNRX_MASK);
+
+	/* if there is just one block of data to send ... */
+	if (last_block == TRUE) {
+		/* reset the data buffer index */
+		sim_module_card_data[reader_id].buffer_index = 0;
+
+		/* enable the receiver right away */
+		write_reg_bits(&(sim_registers[reader_id]->usimconf2),
+			       TXNRX_MASK, 0);
+
+		/* indicate this is the last block */
+		sim_module_all_tx_data_sent = TRUE;
+
+		/* initialize rx mode */
+		sim_module_init_rx_mode(reader_id);
+
+	}
+    }
+    return;
+}
+
+/*
+
+DESCRIPTION:
+    This function is the interrupt handler for the SIM Reset Detect Mode.  This function only reads
+    data and copies it into the receive buffer without checking for parity errors.  The purpose is
+    to advance the buffer_index variable for the detection of an incoming ATR message which
+    indicates that the SIM card has reset.  An ATR message is the only thing which should be
+    received (and then only on SIM card resets) when this interrupt handler is active.
+
+INPUTS:
+    UINT8 reader_id: the card reader ID of the interrupt to handle
+
+OUTPUT:
+    None
+
+IMPORTANT NOTES:
+    None
+
+*/
+static void sim_module_int_reset_detect(UINT8 reader_id)
+{
+	/* mask the RX FIFO full interrupt */
+	write_reg_bits(&(sim_registers[reader_id]->irqenable),
+		       USIM_RX_EN_MASK, 0);
+
+	/* while there is data in the FIFO ... */
+	while (((sim_registers[reader_id]->
+		 usim_fifos) & FIFORX_EMPTY_MASK) == 0) {
+		/* copy the character into the data buffer */
+		sim_module_card_data[reader_id].
+		    buffer[sim_module_card_data[reader_id].buffer_index++]
+		    = (read_reg(&(sim_registers[reader_id]->usim_drx)) &
+		       USIMDRX_MASK);
+	}
+
+	/* set an event for user space */
+	sim_module_rx_event |= SIM_MODULE_EVENT_BUFFER_INDEX;
+
+	/* clear the interrupt */
+	write_reg(&(sim_registers[reader_id]->irqstatus), USIM_RX_MASK);
+
+	return;
+}
+
+
+/*
+
+DESCRIPTION:
+    This function is the interrupt service routine that handles non-data interrupts of smart card
+    interface module 1.
+
+INPUTS:
+    int irq       : the interrupt request number
+    void * dev_id : pointer to the device associated with the interrupt
+
+OUTPUT:
+    irqreturn_t status : a status indicating if an interrupt was handled successfully
+
+IMPORTANT NOTES:
+    None
+
+*/
+static irqreturn_t sim_module_int_irq_1(int irq, void *dev_id)
+{
+	if (sim_low_power_enabled == TRUE) {
+		/* enable the SIM FCLK */
+		clk_enable(usim_fck);
+	}
+
+	/* if the byte resent interrupt fired ... */
+	if (((read_reg(&(sim_registers[SIM_MODULE_1]->irqstatus)) &
+	      USIM_RESENT_MASK) == USIM_RESENT_MASK)
+	    &&
+	    ((read_reg(&(sim_registers[SIM_MODULE_1]->irqenable)) &
+	      USIM_RESENT_EN_MASK) == USIM_RESENT_EN_MASK)) {
+		sim_module_nack_counter++;
+
+		/* if the number of nacks on a character exceed the threshold ... */
+		if (sim_module_nack_counter > SIM_MODULE_NACK_THRESHOLD) {
+			/* we must have a bad ME->SIM connection.
+			   user space must be notified of this fatal error */
+			sim_module_rx_event |= SIM_MODULE_EVENT_ERROR_FLAG;
+			sim_module_nack_counter = 0;
+		}
+
+		write_reg(&(sim_registers[SIM_MODULE_1]->irqstatus),
+			  USIM_RESENT_MASK);
+	}
+
+	/* if the position detect interrupt fired ... */
+	if (((read_reg(&(sim_registers[SIM_MODULE_1]->irqstatus)) &
+	      USIM_CD_MASK) == USIM_CD_MASK)
+	    &&
+	    ((read_reg(&(sim_registers[SIM_MODULE_1]->irqenable)) &
+	      USIM_CD_EN_MASK) == USIM_CD_EN_MASK)) {
+		/* if card status is changing from removed -> present ... */
+		if (((read_reg(&(sim_registers[SIM_MODULE_1]->usimstat)) &
+		      STATNOCARD_MASK) == STATNOCARD_MASK)
+		    && (sim_module_current_pd_state_sim1 == SIM_REMOVED)) {
+			sim_module_rx_event |=
+			    SIM_MODULE_EVENT_SIMPD_INSERTION;
+			sim_module_current_pd_state_sim1 = SIM_PRESENT;
+		}
+
+		/* else if card status is changing from present -> removed ... */
+
+		else if (((read_reg
+			   (&(sim_registers[SIM_MODULE_1]->usimstat)) &
+			   STATNOCARD_MASK) == 0)
+			 && (sim_module_current_pd_state_sim1 ==
+			     SIM_PRESENT)) {
+			sim_module_rx_event |=
+			    SIM_MODULE_EVENT_SIMPD_REMOVAL;
+			sim_module_current_pd_state_sim1 = SIM_REMOVED;
+		}
+
+		/* else the CD interrupt fired, but the status didn't change, so ignore */
+
+		write_reg(&(sim_registers[SIM_MODULE_1]->irqstatus),
+			  USIM_CD_MASK);
+	}
+
+	/* if the character timer interrupt fired ... */
+	if (((read_reg(&(sim_registers[SIM_MODULE_1]->irqstatus)) &
+	      USIM_WT_MASK) == USIM_WT_MASK)
+	    &&
+	    ((read_reg(&(sim_registers[SIM_MODULE_1]->irqenable)) &
+	      USIM_WT_EN_MASK) == USIM_WT_EN_MASK)) {
+		/* notify user space */
+		sim_module_rx_event |= SIM_MODULE_EVENT_WWT_VIOLATION;
+		write_reg_bits(&(sim_registers[SIM_MODULE_1]->irqenable),
+			       USIM_WT_EN_MASK, 0);
+	}
+
+	/* if the no ATR interrupt fired ... */
+	if (((read_reg(&(sim_registers[SIM_MODULE_1]->irqstatus)) &
+	      USIM_NATR_MASK) == USIM_NATR_MASK)
+	    &&
+	    ((read_reg(&(sim_registers[SIM_MODULE_1]->irqenable)) &
+	      USIM_NATR_EN_MASK) == USIM_NATR_EN_MASK)) {
+		write_reg_bits(&(sim_registers[SIM_MODULE_1]->irqenable),
+			       USIM_NATR_EN_MASK, 0);
+		/* notify user space */
+		sim_module_rx_event |= SIM_MODULE_EVENT_NO_ATR_FLAG;
+	}
+
+	/* if one of the data interrupts fired ... */
+	if ((((sim_module_interrupt_mode == SIM_MODULE_RX_MODE)
+	      || (sim_module_interrupt_mode ==
+		  SIM_MODULE_RESET_DETECT_MODE))
+	     &&
+	     ((read_reg(&(sim_registers[SIM_MODULE_1]->irqstatus)) &
+	       USIM_RX_MASK) == USIM_RX_MASK)
+	     &&
+	     ((read_reg(&(sim_registers[SIM_MODULE_1]->irqenable)) &
+	       USIM_RX_EN_MASK) == USIM_RX_EN_MASK))
+	    || ((sim_module_interrupt_mode == SIM_MODULE_TX_MODE)
+		&&
+		((read_reg(&(sim_registers[SIM_MODULE_1]->irqstatus)) &
+		  USIM_TX_MASK) == USIM_TX_MASK)
+		&&
+		((read_reg(&(sim_registers[SIM_MODULE_1]->irqenable)) &
+		  USIM_TX_EN_MASK) == USIM_TX_EN_MASK))) {
+		/* execute the mode specific data interrupt handler */
+		if (sim_module_interrupt_mode == SIM_MODULE_RX_MODE) {
+			sim_module_int_rx(SIM_MODULE_1);
+		} else if (sim_module_interrupt_mode == SIM_MODULE_TX_MODE) {
+			sim_module_int_tx(SIM_MODULE_1);
+		} else if (sim_module_interrupt_mode ==
+			   SIM_MODULE_RESET_DETECT_MODE)
+		{
+			sim_module_int_reset_detect(SIM_MODULE_1);
+		}
+	}
+
+	/* if there was a FIFO overflow ... */
+	if (((read_reg(&(sim_registers[SIM_MODULE_1]->irqstatus)) &
+	      USIM_RXFULL_MASK) == USIM_RXFULL_MASK)
+	    &&
+	    ((read_reg(&(sim_registers[SIM_MODULE_1]->irqenable)) &
+	      USIM_RXFULL_EN_MASK) == USIM_RXFULL_EN_MASK)) {
+		/* there is no reason to read the data in the FIFO, as we've already missed data
+		   at this point. this is a fatal error. the OMAP3430 does not have the ability
+		   to automatically NACK characters when the FIFO is full, therefore characters will
+		   be lost. this can never be allowed to happen because of the lack of flow control
+		   on this IC. */
+
+		/* clear and disable the interrupt */
+		write_reg(&(sim_registers[SIM_MODULE_1]->irqstatus),
+			  USIM_RXFULL_MASK);
+		write_reg_bits(&(sim_registers[SIM_MODULE_1]->irqenable),
+			       USIM_RXFULL_EN_MASK, 0);
+
+		/* notify user space as this could be a fatal error */
+		sim_module_rx_event |= SIM_MODULE_EVENT_FIFO_OVERFLOW;
+	}
+
+	/* if this interrupt caused a user space event ... */
+	if (sim_module_rx_event != SIM_MODULE_EVENT_NONE) {
+		/* wake up the user space event thread */
+		wake_up_interruptible(&sim_module_wait);
+	}
+
+	if (sim_low_power_enabled == TRUE) {
+		/* disable the SIM FCLK */
+		clk_disable(usim_fck);
+	}
+
+	return (IRQ_RETVAL(1));
+}
+
+/*
+
+DESCRIPTION:
+    This routine sets up the hardware and interrupt system to receive data.
+
+INPUTS:
+    UINT8 card_reader_id: card reader ID for which to setup
+
+OUTPUT:
+    None
+
+IMPORTANT NOTES:
+    None
+*/
+static void sim_module_init_rx_mode(UINT8 reader_id)
+{
+	/* if the reader ID is valid ... */
+	if (reader_id < NUM_SIM_MODULES) {
+		/* disable TX mode */
+		write_reg_bits(&(sim_registers[reader_id]->irqenable),
+			       USIM_TX_EN_MASK, 0);
+
+		/* clear the RX fifo threshold */
+		write_reg_bits(&(sim_registers[reader_id]->usim_fifos),
+			       FIFO_RX_TRIGGER_MASK, 0);
+
+		/* enable DMA mode */
+		write_reg_bits(&(sim_registers[reader_id]->usim_fifos),
+			       SIM_DMA_MODE_MASK, SIM_DMA_MODE_MASK);
+
+		/* indicate the card is in the non-ATR receive mode */
+		sim_module_interrupt_mode = SIM_MODULE_RX_MODE;
+
+		/* if there is no data in the FIFO ... */
+		if ((read_reg(&(sim_registers[reader_id]->usim_fifos)) &
+		     FIFORX_EMPTY_MASK) == FIFORX_EMPTY_MASK) {
+			/* clear the RX fifo interrupt */
+			write_reg(&(sim_registers[reader_id]->irqstatus),
+				  (USIM_RX_MASK | USIM_RXFULL_MASK));
+		}
+
+		/* enable the RX full interrupt */
+		write_reg_bits(&(sim_registers[reader_id]->irqenable),
+			       (USIM_RX_MASK | USIM_RXFULL_EN_MASK),
+			       (USIM_RX_MASK | USIM_RXFULL_EN_MASK));
+
+	}
+
+	return;
+}
+
+/*
+
+DESCRIPTION:
+    This routine configures the voltage level
+
+INPUTS:
+    SIM_MODULE_VOLTAGE_LEVEL level : the voltage level to use
+
+OUTPUT:
+    None
+
+IMPORTANT NOTES:
+    None
+*/
+static void sim_module_set_voltage_level(SIM_MODULE_VOLTAGE_LEVEL level)
+{
+	/* power down the voltage regulator */
+	if (regulator_enabled_flag) {
+		regulator_disable(vsim_regulator);
+		regulator_disable(vsimcard_regulator);
+		regulator_enabled_flag = 0;
+	}
+
+	/* power down the pads */
+	write_reg_bits((volatile UINT32 *) PBIAS_CONTROL_LITE,
+		       PBIASPWRDNZ1, 0);
+
+	/* enable fast I/O */
+	write_reg_bits((volatile UINT32 *) PBIAS_CONTROL_LITE,
+		       PBIASSPEEDCNTL1, PBIASSPEEDCNTL1);
+
+	/* 3.0V is desired */
+	if (level == SIM_MODULE_VOLTAGE_HIGH) {
+		/* power on the voltagage regulator at 3 volts */
+		regulator_set_voltage(vsim_regulator, 2900000, 2900000);
+		regulator_set_voltage(vsimcard_regulator, 2900000,
+				      2900000);
+
+		if (!(regulator_enabled_flag)) {
+			regulator_enable(vsim_regulator);
+			regulator_enable(vsimcard_regulator);
+			regulator_enabled_flag = 1;
+		}
+
+		/* configure the pad for 3.0V operation */
+		write_reg_bits((volatile UINT32 *) PBIAS_CONTROL_LITE,
+			       PBIASVMODE1, PBIASVMODE1);
+	}
+
+	/* 1.8V is desired */
+	else if (level == SIM_MODULE_VOLTAGE_LOW) {
+		regulator_set_voltage(vsim_regulator, 1800000, 1800000);
+		regulator_set_voltage(vsimcard_regulator, 1800000,
+				      1800000);
+		if (!(regulator_enabled_flag)) {
+			regulator_enable(vsim_regulator);
+			regulator_enable(vsimcard_regulator);
+			regulator_enabled_flag = 1;
+		}
+
+		/* configure the pad for 1.8V operation */
+		write_reg_bits((volatile UINT32 *) PBIAS_CONTROL_LITE,
+			       PBIASVMODE1, 0);
+	}
+
+	/* else, leave the voltage supply */
+	if ((level == SIM_MODULE_VOLTAGE_HIGH)
+	    || (level == SIM_MODULE_VOLTAGE_LOW)) {
+		/* the pad bias level doesn't equal the VSIM level ... */
+		while ((read_reg((volatile UINT32 *) PBIAS_CONTROL_LITE) &
+			PBIASVMODEERROR1) != 0) {
+			/* block the current thread, but yeild the processor
+			   every iteration of the loop */
+			msleep(1);
+		}
+
+		/* enable the pad */
+		write_reg_bits((volatile UINT32 *) PBIAS_CONTROL_LITE,
+			       PBIASPWRDNZ1, PBIASPWRDNZ1);
+
+		/* let voltages stabalize */
+		msleep(1);
+	}
+
+	return;
+
+}
+
+/*
+
+DESCRIPTION:
+    This routine sets the clock rate
+
+INPUTS:
+    UINT8 reader_id		: the reader ID for which to set the clock rate
+    SIM_MODULE_CLOCK_RATE level : the clock rate to set
+
+OUTPUT:
+    None
+
+IMPORTANT NOTES:
+    None
+*/
+static void sim_module_set_clock_rate(UINT8 reader_id,
+				      SIM_MODULE_CLOCK_RATE rate)
+{
+	/* if the reader ID is valid ... */
+	if (reader_id < NUM_SIM_MODULES) {
+		switch (rate) {
+		case SIM_MODULE_CLOCK_0:
+
+			/* disable the SIM FCLK */
+			clk_disable(usim_fck);
+			break;
+		case SIM_MODULE_CLOCK_4:
+			/* set the internal SIM clock divider to divide by 2 */
+			write_reg_bits(&
+				       (sim_registers[reader_id]->
+					usimconf2), CONFSCLKDIV_MASK, 0);
+			/* disable the SIM FCLK */
+			clk_disable(usim_fck);
+			/* set the source of the SIM FCLK to the 120 MHz clock divided
+			   by 16 to obtain a 3.75 MHz SIM clock */
+			clk_set_parent(usim_fck, omap_120m_fck);
+			clk_set_rate(usim_fck, 7500000);
+
+			/* enable the SIM FCLK */
+			clk_enable(usim_fck);
+			sim_module_clock_frequency =
+			    SIM_MODULE_FREQUENCY_4;
+			break;
+		case SIM_MODULE_CLOCK_5:
+			/* set the internal SIM clock divider to divide by 2 */
+			write_reg_bits(&
+				       (sim_registers[reader_id]->
+					usimconf2), CONFSCLKDIV_MASK, 0);
+			/* disable the SIM FCLK */
+			clk_disable(usim_fck);
+			/* set the source of the SIM FCLK to the 96 MHz clock divided
+			   by 10 to obtain a 4.8 MHz SIM clock */
+			clk_set_parent(usim_fck, omap_96m_fck);
+			clk_set_rate(usim_fck, 9600000);
+
+			/* enable the SIM FCLK */
+			clk_enable(usim_fck);
+			sim_module_clock_frequency =
+			    SIM_MODULE_FREQUENCY_5;
+			break;
+		default:
+			tracemsg
+			    ("Warning: Invalid SIM clock selection.\n");
+			break;
+		}
+	}
+
+	if ((rate == SIM_MODULE_CLOCK_4) || (rate == SIM_MODULE_CLOCK_5)) {
+		/* wait for the clock to stabalize */
+		msleep(1);
+	}
+
+	return;
+}
+
+
+/*
+DESCRIPTION:
+    This routine runs when the GPT1 expires and the system is in full suspend. The routine will
+issue a STATUS command to the SIM card, and verify the response. If the returned status words 
+indicate something that can't be fully handled in user space, the handler will return and the phone
+will be resumed
+
+INPUTS:
+    None
+
+OUTPUT:
+    int status: -1 if user space needs to be woken to handle an event, 0 for success
+
+IMPORTANT NOTES:
+    None
+*/
+int sim_slim_status_handler()
+{
+	int status = -1;
+	int error = 0;
+	UINT8 length = 5;
+	UINT8 tx_index = 0;
+	unsigned long flags = 0;
+	UINT8 sleep_counter = 0;
+	UINT32 save_irq_state = 0;
+	UINT32 save_irq = 0;
+	UINT8 sw1 = 0;
+	UINT8 sw2 = 0;
+
+	if((currently_in_call == FALSE) && (sim_mutex_update(KERNEL_LOCK_MUTEX)) && 
+                (card_type != UNKNOWN_CARD))
+	{
+		preforming_status_command = TRUE;
+		status_slow_card = TRUE;
+ 
+		/* steps normally done from user space: */
+		/* disable low power */
+		sim_low_power_enabled = FALSE;
+		clk_enable(usim_fck);
+		write_reg_bits((volatile UINT32 *)DMA_SYSCONFIG,DMA_MIDLE,DMA_SYSCONFIG_MIDLEMODE(1));
+
+		/* enable the module clock */
+		write_reg_bits (&(sim_registers[0]->usimcmd), MODULE_CLK_EN_MASK, MODULE_CLK_EN_MASK);
+
+		/* reset card reader data */
+		sim_module_card_data[0].buffer_index = 0;
+		sim_module_card_data[0].rx_last_index = 0;
+		sim_module_card_data[0].tx_length = 5;
+		sim_module_card_data[0].error_flag = ISR_NO_ERROR;
+
+		/* save the current interrupts */
+		save_irq_state = read_reg(&(sim_registers[0]->irqenable));    
+		save_irq = save_irq_state;
+    
+		save_irq_state &= ~(USIM_TX_EN_MASK);
+		save_irq_state |= (USIM_RX_EN_MASK);
+
+		/* clear interrupt sources */
+		write_reg_bits (&(sim_registers[0]->irqenable), USIM_IRQEN_MASK_ALL, 0);
+
+		/* set the interrupt mode */
+		sim_module_interrupt_mode = SIM_MODULE_TX_MODE;    
+
+		/* rx_fifo threashold to 1 */
+		write_reg_bits (&(sim_registers[0]->usim_fifos), FIFO_RX_TRIGGER_MASK, 0);
+
+		/* disable the transmitter */
+		write_reg_bits (&(sim_registers[0]->usimconf2), TXNRX_MASK, 0);
+
+		/* set the interrupt mask */
+		write_reg_bits(&(sim_registers[0]->irqenable), USIM_IRQEN_MASK_ALL, save_irq_state);
+
+		/* enable the module clock */
+		write_reg_bits (&(sim_registers[0]->usimcmd), CMD_CLOCK_STOP_MASK, 0);  
+
+		save_irq_state &= ~(USIM_RX_EN_MASK);
+  
+		/* set the interrupt mask */
+		write_reg_bits(&(sim_registers[0]->irqenable), USIM_IRQEN_MASK_ALL, save_irq_state);
+    
+		bytes_recieved = 0;
+    
+		if(card_type == UICC){
+			memcpy(sim_module_card_data[0].buffer, uicc_status, length);
+		}
+		else{
+			memcpy(sim_module_card_data[0].buffer, gsm_status, length);
+		}
+    
+		/* Enable DMA mode */
+		write_reg_bits(&(sim_registers[0]->usim_fifos), SIM_DMA_MODE_MASK, SIM_DMA_MODE_MASK);
+
+		if (sim_module_dma_channel != 0) {
+			omap_free_dma(sim_module_dma_channel);
+			sim_module_dma_channel = 0;
+		}
+
+		/* request a DMA logical channel */
+		error = omap_request_dma(OMAP34XX_DMA_USIM_RX, SIM_DEV_NAME, sim_module_dma_callback,
+			(void *)sim_module_card_data[0].dma_buffer, &sim_module_dma_channel);
+		/* if we failed to get our logical channel */
+		if (error != 0) {
+			tracemsg("sim_slim_status_hdlr: Fatal error - request_dma API failed\n");
+			sim_module_rx_event |= SIM_MODULE_EVENT_NO_DMA_CN_AVB;
+			return 1;
+		}
+		/* configure the DMA parameters */
+		omap_set_dma_transfer_params(sim_module_dma_channel, OMAP_DMA_DATA_TYPE_S8, 1,
+			SIM_MODULE_MAX_DATA, OMAP_DMA_SYNC_ELEMENT, OMAP34XX_DMA_USIM_RX,
+			OMAP_DMA_SRC_SYNC);
+		omap_set_dma_src_params(sim_module_dma_channel, 0, OMAP_DMA_AMODE_CONSTANT,
+			(unsigned long) (&(sim_phys_registers[0]->usim_drx)), 0, 0);
+		omap_set_dma_dest_params(sim_module_dma_channel, 0, OMAP_DMA_AMODE_POST_INC,
+			(unsigned long) sim_module_card_data[0].dma_buffer, 0, 0);
+
+		omap_start_dma(sim_module_dma_channel);
+
+		local_irq_save(flags);
+	
+		/* for each character to transmit ... */
+		for (tx_index = 0; tx_index < length; tx_index++) {
+			/* copy the byte to the TX FIFO */
+			write_reg(&(sim_registers[0]->usim_dtx), sim_module_card_data[0].
+				buffer[sim_module_card_data[0].buffer_index++]);
+		}
+
+		/* setup the TX threshold value to write more data into the FIFO */
+		write_reg_bits(&(sim_registers[0]->usim_fifos), FIFO_TX_TRIGGER_MASK,
+			(SIM_MODULE_TX_FIFO_SIZE - 1) << 2);
+
+		/* clear the transmit complete interrupt */
+		write_reg_bits(&(sim_registers[0]->irqstatus), USIM_TX_MASK, USIM_TX_MASK);
+
+		/* enable the transmit complete interrupt */
+		write_reg_bits(&(sim_registers[0]->irqenable), USIM_TX_EN_MASK, USIM_TX_EN_MASK);
+
+		/* enable WWT */
+		write_reg_bits (&(sim_registers[0]->irqstatus), USIM_WT_MASK, USIM_WT_MASK);
+		write_reg_bits (&(sim_registers[0]->irqenable), USIM_WT_EN_MASK, USIM_WT_EN_MASK);
+
+		/* enable the transmitter */
+		write_reg_bits(&(sim_registers[0]->usimconf2), TXNRX_MASK, TXNRX_MASK);
+
+		sim_module_card_data[0].buffer_index = 0;
+
+		/* enable the receiver right away */
+		write_reg_bits(&(sim_registers[0]->usimconf2), TXNRX_MASK, 0);
+
+		/* indicate this is the last block */
+		sim_module_all_tx_data_sent = TRUE;
+
+		/* initialize rx mode */
+		sim_module_init_rx_mode(0);
+
+		local_irq_restore(flags);
+     
+		while ((!all_data_received) && (sleep_counter <= 19)) {
+			sleep_counter++;
+			msleep(5);
+		}  
+
+		preforming_status_command = FALSE;
+
+		if(all_data_received == TRUE){
+			/* restore interrupt sources */
+			write_reg(&(sim_registers[0]->irqenable), save_irq);
+
+			status_slow_card = FALSE;
+			all_data_received = FALSE;
+
+			sw1 = sim_module_card_data[0].buffer[bytes_recieved - 2];
+			sw2 = sim_module_card_data[0].buffer[bytes_recieved - 1];
+
+			if((((sw1 == 0x90) || (card_type == GSM_SIM && sw1==0x67)) && (sw2 == 0x00)) || (sw1 == 0x91)){
+				sim_low_power_enabled = TRUE;
+      
+				/* Allow DMA to ACK idle requests */
+				write_reg_bits((volatile UINT32 *)DMA_SYSCONFIG,DMA_MIDLE,DMA_SYSCONFIG_MIDLEMODE(2));
+
+				/* Disable DMA mode for low power mode */
+				write_reg_bits(&(sim_registers[0]->usim_fifos), SIM_DMA_MODE_MASK, 0);
+
+				/* disable the module clock */
+				write_reg_bits (&(sim_registers[0]->usimcmd), MODULE_CLK_EN_MASK, 0);
+
+				/* disable the SIM FCLK */
+				clk_disable(usim_fck);
+				if(sim_mutex_update(KERNEL_UNLOCK_MUTEX)) {
+					status = 0;
+				}
+				else {
+					sim_module_rx_event |= SIM_MODULE_EVENT_MUTEX_FREE;
+					status = 1;
+				}
+			}
+			else {
+				sim_module_rx_event |= SIM_MODULE_EVENT_RX_A;
+				sim_module_rx_event |= SIM_MODULE_EVENT_INCOMPLETE_SLIM_STATUS;
+				status = 1;
+			}
+		}
+		else if(null_byte_counter >= 500){
+			sim_module_rx_event |= SIM_MODULE_EVENT_RX_A;
+			sim_module_rx_event |= SIM_MODULE_EVENT_INCOMPLETE_SLIM_STATUS;
+			sim_module_rx_event |= SIM_MODULE_EVENT_NULL_BYTE_OVERFLOW;
+			status = 1;
+		}
+		/* send incomplete slim status with RX_A event */
+		else {
+			sim_module_rx_event |= SIM_MODULE_EVENT_RX_A;
+			sim_module_rx_event |=
+				SIM_MODULE_EVENT_INCOMPLETE_SLIM_STATUS;
+			status = 1;
+		}
+	}
+
+	/* if this interrupt caused a user space event ... */
+	if (sim_module_rx_event != SIM_MODULE_EVENT_NONE) {
+		/* wake up the user space event thread */
+		wake_up_interruptible(&sim_module_wait);
+	}
+
+	return(status);
+}
+
+
+/*
+
+DESCRIPTION:
+    This function manipulates the mutex protecting the SIM HW
+
+INPUTS:
+    UINT8 reader_id: the card reader ID of the HW to protect
+    UINT8 mutex_request: the requester ID and action for the mutex   
+
+OUTPUT:
+    BOOL success: the status of the request
+
+IMPORTANT NOTES:
+    None
+
+*/
+static BOOL sim_mutex_update(UINT8 mutex_request)
+{
+	UINT8 mutex_requester = 0;
+	UINT8 mutex_action = 0;
+	BOOL success = FALSE;
+
+	/* Extract the requester's ID and the action from the request */
+	mutex_requester = mutex_request & MUTEX_REQUESTER_MASK;
+	mutex_action = mutex_request & MUTEX_UNLOCK_MASK;
+
+	spin_lock(&sim_status_lock);
+
+	/* If the request is to unlock the mutex */
+	if(mutex_action == MUTEX_UNLOCK_MASK) {
+		/* If the HW is currently not locked */
+		if(sim_mutex_locked_by_id == 0) {
+       			success = TRUE;
+		}
+		/* If the holder of the mutex is requesting to unlock */
+		else if(mutex_requester == sim_mutex_locked_by_id) {
+			/* If there are no pending requests, simply unlock */
+			if(sim_mutex_requested_by_id == 0){
+				sim_mutex_locked_by_id = 0;
+				success = TRUE;
+			}
+			/* The mutex was requested while we were using it, transfer control to the requester */
+			else {
+				sim_mutex_locked_by_id = sim_mutex_requested_by_id;
+				sim_mutex_requested_by_id = 0;
+			}
+		}
+		/* If we get any requests to unlock from a non-lock holder, we'll ignore them */
+	}
+	/* Else we're trying to lock the SIM HW */
+	else {
+		/* If it's not locked, then go ahead and let the requester have it */
+		if(sim_mutex_locked_by_id == 0){
+			sim_mutex_locked_by_id = mutex_requester;
+			success = TRUE;
+		}
+		/* If it's locked by the kernel, and SCPC wants it, transfer control to SCPC */
+		else if((sim_mutex_locked_by_id == KERNEL_MUTEX_ID) &&
+			(mutex_requester == SCPC_MUTEX_ID)) {
+			sim_mutex_locked_by_id = SCPC_MUTEX_ID;
+			success = TRUE;
+		}
+		/* If its locked and requested by the owner */
+		else if (sim_mutex_locked_by_id == mutex_requester) {
+			success = TRUE;
+		}
+		/* If it's locked, and requested by anyone but the KERNEL, then queue the request */
+		else{
+			if(mutex_requester != KERNEL_MUTEX_ID) {
+				sim_mutex_requested_by_id = mutex_requester;
+			}
+		}
+	}
+	spin_unlock(&sim_status_lock);
+
+	return success;
+}
+
+
+/*
+
+DESCRIPTION:
+    This routine is the callback function for the SIM DMA request
+
+INPUTS:
+    INT32 lch : the logical channel which caused the callback to execute
+    UINT16 ch_status : the status of the logical channel
+    void * data : a pointer to the DMA data.
+
+OUTPUT:
+    None
+
+IMPORTANT NOTES:
+    Given the way we're using DMA due to H/W design and T=0 protocol limitations
+    , this shouldn't ever be called unless there is a problem. Either there was an error,
+    or we ran out of room in the RAM buffer because of too many errors.
+*/
+void sim_module_dma_callback(INT32 lch, UINT16 ch_status, void *data)
+{
+
+	if (ch_status != 0) {
+		tracemsg
+		    ("SIM MODULE DMA CALLBACK ERROR lch -> %X, ch_status -> %X\nregister contents: ",
+		     lch, ch_status);
+
+		tracemsg(" **************************"
+			 " DMA Channel (%d) Registers"
+			 "***************************\n",
+			 sim_module_dma_channel);
+#if(0)
+/* TODO: These don't exist on the new kernel, submit a CR to check out where they went */
+		tracemsg("OMAP_DMA_CCR_REG(%d)	   : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CCR_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CLNK_CTRL_REG(%d)     : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CLNK_CTRL_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CICR_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CICR_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CSR_REG(%d)	   : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CSR_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CSDP_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CSDP_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CEN_REG(%d)	   : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CEN_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CFN_REG(%d)	   : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CFN_REG(sim_module_dma_channel));
+		tracemsg("OMAP2_DMA_CSSA_REG(%d)	 : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP2_DMA_CSSA_REG(sim_module_dma_channel));
+		tracemsg("OMAP2_DMA_CDSA_REG(%d)	 : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP2_DMA_CDSA_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CSEI_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CSEI_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CSFI_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CSFI_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CDEI_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CDEI_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CDFI_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CDFI_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CSAC_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CSAC_REG(sim_module_dma_channel));
+		tracemsg("OMAP_DMA_CDAC_REG(%d)	  : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP_DMA_CDAC_REG(sim_module_dma_channel));
+		tracemsg("OMAP2_DMA_CCEN_REG(%d)	 : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP2_DMA_CCEN_REG(sim_module_dma_channel));
+		tracemsg("OMAP2_DMA_CCFN_REG(%d)	 : 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP2_DMA_CCFN_REG(sim_module_dma_channel));
+		tracemsg("OMAP2_DMA_COLOR_REG(%d)	: 0x%08x\n",
+			 sim_module_dma_channel,
+			 OMAP2_DMA_COLOR_REG(sim_module_dma_channel));
+#endif
+
+	}
+
+	sim_module_rx_event |= SIM_MODULE_EVENT_ERROR_FLAG;
+
+	/* wake up the user space event thread */
+	wake_up_interruptible(&sim_module_wait);
+
+	return;
+}
+
+/* DESCRIPTION:
+       The probe routine.
+ 
+   INPUTS:
+       struct platform_device *pdev : the platform device pointer.  
+
+   OUTPUTS:
+       Returns probe sucess/error indication.
+
+   IMPORTANT NOTES:
+       None.
+*/
+static int sim_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *temp_class;
+
+	sim_module_major = register_chrdev(0, SIM_DEV_NAME, &sim_fops);
+	if (sim_module_major < 0) {
+		tracemsg
+		    ("sim_probe: Unable to get a major for SIM driver\n");
+		return sim_module_major;
+	}
+
+	sim_class = class_create(THIS_MODULE, SIM_DEV_NAME);
+	if (IS_ERR(sim_class)) {
+		unregister_chrdev(sim_module_major, SIM_DEV_NAME);
+		tracemsg("sim_probe: Error creating SIM class.\n");
+		ret = PTR_ERR(sim_class);
+		return ret;
+	}
+
+	temp_class =
+	    device_create(sim_class, NULL, MKDEV(sim_module_major, 0),
+			  NULL, SIM_DEV_NAME);
+
+	if (IS_ERR(temp_class)) {
+		class_destroy(sim_class);
+		unregister_chrdev(sim_module_major, SIM_DEV_NAME);
+		tracemsg("sim_probe: Error creating SIM class device.\n");
+		ret = PTR_ERR(temp_class);
+		return ret;
+	}
+
+	tracemsg("sim_probe: SIM Module successfully probed\n");
+	return ret;
+}
+
+/* DESCRIPTION:
+       The remove routine to disassociate the SIM driver with the device.
+ 
+   INPUTS:
+       struct platform_device *pdev : the platform device pointer.
+
+   OUTPUTS:
+       Returns 0 if successful.
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static int sim_remove(struct platform_device *pdev)
+{
+	device_destroy(sim_class, MKDEV(sim_module_major, 0));
+	class_destroy(sim_class);
+	unregister_chrdev(sim_module_major, SIM_DEV_NAME);
+	tracemsg("sim_remove: Driver-device disassociation complete.\n");
+	return 0;
+}
+
+/* DESCRIPTION:
+       This routine suspends the device.
+
+   INPUTS:
+       struct platform_device *pdev : the platform device pointer
+       pm_message_t state : the power mode that the system is going into
+
+   OUTPUTS:
+       Returns 0 if successful.
+
+   IMPORTANT NOTES:
+       None.
+*/
+static int sim_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int ret = 0;
+	if (sim_low_power_enabled == FALSE)
+		ret = -EBUSY;
+	return ret;
+}
+
+/* DESCRIPTION:
+       This routine resumes the device.
+
+   INPUTS:
+       struct platform_device *pdev : the platform device pointer
+
+   OUTPUTS:
+       Returns 0 if successful.
+
+   IMPORTANT NOTES:
+       None.
+*/
+static int sim_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+
+/* DESCRIPTION:
+       The SIM quick wakeup callback function. This is called by the kernel clock handler when
+   a GPT1 experation happens due to a SCIM set timer. This function also restarts the clock if
+   the last status operation returned successfully.
+ 
+   INPUTS:
+       None. 
+
+   OUTPUTS:
+       int ret - the value return from the sim_slim_status_handler. If the value is success
+                 the kernel puts SIM back to sleep. If it's failure, all drivers are resumed
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static int sim_qw_callback(void)
+{
+    int ret = 0;
+	
+    ret = sim_slim_status_handler();
+
+    if(ret == 0){
+	    wakeup_start_status_timer(sim_timer, sim_poll_interval);
+    }
+    else {
+            wakeup_stop_status_timer(sim_timer);
+    }
+    return ret;
+}
+
+/* DESCRIPTION:
+       The SIM quick wakeup check looks to see if the GPT1 expiration was due to SCIM or some other
+   source.
+ 
+   INPUTS:
+       None. 
+
+   OUTPUTS:
+       int success - 1 if SIM's timer was the cause of the wakeup, otherwise 0
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static int sim_qw_check(void)
+{
+	UINT32 reg;
+	int success = 0;
+
+	/* check GPT1 irq wake up source*/
+	reg = (volatile UINT32)read_reg((volatile UINT32 *)INTCPS_ITR1);
+	reg &= WP_TPIR;
+
+	/* 0 is for GPIO/USB wakeups */
+	if ((reg != 0) && (wakeup_check_status_timer(sim_timer) == 0)){
+		success = 1;
+	}
+	return success;
+}
+
+/* DESCRIPTION:
+       The SIM timer callback function. This is called by the kernel wakeup timer, 
+       when the sim timer expire, and the system is NOT suspended.
+ 
+   INPUTS:
+       None. 
+
+   OUTPUTS:
+       int ret - the return value is currently ignored
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static int sim_timer_callback(void)
+{
+    int ret = 0;
+	
+    sim_module_rx_event |= SIM_MODULE_EVENT_TIMER_EXP;
+
+    /* wake up the user space event thread */
+    wake_up_interruptible(&sim_module_wait);
+
+    return ret;
+}
+
+/* DESCRIPTION:
+       The SIM intialization function.
+ 
+   INPUTS:
+       None.
+
+   OUTPUTS:
+       Returns 0 if successful.
+
+   IMPORTANT NOTES:
+       None.   
+*/
+int __init sim_init(void)
+{
+	int ret = 0;
+
+	tracemsg("sim_init: SIM driver loading...\n");
+
+	vsim_regulator = regulator_get(NULL, "vsim");
+	if (IS_ERR(vsim_regulator)) {
+		printk("Could not get VSIM regulator\n");
+		return PTR_ERR(vsim_regulator);
+	}
+	vsimcard_regulator = regulator_get(NULL, "vsimcard");
+	if (IS_ERR(vsimcard_regulator)) {
+		printk("Could not get VSIMCARD regulator\n");
+		return PTR_ERR(vsimcard_regulator);
+	}
+
+	/* Register the Driver */
+	ret = platform_driver_register(&sim_driver);
+	if (ret != 0) {
+		tracemsg("sim_init: Driver registration failed.\n");
+	} else {
+		tracemsg("sim_init: Driver regristration passed.\n");
+		ret = platform_device_register(&sim_device);
+		if (ret != 0) {
+			platform_driver_unregister(&sim_driver);
+			tracemsg
+			    ("sim_init: Device registration failed.\n");
+		} else {
+			tracemsg
+			    ("sim_init: Device registration passed.\n");
+		}
+	}
+
+	usim_fck = clk_get(&sim_device.dev, USIM_FCK);
+	if (IS_ERR(usim_fck)) {
+		tracemsg("sim_init: Error getting USIM FCLK.\n");
+		ret = PTR_ERR(usim_fck);
+	}
+
+	usim_ick = clk_get(&sim_device.dev, USIM_ICK);
+	if (IS_ERR(usim_ick)) {
+		tracemsg("sim_init: Error getting USIM ICLK.\n");
+		ret = PTR_ERR(usim_ick);
+	}
+
+	omap_96m_fck = clk_get(&sim_device.dev, OMAP_96M_FCK);
+	if (IS_ERR(omap_96m_fck)) {
+		tracemsg("sim_init: Error getting 96M FCLK.\n");
+		ret = PTR_ERR(omap_96m_fck);
+	}
+
+	omap_120m_fck = clk_get(&sim_device.dev, OMAP_120M_FCK);
+	if (IS_ERR(omap_120m_fck)) {
+		tracemsg("sim_init: Error getting 120M FCLK.\n");
+		ret = PTR_ERR(omap_120m_fck);
+	}
+	quickwakeup_register(&sim_qw_ops);
+	sim_timer = wakeup_create_status_timer(sim_timer_callback);
+	if (sim_timer == NULL) {
+		tracemsg("sim_init: sim_timer creation failed.\n");
+		ret = -ENOMEM;
+	}
+	return ret;
+}
+
+/* DESCRIPTION:
+       The SIM device cleanup function
+ 
+   INPUTS:
+       None. 
+
+   OUTPUTS:
+       None.
+
+   IMPORTANT NOTES:
+       None.   
+*/
+static void __exit sim_exit(void)
+{
+	regulator_put(vsim_regulator);
+	regulator_put(vsimcard_regulator);
+
+
+	/* release the clock resources */
+	clk_put(usim_fck);
+	clk_put(usim_ick);
+	clk_put(omap_96m_fck);
+	clk_put(omap_120m_fck);
+
+        /* free the SIM status timer */
+        wakeup_del_status_timer(sim_timer);
+        sim_timer = NULL;
+
+	/* unregister the device */
+	platform_device_unregister(&sim_device);
+	platform_driver_unregister(&sim_driver);
+	tracemsg("sim_exit: SIM driver successfully unloaded.\n");
+}
+
+
+/*
+ * Module entry points
+ */
+module_init(sim_init);
+module_exit(sim_exit);
+
+MODULE_DESCRIPTION("SIM driver");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
diff --git a/drivers/sim/smart_card.h b/drivers/sim/smart_card.h
new file mode 100644
index 0000000..90cb2d1
--- /dev/null
+++ b/drivers/sim/smart_card.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2005-2009 Motorola, Inc.
+ * This program is licensed under a BSD license with the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted
+ * provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this list of conditions
+ *   and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice, this list of
+ *   conditions and the following disclaimer in the documentation and/or other materials provided
+ *   with the distribution.
+ * - Neither the name of Motorola nor the names of its contributors may be used to endorse or
+ *   promote products derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Motorola 2009-Nov-06 - Add support for local timers
+ * Motorola 2009-Oct-10 - Add support for low current drain wakeups
+ * Motorola 2009-Mar-16 - Support the GIT build environment
+ * Motorola 2008-Dec-06 - Added a Sleep IOCTL
+ * Motorola 2008-Mar-05 - OMAP support
+ * Motorola 2007-May-23 - Add new IOCTLs
+ * Motorola 2006-Aug-31 - Remove some functionality from the driver
+ * Motorola 2006-Aug-21 - Add support for all peripheral clock frequencies
+ * Motorola 2006-Jul-25 - More MVL upmerge changes
+ * Motorola 2006-Jul-14 - MVL upmerge
+ * Motorola 2006-May-24 - Fix GPL issues
+ * Motorola 2005-Oct-04 - Initial Creation
+ */
+ 
+#ifndef __SMART_CARD_H__
+#define __SMART_CARD_H__
+
+#include <linux/ioctl.h>
+
+#ifdef __KERNEL__
+#include "smart_card_kernel.h"
+#endif
+
+enum
+{
+    ISR_NO_ERROR = 0,
+    ISR_FATAL_ERROR,
+    ISR_NACK_LIMIT_ERROR
+};
+typedef UINT8 SIM_MODULE_ISR_ERROR;
+
+enum
+{
+    SIM_MODULE_VOLTAGE_OFF = 0,
+    SIM_MODULE_VOLTAGE_LOW,
+    SIM_MODULE_VOLTAGE_HIGH
+};
+typedef UINT8 SIM_MODULE_VOLTAGE_LEVEL;
+
+enum
+{
+    SIM_MODULE_RX_MODE,
+    SIM_MODULE_TX_MODE,
+    SIM_MODULE_RESET_DETECT_MODE
+};
+typedef UINT8 SIM_MODULE_INTERRUPT_MODE;
+
+enum
+{
+    SIM_MODULE_1 = 0,
+    NUM_SIM_MODULES
+};
+typedef UINT8 SIM_MODULE_ID;
+
+enum
+{
+    SIM_MODULE_CLOCK_0,
+    SIM_MODULE_CLOCK_4,
+    SIM_MODULE_CLOCK_5
+};
+typedef UINT8 SIM_MODULE_CLOCK_RATE;
+
+/* List of values for manipulating the mutex */
+enum
+{
+    KERNEL_MUTEX_ID     = 0x01,
+    SCSM_MUTEX_ID       = 0x02,
+    SCPC_MUTEX_ID       = 0x03,
+};
+typedef UINT8 SIM_MUTEX_ID;
+
+#define MUTEX_UNLOCK_MASK      0x10
+#define MUTEX_REQUESTER_MASK   0x0F
+#define KERNEL_LOCK_MUTEX      KERNEL_MUTEX_ID
+#define KERNEL_UNLOCK_MUTEX    0x11
+
+/* SIM module A events */
+#define SIM_MODULE_EVENT_NONE                   0x00000000
+#define SIM_MODULE_EVENT_RX_A                   0x00000001
+#define SIM_MODULE_EVENT_SIMPD_BOUNCE           0x00000002
+#define SIM_MODULE_EVENT_SIMPD_INSERTION        0x00000004      
+#define SIM_MODULE_EVENT_SIMPD_REMOVAL          0x00000008
+#define SIM_MODULE_EVENT_PARITY_ERROR           0x00000010
+#define SIM_MODULE_EVENT_BUFFER_INDEX           0x00000020
+#define SIM_MODULE_EVENT_ERROR_FLAG             0x00000040
+#define SIM_MODULE_EVENT_NO_ATR_FLAG            0x00000080
+#define SIM_MODULE_EVENT_WWT_VIOLATION          0x00000100
+#define SIM_MODULE_EVENT_FIFO_OVERFLOW          0x00000200
+#define SIM_MODULE_EVENT_INCOMPLETE_SLIM_STATUS 0x00000400
+#define SIM_MODULE_EVENT_MUTEX_FREE             0x00000800
+#define SIM_MODULE_EVENT_NULL_BYTE_OVERFLOW     0x00001000
+#define SIM_MODULE_EVENT_NO_DMA_CN_AVB          0x00002000
+#define SIM_MODULE_EVENT_TIMER_EXP              0x00004000
+
+#define SIM_NUM 230
+/*******************************************************************************************
+ * Ioctl commands
+ *
+ *    These are the ioctl commands for the SIM interface module driver. These will not be used directly
+ *    from user-space, but are used to construct the request parameters used in ioctl() 
+ *    calls to the driver. 
+ ******************************************************************************************/
+
+#define SIM_IOC_CMD_CORE_CONFIGURE_GPIO                (0x00)
+#define SIM_IOC_CMD_CORE_INTERRUPT_INIT                (0x01)
+#define SIM_IOC_CMD_CORE_INTERRUPT_MODE                (0x02)
+#define SIM_IOC_CMD_CORE_READ_BUFFER_INDEX             (0x03)
+#define SIM_IOC_CMD_CORE_READ_DATA_BUFFER              (0x04)
+#define SIM_IOC_CMD_CORE_READ_RX_EVENT                 (0x05)
+#define SIM_IOC_CMD_CORE_READ_SIM_REG_DATA             (0x06)
+#define SIM_IOC_CMD_CORE_RESET_CARD_READER_DATA        (0x07)
+#define SIM_IOC_CMD_CORE_SET_CWTCNT                    (0x08)
+#define SIM_IOC_CMD_CORE_SET_GPCNT                     (0x09)
+#define SIM_IOC_CMD_CORE_SET_VOLTAGE_LEVEL             (0x0A)
+#define SIM_IOC_CMD_CORE_UPDATE_DATA_BUFFER            (0x0B)
+#define SIM_IOC_CMD_CORE_UPDATE_BUFFER_INDEX           (0x0C)
+#define SIM_IOC_CMD_CORE_UPDATE_RX_LAST_INDEX          (0x0D)
+#define SIM_IOC_CMD_CORE_WRITE_SIM_REG_BIT             (0x0E)
+#define SIM_IOC_CMD_CORE_WRITE_SIM_REG_DATA            (0x0F)
+#define SIM_IOC_CMD_CORE_ALL_TX_DATA_SENT              (0x10)
+#define SIM_IOC_CMD_CORE_RESET_ALL_TX_DATA_SENT        (0x11)
+#define SIM_IOC_CMD_CORE_SET_SIM_CLOCK_RATE            (0x12)
+#define SIM_IOC_CMD_CORE_DATA_TX                       (0x13)
+#define SIM_IOC_CMD_CORE_GET_SIM_CLOCK_FREQ            (0x14)
+#define SIM_IOC_CMD_CORE_LOW_POWER_STATE               (0x15)
+#define SIM_IOC_CMD_CORE_SLEEP                         (0x16)
+#define SIM_IOC_CMD_CORE_CARD_TYPE                     (0x17)
+#define SIM_IOC_CMD_CORE_MUTEX_UPDATE                  (0x18)
+#define SIM_IOC_CMD_CORE_POLL_INTERVAL                 (0x19)
+#define SIM_IOC_CMD_CORE_CALL_STATUS                   (0x1A)
+#define SIM_IOC_CMD_CORE_START_TIMER                   (0x1B)
+#define SIM_IOC_CMD_CORE_STOP_TIMER                    (0x1C)
+#define SIM_IOC_CMD_CORE_LAST_CMD                      SIM_IOC_CMD_CORE_STOP_TIMER
+
+/*******************************************************************************************
+ * Ioctl requests
+ *
+ *    These are the requests that can be passed to ioctl() to request operations on the
+ *    SIM interface module driver.
+ ******************************************************************************************/
+#define SIM_IOCTL_CONFIGURE_GPIO \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_CONFIGURE_GPIO, UINT8)
+#define SIM_IOCTL_INTERRUPT_INIT \
+        _IOW(SIM_NUM,  SIM_IOC_CMD_CORE_INTERRUPT_INIT, UINT32 *)
+#define SIM_IOCTL_INTERRUPT_MODE \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_INTERRUPT_MODE, UINT8)
+#define SIM_IOCTL_READ_BUFFER_INDEX \
+        _IOR(SIM_NUM, SIM_IOC_CMD_CORE_READ_BUFFER_INDEX, UINT32 *)
+#define SIM_IOCTL_READ_DATA_BUFFER \
+        _IOR(SIM_NUM, SIM_IOC_CMD_CORE_READ_DATA_BUFFER, UINT32 *)
+#define SIM_IOCTL_READ_RX_EVENT \
+        _IOR(SIM_NUM, SIM_IOC_CMD_CORE_READ_RX_EVENT, UINT32 *)
+#define SIM_IOCTL_READ_SIM_REG_DATA \
+        _IOR(SIM_NUM, SIM_IOC_CMD_CORE_READ_SIM_REG_DATA, UINT32 *)
+#define SIM_IOCTL_RESET_CARD_READER_DATA \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_RESET_CARD_READER_DATA, UINT32 *)
+#define SIM_IOCTL_SET_VOLTAGE_LEVEL \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_SET_VOLTAGE_LEVEL, UINT32 *)
+#define SIM_IOCTL_UPDATE_DATA_BUFFER \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_UPDATE_DATA_BUFFER, UINT8 *)
+#define SIM_IOCTL_UPDATE_BUFFER_INDEX \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_UPDATE_BUFFER_INDEX, UINT32 *)
+#define SIM_IOCTL_UPDATE_RX_LAST_INDEX \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_UPDATE_RX_LAST_INDEX, UINT32 *)
+#define SIM_IOCTL_WRITE_SIM_REG_BIT \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_WRITE_SIM_REG_BIT, UINT32 *)
+#define SIM_IOCTL_WRITE_SIM_REG_DATA \
+        _IOW(SIM_NUM, SIM_IOC_CMD_CORE_WRITE_SIM_REG_DATA, UINT32 *)
+#define SIM_IOCTL_ALL_TX_DATA_SENT \
+       _IOR(SIM_NUM, SIM_IOC_CMD_CORE_ALL_TX_DATA_SENT, BOOLEAN *)
+#define SIM_IOCTL_RESET_ALL_TX_DATA_SENT \
+       _IO(SIM_NUM, SIM_IOC_CMD_CORE_RESET_ALL_TX_DATA_SENT)
+#define SIM_IOCTL_SET_SIM_CLOCK_RATE \
+       _IOW(SIM_NUM, SIM_IOC_CMD_CORE_SET_SIM_CLOCK_RATE, UINT32)
+#define SIM_IOCTL_DATA_TX \
+       _IOW(SIM_NUM, SIM_IOC_CMD_CORE_DATA_TX, UINT32 *)
+#define SIM_IOCTL_GET_SIM_CLOCK_FREQ \
+       _IOR(SIM_NUM, SIM_IOC_CMD_CORE_GET_SIM_CLOCK_FREQ, UINT32 *)
+#define SIM_IOCTL_LOW_POWER_STATE \
+       _IOW(SIM_NUM, SIM_IOC_CMD_CORE_LOW_POWER_STATE, UINT32 *)
+#define SIM_IOCTL_SLEEP \
+       _IO(SIM_NUM, SIM_IOC_CMD_CORE_SLEEP)
+#define SIM_IOCTL_CARD_TYPE \
+       _IOW(SIM_NUM, SIM_IOC_CMD_CORE_CARD_TYPE, UINT32 *)
+#define SIM_IOCTL_MUTEX_UPDATE \
+       _IOW(SIM_NUM, SIM_IOC_CMD_CORE_MUTEX_UPDATE, UINT32 *)
+#define SIM_IOCTL_POLL_INTERVAL \
+       _IOW(SIM_NUM, SIM_IOC_CMD_CORE_POLL_INTERVAL, UINT32 *)
+#define SIM_IOCTL_CALL_STATUS \
+       _IOW(SIM_NUM, SIM_IOC_CMD_CORE_CALL_STATUS, UINT32 *)
+#define SIM_IOCTL_START_TIMER \
+       _IO(SIM_NUM, SIM_IOC_CMD_CORE_START_TIMER)
+#define SIM_IOCTL_STOP_TIMER \
+       _IO(SIM_NUM, SIM_IOC_CMD_CORE_STOP_TIMER)
+
+#endif /* __SMART_CARD_H__ */
diff --git a/drivers/sim/smart_card_kernel.h b/drivers/sim/smart_card_kernel.h
new file mode 100644
index 0000000..26d188f
--- /dev/null
+++ b/drivers/sim/smart_card_kernel.h
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2007-2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  
+ * 02111-1307, USA
+ *
+ * Motorola 2009-Oct-29 - Support for low current drain wakeups
+ * Motorola 2009-Jan-06 - Update for TI Kernel 25.3
+ * Motorola 2008-Mar-05 - Update for OMAP
+ * Motorola 2007-Sep-14 - Initial Creation
+ */
+ 
+#ifndef __SMART_CARD_KERNEL_H__
+#define __SMART_CARD_KERNEL_H__
+
+#ifdef __KERNEL__
+
+#include <mach/hardware.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+/************** STRUCTURES, ENUMS, AND TYPEDEFS *******************************/
+typedef signed char INT8;
+typedef unsigned char UINT8;
+typedef signed short int INT16;
+typedef unsigned short int UINT16;
+typedef signed int INT32;
+typedef unsigned int UINT32;
+typedef unsigned char BOOL;
+typedef unsigned char BOOLEAN;
+
+typedef struct
+{
+    UINT32 revision;              /* 0x00 */
+    UINT32 ident;                 /* 0x04 */
+    UINT32 unused1;               /* 0x08 */
+    UINT32 unused2;               /* 0x0C */
+    UINT32 sysconfig;             /* 0x10 */
+    UINT32 sysstatus;             /* 0x14 */
+    UINT32 irqstatus;             /* 0x18 */
+    UINT32 irqenable;             /* 0x1C */
+    UINT32 wakeupen;              /* 0x20 */
+    UINT32 usimcmd;               /* 0x24 */
+    UINT32 usimstat;              /* 0x28 */
+    UINT32 usimconf1;             /* 0x2C */
+    UINT32 usimconf2;             /* 0x30 */
+    UINT32 usimconf3;             /* 0x34 */
+    UINT32 usim_drx;              /* 0x38 */
+    UINT32 usim_dtx;              /* 0x3C */
+    UINT32 usim_fifos;            /* 0x40 */
+    UINT32 usim_cgt;              /* 0x44 */
+    UINT32 usim_cwt;              /* 0x48 */
+    UINT32 usim_bwt;              /* 0x4C */
+    UINT32 debug_reg;             /* 0x50 */
+    UINT32 conf_sam1_div;         /* 0x54 */
+    UINT32 conf4_reg;             /* 0x58 */
+    UINT32 atr_clk_prd_nbs;       /* 0x5C */
+    UINT32 conf_etu_div;          /* 0x60 */
+    UINT32 conf5_reg;             /* 0x64 */
+    UINT32 tc_guard_time_add_reg; /* 0x68 */
+} SIM_MODULE_REGISTER_BANK;
+
+
+/*******************************************************************************************
+ * Constants
+ *******************************************************************************************/
+
+#define INT_SIM_GENERAL                    35 
+
+#define SIM_DEV_NAME                       "sim"
+
+#define TRUE                                1
+#define FALSE                               0
+
+#define SIM_MODULE_RX_FIFO_SIZE          16
+#define SIM_MODULE_TX_FIFO_SIZE          16
+
+#define SIM_MODULE_MAX_NULL_PROCEDURE_BYTES   500
+#define SIM_MODULE_MAX_DATA                  (260 + SIM_MODULE_MAX_NULL_PROCEDURE_BYTES)
+
+#define SIM_NUM                       230
+
+#define SIM1_BASE_ADDR (L4_WK_34XX_BASE + 0xe000) /* 0x4830E000 */
+
+/* revision register */
+#define REV_MASK 0x00FF
+
+/* ident */
+#define VENDOR_CODE_MASK 0xFFFF
+
+/* sysconfig */
+#define CLOCK_ACTIVITY_MASK 0x0300
+#define EMUFREE_MASK        0x0020
+#define IDLEMODE_MASK       0x0018
+#define ENAWAKEUP_MASK      0x0004
+#define SOFTRESET_MASK      0x0002
+#define AUTOIDLE_MASK       0x0001
+
+/* sysstatus */
+#define RESETDONE_MASK 0x0001
+
+/* irqstatus */
+#define USIM_STOP_CLK_MASK              0x1000
+#define IT_EMV_ATR_LENGTH_TIME_OUT_MASK 0x0800
+#define TS_ERROR_MASK                   0x0400
+#define USIM_RESENT_MASK                0x0200
+#define USIM_TOB_MASK                   0x0100
+#define USIM_TOC_MASK                   0x0080
+#define USIM_EOB_MASK                   0x0040
+#define USIM_CD_MASK                    0x0020
+#define USIM_RX_MASK                    0x0010
+#define USIM_TX_MASK                    0x0008
+#define USIM_RXFULL_MASK                0x0004
+#define USIM_WT_MASK                    0x0002
+#define USIM_NATR_MASK                  0x0001
+
+/* irqenable */
+#define USIM_IRQEN_MASK_ALL                0x1FFF
+#define USIM_STOP_CLK_EN_MASK              0x1000
+#define IT_EMV_ATR_LENGTH_TIME_OUT_EN_MASK 0x0800
+#define TS_ERROR_EN_MASK                   0x0400
+#define USIM_RESENT_EN_MASK                0x0200
+#define USIM_TOB_EN_MASK                   0x0100
+#define USIM_TOC_EN_MASK                   0x0080
+#define USIM_EOB_EN_MASK                   0x0040
+#define USIM_CD_EN_MASK                    0x0020
+#define USIM_RX_EN_MASK                    0x0010
+#define USIM_TX_EN_MASK                    0x0008
+#define USIM_RXFULL_EN_MASK                0x0004
+#define USIM_WT_EN_MASK                    0x0002
+#define USIM_NATR_EN_MASK                  0x0001
+
+/* wakeupen */
+#define USIM_STOP_CLK_WK_EN_MASK              0x1000
+#define IT_EMV_ATR_LENGTH_TIME_OUT_WK_EN_MASK 0x0800
+#define TS_ERROR_WK_EN_MASK                   0x0400
+#define USIM_RESENT_WK_EN_MASK                0x0200
+#define USIM_TOB_WK_EN_MASK                   0x0100
+#define USIM_TOC_WK_EN_MASK                   0x0080
+#define USIM_EOB_WK_EN_MASK                   0x0040
+#define USIM_CD_WK_EN_MASK                    0x0020
+#define USIM_RX_WK_EN_MASK                    0x0010
+#define USIM_TX_WK_EN_MASK                    0x0008
+#define USIM_RXFULL_WK_EN_MASK                0x0004
+#define USIM_WT_WK_EN_MASK                    0x0002
+#define USIM_NATR_WK_EN_MASK                  0x0001
+
+/* usimcmd */
+#define STOP_EMV_ATR_LENGTH_TIMER_MASK 0x0040
+#define CMD_CLOCK_STOP_MASK            0x0020
+#define CMD_WARM_RST_MASK              0x0010
+#define MODULE_CLK_EN_MASK             0x0008
+#define CMDSTART_MASK                  0x0004
+#define CMDSTOP_MASK                   0x0002
+
+/* usimstat */
+#define X_MODE_MASK      0x0010
+#define CONFCODCONV_MASK 0x0008
+#define STATLRC_MASK     0x0004
+#define STATTXPAR_MASK   0x0002
+#define STATNOCARD_MASK  0x0001
+
+/* usimconf1 */
+#define EMV_CONF_MASK     0x0040
+#define CONF_SCLK_EN_MASK 0x0020
+#define SRSTLEV_MASK      0x0010
+#define SVCCLEV_MASK      0x0008
+#define CONFBYPASS_MASK   0x0004
+#define CONFSIOLOW_MASK   0x0002
+#define SCLKLEV_MASK      0x0001
+
+/* usimconf2 */
+#define DEBOUNCE_EN_MASK     0x2000
+#define HW_DEACTIV_EN_MASK   0x1000
+#define CARD_POLARITY_MASK   0x0800
+#define CONFRESET_MASK       0x0700
+#define CONFLRCCHECK_MASK    0x0080
+#define CONFEDC_MASK         0x0040
+#define CONFPROTOCOL_MASK    0x0020
+#define ATR_ASYN_BYPASS_MASK 0x0010
+#define CONFSCLKDIV_MASK     0x000C
+#define TXNRX_MASK           0x0002
+#define CONFCHKPAR_MASK      0x0001
+
+/* usimconf3 */
+#define TDUSIM_MASK 0x00F0
+#define TFUSIM_MASK 0x000F
+
+/* usim_drx */
+#define STATRXPAR_MASK 0x0100
+#define USIMDRX_MASK   0x00FF
+
+/* usim_dtx */
+#define DTX_MASK 0x00FF
+
+/* usim_fifos */
+#define FIFORX_FULL_MASK     0x8000
+#define FIFORX_EMPTY_MASK    0x4000
+#define FIFORX_RESET_MASK    0x2000
+#define FIFO_RX_TRIGGER_MASK 0x1e00
+#define FIFO_RX_TRIGGER_SHIFT 9
+#define FIFOTX_FULL_MASK     0x0100
+#define FIFOTX_EMPTY_MASK    0x0080
+#define FIFOTX_RESET_MASK    0x0040
+#define FIFO_TX_TRIGGER_MASK 0x003c
+#define FIFO_TX_TRIGGER_SHIFT 2
+#define FIFO_ENABLE_MASK     0x0002
+#define SIM_DMA_MODE_MASK        0x0001
+
+/* usim_cgt */
+#define CGT_MASK 0x00FF
+
+/* usim_cwt */
+#define CWT_MASK 0xFFFF
+
+/* usim_bwt */
+#define BWT_MASK 0x007FFFFF
+
+/* debug_reg */
+#define TXDMA_MASK            0x4000
+#define RXDMA_MASK            0x2000
+#define RXFIFO_PEAK_MASK      0x1F00
+#define RX_STATE_MACHINE_MASK 0x00C0
+#define TX_STATE_MACHINE_MASK 0x0030
+#define MAIN_STATE_DEBUG      0x000F
+
+/* conf_sam1_div */
+#define SAM1_DIV_MASK 0x0FFF
+
+/* conf4_reg */
+#define CONFWAITI_MASK 0xFFFF
+
+/* atr_clk_prd_nbs */
+#define CLOCK_NUMBER_BEFORE_ATR_MASK 0xFFFF
+
+/* conf_etu_div */
+#define ETU_DIV_MASK 0xFFFF
+
+/* conf5_reg */
+#define SOFT_NHARD_FIDI_PROG_MASK 0x0100
+#define CONFFI_MASK               0x00F0
+#define DI_MASK                   0x000F
+
+/* tc_guard_time_add_reg */
+#define SOFT_TC_GUARD_TIME_ADD_EN_MASK 0x2000
+#define SOFT_TC_GUARD_TIME_ADD_MASK    0x1FFF
+
+#endif /* __SMART_CARD_KERNEL_H__ */
+#endif 
diff --git a/drivers/spi/omap2_mcspi.c b/drivers/spi/omap2_mcspi.c
index 3da8825..39a9cf7 100644
--- a/drivers/spi/omap2_mcspi.c
+++ b/drivers/spi/omap2_mcspi.c
@@ -4,6 +4,7 @@
  * Copyright (C) 2005, 2006 Nokia Corporation
  * Author:	Samuel Ortiz <samuel.ortiz@nokia.com> and
  *		Juha Yrjl <juha.yrjola@nokia.com>
+ *  Copyright (C) 2009 Motorola, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,6 +20,10 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
+ *  Revision History:
+ *  Date         Author        Comment
+ *  ---------    ----------    ---------
+ *  Jun 30,2008   Motorola      Update cmdline param for emu_uart_debug option
  */
 
 #include <linux/kernel.h>
@@ -37,7 +42,9 @@
 
 #include <mach/dma.h>
 #include <mach/clock.h>
-
+#ifdef CONFIG_EMU_UART_DEBUG
+#include <mach/board-mapphone-emu_uart.h>
+#endif
 
 #define OMAP2_MCSPI_MAX_FREQ		48000000
 
@@ -897,6 +904,53 @@ static int omap2_mcspi_transfer(struct spi_device *spi, struct spi_message *m)
 			return -EINVAL;
 		}
 
+#ifdef CONFIG_EMU_UART_DEBUG
+		if (is_emu_uart_active() && tx_buf != NULL) {
+			char *buf = (char *) tx_buf;
+			unsigned short addr = (buf[3] & 0x7F)<<6 | buf[2]>>2;
+			unsigned short old_val;
+
+			/* If trying to write CPCAP VBUSC or USBC2 register */
+			if ((buf[3] & 0x80) &&
+				(!strncmp(spi->dev.driver->name, "cpcap", 5)) &&
+				(addr == 897 || addr == 411)) {
+				old_val = *(unsigned short *)&buf[0];
+				/*
+				 * Update value to be written into
+				 * "USB Control 2" register
+				 */
+				if (addr == 897) {
+					/*
+					 * Make sure EMUMODE and UART setting
+					 * fields not changed
+					 * */
+					buf[1] = (buf[1] & 0xF0) | 0x01;
+					buf[0] = (buf[0] & 0xF8) | 0x01;
+				}
+				/*
+				 * Update value to be written into
+				 * "VUSB Control" register
+				 */
+				else if (addr == 411) {
+					/* Make sure VBUS power mode fields
+					 * not changed
+					 */
+					buf[1] = 0x01;
+					buf[0] = 0x4C;
+				}
+				if (old_val != *(unsigned short *)&buf[0]) {
+					printk(KERN_ALERT
+						"omap2_mcspi_transfer: write"
+						"CPCAP reg %d with 0x%04x "
+						"instead of 0x%04x\n",
+						addr,\
+						*(unsigned short *)&buf[0],\
+						old_val);
+				}
+			}
+		}
+#endif
+
 		if (m->is_dma_mapped || len < DMA_MIN_BYTES)
 			continue;
 
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 643908b..d807583 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -25,6 +25,9 @@
 #include <linux/mutex.h>
 #include <linux/spi/spi.h>
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+static struct spi_device *spi_device_smsmdtv;
+#endif
 
 /* SPI bustype and spi_master class are registered after board init code
  * provides the SPI device tables, ensuring that both are present by the
@@ -381,6 +384,9 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 static void scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+	struct spi_device *spi;
+#endif
 
 	mutex_lock(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
@@ -393,7 +399,19 @@ static void scan_boardinfo(struct spi_master *master)
 			/* NOTE: this relies on spi_new_device to
 			 * issue diagnostics when given bogus inputs
 			 */
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+		spi = spi_new_device(master, chip);
+/* note: this macro is remove from include/linux/kobject.h */
+#define KOBJ_NAME_LEN 20
+
+	if (strncmp(chip->modalias, "smsspi", KOBJ_NAME_LEN) == 0) {
+		spi_device_smsmdtv = spi;
+
+		printk(KERN_INFO "smsspi device is added.\n");
+	}
+#else
 			(void) spi_new_device(master, chip);
+#endif
 		}
 	}
 	mutex_unlock(&board_lock);
@@ -699,6 +717,19 @@ int spi_write_then_read(struct spi_device *spi,
 }
 EXPORT_SYMBOL_GPL(spi_write_then_read);
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+struct spi_device *spi_get_spi_device(char *modalias)
+{
+#define KOBJ_NAME_LEN   20
+
+	if (strncmp(modalias, "smsspi", KOBJ_NAME_LEN) == 0)
+		return spi_device_smsmdtv;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_get_spi_device);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 static int __init spi_init(void)
diff --git a/drivers/staging/android/logger.c b/drivers/staging/android/logger.c
index ab32003..b39f8e4 100644
--- a/drivers/staging/android/logger.c
+++ b/drivers/staging/android/logger.c
@@ -23,10 +23,16 @@
 #include <linux/uaccess.h>
 #include <linux/poll.h>
 #include <linux/time.h>
+#ifdef CONFIG_LTT_LITE
+#include <linux/lttlite-events.h>
+#endif
 #include "logger.h"
 
 #include <asm/ioctls.h>
-
+#define KERNEL_LOG
+#ifdef KERNEL_LOG
+#include <linux/console.h>
+#endif
 /*
  * struct logger_log - represents a specific log, such as 'main' or 'radio'
  *
@@ -57,6 +63,17 @@ struct logger_reader {
 	size_t			r_off;	/* current read head offset */
 };
 
+#ifdef KERNEL_LOG
+static void logger_kernel_write(struct console *co, const char *s, unsigned count);
+static struct console loggercons = {
+    name:	"logger",
+    write:	logger_kernel_write,
+    flags:	CON_ENABLED,
+    index:	-1,
+};
+#endif
+int Filter_Mot_Log_Enable = 1;
+
 /* logger_offset - returns index 'n' into the log via (optimized) modulus */
 #define logger_offset(n)	((n) & (log->size - 1))
 
@@ -285,7 +302,7 @@ static void do_write_log(struct logger_log *log, const void *buf, size_t count)
 		memcpy(log->buffer, buf + len, count - len);
 
 	log->w_off = logger_offset(log->w_off + count);
-
+	
 }
 
 /*
@@ -328,6 +345,20 @@ ssize_t logger_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	struct timespec now;
 	ssize_t ret = 0;
 
+#ifdef CONFIG_LTT_LITE
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	/*
+	 * If LTT-lite logging for Android messages is enabled, the LTT Lite
+	 * driver will aggregate the Android log message with LTT-lite kernel
+	 * trace data.
+	 * The 5th character of the log name is an indicator of a specific
+	 * Android log, stream, each of which has a different payload format
+	 * and must be differentiated.
+	 */
+	if (ltt_lite_log_android(iov, nr_segs, log->misc.name[4]))
+		return 0;
+#endif
+#endif
 	now = current_kernel_time();
 
 	header.pid = current->tgid;
@@ -370,7 +401,18 @@ ssize_t logger_aio_write(struct kiocb *iocb, const struct iovec *iov,
 		iov++;
 		ret += nr;
 	}
-
+	if (Filter_Mot_Log_Enable) {
+		size_t len = 0;
+		len = sizeof(struct logger_entry) + 1;
+		if ((*(log->buffer+logger_offset(orig+len)) == 'M')
+		&& (*(log->buffer+logger_offset(orig+len+1)) == 'O')
+		&& (*(log->buffer+logger_offset(orig+len+2)) == 'T')
+		&& (*(log->buffer+logger_offset(orig+len+3)) == '_')) {
+			log->w_off = orig;
+			mutex_unlock(&log->mutex);
+			return ret;
+		}
+	}
 	mutex_unlock(&log->mutex);
 
 	/* wake up any blocked readers */
@@ -464,7 +506,7 @@ static unsigned int logger_poll(struct file *file, poll_table *wait)
 	if (log->w_off != reader->r_off)
 		ret |= POLLIN | POLLRDNORM;
 	mutex_unlock(&log->mutex);
-
+	
 	return ret;
 }
 
@@ -512,6 +554,15 @@ static long logger_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		log->head = log->w_off;
 		ret = 0;
 		break;
+	case LOGGER_FILTER_MOT_LOG_ENABLE:
+		Filter_Mot_Log_Enable = 1;
+		ret = 0;
+		break;
+	case LOGGER_FILTER_MOT_LOG_DISABLE:
+		Filter_Mot_Log_Enable = 0;
+		ret = 0;
+		break;
+
 	}
 
 	mutex_unlock(&log->mutex);
@@ -557,6 +608,110 @@ DEFINE_LOGGER_DEVICE(log_main, LOGGER_LOG_MAIN, 64*1024)
 DEFINE_LOGGER_DEVICE(log_events, LOGGER_LOG_EVENTS, 256*1024)
 DEFINE_LOGGER_DEVICE(log_radio, LOGGER_LOG_RADIO, 64*1024)
 
+#ifdef KERNEL_LOG
+static struct file_operations kernel_logger_fops = {
+        .owner = THIS_MODULE,
+        .read = logger_read,
+//      	.aio_write = logger_kernel_write,
+        .poll = logger_poll,
+        .unlocked_ioctl = logger_ioctl,
+        .compat_ioctl = logger_ioctl,
+        .open = logger_open,
+        .release = logger_release,
+};
+
+
+static unsigned char _buf_log_kernel[64*1024];
+
+static struct logger_log log_kernel = {
+        .buffer = _buf_log_kernel,
+        .misc ={
+                .minor =MISC_DYNAMIC_MINOR,
+                .name = "log_kernel",
+                .fops = & kernel_logger_fops,
+                .parent = NULL,
+        },
+        .wq = __WAIT_QUEUE_HEAD_INITIALIZER(log_kernel.wq),
+        .readers = LIST_HEAD_INIT(log_kernel.readers),
+        .mutex = __MUTEX_INITIALIZER(log_kernel.mutex),
+        .w_off = 0,
+        .head = 0,
+        .size = 64*1024,
+};
+
+
+static void logger_kernel_write(struct console *co, const char *s, unsigned count)
+{
+        struct logger_entry header;
+        struct timespec now;
+        struct logger_log *log= &log_kernel;
+        unsigned int msg_len;
+        int prio=3;
+        struct iovec vec[3];
+        struct iovec *iov;
+        int vec_count=3;
+        ssize_t ret = 0;
+        const char tag[7] ="kernel\0";
+	iov=&vec[0];
+	/* since s is a pointer to LOG_BUF and we know LOG_BUF is continuous, s[-3]='<', s[-2] is the log level and s[-1]='>'.If not, we set loglevel as default value 0*/
+	/*switch (s[-2]) {
+		case '0': prio=3;break;
+		case '1': prio=3;break;
+		case '2': prio=3;break;
+		case '3': prio=6;break;
+		case '4': prio=5;break;
+		case '5': prio=4;break;
+		case '6': prio=4;break;
+		case '7': prio=3;break;
+		default:  prio=3;	
+	}*/
+        vec[0].iov_base = (unsigned char *) &prio;
+        vec[0].iov_len  = 1;
+        vec[1].iov_base = (void *)tag;
+        vec[1].iov_len = strlen(tag) + 1;
+        vec[2].iov_base = (void *)s;
+        vec[2].iov_len  = count;
+        msg_len= vec[0].iov_len+vec[1].iov_len+vec[2].iov_len;
+        now = current_kernel_time();
+
+        header.pid = 0;
+        header.tid = 0;
+        header.sec = now.tv_sec;
+        header.nsec= now.tv_nsec;
+        header.len = min_t(size_t, msg_len, LOGGER_ENTRY_MAX_PAYLOAD);
+
+        //mutex_lock(&log->mutex);
+
+        do_write_log(log, &header, sizeof(struct logger_entry));
+
+        fix_up_readers(log, sizeof(struct logger_entry) + header.len);
+
+        while (vec_count-- > 0) {
+                size_t len;
+
+                /* figure out how much of this vector we can keep */
+                len = min_t(size_t, iov->iov_len, header.len - ret);
+
+                /* write out this segment's payload */
+                do_write_log(log, iov->iov_base, len);
+
+                iov++;
+        }
+
+        //mutex_unlock(&log->mutex);
+
+        /* wake up any blocked readers */
+        wake_up_interruptible(&log->wq);
+
+        return ;
+
+}
+
+
+
+
+#endif
+
 static struct logger_log * get_log_from_minor(int minor)
 {
 	if (log_main.misc.minor == minor)
@@ -565,6 +720,10 @@ static struct logger_log * get_log_from_minor(int minor)
 		return &log_events;
 	if (log_radio.misc.minor == minor)
 		return &log_radio;
+#ifdef KERNEL_LOG
+	if (log_kernel.misc.minor == minor)
+		return &log_kernel;
+#endif
 	return NULL;
 }
 
@@ -600,8 +759,15 @@ static int __init logger_init(void)
 	ret = init_log(&log_radio);
 	if (unlikely(ret))
 		goto out;
-
+#ifdef KERNEL_LOG
+	ret = init_log(&log_kernel);
+        if (unlikely(ret))
+                goto out;
+	register_console(&loggercons);
+#endif
 out:
 	return ret;
 }
 device_initcall(logger_init);
+
+
diff --git a/drivers/staging/android/logger.h b/drivers/staging/android/logger.h
index a562434..8a7a7fa 100644
--- a/drivers/staging/android/logger.h
+++ b/drivers/staging/android/logger.h
@@ -44,5 +44,10 @@ struct logger_entry {
 #define LOGGER_GET_LOG_LEN		_IO(__LOGGERIO, 2) /* used log len */
 #define LOGGER_GET_NEXT_ENTRY_LEN	_IO(__LOGGERIO, 3) /* next entry len */
 #define LOGGER_FLUSH_LOG		_IO(__LOGGERIO, 4) /* flush log */
+/* enable Mot internal log filter*/
+#define LOGGER_FILTER_MOT_LOG_ENABLE    _IO(__LOGGERIO, 5)
+/* disable Mot internal log filter*/
+#define LOGGER_FILTER_MOT_LOG_DISABLE   _IO(__LOGGERIO, 6)
+
 
 #endif /* _LINUX_LOGGER_H */
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index a1afd50..b31d8f4 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -153,4 +153,6 @@ source "drivers/usb/gadget/Kconfig"
 
 source "drivers/usb/otg/Kconfig"
 
+source "drivers/usb/ipchost/Kconfig"
+
 endif # USB_SUPPORT
diff --git a/drivers/usb/Makefile b/drivers/usb/Makefile
index b2ceb4a..4649e5c 100644
--- a/drivers/usb/Makefile
+++ b/drivers/usb/Makefile
@@ -39,3 +39,5 @@ obj-$(CONFIG_USB)		+= misc/
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+
+obj-$(CONFIG_USB_IPC)		+= ipchost/
diff --git a/drivers/usb/class/Kconfig b/drivers/usb/class/Kconfig
index 2519e32..47c8500 100644
--- a/drivers/usb/class/Kconfig
+++ b/drivers/usb/class/Kconfig
@@ -50,3 +50,11 @@ config USB_TMC
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called usbtmc.
+
+
+config USB_PANIC_ENUMERATION
+	bool "USB Panic Enumeration"
+	default y
+	depends on USB_ACM
+	help
+	  Say Y here if you want to use the ACM driver for Panic Enumeration
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index b3d5a23..0f9231b 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -1024,9 +1024,11 @@ skip_normal_probe:
 		}
 	}
 
+#ifndef CONFIG_USB_PANIC_ENUMERATION
 	/* Accept probe requests only for the control interface */
 	if (intf != control_interface)
 		return -ENODEV;
+#endif
 	
 	if (usb_interface_claimed(data_interface)) { /* valid in this context */
 		dev_dbg(&intf->dev,"The data interface isn't available\n");
@@ -1272,9 +1274,13 @@ static void acm_disconnect(struct usb_interface *intf)
 #ifdef CONFIG_PM
 static int acm_suspend(struct usb_interface *intf, pm_message_t message)
 {
+#ifdef CONFIG_USB_PANIC_ENUMERATION
+	return -EBUSY;
+#else
 	struct acm *acm = usb_get_intfdata(intf);
 	int cnt;
 
+
 	if (message.event & PM_EVENT_AUTO) {
 		int b;
 
@@ -1306,6 +1312,7 @@ static int acm_suspend(struct usb_interface *intf, pm_message_t message)
 
 	mutex_unlock(&acm->mutex);
 	return 0;
+#endif
 }
 
 static int acm_resume(struct usb_interface *intf)
@@ -1376,8 +1383,11 @@ static struct usb_device_id acm_ids[] = {
 	{ USB_DEVICE(0x0572, 0x1324), /* Conexant USB MODEM RD02-D400 */
 	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
 	},
-	{ USB_DEVICE(0x22b8, 0x6425), /* Motorola MOTOMAGX phones */
+#ifdef CONFIG_USB_PANIC_ENUMERATION
+	{ USB_DEVICE(0x22b8, 0x6023), /* Motorola BP panic driver */
+	.driver_info = NO_UNION_NORMAL, /* has no union descriptor */
 	},
+#endif
 	{ USB_DEVICE(0x0572, 0x1329), /* Hummingbird huc56s (Conexant) */
 	.driver_info = NO_UNION_NORMAL, /* union descriptor misplaced on
 					   data interface instead of
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index e1759d1..d98b33d 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -136,3 +136,11 @@ config USB_OTG_BLACKLIST_HUB
 	  and software costs by not supporting external hubs.  So
 	  are "Embedded Hosts" that don't offer OTG support.
 
+config EHCI_SKIP_SYS_RESUME
+	bool "skip system resume"
+	default n
+	help
+	  This should be enabled for MAPPHONE only - mapphone_defconfig,
+	  where no use case existing for USB-PERSIST port handover. Please
+	  refer to function usb_suspend in driver.c for details.
+
diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 568244c..5a608ab 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -4,6 +4,7 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/device.h>
+#include <linux/dma-mapping.h>
 #include <asm/byteorder.h>
 #include "usb.h"
 #include "hcd.h"
@@ -620,6 +621,7 @@ int usb_get_configuration(struct usb_device *dev)
 
 		dev->rawdescriptors[cfgno] = bigbuffer;
 
+		dma_cache_maint(bigbuffer, length, DMA_FROM_DEVICE);
 		result = usb_parse_configuration(&dev->dev, cfgno,
 		    &dev->config[cfgno], bigbuffer, length);
 		if (result < 0) {
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index d0a21a5..00ca8a9 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1474,6 +1474,8 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 	else {
 		udev->auto_pm = 1;
 		intf->pm_usage_cnt += inc_usage_cnt;
+		if (intf->pm_usage_cnt < 0)
+			intf->pm_usage_cnt = 0;
 		udev->last_busy = jiffies;
 		if (inc_usage_cnt >= 0 && intf->pm_usage_cnt > 0) {
 			if (udev->state == USB_STATE_SUSPENDED)
@@ -1750,7 +1752,9 @@ int usb_suspend(struct device *dev, pm_message_t msg)
 	 * properly.
 	 */
 	if (udev->state == USB_STATE_SUSPENDED) {
+#ifndef CONFIG_EHCI_SKIP_SYS_RESUME
 		if (udev->parent || udev->speed != USB_SPEED_HIGH)
+#endif
 			udev->skip_sys_resume = 1;
 		return 0;
 	}
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index cd50d86..6b06969 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1826,6 +1826,8 @@ static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 	return -EBUSY;
 }
 
+static int hub_port_debounce(struct usb_hub *hub, int port1);
+
 static int hub_port_reset(struct usb_hub *hub, int port1,
 				struct usb_device *udev, unsigned int delay)
 {
@@ -1845,6 +1847,9 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 					"cannot reset port %d (err = %d)\n",
 					port1, status);
 		else {
+			 /* port debounce */
+			status = hub_port_debounce(hub, port1);
+
 			status = hub_port_wait_reset(hub, port1, udev, delay);
 			if (status && status != -ENOTCONN)
 				dev_dbg(hub->intfdev,
@@ -2069,8 +2074,13 @@ static int finish_port_resume(struct usb_device *udev)
 	 * and device drivers will know about any resume quirks.
 	 */
 	if (status == 0) {
+#ifdef CONFIG_ARCH_OMAP
+		devstatus = 1;
+		status = 2;
+#else
 		devstatus = 0;
 		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);
+#endif
 		if (status >= 0)
 			status = (status > 0 ? 0 : -ENODEV);
 
@@ -2876,7 +2886,8 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 			status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
 					&devstat);
 			if (status < 2) {
-				dev_dbg(&udev->dev, "get status %d ?\n", status);
+				dev_dbg(&udev->dev, "get status %d ?\n",
+					status);
 				goto loop_disable;
 			}
 			le16_to_cpus(&devstat);
@@ -3141,7 +3152,7 @@ static void hub_events(void)
 			dev_err (hub_dev, "get_hub_status failed\n");
 		else {
 			if (hubchange & HUB_CHANGE_LOCAL_POWER) {
-				dev_dbg (hub_dev, "power change\n");
+				dev_dbg(hub_dev, "power change\n");
 				clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
 				if (hubstatus & HUB_STATUS_LOCAL_POWER)
 					/* FIXME: Is this always true? */
@@ -3150,7 +3161,7 @@ static void hub_events(void)
 					hub->limited_power = 0;
 			}
 			if (hubchange & HUB_CHANGE_OVERCURRENT) {
-				dev_dbg (hub_dev, "overcurrent change\n");
+				dev_dbg(hub_dev, "overcurrent change\n");
 				msleep(500);	/* Cool down */
 				clear_hub_feature(hdev, C_HUB_OVER_CURRENT);
                         	hub_power_on(hub, true);
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 71e3db9..2a801cf 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -699,9 +699,16 @@ config USB_G_PRINTER
 	  For more information, see Documentation/usb/gadget_printer.txt
 	  which includes sample code for accessing the device file.
 
+config USB_MOT_ANDROID
+        tristate "MOTO Android Gadget"
+        help
+          The MOTO Android gadget provides mass storage, adb and ethernet transport.
+
+          Say "y" to link the driver statically, or "m" to build a
+          dynamically linked module called "g_mot_android".
+
 config USB_ANDROID
 	tristate "Android Gadget"
-	depends on SWITCH
 	help
 	  The Android gadget provides mass storage and adb transport.
 
@@ -730,3 +737,8 @@ config USB_CDC_COMPOSITE
 endchoice
 
 endif # USB_GADGET
+
+config MOT_FEAT_ADB_ENDEV
+        tristate "ADB Enable Device"
+        default n
+
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 2a93bff..a0bc83c 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -21,7 +21,7 @@ obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
 obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
-
+obj-$(CONFIG_MOT_FEAT_ADB_ENDEV)+= adb_enable.o
 #
 # USB gadget drivers
 #
@@ -33,7 +33,8 @@ gadgetfs-objs			:= inode.o
 g_file_storage-objs		:= file_storage.o
 g_printer-objs			:= printer.o
 g_cdc-objs			:= cdc2.o
-g_android-objs			:= android.o f_adb.o f_mass_storage.o f_usbnet.o
+g_android-objs			:= android.o f_adb.o f_usbnet.o f_mtp.o f_acm.o u_serial.o
+g_mot_android-objs              := mot_android.o f_usbnet.o f_adb.o f_mass_storage.o f_mtp.o f_acm.o u_serial.o
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_ETH)		+= g_ether.o
@@ -43,5 +44,6 @@ obj-$(CONFIG_USB_G_SERIAL)	+= g_serial.o
 obj-$(CONFIG_USB_G_PRINTER)	+= g_printer.o
 obj-$(CONFIG_USB_MIDI_GADGET)	+= g_midi.o
 obj-$(CONFIG_USB_CDC_COMPOSITE) += g_cdc.o
+obj-$(CONFIG_USB_MOT_ANDROID)  += g_mot_android.o
 obj-$(CONFIG_USB_ANDROID)	+= g_android.o
 
diff --git a/drivers/usb/gadget/android.c b/drivers/usb/gadget/android.c
index a5ca30c..e23b747 100644
--- a/drivers/usb/gadget/android.c
+++ b/drivers/usb/gadget/android.c
@@ -35,7 +35,6 @@
 
 #include "f_mass_storage.h"
 #include "f_adb.h"
-#include "f_usbnet.h"
 
 #include "gadget_chips.h"
 
@@ -71,7 +70,6 @@ struct android_dev {
 	int version;
 
 	int adb_enabled;
-	int factory_enabled;
 	int nluns;
 };
 
@@ -130,19 +128,13 @@ static int __init android_bind_config(struct usb_configuration *c)
 	int ret;
 	printk(KERN_DEBUG "android_bind_config\n");
 
-	if (dev->factory_enabled) {
-		ret = usbnet_function_add(dev->cdev, c);
-		return ret;
-	}
-
 	ret = mass_storage_function_add(dev->cdev, c, dev->nluns);
 	if (ret)
 		return ret;
-	ret = adb_function_add(dev->cdev, c);
-	return ret;
+	return adb_function_add(dev->cdev, c);
 }
 
-static  int android_setup_config(struct usb_configuration *c,
+static int android_setup_config(struct usb_configuration *c,
 		const struct usb_ctrlrequest *ctrl);
 
 static struct usb_configuration android_config_driver = {
@@ -154,7 +146,7 @@ static struct usb_configuration android_config_driver = {
 	.bMaxPower	= CONFIG_USB_GADGET_VBUS_DRAW / 2,
 };
 
-static  int android_setup_config(struct usb_configuration *c,
+static int android_setup_config(struct usb_configuration *c,
 		const struct usb_ctrlrequest *ctrl)
 {
 	int i;
@@ -202,6 +194,9 @@ static int __init android_bind(struct usb_composite_dev *cdev)
 	strings_dev[STRING_SERIAL_IDX].id = id;
 	device_desc.iSerialNumber = id;
 
+	if (gadget->ops->wakeup)
+		android_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+
 	/* register our configuration */
 	ret = usb_add_config(cdev, &android_config_driver);
 	if (ret) {
@@ -240,7 +235,7 @@ static struct usb_composite_driver android_usb_driver = {
 
 static void enable_adb(struct android_dev *dev, int enable)
 {
-	if (!(dev->factory_enabled) && enable != dev->adb_enabled) {
+	if (enable != dev->adb_enabled) {
 		dev->adb_enabled = enable;
 		adb_function_enable(enable);
 
@@ -326,13 +321,6 @@ static int __init android_probe(struct platform_device *pdev)
 		if (pdata->serial_number)
 			strings_dev[STRING_SERIAL_IDX].s = pdata->serial_number;
 		dev->nluns = pdata->nluns;
-
-		if (pdata->factory_enabled) {
-			dev->factory_enabled = pdata->factory_enabled;
-			device_desc.bDeviceClass = USB_CLASS_COMM;
-			device_desc.bDeviceSubClass = USB_CLASS_COMM;
-			device_desc.bDeviceProtocol = USB_CLASS_PER_INTERFACE;
-		}
 	}
 
 	return 0;
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 905fca8..6b72045 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -27,6 +27,9 @@
 
 #include <linux/usb/composite.h>
 
+#ifdef CONFIG_USB_MOT_ANDROID
+#include "f_mot_android.h"
+#endif
 
 /*
  * The code in this file is utility code, used to build a gadget driver
@@ -235,7 +238,9 @@ static int config_buf(struct usb_configuration *config,
 	int				len = USB_BUFSIZ - USB_DT_CONFIG_SIZE;
 	struct usb_function		*f;
 	int				status;
+#ifndef CONFIG_USB_MOT_ANDROID
 	int				interfaceCount = 0;
+#endif
 
 	/* write the config descriptor */
 	c = buf;
@@ -266,15 +271,19 @@ static int config_buf(struct usb_configuration *config,
 			descriptors = f->hs_descriptors;
 		else
 			descriptors = f->descriptors;
-		if (!descriptors || descriptors[0] == NULL) {
+		if (f->hidden || !descriptors || descriptors[0] == NULL) {
+#ifndef CONFIG_USB_MOT_ANDROID
 			for (; f != config->interface[interfaceCount];) {
 				interfaceCount++;
 				c->bNumInterfaces--;
 			}
+#endif
 			continue;
 		}
+#ifndef CONFIG_USB_MOT_ANDROID
 		for (; f != config->interface[interfaceCount];)
 			interfaceCount++;
+#endif
 
 		status = usb_descriptor_fillbuf(next, len,
 			(const struct usb_descriptor_header **) descriptors);
@@ -685,6 +694,7 @@ static void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)
  * housekeeping for the gadget function we're implementing.  Most of
  * the work is in config and function specific setup.
  */
+
 static int
 composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 {
@@ -710,6 +720,9 @@ composite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 
 	/* we handle all standard USB descriptors */
 	case USB_REQ_GET_DESCRIPTOR:
+#ifdef CONFIG_USB_MOT_ANDROID
+		usb_data_transfer_callback();
+#endif
 		if (ctrl->bRequestType != USB_DIR_IN)
 			goto unknown;
 		switch (w_value >> 8) {
@@ -816,12 +829,14 @@ unknown:
 		 * take such requests too, if that's ever needed:  to work
 		 * in config 0, etc.
 		 */
+#ifndef CONFIG_USB_MOT_ANDROID
 		if ((ctrl->bRequestType & USB_RECIP_MASK)
 				== USB_RECIP_INTERFACE) {
 			if (cdev->config == NULL)
 				return value;
 
 			f = cdev->config->interface[intf];
+
 			if (f && f->setup)
 				value = f->setup(f, ctrl);
 			else
@@ -834,16 +849,16 @@ unknown:
 			if (c && c->setup)
 				value = c->setup(c, ctrl);
 		}
-
+#else
 		/* If the vendor request is not processed (value < 0),
-		* call all device registered configure setup callbacks
-		* to process it.
-		* This is used to handle the following cases:
-		* - vendor request is for the device and arrives before
-		* setconfiguration.
-		* - Some devices are required to handle vendor request before
-		* setconfiguration such as MTP, USBNET.
-		*/
+		 * call all device registered configure setup callbacks
+		 * to process it.
+		 * This is used to handle the following cases:
+		 * - vendor request is for the device and arrives before
+		 * setconfiguration.
+		 * - Some devices are required to handle vendor request before
+		 * setconfiguration such as MTP, USBNET.
+		 */
 
 		if (value < 0) {
 			struct usb_configuration        *cfg;
@@ -853,6 +868,7 @@ unknown:
 				value = cfg->setup(cfg, ctrl);
 			}
 		}
+#endif
 
 		goto done;
 	}
diff --git a/drivers/usb/gadget/f_acm.c b/drivers/usb/gadget/f_acm.c
index a283c1e..93c44c8 100644
--- a/drivers/usb/gadget/f_acm.c
+++ b/drivers/usb/gadget/f_acm.c
@@ -14,10 +14,15 @@
 
 #include <linux/kernel.h>
 #include <linux/device.h>
+#include <linux/tty.h>
 
 #include "u_serial.h"
 #include "gadget_chips.h"
 
+#ifdef CONFIG_USB_MOT_ANDROID
+#include "f_mot_android.h"
+#endif
+
 
 /*
  * This CDC ACM function support just wraps control functions and
@@ -90,16 +95,27 @@ static inline struct f_acm *port_to_acm(struct gserial *p)
 	return container_of(p, struct f_acm, port);
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct f_acm *g_acm_dev;
+static struct usb_descriptor_header *null_acm_descs[] = {
+	NULL,
+};
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /* notification endpoint uses smallish and infrequent fixed-size messages */
 
 #define GS_LOG2_NOTIFY_INTERVAL		5	/* 1 << 5 == 32 msec */
-#define GS_NOTIFY_MAXPACKET		10	/* notification + 2 bytes */
+#define GS_NOTIFY_MAXPACKET		64	/* notification + 2 bytes */
 
 /* interface and class descriptors: */
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_interface_descriptor acm_control_interface_desc = {
+#else
 static struct usb_interface_descriptor acm_control_interface_desc __initdata = {
+#endif
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	/* .bInterfaceNumber = DYNAMIC */
@@ -110,7 +126,11 @@ static struct usb_interface_descriptor acm_control_interface_desc __initdata = {
 	/* .iInterface = DYNAMIC */
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_interface_descriptor acm_data_interface_desc = {
+#else
 static struct usb_interface_descriptor acm_data_interface_desc __initdata = {
+#endif
 	.bLength =		USB_DT_INTERFACE_SIZE,
 	.bDescriptorType =	USB_DT_INTERFACE,
 	/* .bInterfaceNumber = DYNAMIC */
@@ -121,7 +141,11 @@ static struct usb_interface_descriptor acm_data_interface_desc __initdata = {
 	/* .iInterface = DYNAMIC */
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_cdc_header_desc acm_header_desc = {
+#else
 static struct usb_cdc_header_desc acm_header_desc __initdata = {
+#endif
 	.bLength =		sizeof(acm_header_desc),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_HEADER_TYPE,
@@ -129,7 +153,11 @@ static struct usb_cdc_header_desc acm_header_desc __initdata = {
 };
 
 static struct usb_cdc_call_mgmt_descriptor
+#ifdef CONFIG_USB_MOT_ANDROID
+acm_call_mgmt_descriptor = {
+#else
 acm_call_mgmt_descriptor __initdata = {
+#endif
 	.bLength =		sizeof(acm_call_mgmt_descriptor),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_CALL_MANAGEMENT_TYPE,
@@ -137,14 +165,22 @@ acm_call_mgmt_descriptor __initdata = {
 	/* .bDataInterface = DYNAMIC */
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_cdc_acm_descriptor acm_descriptor = {
+#else
 static struct usb_cdc_acm_descriptor acm_descriptor __initdata = {
+#endif
 	.bLength =		sizeof(acm_descriptor),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_ACM_TYPE,
 	.bmCapabilities =	USB_CDC_CAP_LINE,
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_cdc_union_desc acm_union_desc = {
+#else
 static struct usb_cdc_union_desc acm_union_desc __initdata = {
+#endif
 	.bLength =		sizeof(acm_union_desc),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_UNION_TYPE,
@@ -154,7 +190,11 @@ static struct usb_cdc_union_desc acm_union_desc __initdata = {
 
 /* full speed support: */
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_endpoint_descriptor acm_fs_notify_desc = {
+#else
 static struct usb_endpoint_descriptor acm_fs_notify_desc __initdata = {
+#endif
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -163,21 +203,33 @@ static struct usb_endpoint_descriptor acm_fs_notify_desc __initdata = {
 	.bInterval =		1 << GS_LOG2_NOTIFY_INTERVAL,
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_endpoint_descriptor acm_fs_in_desc = {
+#else
 static struct usb_endpoint_descriptor acm_fs_in_desc __initdata = {
+#endif
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_endpoint_descriptor acm_fs_out_desc = {
+#else
 static struct usb_endpoint_descriptor acm_fs_out_desc __initdata = {
+#endif
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_OUT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_descriptor_header *acm_fs_function[] = {
+#else
 static struct usb_descriptor_header *acm_fs_function[] __initdata = {
+#endif
 	(struct usb_descriptor_header *) &acm_control_interface_desc,
 	(struct usb_descriptor_header *) &acm_header_desc,
 	(struct usb_descriptor_header *) &acm_call_mgmt_descriptor,
@@ -192,7 +244,11 @@ static struct usb_descriptor_header *acm_fs_function[] __initdata = {
 
 /* high speed support: */
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_endpoint_descriptor acm_hs_notify_desc = {
+#else
 static struct usb_endpoint_descriptor acm_hs_notify_desc __initdata = {
+#endif
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
@@ -201,21 +257,33 @@ static struct usb_endpoint_descriptor acm_hs_notify_desc __initdata = {
 	.bInterval =		GS_LOG2_NOTIFY_INTERVAL+4,
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_endpoint_descriptor acm_hs_in_desc = {
+#else
 static struct usb_endpoint_descriptor acm_hs_in_desc __initdata = {
+#endif
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_endpoint_descriptor acm_hs_out_desc = {
+#else
 static struct usb_endpoint_descriptor acm_hs_out_desc __initdata = {
+#endif
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
 	.wMaxPacketSize =	__constant_cpu_to_le16(512),
 };
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static struct usb_descriptor_header *acm_hs_function[] = {
+#else
 static struct usb_descriptor_header *acm_hs_function[] __initdata = {
+#endif
 	(struct usb_descriptor_header *) &acm_control_interface_desc,
 	(struct usb_descriptor_header *) &acm_header_desc,
 	(struct usb_descriptor_header *) &acm_call_mgmt_descriptor,
@@ -235,8 +303,13 @@ static struct usb_descriptor_header *acm_hs_function[] __initdata = {
 
 /* static strings, in UTF-8 */
 static struct usb_string acm_string_defs[] = {
+#ifdef CONFIG_USB_MOT_ANDROID
+	[ACM_CTRL_IDX].s = "Motorola Communication Interface",
+	[ACM_DATA_IDX].s = "Motorola Data Interface",
+#else
 	[ACM_CTRL_IDX].s = "CDC Abstract Control Model (ACM)",
 	[ACM_DATA_IDX].s = "CDC ACM Data",
+#endif
 	{  /* ZEROES END LIST */ },
 };
 
@@ -406,6 +479,9 @@ static int acm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 
 	} else
 		return -EINVAL;
+#ifdef CONFIG_USB_MOT_ANDROID
+	usb_interface_enum_cb(ACM_TYPE_FLAG);
+#endif
 
 	return 0;
 }
@@ -515,6 +591,38 @@ static void acm_cdc_notify_complete(struct usb_ep *ep, struct usb_request *req)
 		acm_notify_serial_state(acm);
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static void acm_tiocmset(struct gserial *port, int set, int clear)
+{
+	struct f_acm            *acm = port_to_acm(port);
+
+	if (set & TIOCM_DTR)
+		acm->serial_state |= ACM_CTRL_DCD;
+	if (clear & TIOCM_DTR)
+		acm->serial_state &= ~ACM_CTRL_DCD;
+
+	if (set & TIOCM_DSR)
+		acm->serial_state |= ACM_CTRL_DSR;
+	if (clear & TIOCM_DSR)
+		acm->serial_state &= ~ACM_CTRL_DSR;
+
+	if (set & TIOCM_OUT1)
+		acm->serial_state |= ACM_CTRL_RI;
+	if (clear & TIOCM_OUT1)
+		acm->serial_state &= ~ACM_CTRL_RI;
+
+	if (set & TIOCM_OUT2)
+		acm->serial_state |= ACM_CTRL_OVERRUN;
+	if (clear & TIOCM_OUT2)
+		acm->serial_state &= ~ACM_CTRL_OVERRUN;
+
+	/*
+	*  TODO:  configure DSR/DCD/OUT1, etc according to set/clear
+	*/
+	acm_notify_serial_state(acm);
+}
+#endif
+
 /* connect == the TTY link is open */
 
 static void acm_connect(struct gserial *port)
@@ -608,9 +716,13 @@ acm_bind(struct usb_configuration *c, struct usb_function *f)
 	acm->notify_req->context = acm;
 
 	/* copy descriptors, and track endpoint copies */
+#ifdef CONFIG_USB_MOT_ANDROID
+	f->descriptors = acm_fs_function;
+#else
 	f->descriptors = usb_copy_descriptors(acm_fs_function);
 	if (!f->descriptors)
 		goto fail;
+#endif
 
 	acm->fs.in = usb_find_endpoint(acm_fs_function,
 			f->descriptors, &acm_fs_in_desc);
@@ -632,8 +744,11 @@ acm_bind(struct usb_configuration *c, struct usb_function *f)
 				acm_fs_notify_desc.bEndpointAddress;
 
 		/* copy descriptors, and track endpoint copies */
+#ifdef CONFIG_USB_MOT_ANDROID
+		f->hs_descriptors = acm_hs_function;
+#else
 		f->hs_descriptors = usb_copy_descriptors(acm_hs_function);
-
+#endif
 		acm->hs.in = usb_find_endpoint(acm_hs_function,
 				f->hs_descriptors, &acm_hs_in_desc);
 		acm->hs.out = usb_find_endpoint(acm_hs_function,
@@ -642,6 +757,11 @@ acm_bind(struct usb_configuration *c, struct usb_function *f)
 				f->hs_descriptors, &acm_hs_notify_desc);
 	}
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	f->descriptors = null_acm_descs;
+	f->hs_descriptors = null_acm_descs;
+#endif
+
 	DBG(cdev, "acm ttyGS%d: %s speed IN/%s OUT/%s NOTIFY/%s\n",
 			acm->port_num,
 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
@@ -671,9 +791,11 @@ acm_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct f_acm		*acm = func_to_acm(f);
 
+#ifndef CONFIG_USB_MOT_ANDROID
 	if (gadget_is_dualspeed(c->cdev->gadget))
 		usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
+#endif
 	gs_free_req(acm->notify, acm->notify_req);
 	kfree(acm);
 }
@@ -756,17 +878,63 @@ int __init acm_bind_config(struct usb_configuration *c, u8 port_num)
 	acm->port.func.setup = acm_setup;
 	acm->port.func.disable = acm_disable;
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	acm->port.tiocmset = acm_tiocmset;
+	g_acm_dev = acm;
+#endif
+
 	status = usb_add_function(c, &acm->port.func);
 	if (status)
 		kfree(acm);
 	return status;
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+struct usb_configuration *g_device_cfg;
+static int g_serial_setup_flag;
 int __init acm_function_add(struct usb_composite_dev *cdev,
 	struct usb_configuration *c)
 {
-	int ret = acm_bind_config(c, 0);
-	if (ret == 0)
-		gserial_setup(c->cdev->gadget, 1);
-	return ret;
+	g_device_cfg = c;
+	g_serial_setup_flag = 0;
+	return acm_bind_config(c, 0);
 }
+
+struct usb_function *acm_function_enable(int enable, int id)
+{
+	printk(KERN_DEBUG "%s(): enable=%d id=%d\n", __func__, enable, id);
+
+	if (g_acm_dev) {
+		if (enable) {
+			acm_control_interface_desc.bInterfaceNumber = id;
+			acm_union_desc .bMasterInterface0 = id;
+			acm_data_interface_desc.bInterfaceNumber = id + 1;
+			acm_union_desc.bSlaveInterface0 = id + 1;
+			acm_call_mgmt_descriptor.bDataInterface = id + 1;
+			g_acm_dev->port.func.descriptors = acm_fs_function;
+			g_acm_dev->port.func.hs_descriptors = acm_hs_function;
+			g_acm_dev->ctrl_id = id;
+			g_acm_dev->data_id = id + 1;
+/*
+			if (!g_serial_setup_flag)  {
+				int status = gserial_setup(
+					g_device_cfg->cdev->gadget, 1);
+				if (status >= 0)
+					g_serial_setup_flag = 1;
+			}
+*/
+		} else {
+			g_acm_dev->port.func.descriptors = null_acm_descs;
+			g_acm_dev->port.func.hs_descriptors = null_acm_descs;
+			if (g_serial_setup_flag)  {
+				/* gserial_cleanup(); */
+				g_serial_setup_flag = 0;
+			}
+		}
+	}
+	return &g_acm_dev->port.func;
+}
+
+#endif
+
+
diff --git a/drivers/usb/gadget/f_acm.h b/drivers/usb/gadget/f_acm.h
index 8e27b34..72e906c 100644
--- a/drivers/usb/gadget/f_acm.h
+++ b/drivers/usb/gadget/f_acm.h
@@ -18,6 +18,8 @@
 #ifndef __F_ACM_H
 #define __F_ACM_H
 
+struct usb_function *acm_function_enable(int enable, int id);
+
 int acm_function_add(struct usb_composite_dev *cdev,
 	struct usb_configuration *c);
 
diff --git a/drivers/usb/gadget/f_adb.c b/drivers/usb/gadget/f_adb.c
index 6ca5327..f962ebd 100644
--- a/drivers/usb/gadget/f_adb.c
+++ b/drivers/usb/gadget/f_adb.c
@@ -36,12 +36,35 @@
 
 #include "f_adb.h"
 
+#ifdef CONFIG_USB_MOT_ANDROID
+#include "f_mot_android.h"
+#endif
+
 #define BULK_BUFFER_SIZE           4096
 
 /* number of rx and tx requests to allocate */
 #define RX_REQ_MAX 4
 #define TX_REQ_MAX 4
 
+#define STRING_INTERFACE        0
+
+/* static strings, in UTF-8 */
+static struct usb_string adb_string_defs[] = {
+	[STRING_INTERFACE].s = "Motorola ADB Interface",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings adb_string_table = {
+	.language =             0x0409, /* en-us */
+	.strings =              adb_string_defs,
+};
+
+static struct usb_gadget_strings *adb_strings[] = {
+	&adb_string_table,
+	NULL,
+};
+
+
 static const char shortname[] = "android_adb";
 
 struct adb_dev {
@@ -251,6 +274,9 @@ static int __init create_bulk_endpoints(struct adb_dev *dev,
 		return -ENODEV;
 	}
 	DBG(cdev, "usb_ep_autoconfig for ep_in got %s\n", ep->name);
+#if CONFIG_USB_MOT_ANDROID
+	ep->driver_data = _adb_dev;
+#endif
 	dev->ep_in = ep;
 
 	ep = usb_ep_autoconfig(cdev->gadget, out_desc);
@@ -259,6 +285,9 @@ static int __init create_bulk_endpoints(struct adb_dev *dev,
 		return -ENODEV;
 	}
 	DBG(cdev, "usb_ep_autoconfig for adb ep_out got %s\n", ep->name);
+#if CONFIG_USB_MOT_ANDROID
+	ep->driver_data = _adb_dev;
+#endif
 	dev->ep_out = ep;
 
 	/* now allocate requests for our endpoints */
@@ -548,6 +577,26 @@ adb_function_unbind(struct usb_configuration *c, struct usb_function *f)
 	_adb_dev = NULL;
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static void adb_start_out_receive(struct adb_dev *dev)
+{
+	struct usb_request *req;
+	int ret;
+
+	/* if we have idle read requests, get them queued */
+	while ((req = req_get(dev, &dev->rx_idle))) {
+		req->length = BULK_BUFFER_SIZE;
+		ret = usb_ep_queue(dev->ep_out, req, GFP_ATOMIC);
+
+		if (ret < 0) {
+			dev->error = 1;
+			req_put(dev, &dev->rx_idle, req);
+			break;
+		}
+	}
+}
+#endif
+
 static int adb_function_set_alt(struct usb_function *f,
 		unsigned intf, unsigned alt)
 {
@@ -572,6 +621,10 @@ static int adb_function_set_alt(struct usb_function *f,
 	}
 	dev->online = 1;
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	adb_start_out_receive(dev);
+	usb_interface_enum_cb(ADB_TYPE_FLAG);
+#endif
 	/* readers may be blocked waiting for us to go online */
 	wake_up(&dev->read_wq);
 	return 0;
@@ -598,7 +651,7 @@ int __init adb_function_add(struct usb_composite_dev *cdev,
 	struct usb_configuration *c)
 {
 	struct adb_dev *dev;
-	int ret;
+	int ret, status;
 
 	printk(KERN_INFO "adb_function_add\n");
 
@@ -619,6 +672,12 @@ int __init adb_function_add(struct usb_composite_dev *cdev,
 	INIT_LIST_HEAD(&dev->rx_done);
 	INIT_LIST_HEAD(&dev->tx_idle);
 
+	status = usb_string_id(c->cdev);
+	if (status >= 0) {
+		adb_string_defs[STRING_INTERFACE].id = status;
+		adb_interface_desc.iInterface = status;
+	}
+
 	dev->cdev = cdev;
 	dev->function.name = "adb";
 	dev->function.descriptors = null_adb_descs;
@@ -627,6 +686,7 @@ int __init adb_function_add(struct usb_composite_dev *cdev,
 	dev->function.unbind = adb_function_unbind;
 	dev->function.set_alt = adb_function_set_alt;
 	dev->function.disable = adb_function_disable;
+	dev->function.strings = adb_strings;
 
 	/* _adb_dev must be set before calling usb_gadget_register_driver */
 	_adb_dev = dev;
@@ -666,3 +726,22 @@ void adb_function_enable(int enable)
 	}
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+struct usb_function *adb_function_enable_id(int enable, int id)
+{
+	struct adb_dev *dev = _adb_dev;
+
+	printk(KERN_DEBUG "%s enable=%d id =%d\n", __func__, enable, id);
+	if (dev) {
+		if (enable) {
+			dev->function.descriptors = fs_adb_descs;
+			dev->function.hs_descriptors = hs_adb_descs;
+			adb_interface_desc.bInterfaceNumber = id;
+		} else {
+			dev->function.descriptors = null_adb_descs;
+			dev->function.hs_descriptors = null_adb_descs;
+		}
+	}
+	return &dev->function;
+}
+#endif
diff --git a/drivers/usb/gadget/f_adb.h b/drivers/usb/gadget/f_adb.h
index 4854ff6..b1e8172 100644
--- a/drivers/usb/gadget/f_adb.h
+++ b/drivers/usb/gadget/f_adb.h
@@ -22,4 +22,8 @@ int adb_function_add(struct usb_composite_dev *cdev,
 	struct usb_configuration *c);
 void adb_function_enable(int enable);
 
+#ifdef CONFIG_USB_MOT_ANDROID
+struct usb_function *adb_function_enable_id(int enable, int id);
+#endif
+
 #endif /* __F_ADB_H */
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index f63f572..a7f4b42 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -75,6 +75,10 @@
 #include <linux/usb/gadget.h>
 #include <linux/usb/android.h>
 
+#ifdef CONFIG_USB_MOT_ANDROID
+#include "f_mot_android.h"
+#endif
+
 #include "f_mass_storage.h"
 #include "gadget_chips.h"
 
@@ -138,6 +142,17 @@ static const char shortname[] = DRIVER_NAME;
 
 /*-------------------------------------------------------------------------*/
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static int cdrom_enable ;
+
+module_param_named(cdrom, cdrom_enable, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(cdrom, "true to emulate cdrom instead of disk");
+
+/* SCSI device types */
+#define TYPE_DISK      0x00
+#define TYPE_CDROM     0x05
+#endif
+
 /* Bulk-only data structures */
 
 /* Command Block Wrapper */
@@ -201,6 +216,12 @@ struct bulk_cs_wrap {
 #define SC_WRITE_10			0x2a
 #define SC_WRITE_12			0xaa
 
+#ifdef CONFIG_USB_MOT_ANDROID
+#define SC_READ_TOC         0x43
+#define SC_READ_HEADER      0x44
+#define SC_MOT_MODE_SWITCH	0xD6
+#endif
+
 /* SCSI Sense Key/Additional Sense Code/ASC Qualifier values */
 #define SS_NO_SENSE				0
 #define SS_COMMUNICATION_FAILURE		0x040800
@@ -472,6 +493,31 @@ static void put_be32(u8 *buf, u32 val)
  * descriptors are built on demand.  Also the (static) config and interface
  * descriptors are adjusted during fsg_bind().
  */
+#ifdef CONFIG_USB_MOT_ANDROID
+
+/* used when eth function is disabled */
+static struct usb_descriptor_header *null_msc_descs[] = {
+	NULL,
+};
+
+#define STRING_INTERFACE        0
+
+/* static strings, in UTF-8 */
+static struct usb_string usbmsc_string_defs[] = {
+	[STRING_INTERFACE].s = "Motorola MSD Interface",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings usbmsc_string_table = {
+	.language =             0x0409, /* en-us */
+	.strings =              usbmsc_string_defs,
+};
+
+static struct usb_gadget_strings *usbmsc_strings[] = {
+	&usbmsc_string_table,
+	NULL,
+};
+#endif
 
 /* There is only one interface. */
 
@@ -679,15 +725,15 @@ static int fsg_function_setup(struct usb_function *f,
 		}
 	}
 
-		/* respond with data transfer or status phase? */
-		if (value >= 0) {
-			int rc;
-			cdev->req->zero = value < w_length;
-			cdev->req->length = value;
-			rc = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
-			if (rc < 0)
-				printk("%s setup response queue error\n", __func__);
-		}
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		int rc;
+		cdev->req->zero = value < w_length;
+		cdev->req->length = value;
+		rc = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (rc < 0)
+			printk("%s setup response queue error\n", __func__);
+	}
 
 	if (value == -EOPNOTSUPP)
 		VDBG(fsg,
@@ -1234,14 +1280,28 @@ static int do_inquiry(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 {
 	u8	*buf = (u8 *) bh->buf;
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	u8 *vend_str = "Motorola";
+	u8 *prod_str = "XT701";
+
+	fsg->vendor = vend_str;
+	fsg->product = prod_str;
+#endif
+
 	if (!fsg->curlun) {		/* Unsupported LUNs are okay */
 		fsg->bad_lun_okay = 1;
 		memset(buf, 0, 36);
 		buf[0] = 0x7f;		/* Unsupported, no device-type */
+#ifdef CONFIG_USB_MOT_ANDROID
+		buf[4] = 31;	/* Additional length */
+#endif
 		return 36;
 	}
 
 	memset(buf, 0, 8);	/* Non-removable, direct-access device */
+#ifdef CONFIG_USB_MOT_ANDROID
+	buf[0] = (cdrom_enable ? TYPE_CDROM : TYPE_DISK);
+#endif
 
 	buf[1] = 0x80;	/* set removable bit */
 	buf[2] = 2;		/* ANSI SCSI level 2 */
@@ -1326,6 +1386,74 @@ static int do_read_capacity(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	return 8;
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+static void store_cdrom_address(u8 *dest, int msf, u32 addr)
+{
+	if (msf) {
+		/* Convert to Minutes-Seconds-Frames */
+		addr >>= 2;	/* Convert to 2048-byte frames */
+		addr += 2 * 75;	/* Lead-in occupies 2 seconds */
+		dest[3] = addr % 75;	/* Frames */
+		addr /= 75;
+		dest[2] = addr % 60;	/* Seconds */
+		addr /= 60;
+		dest[1] = addr;	/* Minutes */
+		dest[0] = 0;	/* Reserved */
+	} else {
+		/* Absolute sector */
+		put_be32(dest, addr);
+	}
+}
+
+static int do_read_header(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun *curlun = fsg->curlun;
+	int msf = fsg->cmnd[1] & 0x02;
+	u32 lba = get_be32(&fsg->cmnd[2]);
+	u8 *buf = (u8 *) bh->buf;
+
+	if ((fsg->cmnd[1] & ~0x02) != 0) {	/* Mask away MSF */
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+	if (lba >= curlun->num_sectors) {
+		curlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
+		return -EINVAL;
+	}
+
+	memset(buf, 0, 8);
+	buf[0] = 0x01;		/* 2048 bytes of user data, rest is EC */
+	store_cdrom_address(&buf[4], msf, lba);
+	return 8;
+}
+
+static int do_read_toc(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	struct lun *curlun = fsg->curlun;
+	int msf = fsg->cmnd[1] & 0x02;
+	int start_track = fsg->cmnd[6];
+	u8 *buf = (u8 *) bh->buf;
+
+	if ((fsg->cmnd[1] & ~0x02) != 0 ||	/* Mask away MSF */
+	    start_track > 1) {
+		curlun->sense_data = SS_INVALID_FIELD_IN_CDB;
+		return -EINVAL;
+	}
+
+	memset(buf, 0, 20);
+	buf[1] = (20 - 2);	/* TOC data length */
+	buf[2] = 1;		/* First track number */
+	buf[3] = 1;		/* Last track number */
+	buf[5] = 0x16;		/* Data track, copying allowed */
+	buf[6] = 0x01;		/* Only track is number 1 */
+	store_cdrom_address(&buf[8], msf, 0);
+
+	buf[13] = 0x16;		/* Lead-out track is data */
+	buf[14] = 0xAA;		/* Lead-out track number */
+	store_cdrom_address(&buf[16], msf, curlun->num_sectors);
+	return 20;
+}
+#endif
 
 static int do_mode_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 {
@@ -1902,6 +2030,30 @@ static int do_scsi_command(struct fsg_dev *fsg)
 			reply = do_read_capacity(fsg, bh);
 		break;
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	case SC_READ_HEADER:
+		if (!cdrom_enable)
+			goto unknown_cmnd;
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(3 << 7) | (0x1f << 1), 1,
+				"READ HEADER");
+		if (reply == 0)
+			reply = do_read_header(fsg, bh);
+		break;
+
+	case SC_READ_TOC:
+		if (!cdrom_enable)
+			goto unknown_cmnd;
+		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
+		reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
+				(7 << 6) | (1 << 1), 1,
+				"READ TOC");
+		if (reply == 0)
+			reply = do_read_toc(fsg, bh);
+		break;
+#endif
+
 	case SC_READ_FORMAT_CAPACITIES:
 		fsg->data_size_from_cmnd = get_be16(&fsg->cmnd[7]);
 		if ((reply = check_command(fsg, 10, DATA_DIR_TO_HOST,
@@ -1976,6 +2128,18 @@ static int do_scsi_command(struct fsg_dev *fsg)
 			reply = do_write(fsg);
 		break;
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	case SC_MOT_MODE_SWITCH:
+	{
+		u8 mode;
+		fsg->data_size_from_cmnd = 0;
+		mode = fsg->cmnd[10];
+		mode_switch_cb((int)mode);
+		reply = 0;
+		break;
+	}
+#endif
+
 	/* Some mandatory commands that we recognize but don't implement.
 	 * They don't mean much in this setting.  It's left as an exercise
 	 * for anyone interested to implement RESERVE and RELEASE in terms
@@ -1987,6 +2151,9 @@ static int do_scsi_command(struct fsg_dev *fsg)
 		/* Fall through */
 
 	default:
+#ifdef CONFIG_USB_MOT_ANDROID
+unknown_cmnd:
+#endif
 		fsg->data_size_from_cmnd = 0;
 		sprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);
 		if ((reply = check_command(fsg, fsg->cmnd_size,
@@ -2072,12 +2239,8 @@ static int get_next_command(struct fsg_dev *fsg)
 	bh = fsg->next_buffhd_to_fill;
 	while (bh->state != BUF_STATE_EMPTY) {
 		rc = sleep_thread(fsg);
-		if (rc) {
-			usb_ep_dequeue(fsg->bulk_out, bh->outreq);
-			bh->outreq_busy = 0;
-			bh->state = BUF_STATE_EMPTY;
+		if (rc)
 			return rc;
-		}
 	}
 
 	/* Queue a request to read a Bulk-only CBW */
@@ -2147,7 +2310,7 @@ static int do_set_interface(struct fsg_dev *fsg, int altsetting)
 	if (fsg->running)
 		DBG(fsg, "reset interface\n");
 reset:
-	 /* Disable the endpoints */
+	/* Disable the endpoints */
 	if (fsg->bulk_in_enabled) {
 		DBG(fsg, "usb_ep_disable %s\n", fsg->bulk_in->name);
 		usb_ep_disable(fsg->bulk_in);
@@ -2172,7 +2335,6 @@ reset:
 		}
 	}
 
-
 	fsg->running = 0;
 	if (altsetting < 0 || rc != 0)
 		return rc;
@@ -2463,6 +2625,9 @@ static int open_backing_file(struct fsg_dev *fsg, struct lun *curlun,
 	struct inode			*inode = NULL;
 	loff_t				size;
 	loff_t				num_sectors;
+#ifdef CONFIG_USB_MOT_ANDROID
+	loff_t				min_sectors;
+#endif
 
 	/* R/W if we can, R/O if we must */
 	ro = curlun->ro;
@@ -2507,7 +2672,22 @@ static int open_backing_file(struct fsg_dev *fsg, struct lun *curlun,
 		goto out;
 	}
 	num_sectors = size >> 9;	/* File size in 512-byte sectors */
+#ifdef CONFIG_USB_MOT_ANDROID
+	min_sectors = 1;
+	if (cdrom_enable) {
+		num_sectors &= ~3;	/* Reduce to a multiple of 2048 */
+		min_sectors = 300 * 4;	/* Smallest track is 300 frames */
+		if (num_sectors >= 256 * 60 * 75 * 4) {
+			num_sectors = (256 * 60 * 75 - 1) * 4;
+			LINFO(curlun, "file too big: %s\n", filename);
+			LINFO(curlun, "using only first %d blocks\n",
+			      (int) num_sectors);
+		}
+	}
+	if (num_sectors < min_sectors) {
+#else
 	if (num_sectors == 0) {
+#endif
 		LINFO(curlun, "file too small: %s\n", filename);
 		rc = -ETOOSMALL;
 		goto out;
@@ -2708,7 +2888,6 @@ fsg_function_unbind(struct usb_configuration *c, struct usb_function *f)
 	/* Free the data buffers */
 	for (i = 0; i < NUM_BUFFERS; ++i)
 		kfree(fsg->buffhds[i].buf);
-	switch_dev_unregister(&fsg->sdev);
 }
 
 static int __init
@@ -2749,7 +2928,14 @@ fsg_function_bind(struct usb_configuration *c, struct usb_function *f)
 
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
+#ifdef CONFIG_USB_MOT_ANDROID
+		if (cdrom_enable)
+			curlun->ro = 1;
+		else
+			curlun->ro = 0;
+#else
 		curlun->ro = 0;
+#endif
 		curlun->dev.release = lun_release;
 		/* use "usb_mass_storage" platform device as parent if available */
 		if (fsg->pdev)
@@ -2801,8 +2987,11 @@ fsg_function_bind(struct usb_configuration *c, struct usb_function *f)
 				fs_bulk_in_desc.bEndpointAddress;
 		hs_bulk_out_desc.bEndpointAddress =
 				fs_bulk_out_desc.bEndpointAddress;
-
+#ifdef CONFIG_USB_MOT_ANDROID
+		f->hs_descriptors = null_msc_descs;
+#else
 		f->hs_descriptors = hs_function;
+#endif
 	}
 
 	/* Allocate the data buffers */
@@ -2869,9 +3058,15 @@ static int fsg_function_set_alt(struct usb_function *f,
 {
 	struct fsg_dev	*fsg = func_to_dev(f);
 	DBG(fsg, "fsg_function_set_alt intf: %d alt: %d\n", intf, alt);
+	printk(KERN_DEBUG "fsg_function_set_alt intf: %d alt: %d\n",
+	intf, alt);
 	fsg->new_config = 1;
 	do_set_interface(fsg, 0);
 	raise_exception(fsg, FSG_STATE_CONFIG_CHANGE);
+
+#ifdef CONFIG_USB_MOT_ANDROID
+	usb_interface_enum_cb(cdrom_enable ? CDROM_TYPE_FLAG : MSC_TYPE_FLAG);
+#endif
 	return 0;
 }
 
@@ -2879,6 +3074,7 @@ static void fsg_function_disable(struct usb_function *f)
 {
 	struct fsg_dev	*fsg = func_to_dev(f);
 	DBG(fsg, "fsg_function_disable\n");
+	printk(KERN_DEBUG "fsg_function_disable\n");
 	if (fsg->new_config)
 		do_set_interface(fsg, -1);
 	fsg->new_config = 0;
@@ -2917,7 +3113,9 @@ int __init mass_storage_function_add(struct usb_composite_dev *cdev,
 {
 	int		rc;
 	struct fsg_dev	*fsg;
-
+#ifdef CONFIG_USB_MOT_ANDROID
+	int status;
+#endif
 	printk(KERN_INFO "mass_storage_function_add\n");
 	rc = fsg_alloc();
 	if (rc)
@@ -2925,6 +3123,13 @@ int __init mass_storage_function_add(struct usb_composite_dev *cdev,
 	fsg = the_fsg;
 	fsg->nluns = nluns;
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	status = usb_string_id(c->cdev);
+	if (status >= 0) {
+		usbmsc_string_defs[STRING_INTERFACE].id = status;
+		intf_desc.iInterface = status;
+	}
+#endif
 	spin_lock_init(&fsg->lock);
 	init_rwsem(&fsg->filesem);
 	kref_init(&fsg->ref);
@@ -2947,13 +3152,21 @@ int __init mass_storage_function_add(struct usb_composite_dev *cdev,
 
 	fsg->cdev = cdev;
 	fsg->function.name = shortname;
+#ifdef CONFIG_USB_MOT_ANDROID
+	fsg->function.descriptors = null_msc_descs;
+#else
 	fsg->function.descriptors = fs_function;
+#endif
 	fsg->function.bind = fsg_function_bind;
 	fsg->function.unbind = fsg_function_unbind;
 	fsg->function.setup = fsg_function_setup;
 	fsg->function.set_alt = fsg_function_set_alt;
 	fsg->function.disable = fsg_function_disable;
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	fsg->function.strings = usbmsc_strings;
+#endif
+
 	rc = usb_add_function(c, &fsg->function);
 	if (rc != 0)
 		goto err_usb_add_function;
@@ -2972,4 +3185,25 @@ err_switch_dev_register:
 	return rc;
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+struct usb_function *msc_function_enable(int enable, int id)
+{
+	struct fsg_dev	*fsg = the_fsg;
 
+	printk(KERN_DEBUG "%s enable = %d id=%d\n", __func__, enable, id);
+	if (fsg) {
+		DBG(fsg, "msc_function_enable(%s)\n",
+			enable ? "true" : "false");
+
+		if (enable) {
+			fsg->function.descriptors = fs_function;
+			fsg->function.hs_descriptors = hs_function;
+			intf_desc.bInterfaceNumber = id;
+		} else {
+			fsg->function.descriptors = null_msc_descs;
+			fsg->function.hs_descriptors = null_msc_descs;
+		}
+	}
+	return &fsg->function;
+}
+#endif
diff --git a/drivers/usb/gadget/f_mass_storage.h b/drivers/usb/gadget/f_mass_storage.h
index 8e63ac0..1753e90 100644
--- a/drivers/usb/gadget/f_mass_storage.h
+++ b/drivers/usb/gadget/f_mass_storage.h
@@ -49,4 +49,8 @@
 int mass_storage_function_add(struct usb_composite_dev *cdev,
 	struct usb_configuration *c, int nluns);
 
+#ifdef CONFIG_USB_MOT_ANDROID
+struct usb_function *msc_function_enable(int enable, int id);
+#endif
+
 #endif /* __F_MASS_STORAGE_H */
diff --git a/drivers/usb/gadget/f_mot_android.h b/drivers/usb/gadget/f_mot_android.h
new file mode 100644
index 0000000..911d121
--- /dev/null
+++ b/drivers/usb/gadget/f_mot_android.h
@@ -0,0 +1,32 @@
+/*
+ * Gadget Driver for Android
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Author:
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __F_MOT_ANDROID_H
+#define __F_MOT_ANDROID_H
+
+#define MSC_TYPE_FLAG         0x01
+#define ADB_TYPE_FLAG         0x02
+#define ETH_TYPE_FLAG         0x04
+#define MTP_TYPE_FLAG         0x08
+#define ACM_TYPE_FLAG         0x10
+#define CDROM_TYPE_FLAG       0x20
+
+void usb_interface_enum_cb(int flag);
+void usb_data_transfer_callback(void);
+void mode_switch_cb(int mode);
+
+#endif /* __F_MOT_ANDROID_H */
diff --git a/drivers/usb/gadget/f_mtp.c b/drivers/usb/gadget/f_mtp.c
new file mode 100644
index 0000000..194653b
--- /dev/null
+++ b/drivers/usb/gadget/f_mtp.c
@@ -0,0 +1,1205 @@
+/*
+ * f_mtp.c -- USB MTP gadget driver
+ *
+ * Copyright (C) 2009 Motorola Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* #define VERBOSE_DEBUG */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+
+#include "gadget_chips.h"
+
+#include "f_mot_android.h"
+
+/*
+#define DEBUG
+*/
+
+#define mtp_err(fmt, arg...)	printk(KERN_ERR "%s(): " fmt, __func__, ##arg)
+#ifdef DEBUG
+#define mtp_debug(fmt, arg...)	printk(KERN_DEBUG "%s(): " fmt, __func__, ##arg)
+#else
+#define mtp_debug(fmt, arg...)
+#endif
+
+#define BULK_BUFFER_SIZE    8192
+#define MIN(a, b)	((a < b) ? a : b)
+
+/*
+ *
+ */
+#define STRING_INTERFACE	0
+#define STRING_MTP      	0
+
+/* static strings, in UTF-8 */
+static struct usb_string mtp_string_defs1[] = {
+	[STRING_INTERFACE].s = "Motorola MTP Interface",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_string mtp_string_defs2[] = {
+     [STRING_MTP].s = "MSFT100\034",
+     {  /* ZEROES END LIST */ },
+};
+
+
+static struct usb_gadget_strings mtp_string_table1 = {
+	.language =		0x0409,	/* en-us */
+	.strings =		mtp_string_defs1,
+};
+
+static struct usb_gadget_strings mtp_string_table2 = {
+     .language =     0x0, /* en-us */
+     .strings =      mtp_string_defs2,
+};
+
+static struct usb_gadget_strings *mtp_strings[] = {
+	&mtp_string_table1,
+	&mtp_string_table2,
+	NULL,
+};
+
+/* There is only one interface. */
+static struct usb_interface_descriptor intf_desc = {
+	.bLength = sizeof intf_desc,
+	.bDescriptorType = USB_DT_INTERFACE,
+	.bInterfaceNumber       = 0,
+	.bNumEndpoints = 3,
+	.bInterfaceClass = 0x06,
+	.bInterfaceSubClass = 0x01,
+	.bInterfaceProtocol = 0x01,
+};
+
+static struct usb_endpoint_descriptor fs_bulk_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor fs_bulk_out_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_OUT,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor fs_intr_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_IN,
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize = __constant_cpu_to_le16(64),
+	.bInterval = 10,
+};
+
+static struct usb_descriptor_header *fs_mtp_descs[] = {
+	(struct usb_descriptor_header *) &intf_desc,
+	(struct usb_descriptor_header *) &fs_bulk_out_desc,
+	(struct usb_descriptor_header *) &fs_bulk_in_desc,
+	(struct usb_descriptor_header *) &fs_intr_in_desc,
+	NULL,
+};
+
+static struct usb_endpoint_descriptor hs_bulk_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize = __constant_cpu_to_le16(512),
+	.bInterval = 0,
+};
+
+static struct usb_endpoint_descriptor hs_bulk_out_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize = __constant_cpu_to_le16(512),
+	.bInterval = 0,
+};
+
+static struct usb_endpoint_descriptor hs_intr_in_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bmAttributes = USB_ENDPOINT_XFER_INT,
+	.wMaxPacketSize = __constant_cpu_to_le16(64),
+	.bInterval = 10,
+};
+
+static struct usb_descriptor_header *hs_mtp_descs[] = {
+	(struct usb_descriptor_header *) &intf_desc,
+	(struct usb_descriptor_header *) &hs_bulk_out_desc,
+	(struct usb_descriptor_header *) &hs_bulk_in_desc,
+	(struct usb_descriptor_header *) &hs_intr_in_desc,
+	NULL,
+};
+
+/* used when MTP function is disabled */
+static struct usb_descriptor_header *null_mtp_descs[] = {
+	NULL,
+};
+
+#define MAX_BULK_RX_REQ_NUM 8
+#define MAX_BULK_TX_REQ_NUM 4
+#define MAX_CTL_RX_REQ_NUM	8
+
+/*---------------------------------------------------------------------------*/
+struct usb_mtp_context {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+
+	spinlock_t lock;  /* For RX/TX/INT list */
+
+	struct usb_ep *bulk_in;
+	struct usb_ep *bulk_out;
+	struct usb_ep *intr_in;
+
+	struct list_head rx_reqs;
+	struct list_head rx_done_reqs;
+	struct list_head tx_reqs;
+	struct list_head ctl_rx_reqs;
+	struct list_head ctl_rx_done_reqs;
+
+	int online;
+	int error;
+	int cancel;
+	int ctl_cancel;
+	int intr_in_busy;
+
+	wait_queue_head_t rx_wq;
+	wait_queue_head_t tx_wq;
+	wait_queue_head_t ctl_rx_wq;
+	wait_queue_head_t ctl_tx_wq;
+
+	struct usb_request *int_tx_req;
+	struct usb_request *ctl_tx_req;
+
+	/* the request we're currently reading from */
+	struct usb_request *cur_read_req;
+	/* buffer to point to available data in the current request */
+	unsigned char *read_buf;
+	/* available data length */
+	int data_len;
+};
+
+static struct usb_mtp_context g_usb_mtp_context;
+
+/* record all usb requests for bulk out */
+static struct usb_request *pending_reqs[MAX_BULK_RX_REQ_NUM];
+#define MTP_CANCEL_REQ_DATA_SIZE		6
+
+struct ctl_req_wrapper {
+	int header;
+	struct usb_ctrlrequest creq;
+	struct list_head	list;
+	char cancel_data[MTP_CANCEL_REQ_DATA_SIZE];
+};
+
+struct ctl_req_wrapper ctl_reqs[MAX_CTL_RX_REQ_NUM];
+struct ctl_req_wrapper *cur_creq;
+int ctl_tx_done;
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_request *req_new(struct usb_ep *ep, int size)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void req_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/* add a request to the tail of a list */
+static void req_put(struct list_head *head, struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&g_usb_mtp_context.lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&g_usb_mtp_context.lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request *req_get(struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&g_usb_mtp_context.lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&g_usb_mtp_context.lock, flags);
+	return req;
+}
+
+/* add a mtp control request to the tail of a list */
+static void ctl_req_put(struct list_head *head, struct ctl_req_wrapper *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&g_usb_mtp_context.lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&g_usb_mtp_context.lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct ctl_req_wrapper *ctl_req_get(struct list_head *head)
+{
+	unsigned long flags;
+	struct ctl_req_wrapper *req;
+
+	spin_lock_irqsave(&g_usb_mtp_context.lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct ctl_req_wrapper, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&g_usb_mtp_context.lock, flags);
+	return req;
+}
+/*-------------------------------------------------------------------------*/
+
+static void mtp_in_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	mtp_debug("status is %d %p %d\n", req->status, req, req->actual);
+	if (req->status == -ECONNRESET)
+		usb_ep_fifo_flush(ep);
+
+	if (req->status != 0) {
+		g_usb_mtp_context.error = 1;
+		mtp_err("status is %d %p len=%d\n",
+		req->status, req, req->actual);
+	}
+
+	req_put(&g_usb_mtp_context.tx_reqs, req);
+	wake_up(&g_usb_mtp_context.tx_wq);
+}
+
+static void mtp_out_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	mtp_debug("status is %d %p %d\n", req->status, req, req->actual);
+	if (req->status == 0) {
+		req_put(&g_usb_mtp_context.rx_done_reqs, req);
+	} else {
+		mtp_err("status is %d %p len=%d\n",
+		req->status, req, req->actual);
+		g_usb_mtp_context.error = 1;
+		if (req->status == -ECONNRESET)
+			usb_ep_fifo_flush(ep);
+		req_put(&g_usb_mtp_context.rx_reqs, req);
+	}
+	wake_up(&g_usb_mtp_context.rx_wq);
+}
+
+static void mtp_int_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	mtp_debug("status is %d %d\n", req->status, req->actual);
+
+	if (req->status == -ECONNRESET)
+		usb_ep_fifo_flush(ep);
+
+	if (req->status != 0)
+		mtp_err("status is %d %p len=%d\n",
+		req->status, req, req->actual);
+
+	g_usb_mtp_context.intr_in_busy = 0;
+	return;
+}
+
+static ssize_t mtp_read(struct file *fp, char __user *buf,
+				size_t count, loff_t *pos)
+{
+	struct usb_request *req = 0;
+	int xfer, rc = count;
+	int ret;
+
+	while (count > 0) {
+		mtp_debug("count=%d\n", count);
+		if (g_usb_mtp_context.error) {
+			return -EIO;
+		}
+		/* we will block until we're online */
+		ret = wait_event_interruptible(g_usb_mtp_context.rx_wq,
+			(g_usb_mtp_context.online || g_usb_mtp_context.cancel));
+		if (g_usb_mtp_context.cancel) {
+			mtp_debug("cancel return in mtp_read at beginning\n");
+			g_usb_mtp_context.cancel = 0;
+			return -EINVAL;
+		}
+		if (ret < 0) {
+			mtp_err("wait_event_interruptible return %d\n", ret);
+			rc = ret;
+			break;
+		}
+
+		/* if we have idle read requests, get them queued */
+		while (1) {
+			req = req_get(&g_usb_mtp_context.rx_reqs);
+			if (!req)
+				break;
+requeue_req:
+			req->length = BULK_BUFFER_SIZE;
+			mtp_debug("rx %p queue\n", req);
+			ret = usb_ep_queue(g_usb_mtp_context.bulk_out,
+				req, GFP_ATOMIC);
+
+			if (ret < 0) {
+				mtp_err("queue error %d\n", ret);
+				g_usb_mtp_context.error = 1;
+				req_put(&g_usb_mtp_context.rx_reqs, req);
+				return ret;
+			}
+		}
+
+		/* if we have data pending, give it to userspace */
+		if (g_usb_mtp_context.data_len > 0) {
+			if (g_usb_mtp_context.data_len < count)
+				xfer = g_usb_mtp_context.data_len;
+			else
+				xfer = count;
+
+			if (copy_to_user(buf, g_usb_mtp_context.read_buf,
+								xfer)) {
+				rc = -EFAULT;
+				break;
+			}
+			g_usb_mtp_context.read_buf += xfer;
+			g_usb_mtp_context.data_len -= xfer;
+			buf += xfer;
+			count -= xfer;
+			mtp_debug("xfer=%d\n", xfer);
+
+			/* if we've emptied the buffer, release the request */
+			if (g_usb_mtp_context.data_len == 0) {
+				req_put(&g_usb_mtp_context.rx_reqs,
+						g_usb_mtp_context.cur_read_req);
+				g_usb_mtp_context.cur_read_req = 0;
+			}
+			continue;
+		}
+
+		/* wait for a request to complete */
+		req = 0;
+		mtp_debug("wait req finish\n");
+		ret = wait_event_interruptible(g_usb_mtp_context.rx_wq,
+		((req = req_get(&g_usb_mtp_context.rx_done_reqs))
+			|| g_usb_mtp_context.cancel));
+		mtp_debug("req finished\n");
+		if (g_usb_mtp_context.cancel) {
+			if (req != 0)
+				req_put(&g_usb_mtp_context.rx_reqs, req);
+			mtp_debug("cancel return in mtp_read at complete\n");
+			g_usb_mtp_context.cancel = 0;
+			return -EINVAL;
+		}
+		if (ret < 0) {
+			mtp_err("wait_event_interruptible(2) return %d\n", ret);
+			rc = ret;
+			break;
+		}
+		if (req != 0) {
+			/* if we got a 0-len one we need to put it back into
+			** service.  if we made it the current read req we'd
+			** be stuck forever
+			*/
+			if (req->actual == 0)
+				goto requeue_req;
+
+			g_usb_mtp_context.cur_read_req = req;
+			g_usb_mtp_context.data_len = req->actual;
+			g_usb_mtp_context.read_buf = req->buf;
+			mtp_debug("rx %p done actual=%d\n", req, req->actual);
+		}
+	}
+
+	mtp_debug("mtp_read returning %d\n", rc);
+	return rc;
+}
+
+static ssize_t mtp_write(struct file *fp, const char __user *buf,
+				 size_t count, loff_t *pos)
+{
+	struct usb_request *req;
+	int rc = count, xfer;
+	int ret;
+
+	while (count > 0) {
+		mtp_debug("count=%d\n", count);
+		if (g_usb_mtp_context.error) {
+			return -EIO;
+		}
+		/* get an idle tx request to use */
+		ret = wait_event_interruptible(g_usb_mtp_context.tx_wq,
+			(g_usb_mtp_context.online || g_usb_mtp_context.cancel));
+
+		if (g_usb_mtp_context.cancel) {
+			mtp_debug("cancel return in mtp_write at beginning\n");
+			g_usb_mtp_context.cancel = 0;
+			return -EINVAL;
+		}
+		if (ret < 0) {
+			mtp_err("wait_event_interruptible return %d\n", ret);
+			rc = ret;
+			break;
+		}
+
+		req = 0;
+		mtp_debug("get tx req\n");
+		ret = wait_event_interruptible(g_usb_mtp_context.tx_wq,
+			((req = req_get(&g_usb_mtp_context.tx_reqs))
+			 || g_usb_mtp_context.cancel));
+
+		mtp_debug("got tx req\n");
+		if (g_usb_mtp_context.cancel) {
+			mtp_debug("cancel return in mtp_write get req\n");
+			if (req != 0)
+				req_put(&g_usb_mtp_context.tx_reqs, req);
+			g_usb_mtp_context.cancel = 0;
+			return -EINVAL;
+		}
+		if (ret < 0) {
+			mtp_err("wait_event_interruptible return(2) %d\n", ret);
+			rc = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > BULK_BUFFER_SIZE)
+				xfer = BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+			if (copy_from_user(req->buf, buf, xfer)) {
+				req_put(&g_usb_mtp_context.tx_reqs, req);
+				rc = -EFAULT;
+				break;
+			}
+
+			req->length = xfer;
+			ret = usb_ep_queue(g_usb_mtp_context.bulk_in,
+				req, GFP_ATOMIC);
+			if (ret < 0) {
+				mtp_err("error %d\n", ret);
+				g_usb_mtp_context.error = 1;
+				req_put(&g_usb_mtp_context.tx_reqs, req);
+				rc = ret;
+				break;
+			}
+
+			buf += xfer;
+			count -= xfer;
+			mtp_debug("xfer=%d\n", xfer);
+		}
+	}
+
+	mtp_debug("mtp_write returning %d\n", rc);
+	return rc;
+}
+
+/* ioctl related */
+#define MTP_EVENT_SIZE   28
+struct mtp_event_data {
+    unsigned char data[MTP_EVENT_SIZE];
+};
+
+#define MTP_IOC_MAGIC    'm'
+#define MTP_IOC_MAXNR    10
+
+#define MTP_IOC_EVENT            _IOW(MTP_IOC_MAGIC, 1, struct mtp_event_data)
+#define MTP_IOC_SEND_ZLP         _IO(MTP_IOC_MAGIC, 2)
+#define MTP_IOC_GET_EP_SIZE_IN   _IOR(MTP_IOC_MAGIC, 3, int)
+#define MTP_IOC_GET_VENDOR_FLAG  _IOR(MTP_IOC_MAGIC, 4, int)
+#define MTP_IOC_CANCEL_IO        _IO(MTP_IOC_MAGIC, 5)
+#define MTP_IOC_DEVICE_RESET     _IO(MTP_IOC_MAGIC, 6)
+
+static int mtp_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	int len, clen, count, n;
+	struct usb_request *req;
+	struct mtp_event_data event;
+
+	if (!g_usb_mtp_context.online)
+		return -EINVAL;
+
+	switch (cmd) {
+	case MTP_IOC_EVENT:
+		if (g_usb_mtp_context.intr_in_busy) {
+			mtp_err("interrupt in request busy\n");
+			return -EBUSY;
+		}
+
+		count = MIN(_IOC_SIZE(cmd), MTP_EVENT_SIZE);
+		if (copy_from_user(event.data, (void *)arg,  count))
+			return -EINVAL;
+
+		/* length is in little endian */
+		memcpy(&len, event.data, sizeof(len));
+		clen = le32_to_cpu(len);
+		mtp_debug("len=%d cpu len=%d\n", len, clen);
+		/* send event through interrupt in */
+		req = g_usb_mtp_context.int_tx_req;
+		if (!req)
+			return -EINVAL;
+		count = MIN(MTP_EVENT_SIZE, clen);
+		memcpy(req->buf, event.data, count);
+		req->length = count;
+		req->zero = 0;
+		if (usb_ep_queue(g_usb_mtp_context.intr_in, req, GFP_ATOMIC))
+			return -EINVAL;
+		g_usb_mtp_context.intr_in_busy = 1;
+		break;
+	case MTP_IOC_SEND_ZLP:
+		req = req_get(&g_usb_mtp_context.tx_reqs);
+		if (!req)
+			return -EINVAL;
+		req->length = 0;
+		req->zero = 0;
+		if (usb_ep_queue(g_usb_mtp_context.bulk_in, req, GFP_ATOMIC)) {
+			req_put(&g_usb_mtp_context.tx_reqs, req);
+			return -EINVAL;
+		}
+		break;
+	case MTP_IOC_GET_EP_SIZE_IN:
+		/* get endpoint buffer size for bulk in */
+		len = BULK_BUFFER_SIZE;
+		if (copy_to_user((void *)arg, &len, sizeof(int)))
+			return -EINVAL;
+		break;
+	case MTP_IOC_CANCEL_IO:
+		mtp_debug("MTP_IOC_CANCEL_IO:\n");
+		g_usb_mtp_context.cancel = 1;
+		for (n = 0; n < MAX_BULK_RX_REQ_NUM; n++) {
+			req = pending_reqs[n];
+			if (req && req->actual) {
+				mtp_err("n=%d %p %d\n", n, req, req->actual);
+				req->actual = 0;
+			}
+		}
+		/* we've cancelled the recv urb, start new one */
+		mtp_debug("MTP_IOC_CANCEL_IO end:\n");
+		wake_up(&g_usb_mtp_context.rx_wq);
+		wake_up(&g_usb_mtp_context.tx_wq);
+		break;
+	case MTP_IOC_DEVICE_RESET:
+		g_usb_mtp_context.cancel = 1;
+		g_usb_mtp_context.ctl_cancel = 1;
+		wake_up(&g_usb_mtp_context.rx_wq);
+		wake_up(&g_usb_mtp_context.tx_wq);
+		wake_up(&g_usb_mtp_context.ctl_rx_wq);
+		wake_up(&g_usb_mtp_context.ctl_tx_wq);
+		break;
+	}
+	return 0;
+}
+
+/* file operations for MTP device /dev/mtp */
+static const struct file_operations mtp_fops = {
+	.owner = THIS_MODULE,
+	.read = mtp_read,
+	.write = mtp_write,
+	.ioctl = mtp_ioctl,
+};
+
+static struct miscdevice mtp_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mtp",
+	.fops = &mtp_fops,
+};
+
+/* mtpctl related */
+#define MTP_CTL_CLASS_REQ    1
+#define MTP_CTL_CLASS_REPLY  2
+
+struct mtp_ctl_msg_header {
+    int msg_len;
+    int msg_id;
+};
+
+#define MTP_CTL_MSG_HEADER_SIZE   (sizeof(struct mtp_ctl_msg_header))
+#define MTP_CTL_MSG_SIZE	(MTP_CTL_MSG_HEADER_SIZE +\
+			 sizeof(struct usb_ctrlrequest))
+
+#define MTP_CLASS_CANCEL_REQ			0x64
+#define MTP_CLASS_GET_EXTEND_EVEVT_DATA	0x65
+#define MTP_CLASS_RESET_REQ				0x66
+#define MTP_CLASS_GET_DEVICE_STATUS		0x67
+
+
+static void mtp_ctl_read_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct ctl_req_wrapper	*ctl_req = ep->driver_data;
+
+	mtp_debug("mtp_ctl_read_complete --> %d, %d/%d\n",
+	req->status, req->actual, req->length);
+
+	if (req->status == 0)
+		memcpy(ctl_req->cancel_data, req->buf, req->actual);
+
+	wake_up(&g_usb_mtp_context.ctl_rx_wq);
+}
+
+static void mtp_ctl_write_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	mtp_debug("mtp_ctl_write_complete --> %d, %d/%d\n",
+	req->status, req->actual, req->length);
+
+	ctl_tx_done = 1;
+
+	wake_up(&g_usb_mtp_context.ctl_tx_wq);
+}
+
+static ssize_t mtp_ctl_read(struct file *file, char *buf,
+	size_t count, loff_t *pos)
+{
+    int ret, size = sizeof(struct usb_ctrlrequest);
+	struct mtp_ctl_msg_header msg;
+
+	mtp_debug("count=%d\n", count);
+
+	if (!g_usb_mtp_context.online)
+		return -EINVAL;
+
+	if (!cur_creq) {
+		ret = wait_event_interruptible(g_usb_mtp_context.ctl_rx_wq,
+		((cur_creq = ctl_req_get(&g_usb_mtp_context.ctl_rx_done_reqs))
+			|| g_usb_mtp_context.ctl_cancel));
+		if (g_usb_mtp_context.ctl_cancel) {
+			mtp_debug("ctl_cancel return in mtp_ctl_read\n");
+			if (cur_creq)
+				ctl_req_put(&g_usb_mtp_context.ctl_rx_reqs,
+				cur_creq);
+			g_usb_mtp_context.ctl_cancel = 0;
+			return -EINVAL;
+		}
+		if (ret < 0) {
+			mtp_err("wait_event_interruptible return %d\n", ret);
+			return ret;
+		}
+	}
+
+	msg.msg_id = MTP_CTL_CLASS_REQ;
+	msg.msg_len = MTP_CTL_MSG_SIZE;
+	if (cur_creq->creq.bRequest == MTP_CLASS_CANCEL_REQ)
+		msg.msg_len = MTP_CTL_MSG_SIZE + MTP_CANCEL_REQ_DATA_SIZE;
+
+	if (cur_creq->header == 1) {
+		cur_creq->header = 0;
+		if (copy_to_user(buf, &msg, MTP_CTL_MSG_HEADER_SIZE))
+			goto ctl_read_fail;
+		ret = MTP_CTL_MSG_HEADER_SIZE;
+		mtp_debug("msg header return %d\n", ret);
+	} else {
+		if (copy_to_user(buf, &cur_creq->creq, size))
+			goto ctl_read_fail;
+		ret = size;
+		if (cur_creq->creq.bRequest == MTP_CLASS_CANCEL_REQ) {
+			if (copy_to_user(buf + size, &cur_creq->cancel_data,
+				MTP_CANCEL_REQ_DATA_SIZE))
+				goto ctl_read_fail;
+			ret += MTP_CANCEL_REQ_DATA_SIZE;
+		}
+		mtp_debug("prepare %d %x\n", ret, cur_creq->creq.bRequest);
+		ctl_req_put(&g_usb_mtp_context.ctl_rx_reqs, cur_creq);
+		cur_creq = NULL;
+	}
+
+	mtp_debug("return %d\n", ret);
+    return ret;
+
+ctl_read_fail:
+	ctl_req_put(&g_usb_mtp_context.ctl_rx_reqs, cur_creq);
+	cur_creq = NULL;
+	mtp_debug("return -EFAULT\n");
+    return -EFAULT;
+}
+
+static ssize_t mtp_ctl_write(struct file *file, const char *buf,
+	size_t count, loff_t *pos)
+{
+    struct mtp_ctl_msg_header msg;
+	struct usb_request *req = NULL;
+	struct usb_ep *ep0;
+	int ret;
+
+	mtp_debug("count=%d\n", count);
+
+	ret = wait_event_interruptible(g_usb_mtp_context.ctl_tx_wq,
+		(g_usb_mtp_context.online || g_usb_mtp_context.ctl_cancel));
+	if (g_usb_mtp_context.ctl_cancel) {
+		mtp_debug("ctl_cancel return in mtp_ctl_write 1\n");
+		g_usb_mtp_context.ctl_cancel = 0;
+		return -EINVAL;
+	}
+	if (ret < 0)
+		return ret;
+
+	ep0 = g_usb_mtp_context.cdev->gadget->ep0;
+    if (count > ep0->maxpacket || count < MTP_CTL_MSG_HEADER_SIZE) {
+		mtp_err("size invalid\n");
+		return -ENOMEM;
+    }
+
+    /* msg info */
+    if (copy_from_user(&msg, buf, MTP_CTL_MSG_HEADER_SIZE))
+		return -EINVAL;
+
+    mtp_debug("msg len = %d, msg id = %d", msg.msg_len, msg.msg_id);
+    if (msg.msg_id != MTP_CTL_CLASS_REPLY) {
+		mtp_err("invalid id %d", msg.msg_id);
+		return -EINVAL;
+    }
+
+    /* sending the data */
+	req = g_usb_mtp_context.ctl_tx_req;
+	if (!req)
+		return -ENOMEM;
+    req->length = count - MTP_CTL_MSG_HEADER_SIZE;
+	req->complete = mtp_ctl_write_complete;
+    if (copy_from_user(req->buf,
+		(u8 *)buf + MTP_CTL_MSG_HEADER_SIZE, req->length)) {
+		return -EINVAL;
+	}
+	ctl_tx_done = 0;
+	if (usb_ep_queue(ep0, req, GFP_ATOMIC)) {
+		req->status = 0;
+		mtp_ctl_write_complete(ep0, req);
+		return -EIO;
+	}
+	ret = wait_event_interruptible(g_usb_mtp_context.ctl_tx_wq,
+		(ctl_tx_done || g_usb_mtp_context.ctl_cancel));
+	ctl_tx_done = 0;
+	if (g_usb_mtp_context.ctl_cancel) {
+		mtp_debug("ctl_cancel return in mtp_ctl_write\n");
+		g_usb_mtp_context.ctl_cancel = 0;
+		return -EINVAL;
+	}
+	if (ret < 0)
+		return ret;
+
+	mtp_debug("return count=%d\n", count);
+    return count;
+}
+
+static const struct file_operations mtp_ctl_fops = {
+     .read = mtp_ctl_read,
+     .write = mtp_ctl_write,
+};
+
+static void
+mtp_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_request *req;
+	int n;
+
+	for (n = 0; n < MAX_BULK_RX_REQ_NUM; n++)
+		pending_reqs[n] = NULL;
+
+	while ((req = req_get(&g_usb_mtp_context.rx_reqs)))
+		req_free(req, g_usb_mtp_context.bulk_out);
+	while ((req = req_get(&g_usb_mtp_context.rx_done_reqs)))
+		req_free(req, g_usb_mtp_context.bulk_out);
+	while ((req = req_get(&g_usb_mtp_context.tx_reqs)))
+		req_free(req, g_usb_mtp_context.bulk_in);
+
+	req_free(g_usb_mtp_context.int_tx_req, g_usb_mtp_context.intr_in);
+	req_free(g_usb_mtp_context.ctl_tx_req,
+	g_usb_mtp_context.cdev->gadget->ep0);
+	g_usb_mtp_context.intr_in_busy = 0;
+	misc_deregister(&mtp_device);
+    remove_proc_entry("mtpctl", NULL);
+}
+
+static int __init
+mtp_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	int n, rc, id;
+	struct usb_ep *ep;
+	struct usb_request *req;
+    struct proc_dir_entry *mtp_proc = NULL;
+
+	g_usb_mtp_context.cdev = c->cdev;
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	intf_desc.bInterfaceNumber = id;
+
+	/* Find all the endpoints we will use */
+	ep = usb_ep_autoconfig(g_usb_mtp_context.cdev->gadget,
+						&fs_bulk_in_desc);
+	if (!ep) {
+		mtp_err("auto-configure hs_bulk_in_desc error\n");
+		goto autoconf_fail;
+	}
+	ep->driver_data = &g_usb_mtp_context;
+	g_usb_mtp_context.bulk_in = ep;
+
+	ep = usb_ep_autoconfig(g_usb_mtp_context.cdev->gadget,
+						&fs_bulk_out_desc);
+	if (!ep) {
+		mtp_err("auto-configure hs_bulk_out_desc error\n");
+		goto autoconf_fail;
+	}
+	ep->driver_data = &g_usb_mtp_context;
+	g_usb_mtp_context.bulk_out = ep;
+
+	ep = usb_ep_autoconfig(g_usb_mtp_context.cdev->gadget,
+						&fs_intr_in_desc);
+	if (!ep) {
+		mtp_err("auto-configure hs_intr_in_desc error\n");
+		goto autoconf_fail;
+	}
+	ep->driver_data = &g_usb_mtp_context;
+	g_usb_mtp_context.intr_in = ep;
+
+	if (gadget_is_dualspeed(g_usb_mtp_context.cdev->gadget)) {
+		/* Assume endpoint addresses are the same for both speeds */
+		hs_bulk_in_desc.bEndpointAddress =
+		    fs_bulk_in_desc.bEndpointAddress;
+		hs_bulk_out_desc.bEndpointAddress =
+		    fs_bulk_out_desc.bEndpointAddress;
+		hs_intr_in_desc.bEndpointAddress =
+		    fs_intr_in_desc.bEndpointAddress;
+	}
+
+	rc = -ENOMEM;
+
+	for (n = 0; n < MAX_BULK_RX_REQ_NUM; n++) {
+		req = req_new(g_usb_mtp_context.bulk_out, BULK_BUFFER_SIZE);
+		if (!req)
+			goto autoconf_fail;
+
+		pending_reqs[n] = req;
+
+		req->complete = mtp_out_complete;
+		req_put(&g_usb_mtp_context.rx_reqs, req);
+	}
+	for (n = 0; n < MAX_BULK_TX_REQ_NUM; n++) {
+		req = req_new(g_usb_mtp_context.bulk_in, BULK_BUFFER_SIZE);
+		if (!req)
+			goto autoconf_fail;
+
+		req->complete = mtp_in_complete;
+		req_put(&g_usb_mtp_context.tx_reqs, req);
+	}
+
+	for (n = 0; n < MAX_CTL_RX_REQ_NUM; n++)
+		ctl_req_put(&g_usb_mtp_context.ctl_rx_reqs, &ctl_reqs[n]);
+
+	g_usb_mtp_context.int_tx_req =
+		req_new(g_usb_mtp_context.intr_in, BULK_BUFFER_SIZE);
+	if (!g_usb_mtp_context.int_tx_req)
+		goto autoconf_fail;
+	g_usb_mtp_context.intr_in_busy = 0;
+	g_usb_mtp_context.int_tx_req->complete = mtp_int_complete;
+
+	g_usb_mtp_context.ctl_tx_req =
+		req_new(g_usb_mtp_context.cdev->gadget->ep0, 512);
+	if (!g_usb_mtp_context.ctl_tx_req)
+		goto autoconf_fail;
+
+	misc_register(&mtp_device);
+
+	mtp_proc = create_proc_entry("mtpctl", 0666, 0);
+	if (!mtp_proc) {
+		mtp_err("creating /proc/mtpctl failed\n");
+		goto autoconf_fail;
+    }
+    mtp_proc->proc_fops = &mtp_ctl_fops;
+
+	return 0;
+
+autoconf_fail:
+	rc = -ENOTSUPP;
+	mtp_function_unbind(c, f);
+	return rc;
+}
+
+static void mtp_function_disable(struct usb_function *f)
+{
+	printk(KERN_DEBUG "%s(): disabled\n", __func__);
+	g_usb_mtp_context.online = 0;
+	g_usb_mtp_context.cancel = 1;
+	g_usb_mtp_context.ctl_cancel = 1;
+	g_usb_mtp_context.error = 1;
+
+	usb_ep_disable(g_usb_mtp_context.bulk_in);
+	usb_ep_disable(g_usb_mtp_context.bulk_out);
+	usb_ep_disable(g_usb_mtp_context.intr_in);
+
+	g_usb_mtp_context.cur_read_req = 0;
+	g_usb_mtp_context.read_buf = 0;
+	g_usb_mtp_context.data_len = 0;
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&g_usb_mtp_context.rx_wq);
+	wake_up(&g_usb_mtp_context.tx_wq);
+	wake_up(&g_usb_mtp_context.ctl_rx_wq);
+	wake_up(&g_usb_mtp_context.ctl_tx_wq);
+}
+
+static void start_out_receive(void)
+{
+	struct usb_request *req;
+	int ret;
+
+	/* if we have idle read requests, get them queued */
+	while ((req = req_get(&g_usb_mtp_context.rx_reqs))) {
+		req->length = BULK_BUFFER_SIZE;
+		ret = usb_ep_queue(g_usb_mtp_context.bulk_out, req, GFP_ATOMIC);
+		if (ret < 0) {
+			mtp_err("error %d\n", ret);
+			g_usb_mtp_context.error = 1;
+			req_put(&g_usb_mtp_context.rx_reqs, req);
+		}
+	}
+}
+
+static int mtp_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	int ret;
+
+	printk(KERN_DEBUG "%s intf=%d alt=%d\n", __func__, intf, alt);
+	ret = usb_ep_enable(g_usb_mtp_context.bulk_in,
+			ep_choose(g_usb_mtp_context.cdev->gadget,
+				&hs_bulk_in_desc,
+				&fs_bulk_in_desc));
+	if (ret)
+		return ret;
+	ret = usb_ep_enable(g_usb_mtp_context.bulk_out,
+			ep_choose(g_usb_mtp_context.cdev->gadget,
+				&hs_bulk_out_desc,
+				&fs_bulk_out_desc));
+	if (ret) {
+		usb_ep_disable(g_usb_mtp_context.bulk_in);
+		return ret;
+	}
+
+	ret = usb_ep_enable(g_usb_mtp_context.intr_in,
+			ep_choose(g_usb_mtp_context.cdev->gadget,
+				&hs_intr_in_desc,
+				&fs_intr_in_desc));
+	if (ret) {
+		usb_ep_disable(g_usb_mtp_context.bulk_in);
+		usb_ep_disable(g_usb_mtp_context.bulk_out);
+		return ret;
+	}
+
+	usb_interface_enum_cb(MTP_TYPE_FLAG);
+
+	g_usb_mtp_context.cur_read_req = 0;
+	g_usb_mtp_context.read_buf = 0;
+	g_usb_mtp_context.data_len = 0;
+
+	/* we're online -- get all rx requests queued */
+	start_out_receive();
+
+	g_usb_mtp_context.online = 1;
+	g_usb_mtp_context.cancel = 0;
+	g_usb_mtp_context.ctl_cancel = 0;
+	g_usb_mtp_context.error = 0;
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&g_usb_mtp_context.rx_wq);
+	return 0;
+}
+
+#define MTP_MOD_VENDOR_CODE   0x1C
+static int  mtp_ext_id = 4;
+static unsigned char mtp_ext_desc[] =
+"\050\000\000\000\000\001\004\000\001\000\000\000\000\000\000\000\000\001"
+"\115\124\120\000\000\000\000\000\060\060\000\000\000\000\000\000\000\000"
+"\000\000\000\000";
+static int  mtp_ext_str_idx = 238;
+
+static int mtp_function_setup(struct usb_function *f,
+					const struct usb_ctrlrequest *ctrl)
+{
+	int	value = -EOPNOTSUPP;
+	u16     wIndex = le16_to_cpu(ctrl->wIndex);
+	u16     wLength = le16_to_cpu(ctrl->wLength);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	struct usb_request	*req = cdev->req;
+	struct ctl_req_wrapper	*ctl_req;
+
+	mtp_debug("bRequestType=0x%x bRequest=0x%x wIndex=0x%x wLength=0x%x\n",
+		ctrl->bRequestType, ctrl->bRequest, wIndex, wLength);
+
+	switch (ctrl->bRequestType & USB_TYPE_MASK) {
+	case USB_TYPE_VENDOR:
+		switch (ctrl->bRequest) {
+		case MTP_MOD_VENDOR_CODE:
+			if (wIndex == mtp_ext_id) {
+				memcpy(req->buf, mtp_ext_desc,
+						sizeof(mtp_ext_desc));
+				if (wLength < mtp_ext_desc[0])
+					value = wLength;
+				else
+					value = mtp_ext_desc[0];
+
+				req->zero = 0;
+				req->length = value;
+				if (usb_ep_queue(cdev->gadget->ep0, req,
+					GFP_ATOMIC))
+					mtp_err("ep0 in queue failed\n");
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+	case USB_TYPE_CLASS:
+		switch (ctrl->bRequest) {
+		case MTP_CLASS_CANCEL_REQ:
+		case MTP_CLASS_GET_EXTEND_EVEVT_DATA:
+		case MTP_CLASS_RESET_REQ:
+		case MTP_CLASS_GET_DEVICE_STATUS:
+			mtp_debug("ctl request=0x%x\n", ctrl->bRequest);
+			ctl_req = ctl_req_get(&g_usb_mtp_context.ctl_rx_reqs);
+			if (!ctl_req) {
+				mtp_err("get free ctl req failed\n");
+				break;
+			}
+			memcpy(&ctl_req->creq, ctrl,
+					sizeof(struct usb_ctrlrequest));
+			ctl_req->header = 1;
+			ctl_req_put(&g_usb_mtp_context.ctl_rx_done_reqs,
+				ctl_req);
+			value = 0;
+			if ((ctrl->bRequest  == MTP_CLASS_CANCEL_REQ)
+				&& wLength == MTP_CANCEL_REQ_DATA_SIZE) {
+
+				memset(&ctl_req->cancel_data, 0,
+					MTP_CANCEL_REQ_DATA_SIZE);
+				value = wLength;
+				cdev->gadget->ep0->driver_data = ctl_req;
+				req->complete = mtp_ctl_read_complete;
+				req->zero = 0;
+				req->length = wLength;
+
+				if (usb_ep_queue(cdev->gadget->ep0,
+						req, GFP_ATOMIC)) {
+					mtp_err("ep0 out queue failed\n");
+					mtp_ctl_read_complete(cdev->gadget->ep0,
+							req);
+				}
+			} else
+				wake_up(&g_usb_mtp_context.ctl_rx_wq);
+			break;
+		default:
+			break;
+		}
+	}
+
+	mtp_debug("return value=%d\n", value);
+	return value;
+}
+
+int __init mtp_function_add(struct usb_composite_dev *cdev,
+	struct usb_configuration *c)
+{
+	int ret = 0;
+	int status;
+
+	init_waitqueue_head(&g_usb_mtp_context.rx_wq);
+	init_waitqueue_head(&g_usb_mtp_context.tx_wq);
+	init_waitqueue_head(&g_usb_mtp_context.ctl_rx_wq);
+	init_waitqueue_head(&g_usb_mtp_context.ctl_tx_wq);
+
+	INIT_LIST_HEAD(&g_usb_mtp_context.rx_reqs);
+	INIT_LIST_HEAD(&g_usb_mtp_context.rx_done_reqs);
+	INIT_LIST_HEAD(&g_usb_mtp_context.tx_reqs);
+	INIT_LIST_HEAD(&g_usb_mtp_context.ctl_rx_reqs);
+	INIT_LIST_HEAD(&g_usb_mtp_context.ctl_rx_done_reqs);
+
+	status = usb_string_id(c->cdev);
+	if (status >= 0) {
+		mtp_string_defs1[STRING_INTERFACE].id = status;
+		intf_desc.iInterface = status;
+	}
+
+	mtp_string_defs2[STRING_MTP].id = mtp_ext_str_idx;
+
+	g_usb_mtp_context.cdev = cdev;
+	g_usb_mtp_context.function.name = "mtp";
+	g_usb_mtp_context.function.descriptors = null_mtp_descs;
+	g_usb_mtp_context.function.hs_descriptors = null_mtp_descs;
+	g_usb_mtp_context.function.strings = mtp_strings;
+	g_usb_mtp_context.function.bind = mtp_function_bind;
+	g_usb_mtp_context.function.unbind = mtp_function_unbind;
+	g_usb_mtp_context.function.setup = mtp_function_setup;
+	g_usb_mtp_context.function.set_alt = mtp_function_set_alt;
+	g_usb_mtp_context.function.disable = mtp_function_disable;
+
+	ret = usb_add_function(c, &g_usb_mtp_context.function);
+	if (ret) {
+		mtp_err("MTP gadget driver failed to initialize\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+struct usb_function *mtp_function_enable(int enable, int id)
+{
+	printk(KERN_DEBUG "%s enable=%d id=%d\n", __func__, enable, id);
+	if (enable) {
+		g_usb_mtp_context.function.descriptors = fs_mtp_descs;
+		g_usb_mtp_context.function.hs_descriptors = hs_mtp_descs;
+		intf_desc.bInterfaceNumber = id;
+	} else {
+		g_usb_mtp_context.function.descriptors = null_mtp_descs;
+		g_usb_mtp_context.function.hs_descriptors = null_mtp_descs;
+	}
+	return &g_usb_mtp_context.function;
+}
diff --git a/drivers/usb/gadget/f_mtp.h b/drivers/usb/gadget/f_mtp.h
new file mode 100644
index 0000000..e209169
--- /dev/null
+++ b/drivers/usb/gadget/f_mtp.h
@@ -0,0 +1,41 @@
+/*
+ * Gadget Driver for Android MTP
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ * Author:
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __F_MTP_H
+#define __F_MTP_H
+
+struct usb_function *mtp_function_enable(int enable, int id);
+int mtp_function_add(struct usb_composite_dev *cdev,
+			struct usb_configuration *c);
+
+/* ioctl related */
+#define MTP_EVENT_SIZE   28
+struct mtp_event_data {
+    unsigned char data[MTP_EVENT_SIZE];
+};
+
+#define MTP_IOC_MAGIC    'm'
+#define MTP_IOC_MAXNR    10
+
+#define MTP_IOC_EVENT  _IOW(MTP_IOC_MAGIC, 1, struct mtp_event_data)
+#define MTP_IOC_SEND_ZLP         _IO(MTP_IOC_MAGIC, 2)
+#define MTP_IOC_GET_EP_SIZE_IN   _IOR(MTP_IOC_MAGIC, 3, int)
+#define MTP_IOC_GET_VENDOR_FLAG  _IOR(MTP_IOC_MAGIC, 4, int)
+#define MTP_IOC_CANCEL_IO        _IO(MTP_IOC_MAGIC, 5)
+#define MTP_IOC_DEVICE_RESET     _IO(MTP_IOC_MAGIC, 6)
+
+#endif /* __F_MTP_H */
diff --git a/drivers/usb/gadget/f_usbnet.c b/drivers/usb/gadget/f_usbnet.c
index e493e3d..de6f5cc 100644
--- a/drivers/usb/gadget/f_usbnet.c
+++ b/drivers/usb/gadget/f_usbnet.c
@@ -1,7 +1,7 @@
 /*
  * Gadget Driver for Motorola USBNet
  *
- * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2009 Motorola Corporation
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -28,6 +28,7 @@
 #include <linux/inetdevice.h>
 #include <linux/uaccess.h>
 #include <linux/workqueue.h>
+#include <asm/cacheflush.h>
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
@@ -35,6 +36,7 @@
 #include <asm/cacheflush.h>
 #include "f_usbnet.h"
 
+#include "f_mot_android.h"
 
 /*
  * Macro Defines
@@ -42,7 +44,6 @@
 
 #define EP0_BUFSIZE		256
 
-
 /* Vendor Request to config IP */
 #define USBNET_SET_IP_ADDRESS   0x05
 #define USBNET_SET_SUBNET_MASK  0x06
@@ -53,7 +54,15 @@
 #define MAX_BULK_TX_REQ_NUM	8
 #define MAX_BULK_RX_REQ_NUM	8
 #define MAX_INTR_RX_REQ_NUM	8
-#define STRING_INTERFACE        0
+
+struct usbnet_if_configuration {
+	u32 ip_addr;
+	u32 subnet_mask;
+	u32 router_ip;
+	u32 iff_flag;
+	struct work_struct usbnet_config_wq;
+	struct net_device *usbnet_config_dev;
+};
 
 struct usbnet_context {
 	spinlock_t lock;  /* For RX/TX list */
@@ -70,40 +79,48 @@ struct usbnet_context {
 	struct list_head tx_reqs;
 
 	struct net_device_stats stats;
-	struct work_struct usbnet_config_wq;
-	u32 ip_addr;
-	u32 subnet_mask;
-	u32 router_ip;
-	u32 iff_flag;
 };
 
-
 struct usbnet_device {
 	struct usb_function function;
 	struct usb_composite_dev *cdev;
 	struct usbnet_context *net_ctxt;
 };
 
+static struct usbnet_device             g_usbnet_device;
+static struct usbnet_context 		*g_usbnet_context;
+static struct net_device     		*g_net_dev;
+static struct usbnet_if_configuration 	g_usbnet_ifc;
+
+#ifdef CONFIG_USB_MOT_ANDROID
+/* used when eth function is disabled */
+static struct usb_descriptor_header *null_function[] = {
+	NULL,
+};
+#endif
+
+/*
+ * USB descriptors
+ */
+#define STRING_INTERFACE        0
+
 /* static strings, in UTF-8 */
 static struct usb_string usbnet_string_defs[] = {
-       [STRING_INTERFACE].s = "Motorola Test Command",
-       {  /* ZEROES END LIST */ },
+	[STRING_INTERFACE].s = "Motorola Networking Interface",
+	{  /* ZEROES END LIST */ },
 };
 
 static struct usb_gadget_strings usbnet_string_table = {
-       .language =             0x0409, /* en-us */
-       .strings =              usbnet_string_defs,
+	.language =             0x0409, /* en-us */
+	.strings =              usbnet_string_defs,
 };
 
 static struct usb_gadget_strings *usbnet_strings[] = {
-       &usbnet_string_table,
-       NULL,
+	&usbnet_string_table,
+	NULL,
 };
 
-
-
 /* There is only one interface. */
-
 static struct usb_interface_descriptor intf_desc = {
 	.bLength = sizeof intf_desc,
 	.bDescriptorType = USB_DT_INTERFACE,
@@ -193,9 +210,7 @@ static inline struct usbnet_device *func_to_dev(struct usb_function *f)
 	return container_of(f, struct usbnet_device, function);
 }
 
-
-static int ether_queue_out(struct usb_request *req ,
-				struct usbnet_context *context)
+static int ether_queue_out(struct usb_request *req)
 {
 	unsigned long flags;
 	struct sk_buff *skb;
@@ -203,7 +218,7 @@ static int ether_queue_out(struct usb_request *req ,
 
 	skb = alloc_skb(USB_MTU + NET_IP_ALIGN, GFP_ATOMIC);
 	if (!skb) {
-		USBNETDBG(context, "%s: failed to alloc skb\n", __func__);
+		printk(KERN_INFO "%s: failed to alloc skb\n", __func__);
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -214,71 +229,39 @@ static int ether_queue_out(struct usb_request *req ,
 	req->length = USB_MTU;
 	req->context = skb;
 
-	ret = usb_ep_queue(context->bulk_out, req, GFP_KERNEL);
+	ret = usb_ep_queue(g_usbnet_context->bulk_out, req, GFP_KERNEL);
 	if (ret == 0)
 		return 0;
-	else
-		kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 fail:
-	spin_lock_irqsave(&context->lock, flags);
-	list_add_tail(&req->list, &context->rx_reqs);
-	spin_unlock_irqrestore(&context->lock, flags);
+	spin_lock_irqsave(&g_usbnet_context->lock, flags);
+	list_add_tail(&req->list, &g_usbnet_context->rx_reqs);
+	spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
 
 	return ret;
 }
 
-struct usb_request *usb_get_recv_request(struct usbnet_context *context)
+static int usb_ether_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	unsigned long flags;
 	struct usb_request *req;
-
-	spin_lock_irqsave(&context->lock, flags);
-	if (list_empty(&context->rx_reqs)) {
-		req = NULL;
-	} else {
-		req = list_first_entry(&context->rx_reqs,
-				       struct usb_request, list);
-		list_del(&req->list);
-	}
-	spin_unlock_irqrestore(&context->lock, flags);
-
-	return req;
-}
-
-struct usb_request *usb_get_xmit_request(int stop_flag, struct net_device *dev)
-{
-	struct usbnet_context *context = netdev_priv(dev);
 	unsigned long flags;
-	struct usb_request *req;
+	unsigned len;
+	int rc;
 
-	spin_lock_irqsave(&context->lock, flags);
-	if (list_empty(&context->tx_reqs)) {
-		req = NULL;
+	spin_lock_irqsave(&g_usbnet_context->lock, flags);
+	if (list_empty(&g_usbnet_context->tx_reqs)) {
+		req = 0;
 	} else {
-		req = list_first_entry(&context->tx_reqs,
+		req = list_first_entry(&g_usbnet_context->tx_reqs,
 				       struct usb_request, list);
 		list_del(&req->list);
-		if (stop_flag == STOP_QUEUE &&
-			list_empty(&context->tx_reqs))
+		if (list_empty(&g_usbnet_context->tx_reqs))
 			netif_stop_queue(dev);
 	}
-	spin_unlock_irqrestore(&context->lock, flags);
-	return req;
-}
-
-static int usb_ether_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct usbnet_context *context = netdev_priv(dev);
-	struct usb_request *req;
-	unsigned long flags;
-	unsigned len;
-	int rc;
-
-	req = usb_get_xmit_request(STOP_QUEUE, dev);
+	spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
 
 	if (!req) {
-		USBNETDBG(context, "%s: could not obtain tx request\n",
-			__func__);
+		printk(KERN_INFO "%s: could not obtain tx request\n", __func__);
 		return 1;
 	}
 
@@ -294,17 +277,16 @@ static int usb_ether_xmit(struct sk_buff *skb, struct net_device *dev)
 	req->buf = skb->data;
 	req->length = len;
 
-	rc = usb_ep_queue(context->bulk_in, req, GFP_KERNEL);
+	rc = usb_ep_queue(g_usbnet_context->bulk_in, req, GFP_KERNEL);
 	if (rc != 0) {
-		spin_lock_irqsave(&context->lock, flags);
-		list_add_tail(&req->list, &context->tx_reqs);
-		spin_unlock_irqrestore(&context->lock, flags);
+		spin_lock_irqsave(&g_usbnet_context->lock, flags);
+		list_add_tail(&req->list, &g_usbnet_context->tx_reqs);
+		spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
 
 		dev_kfree_skb_any(skb);
-		context->stats.tx_dropped++;
+		g_usbnet_context->stats.tx_dropped++;
 
-		USBNETDBG(context,
-			  "%s: could not queue tx request\n", __func__);
+		printk(KERN_INFO "%s: could not queue tx request\n", __func__);
 	}
 
 	return 0;
@@ -312,23 +294,20 @@ static int usb_ether_xmit(struct sk_buff *skb, struct net_device *dev)
 
 static int usb_ether_open(struct net_device *dev)
 {
-	struct usbnet_context *context = netdev_priv(dev);
-	USBNETDBG(context, "%s\n", __func__);
+	printk(KERN_INFO "%s\n", __func__);
 	return 0;
 }
 
 static int usb_ether_stop(struct net_device *dev)
 {
-	struct usbnet_context *context = netdev_priv(dev);
-	USBNETDBG(context, "%s\n", __func__);
+	printk(KERN_INFO "%s\n", __func__);
 	return 0;
 }
 
 static struct net_device_stats *usb_ether_get_stats(struct net_device *dev)
 {
-	struct usbnet_context *context = netdev_priv(dev);
-	USBNETDBG(context, "%s\n", __func__);
-	return &context->stats;
+	printk(KERN_INFO "%s\n", __func__);
+	return &g_usbnet_context->stats;
 }
 
 static void usbnet_if_config(struct work_struct *work)
@@ -337,51 +316,57 @@ static void usbnet_if_config(struct work_struct *work)
 	mm_segment_t saved_fs;
 	unsigned err;
 	struct sockaddr_in *sin;
-	struct usbnet_context *context = container_of(work,
-				 struct usbnet_context, usbnet_config_wq);
 
 	memset(&ifr, 0, sizeof(ifr));
 	sin = (void *) &(ifr.ifr_ifru.ifru_addr);
-	strncpy(ifr.ifr_ifrn.ifrn_name, context->dev->name,
-		sizeof(ifr.ifr_ifrn.ifrn_name));
+	strncpy(ifr.ifr_ifrn.ifrn_name, "usb0", strlen("usb0") + 1);
 	sin->sin_family = AF_INET;
 
-	sin->sin_addr.s_addr = context->ip_addr;
+	sin->sin_addr.s_addr = g_usbnet_ifc.ip_addr;
 	saved_fs = get_fs();
 	set_fs(get_ds());
-	err = devinet_ioctl(dev_net(context->dev), SIOCSIFADDR, &ifr);
-	if (err)
-		USBNETDBG(context, "%s: Error in SIOCSIFADDR\n", __func__);
+	err = devinet_ioctl(dev_net(g_usbnet_ifc.usbnet_config_dev),
+			  SIOCSIFADDR, &ifr);
 
-	sin->sin_addr.s_addr = context->subnet_mask;
-	err = devinet_ioctl(dev_net(context->dev), SIOCSIFNETMASK, &ifr);
-	if (err)
-		USBNETDBG(context, "%s: Error in SIOCSIFNETMASK\n", __func__);
+	sin->sin_addr.s_addr = g_usbnet_ifc.subnet_mask;
+	err = devinet_ioctl(dev_net(g_usbnet_ifc.usbnet_config_dev),
+			  SIOCSIFNETMASK, &ifr);
 
-	sin->sin_addr.s_addr = context->ip_addr | ~(context->subnet_mask);
-	err = devinet_ioctl(dev_net(context->dev), SIOCSIFBRDADDR, &ifr);
-	if (err)
-		USBNETDBG(context, "%s: Error in SIOCSIFBRDADDR\n", __func__);
+	sin->sin_addr.s_addr =
+	    g_usbnet_ifc.ip_addr | ~(g_usbnet_ifc.subnet_mask);
+	err = devinet_ioctl(dev_net(g_usbnet_ifc.usbnet_config_dev),
+			  SIOCSIFBRDADDR, &ifr);
 
 	memset(&ifr, 0, sizeof(ifr));
-	strncpy(ifr.ifr_ifrn.ifrn_name, context->dev->name,
-		sizeof(ifr.ifr_ifrn.ifrn_name));
-	ifr.ifr_flags = ((context->dev->flags) | context->iff_flag);
-	err = devinet_ioctl(dev_net(context->dev), SIOCSIFFLAGS, &ifr);
-	if (err)
-		USBNETDBG(context, "%s: Error in SIOCSIFFLAGS\n", __func__);
+	strncpy(ifr.ifr_ifrn.ifrn_name, "usb0", strlen("usb0") + 1);
+	if (g_usbnet_ifc.iff_flag & IFF_UP)
+		ifr.ifr_flags = ((g_usbnet_ifc.usbnet_config_dev->flags) |
+			g_usbnet_ifc.iff_flag);
+	else
+		ifr.ifr_flags = (g_usbnet_ifc.usbnet_config_dev->flags)&
+			~IFF_UP;
+
+	err = devinet_ioctl(dev_net(g_usbnet_ifc.usbnet_config_dev),
+			  SIOCSIFFLAGS, &ifr);
 
 	set_fs(saved_fs);
+
+	if (g_usbnet_ifc.iff_flag == IFF_UP)
+		usb_interface_enum_cb(ETH_TYPE_FLAG);
+	else {
+		g_usbnet_ifc.subnet_mask = 0;
+		g_usbnet_ifc.router_ip   = 0;
+	}
 }
 
 static void __init usb_ether_setup(struct net_device *dev)
 {
-	struct usbnet_context *context = netdev_priv(dev);
-	INIT_LIST_HEAD(&context->rx_reqs);
-	INIT_LIST_HEAD(&context->tx_reqs);
+	g_usbnet_context = netdev_priv(dev);
+	INIT_LIST_HEAD(&g_usbnet_context->rx_reqs);
+	INIT_LIST_HEAD(&g_usbnet_context->tx_reqs);
 
-	spin_lock_init(&context->lock);
-	context->dev = dev;
+	spin_lock_init(&g_usbnet_context->lock);
+	g_usbnet_context->dev = dev;
 
 	dev->open = usb_ether_open;
 	dev->stop = usb_ether_stop;
@@ -395,13 +380,13 @@ static void __init usb_ether_setup(struct net_device *dev)
 }
 
 /*-------------------------------------------------------------------------*/
-static void usbnet_cleanup(struct usbnet_device *dev)
+static void usbnet_cleanup(void)
 {
-	struct usbnet_context *context = dev->net_ctxt;
-	if (context) {
-		unregister_netdev(context->dev);
-		free_netdev(context->dev);
-		dev->net_ctxt = NULL;
+	if (g_net_dev) {
+		unregister_netdev(g_net_dev);
+		free_netdev(g_net_dev);
+		g_net_dev = NULL;
+		g_usbnet_context = NULL;
 	}
 }
 
@@ -409,56 +394,77 @@ static void usbnet_unbind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct usbnet_device *dev = func_to_dev(f);
 	struct usb_composite_dev *cdev = c->cdev;
-	struct usbnet_context *context = dev->net_ctxt;
 	struct usb_request *req;
+	unsigned long flags;
 
 	dev->cdev = cdev;
 
-	usb_ep_disable(context->bulk_in);
-	usb_ep_disable(context->bulk_out);
+	/* Free EP0 Request */
+	usb_ep_disable(g_usbnet_context->bulk_in);
+	usb_ep_disable(g_usbnet_context->bulk_out);
+	usb_ep_disable(g_usbnet_context->intr_out);
 
 	/* Free BULK OUT Requests */
-	while ((req = usb_get_recv_request(context)))
-		usb_ep_free_request(context->bulk_out, req);
+	for (;;) {
+		spin_lock_irqsave(&g_usbnet_context->lock, flags);
+		if (list_empty(&g_usbnet_context->rx_reqs)) {
+			break;
+		} else {
+			req = list_first_entry(&g_usbnet_context->rx_reqs,
+					       struct usb_request, list);
+			list_del(&req->list);
+		}
+		spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
+		if (!req)
+			usb_ep_free_request(g_usbnet_context->bulk_out, req);
+	}
 
 	/* Free BULK IN Requests */
-	while ((req = usb_get_xmit_request(DO_NOT_STOP_QUEUE,
-					  context->dev))) {
-		usb_ep_free_request(context->bulk_in, req);
+	for (;;) {
+		spin_lock_irqsave(&g_usbnet_context->lock, flags);
+		if (list_empty(&g_usbnet_context->tx_reqs)) {
+			break;
+		} else {
+			req = list_first_entry(&g_usbnet_context->tx_reqs,
+					       struct usb_request, list);
+			list_del(&req->list);
+		}
+		spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
+		if (!req)
+			usb_ep_free_request(g_usbnet_context->bulk_in, req);
 	}
 
-	context->config = 0;
+	g_usbnet_context->config = 0;
 
-	usbnet_cleanup(dev);
+	usbnet_cleanup();
 }
 
 static void ether_out_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct sk_buff *skb = req->context;
-	struct usbnet_context *context = ep->driver_data;
 
 	if (req->status == 0) {
 		dmac_inv_range((void *)req->buf, (void *)(req->buf +
 					req->actual));
 		skb_put(skb, req->actual);
-		skb->protocol = eth_type_trans(skb, context->dev);
-		context->stats.rx_packets++;
-		context->stats.rx_bytes += req->actual;
+		skb->protocol = eth_type_trans(skb, g_usbnet_context->dev);
+		g_usbnet_context->stats.rx_packets++;
+		g_usbnet_context->stats.rx_bytes += req->actual;
 		netif_rx(skb);
 	} else {
 		dev_kfree_skb_any(skb);
-		context->stats.rx_errors++;
+		g_usbnet_context->stats.rx_errors++;
 	}
 
 	/* don't bother requeuing if we just went offline */
 	if ((req->status == -ENODEV) || (req->status == -ESHUTDOWN)) {
 		unsigned long flags;
-		spin_lock_irqsave(&context->lock, flags);
-		list_add_tail(&req->list, &context->rx_reqs);
-		spin_unlock_irqrestore(&context->lock, flags);
+		spin_lock_irqsave(&g_usbnet_context->lock, flags);
+		list_add_tail(&req->list, &g_usbnet_context->rx_reqs);
+		spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
 	} else {
-		if (ether_queue_out(req, context))
-			USBNETDBG(context, "ether_out: cannot requeue\n");
+		if (ether_queue_out(req))
+			printk(KERN_INFO "ether_out: cannot requeue\n");
 	}
 }
 
@@ -466,23 +472,22 @@ static void ether_in_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	unsigned long flags;
 	struct sk_buff *skb = req->context;
-	struct usbnet_context *context = ep->driver_data;
 
 	if (req->status == 0) {
-		context->stats.tx_packets++;
-		context->stats.tx_bytes += req->actual;
+		g_usbnet_context->stats.tx_packets++;
+		g_usbnet_context->stats.tx_bytes += req->actual;
 	} else {
-		context->stats.tx_errors++;
+		g_usbnet_context->stats.tx_errors++;
 	}
 
 	dev_kfree_skb_any(skb);
 
-	spin_lock_irqsave(&context->lock, flags);
-	if (list_empty(&context->tx_reqs))
-		netif_start_queue(context->dev);
+	spin_lock_irqsave(&g_usbnet_context->lock, flags);
+	if (list_empty(&g_usbnet_context->tx_reqs))
+		netif_start_queue(g_usbnet_context->dev);
 
-	list_add_tail(&req->list, &context->tx_reqs);
-	spin_unlock_irqrestore(&context->lock, flags);
+	list_add_tail(&req->list, &g_usbnet_context->tx_reqs);
+	spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
 }
 
 static int __init usbnet_bind(struct usb_configuration *c,
@@ -490,7 +495,6 @@ static int __init usbnet_bind(struct usb_configuration *c,
 {
 	struct usb_composite_dev *cdev = c->cdev;
 	struct usbnet_device  *dev = func_to_dev(f);
-	struct usbnet_context *context = dev->net_ctxt;
 	int n, rc, id;
 	struct usb_ep *ep;
 	struct usb_request *req;
@@ -502,36 +506,36 @@ static int __init usbnet_bind(struct usb_configuration *c,
 	if (id < 0)
 		return id;
 	intf_desc.bInterfaceNumber = id;
-	context->gadget = cdev->gadget;
+	g_usbnet_context->gadget = cdev->gadget;
 
-	/* Find all the endpoints we will use */
+	/* config EPs */
 	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_in_desc);
 	if (!ep) {
-		USBNETDBG(context, "%s auto-configure hs_bulk_in_desc error\n",
+		printk(KERN_INFO "%s auto-configure hs_bulk_in_desc error\n",
 			__func__);
 		goto autoconf_fail;
 	}
-	ep->driver_data = context;
-	context->bulk_in = ep;
+	ep->driver_data = g_usbnet_context;
+	g_usbnet_context->bulk_in = ep;
 
 	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_out_desc);
 	if (!ep) {
-		USBNETDBG(context, "%s auto-configure hs_bulk_out_desc error\n",
-			__func__);
+		printk(KERN_INFO "%s auto-configure hs_bulk_out_desc error\n",
+		      __func__);
 		goto autoconf_fail;
 	}
-	ep->driver_data = context;
-	context->bulk_out = ep;
-
+	ep->driver_data = g_usbnet_context;
+	g_usbnet_context->bulk_out = ep;
 
 	ep = usb_ep_autoconfig(cdev->gadget, &fs_intr_out_desc);
 	if (!ep) {
-		USBNETDBG(context, "%s auto-configure hs_intr_out_desc error\n",
+		printk(KERN_INFO "%s auto-configure hs_intr_out_desc error\n",
 		      __func__);
 		goto autoconf_fail;
 	}
-	ep->driver_data = context;
-	context->intr_out = ep;
+	ep->driver_data = g_usbnet_context;
+	g_usbnet_context->intr_out = ep;
+
 
 	if (gadget_is_dualspeed(cdev->gadget)) {
 
@@ -547,122 +551,135 @@ static int __init usbnet_bind(struct usb_configuration *c,
 
 	rc = -ENOMEM;
 
+	/* Allocate the request and buffer for endpoint 0 */
 	for (n = 0; n < MAX_BULK_RX_REQ_NUM; n++) {
-		req = usb_ep_alloc_request(context->bulk_out,
+		req = usb_ep_alloc_request(g_usbnet_context->bulk_out,
 					 GFP_KERNEL);
 		if (!req) {
-			USBNETDBG(context, "%s: alloc request bulk_out fail\n",
+			printk(KERN_INFO "%s: alloc request bulk_out fail\n",
 				__func__);
 			break;
 		}
 		req->complete = ether_out_complete;
-		spin_lock_irqsave(&context->lock, flags);
-		list_add_tail(&req->list, &context->rx_reqs);
-		spin_unlock_irqrestore(&context->lock, flags);
+		spin_lock_irqsave(&g_usbnet_context->lock, flags);
+		list_add_tail(&req->list, &g_usbnet_context->rx_reqs);
+		spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
 	}
 	for (n = 0; n < MAX_BULK_TX_REQ_NUM; n++) {
-		req = usb_ep_alloc_request(context->bulk_in,
+		req = usb_ep_alloc_request(g_usbnet_context->bulk_in,
 					 GFP_KERNEL);
 		if (!req) {
-			USBNETDBG(context, "%s: alloc request bulk_in fail\n",
+			printk(KERN_INFO "%s: alloc request bulk_in fail\n",
 				__func__);
 			break;
 		}
 		req->complete = ether_in_complete;
-		spin_lock_irqsave(&context->lock, flags);
-		list_add_tail(&req->list, &context->tx_reqs);
-		spin_unlock_irqrestore(&context->lock, flags);
+		spin_lock_irqsave(&g_usbnet_context->lock, flags);
+		list_add_tail(&req->list, &g_usbnet_context->tx_reqs);
+		spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
 	}
 
+	usb_gadget_set_selfpowered(cdev->gadget);
 	return 0;
 
 autoconf_fail:
 	rc = -ENOTSUPP;
+
 	usbnet_unbind(c, f);
 	return rc;
 }
 
-
-
-
-static void do_set_config(struct usb_function *f, u16 new_config)
+static void do_set_config(u16 new_config)
 {
-	struct usbnet_device  *dev = func_to_dev(f);
-	struct usbnet_context *context = dev->net_ctxt;
 	int result = 0;
+	unsigned long flags;
 	struct usb_request *req;
 	int high_speed_flag = 0;
 
-	if (context->config == new_config) /* Config did not change */
+	if (g_usbnet_context->config == new_config) /* Config did not change */
 		return;
 
-	context->config = new_config;
+	g_usbnet_context->config = new_config;
 
 	if (new_config == 1) { /* Enable End points */
-		if (gadget_is_dualspeed(context->gadget)
-		    && context->gadget->speed == USB_SPEED_HIGH)
+		if (gadget_is_dualspeed(g_usbnet_context->gadget)
+		    && g_usbnet_context->gadget->speed == USB_SPEED_HIGH)
 			high_speed_flag = 1;
 
 		if (high_speed_flag)
-			result = usb_ep_enable(context->bulk_in,
+			result = usb_ep_enable(g_usbnet_context->bulk_in,
 					  &hs_bulk_in_desc);
 		else
-			result = usb_ep_enable(context->bulk_in,
+			result = usb_ep_enable(g_usbnet_context->bulk_in,
 					  &fs_bulk_in_desc);
 
 		if (result != 0) {
-			USBNETDBG(context,
-				  "%s:  failed to enable BULK_IN EP ret=%d\n",
-				  __func__, result);
+			printk(KERN_INFO "%s:  failed to enable BULK_IN EP ret=%d\n",
+			      __func__, result);
 		}
 
-		context->bulk_in->driver_data = context;
-
 		if (high_speed_flag)
-			result = usb_ep_enable(context->bulk_out,
+			result = usb_ep_enable(g_usbnet_context->bulk_out,
 					  &hs_bulk_out_desc);
 		else
-			result = usb_ep_enable(context->bulk_out,
-					&fs_bulk_out_desc);
+			result = usb_ep_enable(g_usbnet_context->bulk_out,
+				  &fs_bulk_out_desc);
 
 		if (result != 0) {
-			USBNETDBG(context,
-				  "%s: failed to enable BULK_OUT EP ret = %d\n",
-				  __func__, result);
+			printk(KERN_INFO "%s:  failed to enable BULK_OUT EP ret = %d\n",
+			      __func__, result);
 		}
 
-		context->bulk_out->driver_data = context;
-
 		if (high_speed_flag)
-			result = usb_ep_enable(context->intr_out,
-						&hs_intr_out_desc);
+			result = usb_ep_enable(g_usbnet_context->intr_out,
+					&hs_intr_out_desc);
 		else
-		result = usb_ep_enable(context->intr_out,
+			result = usb_ep_enable(g_usbnet_context->intr_out,
 					&fs_intr_out_desc);
 
 		if (result != 0) {
-			USBNETDBG(context,
-				"%s: failed to enable INTR_OUT EP ret = %d\n",
+			printk(KERN_INFO "%s: failed to enable INTR_OUT EP ret = %d\n",
 				__func__, result);
 		}
 
-		context->intr_out->driver_data = context;
+
+
 
 		/* we're online -- get all rx requests queued */
-		while ((req = usb_get_recv_request(context))) {
-			if (ether_queue_out(req, context)) {
-				USBNETDBG(context,
-					  "%s: ether_queue_out failed\n",
-					  __func__);
+		for (;;) {
+			spin_lock_irqsave(&g_usbnet_context->lock, flags);
+			if (list_empty(&g_usbnet_context->rx_reqs)) {
+				req = 0;
+			} else {
+				req = list_first_entry(
+						&g_usbnet_context->rx_reqs,
+						struct usb_request, list);
+				list_del(&req->list);
+			}
+			spin_unlock_irqrestore(&g_usbnet_context->lock, flags);
+			if (!req)
+				break;
+			if (ether_queue_out(req)) {
+				printk(KERN_INFO "%s: ether_queue_out failed\n",
+					__func__);
 				break;
 			}
 		}
+		netif_start_queue(g_net_dev);
 
-	} else {/* Disable Endpoints */
-		if (context->bulk_in)
-			usb_ep_disable(context->bulk_in);
-		if (context->bulk_out)
-			usb_ep_disable(context->bulk_out);
+	} else {
+		netif_stop_queue(g_net_dev);
+		g_usbnet_ifc.ip_addr = 0;
+		g_usbnet_ifc.iff_flag = 0;
+		g_usbnet_ifc.usbnet_config_dev = g_usbnet_context->dev;
+		schedule_work(&g_usbnet_ifc.usbnet_config_wq);
+		/* Disable Endpoints */
+		if (g_usbnet_context->bulk_in)
+			usb_ep_disable(g_usbnet_context->bulk_in);
+		if (g_usbnet_context->bulk_out)
+			usb_ep_disable(g_usbnet_context->bulk_out);
+		if (g_usbnet_context->intr_out)
+			usb_ep_disable(g_usbnet_context->intr_out);
 	}
 }
 
@@ -670,10 +687,8 @@ static void do_set_config(struct usb_function *f, u16 new_config)
 static int usbnet_set_alt(struct usb_function *f,
 		unsigned intf, unsigned alt)
 {
-	struct usbnet_device  *dev = func_to_dev(f);
-	struct usbnet_context *context = dev->net_ctxt;
-	USBNETDBG(context, "usbnet_set_alt intf: %d alt: %d\n", intf, alt);
-	do_set_config(f, 1);
+	printk(KERN_INFO "usbnet_set_alt intf: %d alt: %d\n", intf, alt);
+	do_set_config(1);
 	return 0;
 }
 
@@ -681,39 +696,38 @@ static int usbnet_setup(struct usb_function *f,
 			const struct usb_ctrlrequest *ctrl)
 {
 
-	struct usbnet_device  *dev = func_to_dev(f);
-	struct usbnet_context *context = dev->net_ctxt;
 	int rc = -EOPNOTSUPP;
 	int wIndex = le16_to_cpu(ctrl->wIndex);
 	int wValue = le16_to_cpu(ctrl->wValue);
-	int wLength = le16_to_cpu(ctrl->wLength);
+	u16 wLength = le16_to_cpu(ctrl->wLength);
 	struct usb_composite_dev *cdev = f->config->cdev;
-	struct usb_request      *req = cdev->req;
+	struct usb_request	*req = cdev->req;
 
 	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_VENDOR) {
 		switch (ctrl->bRequest) {
 		case USBNET_SET_IP_ADDRESS:
-			context->ip_addr = (wValue << 16) | wIndex;
+			g_usbnet_ifc.ip_addr = (wValue << 16) | wIndex;
 			rc = 0;
 			break;
 		case USBNET_SET_SUBNET_MASK:
-			context->subnet_mask = (wValue << 16) | wIndex;
+			g_usbnet_ifc.subnet_mask = (wValue << 16) | wIndex;
 			rc = 0;
 			break;
 		case USBNET_SET_HOST_IP:
-			context->router_ip = (wValue << 16) | wIndex;
+			g_usbnet_ifc.router_ip = (wValue << 16) | wIndex;
 			rc = 0;
 			break;
 		default:
 			break;
 		}
 
-		if (context->ip_addr && context->subnet_mask
-		    && context->router_ip) {
-			context->iff_flag = IFF_UP;
+		if (g_usbnet_ifc.ip_addr && g_usbnet_ifc.subnet_mask
+		    && g_usbnet_ifc.router_ip) {
 			/* schedule a work queue to do this because we
 				 need to be able to sleep */
-			schedule_work(&context->usbnet_config_wq);
+			g_usbnet_ifc.usbnet_config_dev = g_usbnet_context->dev;
+			g_usbnet_ifc.iff_flag = IFF_UP;
+			schedule_work(&g_usbnet_ifc.usbnet_config_wq);
 		}
 	}
 
@@ -723,7 +737,7 @@ static int usbnet_setup(struct usb_function *f,
 		req->length = rc;
 		rc = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
 		if (rc < 0)
-			USBNETDBG(context, "usbnet setup response error\n");
+			printk(KERN_INFO "usbnet setup response error\n");
 	}
 
 	return rc;
@@ -731,24 +745,18 @@ static int usbnet_setup(struct usb_function *f,
 
 static void usbnet_disable(struct usb_function *f)
 {
-	struct usbnet_device  *dev = func_to_dev(f);
-	struct usbnet_context *context = dev->net_ctxt;
-	USBNETDBG(context, "%s\n", __func__);
-	do_set_config(f, 0);
+	printk(KERN_INFO "%s\n", __func__);
+	do_set_config(0);
 }
 
 static void usbnet_suspend(struct usb_function *f)
 {
-	struct usbnet_device  *dev = func_to_dev(f);
-	struct usbnet_context *context = dev->net_ctxt;
-	USBNETDBG(context, "%s\n", __func__);
+	printk(KERN_INFO "%s\n", __func__);
 }
 
 static void usbnet_resume(struct usb_function *f)
 {
-	struct usbnet_device  *dev = func_to_dev(f);
-	struct usbnet_context *context = dev->net_ctxt;
-	USBNETDBG(context, "%s\n", __func__);
+	printk(KERN_INFO "%s\n", __func__);
 }
 
 
@@ -756,44 +764,48 @@ int __init usbnet_function_add(struct usb_composite_dev *cdev,
 		struct usb_configuration *c)
 {
 	struct usbnet_device *dev;
-	struct usbnet_context *context;
-	struct net_device *net_dev;
 	int ret, status;
 
-	pr_debug("usbnet_function_add\n");
+	printk(KERN_INFO "usbnet_function_add\n");
 
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev)
-		return -ENOMEM;
+	status = usb_string_id(c->cdev);
+	if (status >= 0) {
+		usbnet_string_defs[STRING_INTERFACE].id = status;
+		intf_desc.iInterface = status;
+	}
 
-	net_dev = alloc_netdev(sizeof(struct usbnet_context),
+	g_net_dev = alloc_netdev(sizeof(struct usbnet_context),
 			   "usb%d", usb_ether_setup);
-	if (!net_dev) {
-		pr_err("%s: alloc_netdev error\n", __func__);
+	if (!g_net_dev) {
+		printk(KERN_INFO "%s: alloc_netdev error\n", __func__);
 		return -EINVAL;
 	}
 
-	ret = register_netdev(net_dev);
+	ret = register_netdev(g_net_dev);
 	if (ret) {
-		pr_err("%s: register_netdev error\n", __func__);
-		free_netdev(net_dev);
+		printk(KERN_INFO "%s: register_netdev error\n", __func__);
+		free_netdev(g_net_dev);
 		return -EINVAL;
+	} else {
+		INIT_WORK(&g_usbnet_ifc.usbnet_config_wq, usbnet_if_config);
+		g_usbnet_context = netdev_priv(g_net_dev);
 	}
-	context = netdev_priv(net_dev);
-	INIT_WORK(&context->usbnet_config_wq, usbnet_if_config);
 
-	status = usb_string_id(c->cdev);
-	if (status >= 0) {
-		usbnet_string_defs[STRING_INTERFACE].id = status;
-		intf_desc.iInterface = status;
-	}
+	g_usbnet_context->config = 0;
 
-	context->config = 0;
-	dev->net_ctxt = context;
+	dev = &g_usbnet_device;
+	dev->net_ctxt = g_usbnet_context;
 	dev->cdev = cdev;
 	dev->function.name = "usbnet";
+
+#ifdef CONFIG_USB_MOT_ANDROID
+	dev->function.descriptors = null_function;
+	dev->function.hs_descriptors = null_function;
+#else
 	dev->function.descriptors = fs_function;
 	dev->function.hs_descriptors = hs_function;
+#endif
+	dev->function.strings = usbnet_strings;
 	dev->function.bind = usbnet_bind;
 	dev->function.unbind = usbnet_unbind;
 	dev->function.set_alt = usbnet_set_alt;
@@ -801,9 +813,6 @@ int __init usbnet_function_add(struct usb_composite_dev *cdev,
 	dev->function.setup = usbnet_setup;
 	dev->function.suspend = usbnet_suspend;
 	dev->function.resume = usbnet_resume;
-	dev->function.strings = usbnet_strings;
-
-
 
 	ret = usb_add_function(c, &dev->function);
 	if (ret)
@@ -812,8 +821,27 @@ int __init usbnet_function_add(struct usb_composite_dev *cdev,
 	return 0;
 
 err1:
-	kfree(dev);
-	pr_err("usbnet gadget driver failed to initialize\n");
-	usbnet_cleanup(dev);
+	printk(KERN_ERR "usbnet gadget driver failed to initialize\n");
+	usbnet_cleanup();
 	return ret;
 }
+
+#ifdef CONFIG_USB_MOT_ANDROID
+struct usb_function *usbnet_function_enable(int enable, int id)
+{
+	printk(KERN_DEBUG "%s enable=%d id = %d\n", __func__, enable, id);
+	if (g_usbnet_context) {
+		if (enable) {
+			g_usbnet_device.function.descriptors = fs_function;
+			g_usbnet_device.function.hs_descriptors = hs_function;
+			intf_desc.bInterfaceNumber = id;
+		} else {
+			g_usbnet_device.function.descriptors = null_function;
+			g_usbnet_device.function.hs_descriptors = null_function;
+		}
+		return &g_usbnet_device.function;
+	}
+	return NULL;
+}
+#endif
+
diff --git a/drivers/usb/gadget/f_usbnet.h b/drivers/usb/gadget/f_usbnet.h
index 15304b2..bc1544d 100644
--- a/drivers/usb/gadget/f_usbnet.h
+++ b/drivers/usb/gadget/f_usbnet.h
@@ -1,7 +1,8 @@
 /*
  * Gadget Driver for Android USBNET
  *
- * Copyright (C) 2009 Motorola, Inc.
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -20,4 +21,6 @@
 int usbnet_function_add(struct usb_composite_dev *cdev,
 	struct usb_configuration *c);
 
+struct usb_function *usbnet_function_enable(int enable, int id);
+
 #endif /* __F_USBNET_H */
diff --git a/drivers/usb/gadget/mot_android.c b/drivers/usb/gadget/mot_android.c
new file mode 100644
index 0000000..0a07e1f
--- /dev/null
+++ b/drivers/usb/gadget/mot_android.c
@@ -0,0 +1,855 @@
+/*
+ * Gadget Driver for Android
+ *
+ * Copyright (C) 2008 Google, Inc.
+ * Author: Mike Lockwood <lockwood@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/device.h>
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/utsname.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+
+#include <linux/usb/android.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/composite.h>
+#include <linux/usb/gadget.h>
+#include <linux/io.h>
+
+#include "f_mass_storage.h"
+#include "f_adb.h"
+#include "f_usbnet.h"
+#include "f_acm.h"
+#include "f_mtp.h"
+#include "f_mot_android.h"
+#include "u_serial.h"
+
+#include "gadget_chips.h"
+
+/*
+ * Kbuild is not very cooperative with respect to linking separately
+ * compiled library objects into one module.  So for now we won't use
+ * separate compilation ... ensuring init/exit sections work to shrink
+ * the runtime footprint, and giving us at least some parts of what
+ * a "gcc --combine ... part1.c part2.c part3.c ... " build would.
+ */
+#include "usbstring.c"
+#include "config.c"
+#include "epautoconf.c"
+#include "composite.c"
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("Motorola Android Composite USB Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+
+static const char longname[] = "Gadget Android";
+
+static DECLARE_WAIT_QUEUE_HEAD(device_mode_change_wait_q);
+
+/* Default vendor and product IDs, overridden by platform data */
+#define VENDOR_ID		0x22b8
+#define PRODUCT_ID		0x41da
+#define ADB_PRODUCT_ID		0x41da
+
+struct device_pid_vid {
+	char *name;
+	u32 type;
+	int vid;
+	int pid;
+	char *config_name;
+	int class;
+	int subclass;
+	int protocol;
+};
+
+#define MAX_DEVICE_TYPE_NUM   20
+#define MAX_DEVICE_NAME_SIZE  30
+static struct device_pid_vid mot_android_vid_pid[MAX_DEVICE_TYPE_NUM] = {
+	{"msc", MSC_TYPE_FLAG, 0x22b8, 0x41d9, "Motorola Config 14",
+	 USB_CLASS_PER_INTERFACE, USB_CLASS_PER_INTERFACE,
+	 USB_CLASS_PER_INTERFACE},
+	{"cdrom", CDROM_TYPE_FLAG, 0x22b8, 0x41de, "Motorola CDROM Device",
+	 USB_CLASS_PER_INTERFACE, USB_CLASS_PER_INTERFACE,
+	 USB_CLASS_PER_INTERFACE},
+	{"msc_adb", MSC_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8, 0x41db,
+	 "Motorola Config 42", USB_CLASS_PER_INTERFACE,
+	 USB_CLASS_PER_INTERFACE, USB_CLASS_PER_INTERFACE},
+	{"eth", ETH_TYPE_FLAG, 0x22b8, 0x41d4, "Motorola Config 13",
+	 USB_CLASS_COMM, USB_CLASS_COMM, USB_CLASS_PER_INTERFACE},
+	{"mtp", MTP_TYPE_FLAG, 0x22b8, 0x41D6, "Motorola Config 15",
+	 USB_CLASS_PER_INTERFACE,
+	 USB_CLASS_PER_INTERFACE, USB_CLASS_PER_INTERFACE},
+	{"acm", ACM_TYPE_FLAG, 0x22b8, 0x6422, "Motorola Config 1",
+	 USB_CLASS_COMM, USB_CLASS_COMM, USB_CLASS_PER_INTERFACE},
+	{"eth_adb", ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8, 0x41d4,
+	 "Motorola Android Composite Device"},
+	/* remove MTP_TYPE_FLAG here to disable mtp function driver */
+	{"acm_eth_mtp", ACM_TYPE_FLAG | ETH_TYPE_FLAG, 0x22b8,
+	 0x41d8, "Motorola Config 30", USB_CLASS_VENDOR_SPEC,
+	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
+	{"mtp_adb", MTP_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8, 0x41dc,
+	 "Motorola Config 32", USB_CLASS_VENDOR_SPEC,
+	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
+	{"acm_eth_mtp_adb",
+	/* remove MTP_TYPE_FLAG here to disable mtp function driver */
+	 ACM_TYPE_FLAG | ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
+	 0x41da, "Motorola Config 31", USB_CLASS_VENDOR_SPEC,
+	 USB_CLASS_VENDOR_SPEC, USB_CLASS_VENDOR_SPEC},
+	{"acm_eth_adb", ACM_TYPE_FLAG | ETH_TYPE_FLAG | ADB_TYPE_FLAG, 0x22b8,
+	 0x41e2, "Motorola Android Composite Device"},
+	{"msc_eth", MSC_TYPE_FLAG | ETH_TYPE_FLAG, 0x22b8, 0x41d4,
+	 "Motorola Android Composite Device"},
+	{"msc_adb_eth", MSC_TYPE_FLAG | ADB_TYPE_FLAG | ETH_TYPE_FLAG, 0x22b8,
+	 0x41d4, "Motorola Android Composite Device"},
+	{}
+};
+
+static int g_device_type;
+static atomic_t device_mode_change_excl;
+
+struct android_dev {
+	struct usb_gadget *gadget;
+	struct usb_composite_dev *cdev;
+
+	int product_id;
+	int adb_product_id;
+	int version;
+
+	int nluns;
+};
+
+static atomic_t adb_enable_excl;
+static struct android_dev *_android_dev;
+
+/* string IDs are assigned dynamically */
+
+#define STRING_MANUFACTURER_IDX		0
+#define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
+#define STRING_CONFIG_IDX		3
+
+/* String Table */
+static struct usb_string strings_dev[] = {
+	/* These dummy values should be overridden by platform data */
+	[STRING_MANUFACTURER_IDX].s = "Android",
+	[STRING_PRODUCT_IDX].s = "Android",
+	[STRING_SERIAL_IDX].s = "0123456789ABCDEF",
+	[STRING_CONFIG_IDX].s = "Motorola Android Composite Device",
+	{}			/* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language = 0x0409,	/* en-us */
+	.strings = strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_device_descriptor device_desc = {
+	.bLength = sizeof(device_desc),
+	.bDescriptorType = USB_DT_DEVICE,
+	.bcdUSB = __constant_cpu_to_le16(0x0200),
+	.bDeviceClass = USB_CLASS_VENDOR_SPEC,
+	.bDeviceSubClass = USB_CLASS_VENDOR_SPEC,
+	.bDeviceProtocol = USB_CLASS_VENDOR_SPEC,
+	.idVendor = __constant_cpu_to_le16(VENDOR_ID),
+	.idProduct = __constant_cpu_to_le16(PRODUCT_ID),
+	.bcdDevice = __constant_cpu_to_le16(0xffff),
+	.bNumConfigurations = 1,
+};
+
+void android_usb_set_connected(int connected)
+{
+	if (_android_dev && _android_dev->cdev && _android_dev->cdev->gadget) {
+		printk(KERN_INFO "USB Driver - Notification from CPCAP for %s \n",
+			 connected ? "attach" : "detach");
+		/*Disconnect so that USBD can control the connection */
+		if (connected)
+			usb_gadget_disconnect(_android_dev->cdev->gadget);
+	}
+}
+
+static int __init android_bind_config(struct usb_configuration *c)
+{
+	struct android_dev *dev = _android_dev;
+	int ret;
+
+	/* the same sequence as force_reenumeration() */
+	ret = mass_storage_function_add(dev->cdev, c, dev->nluns);
+	if (ret)
+		return ret;
+	ret = acm_function_add(dev->cdev, c);
+	if (ret)
+		return ret;
+	ret = usbnet_function_add(dev->cdev, c);
+	if (ret)
+		return ret;
+	ret = mtp_function_add(dev->cdev, c);
+	if (ret)
+		return ret;
+	ret = adb_function_add(dev->cdev, c);
+
+	return ret;
+}
+
+static int android_setup_config(struct usb_configuration *c,
+				const struct usb_ctrlrequest *ctrl);
+static int usb_device_cfg_flag;
+static int usb_get_desc_flag;
+static int usb_data_transfer_flag;
+
+static struct usb_configuration android_config_driver = {
+	.label = "android",
+	.bind = android_bind_config,
+	.setup = android_setup_config,
+	.bConfigurationValue = 1,
+	.bmAttributes = USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+	.bMaxPower = 0xFA,	/* 500ma */
+};
+
+int get_func_thru_config(int mode)
+{
+	int i;
+	char name[50];
+
+	memset(name, 0, 50);
+	sprintf(name, "Motorola Config %d", mode);
+	for (i = 0; i < MAX_DEVICE_TYPE_NUM; i++) {
+		if (!mot_android_vid_pid[i].config_name)
+			break;
+		if (!strcmp(mot_android_vid_pid[i].config_name, name))
+			return i;
+	}
+	return -1;
+}
+
+static int pc_mode_switch_flag;
+
+void mode_switch_cb(int mode)
+{
+	pc_mode_switch_flag = mode;
+	wake_up_interruptible(&device_mode_change_wait_q);
+}
+
+static int android_generic_setup(struct usb_configuration *c,
+				const struct usb_ctrlrequest *ctrl)
+{
+	int	value = -EOPNOTSUPP;
+	u16     wIndex = le16_to_cpu(ctrl->wIndex);
+	u16     wValue = le16_to_cpu(ctrl->wValue);
+	u16     wLength = le16_to_cpu(ctrl->wLength);
+	struct usb_composite_dev *cdev = c->cdev;
+	struct usb_request	*req = cdev->req;
+
+	switch (ctrl->bRequestType & USB_TYPE_MASK) {
+	case USB_TYPE_VENDOR:
+		switch (ctrl->bRequest) {
+		case 1:
+			if ((wValue == 0) && (wLength == 0)) {
+				mode_switch_cb(wIndex);
+				value = 0;
+				req->zero = 0;
+				req->length = value;
+				if (usb_ep_queue(cdev->gadget->ep0, req,
+					GFP_ATOMIC))
+					printk(KERN_ERR "ep0 in queue failed\n");
+			}
+		break;
+		default:
+			break;
+		}
+	default:
+		break;
+	}
+	return value;
+}
+
+static int android_setup_config(struct usb_configuration *c,
+				const struct usb_ctrlrequest *ctrl)
+{
+	int i, ret = -EOPNOTSUPP;
+
+	ret = android_generic_setup(c, ctrl);
+	if (ret >= 0)
+		return ret;
+
+	for (i = 0; i < android_config_driver.next_interface_id; i++)
+		if (android_config_driver.interface[i]->setup) {
+			ret =
+			    android_config_driver.interface[i]->
+			    setup(android_config_driver.interface[i], ctrl);
+			if (ret >= 0)
+				return ret;
+		}
+	return ret;
+}
+
+void usb_data_transfer_callback(void)
+{
+	if (usb_data_transfer_flag == 0) {
+		usb_data_transfer_flag = 1;
+		usb_get_desc_flag = 1;
+		wake_up_interruptible(&device_mode_change_wait_q);
+	}
+}
+
+void usb_interface_enum_cb(int flag)
+{
+	usb_device_cfg_flag |= flag;
+	if (usb_device_cfg_flag == g_device_type)
+		wake_up_interruptible(&device_mode_change_wait_q);
+}
+
+static int __init android_bind(struct usb_composite_dev *cdev)
+{
+	struct android_dev *dev = _android_dev;
+	struct usb_gadget *gadget = cdev->gadget;
+	int gcnum;
+	int id;
+	int ret;
+
+	dev->gadget = gadget;
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_MANUFACTURER_IDX].id = id;
+	device_desc.iManufacturer = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_PRODUCT_IDX].id = id;
+	device_desc.iProduct = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_SERIAL_IDX].id = id;
+	device_desc.iSerialNumber = id;
+
+	id = usb_string_id(cdev);
+	if (id < 0)
+		return id;
+	strings_dev[STRING_CONFIG_IDX].id = id;
+	android_config_driver.iConfiguration = id;
+
+
+	/* double check to move this call to f_acm.c??? */
+	gserial_setup(gadget, 1);
+
+	/* register our configuration */
+	ret = usb_add_config(cdev, &android_config_driver);
+	if (ret) {
+		printk(KERN_ERR "usb_add_config failed\n");
+		return ret;
+	}
+
+	gcnum = usb_gadget_controller_number(gadget);
+	if (gcnum >= 0)
+		device_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);
+	else {
+		/* gadget zero is so simple (for now, no altsettings) that
+		 * it SHOULD NOT have problems with bulk-capable hardware.
+		 * so just warn about unrcognized controllers -- don't panic.
+		 *
+		 * things like configuration and altsetting numbering
+		 * can need hardware-specific attention though.
+		 */
+		pr_warning("%s: controller '%s' not recognized\n",
+			   longname, gadget->name);
+		device_desc.bcdDevice = __constant_cpu_to_le16(0x9999);
+	}
+
+	usb_gadget_set_selfpowered(gadget);
+	dev->cdev = cdev;
+
+	return 0;
+}
+
+static struct usb_composite_driver android_usb_driver = {
+	.name = "android_usb",
+	.dev = &device_desc,
+	.strings = dev_strings,
+	.bind = android_bind,
+};
+
+static void get_device_pid_vid(int type, int *pid, int *vid)
+{
+	int i;
+
+	*vid = 0;
+	*pid = 0;
+	for (i = 0; i < MAX_DEVICE_TYPE_NUM; i++) {
+		if (mot_android_vid_pid[i].type == type) {
+			*pid = mot_android_vid_pid[i].pid;
+			*vid = mot_android_vid_pid[i].vid;
+			break;
+		}
+	}
+}
+
+int get_func_thru_type(int type)
+{
+	int i;
+
+	for (i = 0; i < MAX_DEVICE_TYPE_NUM; i++) {
+		if (mot_android_vid_pid[i].type == type)
+			return i;
+	}
+	return -1;
+}
+
+static void force_reenumeration(struct android_dev *dev, int dev_type)
+{
+	int vid, pid, i, temp_enabled;
+	struct usb_function *f;
+
+	/* using other namespace ??? */
+	usb_device_cfg_flag = 0;
+	usb_get_desc_flag   = 0;
+	usb_data_transfer_flag = 0;
+	pc_mode_switch_flag = 0;
+
+	get_device_pid_vid(dev_type, &pid, &vid);
+	device_desc.idProduct = __constant_cpu_to_le16(pid);
+	device_desc.idVendor = __constant_cpu_to_le16(vid);
+
+	for (i = 0; i < MAX_CONFIG_INTERFACES; i++)
+		android_config_driver.interface[i] = 0;
+
+	/* clear all intefaces */
+	android_config_driver.next_interface_id = 0;
+
+	temp_enabled = dev_type & (MSC_TYPE_FLAG | CDROM_TYPE_FLAG);
+	f = msc_function_enable(temp_enabled,
+				android_config_driver.next_interface_id);
+	if (temp_enabled) {
+		android_config_driver.interface[android_config_driver.
+						next_interface_id] = f;
+		android_config_driver.next_interface_id++;
+	}
+
+	temp_enabled = dev_type & ACM_TYPE_FLAG;
+	f = acm_function_enable(temp_enabled,
+				android_config_driver.next_interface_id);
+	if (temp_enabled) {
+		android_config_driver.interface[android_config_driver.
+						next_interface_id] = f;
+		android_config_driver.next_interface_id++;
+		android_config_driver.interface[android_config_driver.
+						next_interface_id] = f;
+		android_config_driver.next_interface_id++;
+	}
+
+	temp_enabled = dev_type & ETH_TYPE_FLAG;
+	f = usbnet_function_enable(temp_enabled,
+				   android_config_driver.next_interface_id);
+	if (temp_enabled) {
+		android_config_driver.interface[android_config_driver.
+						next_interface_id] = f;
+		android_config_driver.next_interface_id++;
+	}
+
+	temp_enabled = dev_type & MTP_TYPE_FLAG;
+	f = mtp_function_enable(temp_enabled,
+				android_config_driver.next_interface_id);
+	if (temp_enabled) {
+		android_config_driver.interface[android_config_driver.
+						next_interface_id] = f;
+		android_config_driver.next_interface_id++;
+	}
+
+	temp_enabled = dev_type & ADB_TYPE_FLAG;
+	f = adb_function_enable_id(temp_enabled,
+	/*			   android_config_driver.next_interface_id);*/
+	/*
+	 * For acm_eth_mtp and acm_eth_mtp_adb modes, mtp is disabled.
+	 * The interface number have to be increased one to match PC driver.
+	 */
+				((dev_type & ACM_TYPE_FLAG) &&
+					(dev_type & ETH_TYPE_FLAG)) ?
+				(android_config_driver.next_interface_id + 1) :
+				android_config_driver.next_interface_id);
+
+	if (temp_enabled) {
+		android_config_driver.interface[android_config_driver.
+						next_interface_id] = f;
+		android_config_driver.next_interface_id++;
+	}
+
+	if (dev->cdev) {
+		dev->cdev->desc.idProduct = device_desc.idProduct;
+		dev->cdev->desc.idVendor = device_desc.idVendor;
+		i = get_func_thru_type(dev_type);
+		if (i != -1) {
+			dev->cdev->desc.bDeviceClass =
+				mot_android_vid_pid[i].class;
+			dev->cdev->desc.bDeviceSubClass =
+				mot_android_vid_pid[i].subclass;
+			dev->cdev->desc.bDeviceProtocol =
+				mot_android_vid_pid[i].protocol;
+		}
+
+	}
+
+	if (dev->cdev && dev->cdev->gadget)  {
+		/* dev->cdev->gadget->speed != USB_SPEED_UNKNOWN ? */
+		usb_gadget_disconnect(dev->cdev->gadget);
+		msleep(10);
+		usb_gadget_connect(dev->cdev->gadget);
+	}
+}
+
+static int adb_mode_changed_flag;
+
+static int adb_enable_open(struct inode *ip, struct file *fp)
+{
+	if (atomic_inc_return(&adb_enable_excl) != 1) {
+		atomic_dec(&adb_enable_excl);
+		return -EBUSY;
+	}
+	adb_mode_changed_flag = 1;
+	wake_up_interruptible(&device_mode_change_wait_q);
+
+	return 0;
+}
+
+static int adb_enable_release(struct inode *ip, struct file *fp)
+{
+	atomic_dec(&adb_enable_excl);
+	adb_mode_changed_flag = 1;
+	wake_up_interruptible(&device_mode_change_wait_q);
+
+	return 0;
+}
+
+static const struct file_operations adb_enable_fops = {
+	.owner = THIS_MODULE,
+	.open = adb_enable_open,
+	.release = adb_enable_release,
+};
+
+static struct miscdevice adb_enable_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "android_adb_enable",
+	.fops = &adb_enable_fops,
+};
+
+/*
+ * Device is used for USB mode switch
+ */
+static int device_mode_change_open(struct inode *ip, struct file *fp)
+{
+	if (atomic_inc_return(&device_mode_change_excl) != 1) {
+		atomic_dec(&device_mode_change_excl);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int device_mode_change_release(struct inode *ip, struct file *fp)
+{
+	atomic_dec(&device_mode_change_excl);
+	return 0;
+}
+
+static ssize_t
+device_mode_change_write(struct file *file, const char __user *buffer,
+			 size_t count, loff_t *ppos)
+{
+	unsigned char cmd[MAX_DEVICE_NAME_SIZE + 1];
+	int cnt = MAX_DEVICE_NAME_SIZE;
+	int i, temp_device_type;
+
+	if (count <= 0)
+		return 0;
+
+	if (cnt > count)
+		cnt = count;
+
+	if (copy_from_user(cmd, buffer, cnt))
+		return -EFAULT;
+	cmd[cnt] = 0;
+
+	printk(KERN_DEBUG "%s cmd=%s\n", __func__, cmd);
+
+	/* USB cable detached Command */
+	if (strncmp(cmd, "usb_cable_detach", 16) == 0) {
+		usb_data_transfer_flag = 0;
+		g_device_type = 0;
+		usb_device_cfg_flag = 0;
+		usb_get_desc_flag   = 0;
+		usb_gadget_disconnect(_android_dev->gadget);
+		return count;
+	}
+
+	/* USB connect/disconnect Test Commands */
+	if (strncmp(cmd, "usb_connect", 11) == 0) {
+		usb_gadget_connect(_android_dev->gadget);
+		return count;
+	}
+	if (strncmp(cmd, "usb_disconnect", 14) == 0) {
+		usb_gadget_disconnect(_android_dev->gadget);
+		return count;
+	}
+
+	for (i = 0; i < MAX_DEVICE_TYPE_NUM; i++) {
+		if (mot_android_vid_pid[i].name == NULL)
+			return count;
+		if (strlen(mot_android_vid_pid[i].name) > cnt)
+			continue;
+		if (strncmp(cmd, mot_android_vid_pid[i].name, cnt - 1) == 0) {
+			temp_device_type = mot_android_vid_pid[i].type;
+			strings_dev[STRING_CONFIG_IDX].s =
+			mot_android_vid_pid[i].config_name;
+			break;
+		}
+	}
+
+	if (i == MAX_DEVICE_TYPE_NUM)
+		return count;
+
+	if (temp_device_type == g_device_type)
+		return count;
+
+	g_device_type = temp_device_type;
+	force_reenumeration(_android_dev, g_device_type);
+	return count;
+}
+
+static int event_pending(void)
+{
+	if ((usb_device_cfg_flag == g_device_type) && (g_device_type != 0))
+		return 1;
+	else if (adb_mode_changed_flag)
+		return 1;
+	else if (usb_get_desc_flag)
+		return 1;
+	else if (pc_mode_switch_flag)
+		return 1;
+	else
+		return 0;
+}
+
+static unsigned int device_mode_change_poll(struct file *file,
+					    struct poll_table_struct *wait)
+{
+	poll_wait(file, &device_mode_change_wait_q, wait);
+
+	if (event_pending())
+		return POLLIN | POLLRDNORM;
+	else
+		return 0;
+}
+
+static ssize_t device_mode_change_read(struct file *file, char *buf,
+				       size_t count, loff_t *ppos)
+{
+	int ret, size, cnt;
+	/* double check last zero */
+	unsigned char no_changed[] = "none:\0";
+	unsigned char adb_en_str[] = "adb_enable:\0";
+	unsigned char adb_dis_str[] = "adb_disable:\0";
+	unsigned char enumerated_str[] = "enumerated\0";
+	unsigned char get_desc_str[] = "get_desc\0";
+	unsigned char modswitch_str[50];
+
+	/* Message format example:
+	* none:adb_enable:enumerated
+	*/
+
+	if (!event_pending())
+		return 0;
+
+	/* append PC request mode */
+	if (!pc_mode_switch_flag) {
+		size = strlen(no_changed);
+		ret = copy_to_user(buf, no_changed, size);
+	} else {
+		memset(modswitch_str, 0, 50);
+		ret = get_func_thru_config(pc_mode_switch_flag);
+		pc_mode_switch_flag = 0;
+		if (ret == -1) {
+			size = strlen(no_changed);
+			ret = copy_to_user(buf, no_changed, size);
+		} else {
+			sprintf(modswitch_str, "%s",
+				 mot_android_vid_pid[ret].name);
+			strcat(modswitch_str, ":");
+			size = strlen(modswitch_str);
+			ret = copy_to_user(buf, modswitch_str, size);
+		}
+	}
+	cnt = size;
+	buf += size;
+
+	/* append ADB status */
+	if (!adb_mode_changed_flag) {
+		size = strlen(no_changed);
+		ret = copy_to_user(buf, no_changed, size);
+	} else {
+		if (atomic_read(&adb_enable_excl)) {
+			size = strlen(adb_en_str);
+			ret = copy_to_user(buf, adb_en_str, size);
+		} else {
+			size = strlen(adb_dis_str);
+			ret = copy_to_user(buf, adb_dis_str, size);
+		}
+		adb_mode_changed_flag = 0;
+	}
+	cnt += size;
+	buf += size;
+
+	/* append USB enumerated state */
+	if ((usb_device_cfg_flag == g_device_type) && (g_device_type != 0)) {
+		usb_device_cfg_flag = 0;
+		size = strlen(enumerated_str);
+		ret += copy_to_user(buf, enumerated_str, size);
+
+	} else {
+		if (usb_get_desc_flag == 1) {
+			usb_get_desc_flag = 0;
+			size = strlen(get_desc_str);
+			ret += copy_to_user(buf, get_desc_str, size);
+		} else {
+			size = strlen(no_changed) - 1;
+			ret += copy_to_user(buf, no_changed, size);
+		}
+	}
+	cnt += size;
+
+	return cnt;
+}
+
+static const struct file_operations device_mode_change_fops = {
+	.owner = THIS_MODULE,
+	.open = device_mode_change_open,
+	.write = device_mode_change_write,
+	.poll = device_mode_change_poll,
+	.read = device_mode_change_read,
+	.release = device_mode_change_release,
+};
+
+static struct miscdevice mode_change_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "usb_device_mode",
+	.fops = &device_mode_change_fops,
+};
+
+static int __init android_probe(struct platform_device *pdev)
+{
+	struct android_usb_platform_data *pdata = pdev->dev.platform_data;
+	struct android_dev *dev = _android_dev;
+
+	if (pdata) {
+		if (pdata->vendor_id)
+			device_desc.idVendor =
+				__constant_cpu_to_le16(pdata->vendor_id);
+		if (pdata->product_id) {
+			dev->product_id = pdata->product_id;
+			device_desc.idProduct =
+				__constant_cpu_to_le16(pdata->product_id);
+		}
+		if (pdata->adb_product_id)
+			dev->adb_product_id = pdata->adb_product_id;
+		if (pdata->version)
+			dev->version = pdata->version;
+
+		if (pdata->product_name)
+			strings_dev[STRING_PRODUCT_IDX].s = pdata->product_name;
+		if (pdata->manufacturer_name)
+			strings_dev[STRING_MANUFACTURER_IDX].s =
+				pdata->manufacturer_name;
+		if (pdata->serial_number)
+			strings_dev[STRING_SERIAL_IDX].s = pdata->serial_number;
+		dev->nluns = pdata->nluns;
+	}
+
+	return 0;
+}
+
+static struct platform_driver android_platform_driver = {
+	.driver = {.name = "android_usb",},
+	.probe = android_probe,
+};
+
+static int __init init(void)
+{
+	struct android_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	_android_dev = dev;
+
+	ret = platform_driver_register(&android_platform_driver);
+	if (ret)
+		return ret;
+	ret = misc_register(&adb_enable_device);
+	if (ret) {
+		platform_driver_unregister(&android_platform_driver);
+		return ret;
+	}
+	ret = misc_register(&mode_change_device);
+	if (ret) {
+		misc_deregister(&adb_enable_device);
+		platform_driver_unregister(&android_platform_driver);
+		return ret;
+	}
+
+	ret = usb_composite_register(&android_usb_driver);
+	if (ret) {
+		misc_deregister(&adb_enable_device);
+		misc_deregister(&mode_change_device);
+		platform_driver_unregister(&android_platform_driver);
+	}
+
+	return ret;
+}
+
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&android_usb_driver);
+	misc_deregister(&adb_enable_device);
+	misc_deregister(&mode_change_device);
+	platform_driver_unregister(&android_platform_driver);
+	kfree(_android_dev);
+	_android_dev = NULL;
+}
+
+module_exit(cleanup);
diff --git a/drivers/usb/gadget/u_serial.c b/drivers/usb/gadget/u_serial.c
index 53d5928..217b4b6 100644
--- a/drivers/usb/gadget/u_serial.c
+++ b/drivers/usb/gadget/u_serial.c
@@ -998,10 +998,27 @@ static int gs_break_ctl(struct tty_struct *tty, int duration)
 	return status;
 }
 
+#ifdef CONFIG_USB_MOT_ANDROID
+/* Add TIOCMSET which is used by ATCMD */
+static int gs_tiocmset(struct tty_struct *tty, struct file *file,
+	unsigned int set, unsigned int clear)
+{
+	struct gs_port  *port = tty->driver_data;
+
+	printk(KERN_INFO "%s set=%x clear=%x \n", __func__, set, clear);
+	port->port_usb->tiocmset(port->port_usb, set, clear);
+	return 0;
+}
+#endif
+
 static const struct tty_operations gs_tty_ops = {
 	.open =			gs_open,
 	.close =		gs_close,
 	.write =		gs_write,
+
+#ifdef CONFIG_USB_MOT_ANDROID
+	.tiocmset =             gs_tiocmset,
+#endif
 	.put_char =		gs_put_char,
 	.flush_chars =		gs_flush_chars,
 	.write_room =		gs_write_room,
@@ -1014,7 +1031,11 @@ static const struct tty_operations gs_tty_ops = {
 
 static struct tty_driver *gs_tty_driver;
 
+#ifdef CONFIG_USB_MOT_ANDROID
 static int __init
+#else
+static int
+#endif
 gs_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding)
 {
 	struct gs_port	*port;
@@ -1060,7 +1081,11 @@ gs_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding)
  *
  * Returns negative errno or zero.
  */
+#ifdef CONFIG_USB_MOT_ANDROID
+int gserial_setup(struct usb_gadget *g, unsigned count)
+#else
 int __init gserial_setup(struct usb_gadget *g, unsigned count)
+#endif
 {
 	unsigned			i;
 	struct usb_cdc_line_coding	coding;
diff --git a/drivers/usb/gadget/u_serial.h b/drivers/usb/gadget/u_serial.h
index 300f0ed..724a4ce 100644
--- a/drivers/usb/gadget/u_serial.h
+++ b/drivers/usb/gadget/u_serial.h
@@ -42,6 +42,9 @@ struct gserial {
 	struct usb_cdc_line_coding port_line_coding;	/* 9600-8-N-1 etc */
 
 	/* notification callbacks */
+#ifdef CONFIG_USB_MOT_ANDROID
+	void (*tiocmset)(struct gserial *p, int set, int clear);
+#endif
 	void (*connect)(struct gserial *p);
 	void (*disconnect)(struct gserial *p);
 	int (*send_break)(struct gserial *p, int duration);
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 7f4ace7..b0f8ed5 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -358,8 +358,7 @@ struct debug_buffer {
 	struct usb_bus *bus;
 	struct mutex mutex;	/* protect filling of buffer */
 	size_t count;		/* number of characters filled into buffer */
-	char *output_buf;
-	size_t alloc_size;
+	char *page;
 };
 
 #define speed_char(info1) ({ char tmp; \
@@ -455,7 +454,9 @@ static void qh_lines (
 				(scratch >> 16) & 0x7fff,
 				scratch,
 				td->urb);
-		if (size < temp)
+		if (temp < 0)
+			temp = 0;
+		else if (size < temp)
 			temp = size;
 		size -= temp;
 		next += temp;
@@ -464,7 +465,9 @@ static void qh_lines (
 	}
 
 	temp = snprintf (next, size, "\n");
-	if (size < temp)
+	if (temp < 0)
+		temp = 0;
+	else if (size < temp)
 		temp = size;
 	size -= temp;
 	next += temp;
@@ -485,8 +488,8 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 
 	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf->output_buf;
-	size = buf->alloc_size;
+	next = buf->page;
+	size = PAGE_SIZE;
 
 	*next = 0;
 
@@ -507,7 +510,7 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 	}
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
-	return strlen(buf->output_buf);
+	return strlen(buf->page);
 }
 
 #define DBG_SCHED_LIMIT 64
@@ -528,8 +531,8 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 
 	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf->output_buf;
-	size = buf->alloc_size;
+	next = buf->page;
+	size = PAGE_SIZE;
 
 	temp = scnprintf (next, size, "size = %d\n", ehci->periodic_size);
 	size -= temp;
@@ -565,16 +568,14 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 				for (temp = 0; temp < seen_count; temp++) {
 					if (seen [temp].ptr != p.ptr)
 						continue;
-					if (p.qh->qh_next.ptr) {
+					if (p.qh->qh_next.ptr)
 						temp = scnprintf (next, size,
 							" ...");
-						size -= temp;
-						next += temp;
-					}
+					p.ptr = NULL;
 					break;
 				}
 				/* show more info the first time around */
-				if (temp == seen_count) {
+				if (temp == seen_count && p.ptr) {
 					u32	scratch = hc32_to_cpup(ehci,
 							&p.qh->hw_info1);
 					struct ehci_qtd	*qtd;
@@ -648,7 +649,7 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 	spin_unlock_irqrestore (&ehci->lock, flags);
 	kfree (seen);
 
-	return buf->alloc_size - size;
+	return PAGE_SIZE - size;
 }
 #undef DBG_SCHED_LIMIT
 
@@ -664,14 +665,14 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 
 	hcd = bus_to_hcd(buf->bus);
 	ehci = hcd_to_ehci (hcd);
-	next = buf->output_buf;
-	size = buf->alloc_size;
+	next = buf->page;
+	size = PAGE_SIZE;
 
 	spin_lock_irqsave (&ehci->lock, flags);
 
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {
 		size = scnprintf (next, size,
-			"bus %s, device %s\n"
+			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
 			"%s\n"
 			"SUSPENDED (no register access)\n",
 			hcd->self.controller->bus->name,
@@ -683,7 +684,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	/* Capability Registers */
 	i = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	temp = scnprintf (next, size,
-		"bus %s, device %s\n"
+		"bus %s, device %s (driver " DRIVER_VERSION ")\n"
 		"%s\n"
 		"EHCI %x.%02x, hcd state %d\n",
 		hcd->self.controller->bus->name,
@@ -807,7 +808,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 done:
 	spin_unlock_irqrestore (&ehci->lock, flags);
 
-	return buf->alloc_size - size;
+	return PAGE_SIZE - size;
 }
 
 static struct debug_buffer *alloc_buffer(struct usb_bus *bus,
@@ -821,7 +822,6 @@ static struct debug_buffer *alloc_buffer(struct usb_bus *bus,
 		buf->bus = bus;
 		buf->fill_func = fill_func;
 		mutex_init(&buf->mutex);
-		buf->alloc_size = PAGE_SIZE;
 	}
 
 	return buf;
@@ -831,10 +831,10 @@ static int fill_buffer(struct debug_buffer *buf)
 {
 	int ret = 0;
 
-	if (!buf->output_buf)
-		buf->output_buf = (char *)vmalloc(buf->alloc_size);
+	if (!buf->page)
+		buf->page = (char *)get_zeroed_page(GFP_KERNEL);
 
-	if (!buf->output_buf) {
+	if (!buf->page) {
 		ret = -ENOMEM;
 		goto out;
 	}
@@ -867,7 +867,7 @@ static ssize_t debug_output(struct file *file, char __user *user_buf,
 	mutex_unlock(&buf->mutex);
 
 	ret = simple_read_from_buffer(user_buf, len, offset,
-				      buf->output_buf, buf->count);
+				      buf->page, buf->count);
 
 out:
 	return ret;
@@ -879,8 +879,8 @@ static int debug_close(struct inode *inode, struct file *file)
 	struct debug_buffer *buf = file->private_data;
 
 	if (buf) {
-		if (buf->output_buf)
-			vfree(buf->output_buf);
+		if (buf->page)
+			free_page((unsigned long)buf->page);
 		kfree(buf);
 	}
 
@@ -895,14 +895,10 @@ static int debug_async_open(struct inode *inode, struct file *file)
 
 static int debug_periodic_open(struct inode *inode, struct file *file)
 {
-	struct debug_buffer *buf;
-	buf = alloc_buffer(inode->i_private, fill_periodic_buffer);
-	if (!buf)
-		return -ENOMEM;
+	file->private_data = alloc_buffer(inode->i_private,
+					  fill_periodic_buffer);
 
-	buf->alloc_size = (sizeof(void *) == 4 ? 6 : 8)*PAGE_SIZE;
-	file->private_data = buf;
-	return 0;
+	return file->private_data ? 0 : -ENOMEM;
 }
 
 static int debug_registers_open(struct inode *inode, struct file *file)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d832a94..c41cbe8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -24,7 +24,6 @@
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/vmalloc.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/timer.h>
@@ -60,6 +59,7 @@
  * providing early devices for those host controllers to talk to!
  */
 
+#define DRIVER_VERSION "10 Dec 2004"
 #define DRIVER_AUTHOR "David Brownell"
 #define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
 
@@ -485,7 +485,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci->periodic_size = DEFAULT_I_TDPS;
-	INIT_LIST_HEAD(&ehci->cached_itd_list);
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)
 		return retval;
 
@@ -498,7 +497,6 @@ static int ehci_init(struct usb_hcd *hcd)
 
 	ehci->reclaim = NULL;
 	ehci->next_uframe = -1;
-	ehci->clock_frame = -1;
 
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
@@ -622,9 +620,9 @@ static int ehci_run (struct usb_hcd *hcd)
 
 	temp = HC_VERSION(ehci_readl(ehci, &ehci->caps->hc_capbase));
 	ehci_info (ehci,
-		"USB %x.%x started, EHCI %x.%02x%s\n",
+		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
-		temp >> 8, temp & 0xff,
+		temp >> 8, temp & 0xff, DRIVER_VERSION,
 		ignore_oc ? ", overcurrent ignored" : "");
 
 	ehci_writel(ehci, INTR_MASK,
@@ -708,7 +706,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		pcd_status = status;
 
 		/* resume root hub? */
-		if (!(cmd & CMD_RUN))
+		if (!(ehci_readl(ehci, &ehci->regs->command) & CMD_RUN))
 			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
@@ -717,11 +715,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 			if (pstatus & PORT_OWNER)
 				continue;
-			if (!(test_bit(i, &ehci->suspended_ports) &&
-					((pstatus & PORT_RESUME) ||
-						!(pstatus & PORT_SUSPEND)) &&
-					(pstatus & PORT_PE) &&
-					ehci->reset_done[i] == 0))
+			if (!(pstatus & PORT_RESUME)
+					|| ehci->reset_done [i] != 0)
 				continue;
 
 			/* start 20 msec resume signaling from this port,
@@ -731,14 +726,18 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, ehci->reset_done[i]);
+#ifdef CONFIG_HAS_WAKELOCK
+			wake_lock_timeout(&ehci->wake_lock_ehci_rwu, HZ/2);
+#endif
 		}
 	}
 
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status & STS_FATAL) != 0)) {
 		ehci_err(ehci, "fatal error\n");
-		dbg_cmd(ehci, "fatal", cmd);
-		dbg_status(ehci, "fatal", status);
+		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
+						   &ehci->regs->command));
+		dbg_status (ehci, "fatal", status);
 		ehci_halt(ehci);
 dead:
 		ehci_reset(ehci);
@@ -997,7 +996,9 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
-MODULE_DESCRIPTION(DRIVER_DESC);
+#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
+
+MODULE_DESCRIPTION (DRIVER_INFO);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
@@ -1026,6 +1027,11 @@ MODULE_LICENSE ("GPL");
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
 #endif
 
+#if defined(CONFIG_440EPX) && !defined(CONFIG_PPC_MERGE)
+#include "ehci-ppc-soc.c"
+#define	PLATFORM_DRIVER		ehci_ppc_soc_driver
+#endif
+
 #ifdef CONFIG_USB_EHCI_HCD_PPC_OF
 #include "ehci-ppc-of.c"
 #define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
@@ -1050,10 +1056,6 @@ static int __init ehci_hcd_init(void)
 {
 	int retval = 0;
 
-	if (usb_disabled())
-		return -ENODEV;
-
-	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
 	set_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	if (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||
 			test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 97a53a4..1ea942b 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -112,6 +112,14 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	int			port;
 	int			mask;
 
+	port = HCS_N_PORTS(ehci->hcs_params);
+	while (port--) {
+		u32 __iomem	*reg = &ehci->regs->port_status[port];
+		u32		t1 = ehci_readl(ehci, reg);
+		if (t1 & PORT_RESUME)
+			return -EBUSY;
+	}
+
 	ehci_dbg(ehci, "suspend root hub\n");
 
 	if (time_before (jiffies, ehci->next_statechange))
@@ -183,6 +191,11 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	ehci->next_statechange = jiffies + msecs_to_jiffies(10);
 	spin_unlock_irq (&ehci->lock);
+
+	/* ehci_work() may have re-enabled the watchdog timer, which we do not
+	 * want, and so we must delete any pending watchdog timer events.
+	 */
+	del_timer_sync(&ehci->watchdog);
 	return 0;
 }
 
@@ -227,11 +240,16 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	/* restore CMD_RUN, framelist size, and irq threshold */
 	ehci_writel(ehci, ehci->command, &ehci->regs->command);
 
+#if 0
+	/* We don't need this on the OMAP. Hence removing this delay */
+
 	/* Some controller/firmware combinations need a delay during which
 	 * they set up the port statuses.  See Bugzilla #8190. */
+
 	spin_unlock_irq(&ehci->lock);
 	msleep(8);
 	spin_lock_irq(&ehci->lock);
+#endif
 
 	/* manually resume the ports we suspended during bus_suspend() */
 	i = HCS_N_PORTS (ehci->hcs_params);
@@ -240,6 +258,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		temp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &ehci->bus_suspended) &&
 				(temp & PORT_SUSPEND)) {
+			ehci->reset_done [i] = jiffies + msecs_to_jiffies (20);
 			temp |= PORT_RESUME;
 			resume_needed = 1;
 		}
@@ -283,7 +302,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	ehci_writel(ehci, INTR_MASK, &ehci->regs->intr_enable);
 
 	spin_unlock_irq (&ehci->lock);
-	ehci_handover_companion_ports(ehci);
+		ehci_handover_companion_ports(ehci);
 	return 0;
 }
 
@@ -420,29 +439,38 @@ static int check_reset_complete (
 
 		/* with integrated TT, there's nobody to hand it to! */
 		if (ehci_is_TDI(ehci)) {
-			ehci_dbg (ehci,
+			ehci_dbg(ehci,
 				"Failed to enable port %d on root hub TT\n",
 				index+1);
 			return port_status;
 		}
 
-		ehci_dbg (ehci, "port %d full speed --> companion\n",
+		ehci_dbg(ehci, "port %d full speed --> companion\n",
 			index + 1);
 
-		// what happens if HCS_N_CC(params) == 0 ?
-		port_status |= PORT_OWNER;
-		port_status &= ~PORT_RWC_BITS;
-		ehci_writel(ehci, port_status, status_reg);
-
-		/* ensure 440EPX ohci controller state is operational */
-		if (ehci->has_amcc_usb23)
-			set_ohci_hcfs(ehci, 1);
-	} else {
+		/* when detect a full speed device, it's compliant with EHCI
+		 * specification to give up ownership of that port. But for our
+		 * case, there is really no other device connected to port 3,
+		 * and for some reason when a panic in the device happens,
+		 * the peripheral shows up as full speed device, hence
+		 * enumeration with EHCI fails. To workaround this issue, BP
+		 * reset USB controller and restart enumeration process if
+		 * enumeration doesn't seem to happen, and in EHCI driver, we
+		 * don't give up ownership of the port, simply waiting for the
+		 * of the port, simply waiting for the peripheral to connect
+		 * again. */
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+		if ((index != 2) || is_cdma_phone()) {
+#else
+		if (index != 2) {
+#endif
+			// what happens if HCS_N_CC(params) == 0 ?
+			port_status |= PORT_OWNER;
+			port_status &= ~PORT_RWC_BITS;
+			ehci_writel(ehci, port_status, status_reg);
+		}
+	} else
 		ehci_dbg (ehci, "port %d high speed\n", index + 1);
-		/* ensure 440EPx ohci controller state is suspended */
-		if (ehci->has_amcc_usb23)
-			set_ohci_hcfs(ehci, 0);
-	}
 
 	return port_status;
 }
@@ -499,9 +527,10 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		 * controller by the user.
 		 */
 
-		if ((temp & mask) != 0 || test_bit(i, &ehci->port_c_suspend)
-				|| (ehci->reset_done[i] && time_after_eq(
-					jiffies, ehci->reset_done[i]))) {
+		if ((temp & mask) != 0
+				|| ((temp & PORT_RESUME) != 0
+					&& time_after_eq(jiffies,
+						ehci->reset_done[i]))) {
 			if (i < 7)
 			    buf [0] |= 1 << (i + 1);
 			else
@@ -567,6 +596,7 @@ static int ehci_hub_control (
 	unsigned long	flags;
 	int		retval = 0;
 	unsigned	selector;
+	u32	runstop;
 
 	/*
 	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
@@ -704,10 +734,20 @@ static int ehci_hub_control (
 			/* resume completed? */
 			else if (time_after_eq(jiffies,
 					ehci->reset_done[wIndex])) {
-				clear_bit(wIndex, &ehci->suspended_ports);
 				set_bit(wIndex, &ehci->port_c_suspend);
 				ehci->reset_done[wIndex] = 0;
 
+		/* Workaround for OMAP errata:
+		 * The errata effects suspend-resume and remote-wakeup
+		 * We need to halt the controller before clearing the
+		 * resume bit in PORTSC
+		 */
+		runstop = ehci_readl(ehci, &ehci->regs->command);
+		ehci_writel(ehci, (runstop & ~CMD_RUN), &ehci->regs->command);
+		(void) ehci_readl(ehci, &ehci->regs->command);
+		handshake(ehci, &ehci->regs->status,
+				STS_HALT, STS_HALT, 2000);
+
 				/* stop resume signaling */
 				temp = ehci_readl(ehci, status_reg);
 				ehci_writel(ehci,
@@ -715,6 +755,10 @@ static int ehci_hub_control (
 					status_reg);
 				retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
+
+		ehci_writel(ehci, (runstop), &ehci->regs->command);
+		(void) ehci_readl(ehci, &ehci->regs->command);
+
 				if (retval != 0) {
 					ehci_err(ehci,
 						"port %d resume error %d\n",
@@ -751,9 +795,6 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
-		if (!(temp & (PORT_RESUME|PORT_RESET)))
-			ehci->reset_done[wIndex] = 0;
-
 		/* transfer dedicated ports to the companion hc */
 		if ((temp & PORT_CONNECT) &&
 				test_bit(wIndex, &ehci->companion_ports)) {
@@ -777,17 +818,8 @@ static int ehci_hub_control (
 		}
 		if (temp & PORT_PE)
 			status |= 1 << USB_PORT_FEAT_ENABLE;
-
-		/* maybe the port was unsuspended without our knowledge */
-		if (temp & (PORT_SUSPEND|PORT_RESUME)) {
+		if (temp & (PORT_SUSPEND|PORT_RESUME))
 			status |= 1 << USB_PORT_FEAT_SUSPEND;
-		} else if (test_bit(wIndex, &ehci->suspended_ports)) {
-			clear_bit(wIndex, &ehci->suspended_ports);
-			ehci->reset_done[wIndex] = 0;
-			if (temp & PORT_PE)
-				set_bit(wIndex, &ehci->port_c_suspend);
-		}
-
 		if (temp & PORT_OC)
 			status |= 1 << USB_PORT_FEAT_OVER_CURRENT;
 		if (temp & PORT_RESET)
@@ -832,7 +864,6 @@ static int ehci_hub_control (
 					|| (temp & PORT_RESET) != 0)
 				goto error;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
-			set_bit(wIndex, &ehci->suspended_ports);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci->hcs_params))
diff --git a/drivers/usb/host/ehci-ixp4xx.c b/drivers/usb/host/ehci-ixp4xx.c
index 9c32063..f9575c4 100644
--- a/drivers/usb/host/ehci-ixp4xx.c
+++ b/drivers/usb/host/ehci-ixp4xx.c
@@ -1,7 +1,7 @@
 /*
  * IXP4XX EHCI Host Controller Driver
  *
- * Author: Vladimir Barinov <vbarinov@embeddedalley.com>
+ * Author: Vladimir Barinov <vbarinov@ru.mvista.com>
  *
  * Based on "ehci-fsl.c" by Randy Vinson <rvinson@mvista.com>
  *
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 10d5291..0431397 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -128,7 +128,6 @@ static inline void qh_put (struct ehci_qh *qh)
 
 static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
-	free_cached_itd_list(ehci);
 	if (ehci->async)
 		qh_put (ehci->async);
 	ehci->async = NULL;
diff --git a/drivers/usb/host/ehci-omap.c b/drivers/usb/host/ehci-omap.c
index 4a543a4..0dca54f 100644
--- a/drivers/usb/host/ehci-omap.c
+++ b/drivers/usb/host/ehci-omap.c
@@ -5,7 +5,8 @@
  * Tested on OMAP3430 ES2.0 SDP
  *
  * Copyright (C) 2007-2008 Texas Instruments, Inc.
- *	Author: Vikram Pandita <vikram.pandita@ti.com>
+ * Copyright (C) 2008-2009 Motorola, Inc.
+ * Author: Vikram Pandita <vikram.pandita@ti.com>
  *
  * Based on "ehci-fsl.c" and "ehci-au1xxx.c" ehci glue layers
  *
@@ -23,26 +24,36 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  *
+ * Revision History:
+ *
+ * Date        Author          Comment
+ * ----------  --------------- -------------------------------------------
+ * 03/25/2008  Motorola        Porting USB feature for OMAP chip
+ * 03/25/2009  Motorola        Conditionally configure port for OHCI
+ * 04/24/2008  Motorola        Update GPIO common API
  */
 
 #include <linux/platform_device.h>
+#include <linux/spinlock.h>
 #include <linux/clk.h>
 #include <linux/usb/omap.h>
-
+#ifdef CONFIG_MOT_FEAT_IPC_CORERETENTION
+#include <linux/device.h>
+#endif
 #include <mach/gpio.h>
 
 #include "ehci-omap.h"
+#include <mach/hardware.h>
 
-/* These default platform_data configs are an attempt to maintain
- * backwards compatiblity with the old driver.  These contains
- * board specific data and should be migrated the the apropriate
- * board files.
- */
+#ifdef CONFIG_MOT_FEAT_GPIO_API
+#include <mach/mot-gpio-omap.h>
+#endif
 
+struct usb_hcd *ghcd;
 #ifdef CONFIG_OMAP_EHCI_PHY_MODE
 /* EHCI connected to External PHY */
 
-/* External USB connectivity board: 750-2083-001
+/* External USB connectivity board: 750-2099-001(C)
  * Connected to OMAP3430 SDP
  * The board has Port1 and Port2 connected to ISP1504 in 12-pin ULPI mode
  */
@@ -50,117 +61,20 @@
 /* ISSUE1:
  *      ISP1504 for input clocking mode needs special reset handling
  *	Hold the PHY in reset by asserting RESET_N signal
- *	Then start the 60Mhz clock input to PHY
- *	Release the reset after a delay -
- *		to get the PHY state machine in working state
+ * 	Then start the 60Mhz clock input to PHY
+ * 	Release the reset after a delay -
+ * 		to get the PHY state machine in working state
  */
-
+#define EXTERNAL_PHY_RESET
 #define	EXT_PHY_RESET_GPIO_PORT1	(57)
 #define	EXT_PHY_RESET_GPIO_PORT2	(61)
-
-static int default_usb_port_startup(struct platform_device *dev, int port)
-{
-	int r;
-	int gpio;
-	const char *name;
-
-	if (port == 0) {
-		gpio = EXT_PHY_RESET_GPIO_PORT1;
-		name = "ehci port 1 reset";
-	} else if (port == 1) {
-		gpio = EXT_PHY_RESET_GPIO_PORT2;
-		name = "ehci port 2 reset";
-	} else {
-		return -EINVAL;
-	}
-
-	r = gpio_request(gpio, name);
-	if (r < 0) {
-		printk(KERN_WARNING "Could not request GPIO %d"
-		       " for port %d reset\n",
-		       gpio, port);
-		return r;
-	}
-	gpio_direction_output(gpio, 0);
-	return 0;
-}
-
-static void default_usb_port_shutdown(struct platform_device *dev, int port)
-{
-	if (port == 0)
-		gpio_free(EXT_PHY_RESET_GPIO_PORT1);
-	else if (port == 1)
-		gpio_free(EXT_PHY_RESET_GPIO_PORT2);
-}
-
-
-static void default_usb_port_reset(struct platform_device *dev,
-				   int port, int reset)
-{
-	if (port == 0)
-		gpio_set_value(EXT_PHY_RESET_GPIO_PORT1, !reset);
-	else if (port == 1)
-		gpio_set_value(EXT_PHY_RESET_GPIO_PORT2, !reset);
-}
-
-
-static struct omap_usb_port_data default_usb_port_data[] = {
-	[0] = {
-		.flags = OMAP_USB_PORT_FLAG_ENABLED,
-		.mode = OMAP_USB_PORT_MODE_ULPI_PHY,
-		.reset_delay = 10,
-		.startup = default_usb_port_startup,
-		.shutdown = default_usb_port_shutdown,
-		.reset = default_usb_port_reset,
-	},
-	[1] = {
-		.flags = OMAP_USB_PORT_FLAG_ENABLED,
-		.mode = OMAP_USB_PORT_MODE_ULPI_PHY,
-		.reset_delay = 10,
-		.startup = default_usb_port_startup,
-		.shutdown = default_usb_port_shutdown,
-		.reset = default_usb_port_reset,
-	},
-	[2] = { .flags = 0x0, }, /* disabled */
-
-};
-
-/* ISSUE2:
- * USBHOST supports External charge pump PHYs only
- * Use the VBUS from Port1 to power VBUS of Port2 externally
- * So use Port2 as the working ULPI port
- */
-static struct omap_usb_platform_data default_usb_platform_data = {
-	.flags =  OMAP_USB_FLAG_VBUS_INTERNAL_CHARGEPUMP,
-	.port_data = default_usb_port_data,
-	.num_ports = ARRAY_SIZE(default_usb_port_data),
-};
-
-#else /* CONFIG_OMAP_EHCI_PHY_MODE */
-
-static struct omap_usb_port_data default_usb_port_data[] = {
-	[0] = {
-		.flags = OMAP_USB_PORT_FLAG_ENABLED,
-		.mode = OMAP_USB_PORT_MODE_UTMI_PHY_6PIN,
-	},
-	[1] = {
-		.flags = OMAP_USB_PORT_FLAG_ENABLED,
-		.mode = OMAP_USB_PORT_MODE_ULPI_PHY,
-	},
-	[2] = {
-		.flags = OMAP_USB_PORT_FLAG_ENABLED,
-		.mode = OMAP_USB_PORT_MODE_ULPI_PHY,
-	},
-};
-
-static struct omap_usb_platform_data default_usb_platform_data = {
-	.port_data = default_usb_port_data,
-	.num_ports = ARRAY_SIZE(default_usb_port_data),
-};
+#define	EXT_PHY_RESET_DELAY		(500)
+#ifdef CONFIG_MACH_MAPPHONE
+	#define EXT_PHY_RESET_GPIO_PORT (149)
+#endif
 
 #endif /* CONFIG_OMAP_EHCI_PHY_MODE */
 
-
 /*-------------------------------------------------------------------------*/
 
 /* Define USBHOST clocks for clock management */
@@ -170,147 +84,115 @@ struct ehci_omap_clock_defs {
 	struct clk	*usbhost1_48m_fck_clk;
 	struct clk	*usbtll_fck_clk;
 	struct clk	*usbtll_ick_clk;
+	unsigned	suspended:1;
 };
 
+static int usbtll_fclk_enabled;
+static int usbhost_fclk_enabled;
+static DEFINE_SPINLOCK(usbtll_clock_lock);
+
 /* Clock names as per clock framework: May change so keep as #defs */
-#define USBHOST_ICKL		"usbhost_ick"
+#define USBHOST_ICKL	"usbhost_ick"
 #define USBHOST_120M_FCLK	"usbhost_120m_fck"
 #define USBHOST_48M_FCLK	"usbhost_48m_fck"
 #define USBHOST_TLL_ICKL	"usbtll_ick"
 #define USBHOST_TLL_FCLK	"usbtll_fck"
 /*-------------------------------------------------------------------------*/
 
-static int omap_usb_port_ulpi_bypass(enum omap_usb_port_mode mode)
-{
-	return mode != OMAP_USB_PORT_MODE_ULPI_PHY;
-}
+#ifdef CONFIG_MOT_FEAT_IPC_CORERETENTION
+unsigned short disable_irq_value;
+static ssize_t disable_irq_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
+static ssize_t disable_irq_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t n);
+static struct kobj_attribute usbtll_disable_irq_attr = __ATTR(disable_irq_value, 0644, disable_irq_show, disable_irq_store);
 
-static int omap_usb_port_ttl_chanel_config(enum omap_usb_port_mode mode)
+static ssize_t disable_irq_show(struct kobject *kobj, struct kobj_attribute *attr,
+                                char *buf)
 {
-	return (mode == OMAP_USB_PORT_MODE_UTMI_PHY_6PIN) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_PHY_6PIN_ALT) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_PHY_3PIN) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_PHY_4PIN) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_TLL_6PIN) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_TLL_6PIN_ALT) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_TLL_3PIN) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_TLL_4PIN) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_TLL_2PIN) ||
-		(mode == OMAP_USB_PORT_MODE_UTMI_TLL_2PIN_ALT);
+        printk("in disable_irq_show()\n");
+        return sprintf(buf, "%hu\n", disable_irq_value);
 }
-
-static unsigned omap_usb_port_fslsmode(enum omap_usb_port_mode mode)
+static ssize_t disable_irq_store(struct kobject *kobj, struct kobj_attribute *attr,const char *buf, size_t n)
 {
-	switch (mode) {
-		/* non serial modes */
-	case OMAP_USB_PORT_MODE_ULPI_PHY:
-	case OMAP_USB_PORT_MODE_ULPI_TLL_SDR:
-	case OMAP_USB_PORT_MODE_ULPI_TLL_DDR:
-		return 0x0;
-
-		/* serial modes */
-	case OMAP_USB_PORT_MODE_UTMI_PHY_6PIN:
-		return 0x0;
-
-	case OMAP_USB_PORT_MODE_UTMI_PHY_6PIN_ALT:
-		return 0x1;
+        unsigned short value;
 
-	case OMAP_USB_PORT_MODE_UTMI_PHY_3PIN:
-		return 0x2;
+        if (sscanf(buf, "%hu", &value) != 1 ||
+                (value != 0 && value != 1)) {
+                        printk(KERN_ERR "disable_irq_store: Invalid value\n");
+                        return -EINVAL;
+        }
 
-	case OMAP_USB_PORT_MODE_UTMI_PHY_4PIN:
-		return 0x3;
 
-	case OMAP_USB_PORT_MODE_UTMI_TLL_6PIN:
-		return 0x4;
+        if (attr == &usbtll_disable_irq_attr)
+            disable_irq_value = value;
 
-	case OMAP_USB_PORT_MODE_UTMI_TLL_6PIN_ALT:
-		return 0x5;
-
-	case OMAP_USB_PORT_MODE_UTMI_TLL_3PIN:
-		return 0x6;
-
-	case OMAP_USB_PORT_MODE_UTMI_TLL_4PIN:
-		return 0x7;
-
-	case OMAP_USB_PORT_MODE_UTMI_TLL_2PIN:
-		return 0xa;
-
-	case OMAP_USB_PORT_MODE_UTMI_TLL_2PIN_ALT:
-		return 0xB;
-	}
+        printk("disable_irq_value=%d\n", disable_irq_value);
+        if (disable_irq_value)
+        {
+                //omap_writel(6, 0x48062018);
+                //omap_writel(0, 0x4806201C);
+                printk("disable usbtll irq in disable_irq_store()\n");
+        }
 
-	return 0x0;
+        return n;
 }
+#endif
+
+#ifndef CONFIG_OMAP_EHCI_PHY_MODE
 
-static void omap_usb_setup_ports(struct usb_hcd *hcd)
+static void omap_usb_utmi_init(struct usb_hcd *hcd, u8 tll_channel_mask)
 {
 	int i;
-	struct omap_usb_platform_data *data =  (struct omap_usb_platform_data *)
-		hcd->self.controller->platform_data;
-	u32 val;
-
-	val = (1<<OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN_SHIFT)|
-		(1<<OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN_SHIFT)|
-		(1<<OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN_SHIFT)|
-		(0<<OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN_SHIFT);
-
-
-	if ((data->num_ports > 0) &&
-	    (omap_usb_port_ulpi_bypass(data->port_data[0].mode)))
-		val |= (1 << OMAP_UHH_HOSTCONFIG_P1_ULPI_BYPASS_SHIFT);
-	if ((data->num_ports > 1) &&
-	    (omap_usb_port_ulpi_bypass(data->port_data[1].mode)))
-		val |= (1 << OMAP_UHH_HOSTCONFIG_P2_ULPI_BYPASS_SHIFT);
-	if ((data->num_ports > 2) &&
-	    (omap_usb_port_ulpi_bypass(data->port_data[2].mode)))
-		val |= (1 << OMAP_UHH_HOSTCONFIG_P3_ULPI_BYPASS_SHIFT);
-
-	omap_writel(val, OMAP_UHH_HOSTCONFIG);
-
-	/* wait for change to sync */
-	while ((omap_readl(OMAP_UHH_HOSTCONFIG) &
-		OMAP_UHH_HOSTCONFIG_ULPI_BYPASS_MASK) !=
-	       (val & OMAP_UHH_HOSTCONFIG_ULPI_BYPASS_MASK))
+
+	/* Use UTMI Ports of TLL */
+	omap_writel((1 << OMAP_UHH_HOSTCONFIG_P1_ULPI_BYPASS_SHIFT)|
+			(1 << OMAP_UHH_HOSTCONFIG_P3_ULPI_BYPASS_SHIFT)|
+			(1<<OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN_SHIFT)|
+			(1<<OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN_SHIFT)|
+			(1<<OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN_SHIFT)|
+			(0<<OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN_SHIFT),
+						OMAP_UHH_HOSTCONFIG);
+	/* Enusre bit is set */
+	while (!(omap_readl(OMAP_UHH_HOSTCONFIG) &
+		 ((1 << OMAP_UHH_HOSTCONFIG_P1_ULPI_BYPASS_SHIFT) | (1 << OMAP_UHH_HOSTCONFIG_P3_ULPI_BYPASS_SHIFT))))
 		cpu_relax();
 
-	dev_dbg(hcd->self.controller, "ULPI Byppass mode congfigured: %08x\n",
-		omap_readl(OMAP_UHH_HOSTCONFIG));
+	dev_dbg(hcd->self.controller, "\nEntered UTMI MODE: success\n");
+
+	/* Program the 3 TLL channels upfront */
 
-	/* Program the 3 channels upfront */
 	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		/* AutoIdle */
-		if ((data->num_ports > i) &&
-		    (data->port_data[i].flags & OMAP_USB_PORT_FLAG_AUTOIDLE))
-			omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) |
-				    1<<OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE_SHIFT,
-				    OMAP_TLL_CHANNEL_CONF(i));
-		else
-			omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) &
-				    ~(1<<OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE_SHIFT),
-				    OMAP_TLL_CHANNEL_CONF(i));
-
-		/* BitStuffing */
-		if ((data->num_ports > i) &&
-		    (data->port_data[i].flags & OMAP_USB_PORT_FLAG_NOBITSTUFF))
+
+		/* Disable AutoIdle */
+		/* Changed to Enable AutoIdle of UTMI
+		 * This will allow TLL FCLK END interrupt to be generated*/
+		omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) |
+			    (1 << OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE_SHIFT),
+			    OMAP_TLL_CHANNEL_CONF(i));
+
+		/* Disable BitStuffing */
+		omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) |
+			(1<<OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF_SHIFT),
+			OMAP_TLL_CHANNEL_CONF(i));
+
+		/* SDR Mode */
+		omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) &
+			    ~(1<<OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE_SHIFT),
+			    OMAP_TLL_CHANNEL_CONF(i));
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+		if ((is_cdma_phone()) && (i == 2)) {
+			/* 0x1: UTMI-to-serial (FS/LS) mode:
+			 * To serial controller (TLL) or serial PHY */
 			omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) |
-				    1<<OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF_SHIFT,
-				    OMAP_TLL_CHANNEL_CONF(i));
-		else
-			omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) &
-				    ~(1<<OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF_SHIFT),
-				    OMAP_TLL_CHANNEL_CONF(i));
-
-		/* SDR/DDR */
-		if ((data->num_ports > i) &&
-		    (data->port_data[i].mode == OMAP_USB_PORT_MODE_ULPI_TLL_DDR))
+				(1<<OMAP_TLL_CHANNEL_CONF_CHANMODE_SHIFT),
+				OMAP_TLL_CHANNEL_CONF(i));
+			/* 0x3: "4-pin" bidirectional PHY i/f mode. */
 			omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) |
-				    (1<<OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE_SHIFT),
-				    OMAP_TLL_CHANNEL_CONF(i));
-		else
-			omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) &
-				    ~(1<<OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE_SHIFT),
-				    OMAP_TLL_CHANNEL_CONF(i));
+				(3<<OMAP_TLL_CHANNEL_CONF_FSLSMODE_SHIFT),
+				OMAP_TLL_CHANNEL_CONF(i));
+		}
+#endif /* CONFIG_USB_OHCI_HCD or CONFIG_USB_OHCI_HCD_MODULE */
+
 	}
 
 	/* Program Common TLL register */
@@ -320,50 +202,35 @@ static void omap_usb_setup_ports(struct usb_hcd *hcd)
 			(0 << OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN_SHFT),
 				OMAP_TLL_SHARED_CONF);
 
-	/* Enable channels */
+	/* Enable channels now */
 	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		u32 channel_conf;
 
-		if ((data->num_ports <= i) ||
-		   !(data->port_data[i].flags & OMAP_USB_PORT_FLAG_ENABLED)) {
-			dev_dbg(hcd->self.controller,
-				"port %d disabled. skipping.\n", i);
+		/* Enable only the channel that is needed */
+		if (!(tll_channel_mask & 1<<i))
 			continue;
-		}
-
-		channel_conf = omap_readl(OMAP_TLL_CHANNEL_CONF(i));
-		channel_conf |= 1<<OMAP_TLL_CHANNEL_CONF_CHANEN_SHIFT;
-
-		if (omap_usb_port_ttl_chanel_config(data->port_data[i].mode))
-			channel_conf |= 1<<OMAP_TLL_CHANNEL_CONF_CHANMODE_SHIFT;
-		else
-			channel_conf &= ~(3<<OMAP_TLL_CHANNEL_CONF_CHANMODE_SHIFT);
 
-		channel_conf &= ~(OMAP_TLL_CHANNEL_CONF_FSLSMODE(0xf));
-		channel_conf |= OMAP_TLL_CHANNEL_CONF_FSLSMODE(
-			omap_usb_port_fslsmode(data->port_data[i].mode));
-
-
-		omap_writel(channel_conf, OMAP_TLL_CHANNEL_CONF(i));
-		dev_dbg(hcd->self.controller,
-			"port %d enabled: OMAP_TTL_CHANNEL_CONF_%d=%08x\n",
-			i, i+1, omap_readl(OMAP_TLL_CHANNEL_CONF(i)));
+		omap_writel(omap_readl(OMAP_TLL_CHANNEL_CONF(i)) |
+			    (1<<OMAP_TLL_CHANNEL_CONF_CHANEN_SHIFT),
+			    OMAP_TLL_CHANNEL_CONF(i));
 
 		omap_writeb(0xBE, OMAP_TLL_ULPI_SCRATCH_REGISTER(i));
-		dev_dbg(hcd->self.controller, "ULPI_SCRATCH_REG[ch=%d]"
+		dev_dbg(hcd->self.controller, "\nULPI_SCRATCH_REG[ch=%d]"
 			"= 0x%02x\n",
 			i+1, omap_readb(OMAP_TLL_ULPI_SCRATCH_REGISTER(i)));
 	}
 }
 
+#else
+# define omap_usb_utmi_init(x, y)	0
+#endif
+
+
 /* omap_start_ehc
- *	- Start the TI USBHOST controller
+ * 	- Start the TI USBHOST controller
  */
 static int omap_start_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 {
 	struct ehci_omap_clock_defs *ehci_clocks;
-	struct omap_usb_platform_data *data = dev->dev.platform_data;
-	int i, r, reset_delay;
 
 	dev_dbg(hcd->self.controller, "starting TI EHCI USB Controller\n");
 
@@ -371,45 +238,6 @@ static int omap_start_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 				((char *)hcd_to_ehci(hcd)) +
 					sizeof(struct ehci_hcd));
 
-	/* Start DPLL5 Programming:
-	 * Clock Framework is not doing this now:
-	 * This will be done in clock framework later
-	 */
-	/* Enable DPLL 5 : Based on Input of 13Mhz*/
-	cm_write_mod_reg((12 << OMAP3430ES2_PERIPH2_DPLL_DIV_SHIFT)|
-			(120 << OMAP3430ES2_PERIPH2_DPLL_MULT_SHIFT),
-			PLL_MOD, OMAP3430ES2_CM_CLKSEL4);
-
-	cm_write_mod_reg(1 << OMAP3430ES2_DIV_120M_SHIFT,
-			PLL_MOD, OMAP3430ES2_CM_CLKSEL5);
-
-	cm_write_mod_reg((7 << OMAP3430ES2_PERIPH2_DPLL_FREQSEL_SHIFT) |
-			(7 << OMAP3430ES2_EN_PERIPH2_DPLL_SHIFT),
-			PLL_MOD, OMAP3430ES2_CM_CLKEN2);
-
-	while (!(cm_read_mod_reg(PLL_MOD, CM_IDLEST2) &
-				OMAP3430ES2_ST_PERIPH2_CLK_MASK))
-		dev_dbg(hcd->self.controller,
-			"idlest2 = 0x%x\n",
-			cm_read_mod_reg(PLL_MOD, CM_IDLEST2));
-	/* End DPLL5 programming */
-
-
-	/* PRCM settings for USBHOST:
-	 * Interface clk un-related to domain transition
-	 */
-	cm_write_mod_reg(0 << OMAP3430ES2_AUTO_USBHOST_SHIFT,
-				OMAP3430ES2_USBHOST_MOD, CM_AUTOIDLE);
-
-	/* Disable sleep dependency with MPU and IVA */
-	cm_write_mod_reg((0 << OMAP3430ES2_EN_MPU_SHIFT) |
-				(0 << OMAP3430ES2_EN_IVA2_SHIFT),
-				OMAP3430ES2_USBHOST_MOD, OMAP3430_CM_SLEEPDEP);
-
-	/* Disable Automatic transition of clock */
-	cm_write_mod_reg(0 << OMAP3430ES2_CLKTRCTRL_USBHOST_SHIFT,
-				OMAP3430ES2_USBHOST_MOD, CM_CLKSTCTRL);
-
 	/* Enable Clocks for USBHOST */
 	ehci_clocks->usbhost_ick_clk = clk_get(&dev->dev,
 						USBHOST_ICKL);
@@ -420,41 +248,83 @@ static int omap_start_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 
 	ehci_clocks->usbhost2_120m_fck_clk = clk_get(&dev->dev,
 							USBHOST_120M_FCLK);
-	if (IS_ERR(ehci_clocks->usbhost2_120m_fck_clk))
+	if (IS_ERR(ehci_clocks->usbhost2_120m_fck_clk)) {
+		clk_disable(ehci_clocks->usbhost_ick_clk);
+		clk_put(ehci_clocks->usbhost_ick_clk);
 		return PTR_ERR(ehci_clocks->usbhost2_120m_fck_clk);
+	}
 	clk_enable(ehci_clocks->usbhost2_120m_fck_clk);
 
 	ehci_clocks->usbhost1_48m_fck_clk = clk_get(&dev->dev,
 						USBHOST_48M_FCLK);
-	if (IS_ERR(ehci_clocks->usbhost1_48m_fck_clk))
+	if (IS_ERR(ehci_clocks->usbhost1_48m_fck_clk)) {
+		clk_disable(ehci_clocks->usbhost_ick_clk);
+		clk_put(ehci_clocks->usbhost_ick_clk);
+		clk_disable(ehci_clocks->usbhost2_120m_fck_clk);
+		clk_put(ehci_clocks->usbhost2_120m_fck_clk);
 		return PTR_ERR(ehci_clocks->usbhost1_48m_fck_clk);
+	}
 	clk_enable(ehci_clocks->usbhost1_48m_fck_clk);
 
-	reset_delay = 0;
-	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		if ((data->num_ports > i) && (data->port_data[i].startup)) {
-			reset_delay = reset_delay > data->port_data[i].reset_delay ?
-				reset_delay : data->port_data[i].reset_delay;
-			r = data->port_data[i].startup(dev, i);
-			if (r < 0)
-				return r;
-		}
-	}
-	if (reset_delay)
-		udelay(reset_delay);
+
+#ifdef EXTERNAL_PHY_RESET
+	/* Refer: ISSUE1 */
+#ifndef CONFIG_MACH_MAPPHONE
+	omap_request_gpio(EXT_PHY_RESET_GPIO_PORT1);
+	omap_set_gpio_direction(EXT_PHY_RESET_GPIO_PORT1, 0);
+	omap_request_gpio(EXT_PHY_RESET_GPIO_PORT2);
+	omap_set_gpio_direction(EXT_PHY_RESET_GPIO_PORT2, 0);
+	omap_set_gpio_dataout(EXT_PHY_RESET_GPIO_PORT1, 1);
+	omap_set_gpio_dataout(EXT_PHY_RESET_GPIO_PORT2, 1);
+#elif defined(CONFIG_MOT_FEAT_GPIO_API)
+        if (gpio_request(GPIO_SIGNAL_USB_IPC_RESET_PHY, NULL) < 0)
+            printk(KERN_ERR "can't get EXT_PHY_RESET_GPIO_PORT pin.\n");
+        if (gpio_direction_output(GPIO_SIGNAL_USB_IPC_RESET_PHY, 0) != 0)
+            printk(KERN_ERR "can't set EXT_PHY_RESET_GPIO_PORT pin direction output LOW.\n");
+#else
+	omap_request_gpio(EXT_PHY_RESET_GPIO_PORT);
+	omap_set_gpio_direction(EXT_PHY_RESET_GPIO_PORT, 0);
+	omap_set_gpio_dataout(EXT_PHY_RESET_GPIO_PORT, 0);
+#endif
+	/* Hold the PHY in RESET for enough time till DIR is high */
+	udelay(EXT_PHY_RESET_DELAY);
+#endif
 
 	/* Configure TLL for 60Mhz clk for ULPI */
 	ehci_clocks->usbtll_fck_clk = clk_get(&dev->dev, USBHOST_TLL_FCLK);
-	if (IS_ERR(ehci_clocks->usbtll_fck_clk))
+	if (IS_ERR(ehci_clocks->usbtll_fck_clk)) {
+		clk_disable(ehci_clocks->usbhost_ick_clk);
+		clk_put(ehci_clocks->usbhost_ick_clk);
+		clk_disable(ehci_clocks->usbhost2_120m_fck_clk);
+		clk_put(ehci_clocks->usbhost2_120m_fck_clk);
+		clk_disable(ehci_clocks->usbhost1_48m_fck_clk);
+		clk_put(ehci_clocks->usbhost1_48m_fck_clk);
 		return PTR_ERR(ehci_clocks->usbtll_fck_clk);
+	}
 	clk_enable(ehci_clocks->usbtll_fck_clk);
 
 	ehci_clocks->usbtll_ick_clk = clk_get(&dev->dev, USBHOST_TLL_ICKL);
-	if (IS_ERR(ehci_clocks->usbtll_ick_clk))
+	if (IS_ERR(ehci_clocks->usbtll_ick_clk)) {
+		clk_disable(ehci_clocks->usbhost_ick_clk);
+		clk_put(ehci_clocks->usbhost_ick_clk);
+		clk_disable(ehci_clocks->usbhost2_120m_fck_clk);
+		clk_put(ehci_clocks->usbhost2_120m_fck_clk);
+		clk_disable(ehci_clocks->usbhost1_48m_fck_clk);
+		clk_put(ehci_clocks->usbhost1_48m_fck_clk);
+		clk_disable(ehci_clocks->usbtll_fck_clk);
+		clk_put(ehci_clocks->usbtll_fck_clk);
 		return PTR_ERR(ehci_clocks->usbtll_ick_clk);
+	}
 	clk_enable(ehci_clocks->usbtll_ick_clk);
 
-	/* Enable Auto Idle of USBTLL */
+	usbtll_fclk_enabled = 1;
+	usbhost_fclk_enabled = 1;
+
+	ehci_clocks->suspended = 0; /* Superfluous! */
+
+	/* Disable Auto Idle of USBTLL */
+	/* Changed to enable autoidle so that core can transition
+	 * automatically */
 	cm_write_mod_reg((1 << OMAP3430ES2_AUTO_USBTLL_SHIFT),
 				CORE_MOD, CM_AUTOIDLE3);
 
@@ -474,55 +344,91 @@ static int omap_start_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 	dev_dbg(hcd->self.controller, "TLL RESET DONE\n");
 
 	/* Smart Idle mode */
-	omap_writel((1 << OMAP_USBTLL_SYSCONFIG_ENAWAKEUP_SHIFT) |
+	omap_writel((1 << OMAP_USBTLL_SYSCONFIG_ENAWAKEUP_SHIFT)     |
 			(2 << OMAP_USBTLL_SYSCONFIG_SIDLEMODE_SHIFT) |
 			(0 << OMAP_USBTLL_SYSCONFIG_CACTIVITY_SHIFT) |
 			(1 << OMAP_USBTLL_SYSCONFIG_AUTOIDLE_SHIFT),
 			OMAP_USBTLL_SYSCONFIG);
 
-	/* Put UHH in SmartIdle/SmartStandby mode */
-	omap_writel((1 << OMAP_UHH_SYSCONFIG_AUTOIDLE_SHIFT) |
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	if (is_cdma_phone()) {
+		/* Put UHH in NoIdle/NoStandby mode */
+		omap_writel((0 << OMAP_UHH_SYSCONFIG_AUTOIDLE_SHIFT) |
+			(1 << OMAP_UHH_SYSCONFIG_ENAWAKEUP_SHIFT) |
+			(1 << OMAP_UHH_SYSCONFIG_SIDLEMODE_SHIFT) |
+			(1 << OMAP_UHH_SYSCONFIG_CACTIVITY_SHIFT) |
+			(1 << OMAP_UHH_SYSCONFIG_MIDLEMODE_SHIFT),
+			OMAP_UHH_SYSCONFIG);
+	} else {
+#endif
+		/* Put UHH in SmartIdle/SmartStandby mode */
+		omap_writel((1 << OMAP_UHH_SYSCONFIG_AUTOIDLE_SHIFT) |
 			(1 << OMAP_UHH_SYSCONFIG_ENAWAKEUP_SHIFT) |
 			(2 << OMAP_UHH_SYSCONFIG_SIDLEMODE_SHIFT) |
 			(0 << OMAP_UHH_SYSCONFIG_CACTIVITY_SHIFT) |
 			(2 << OMAP_UHH_SYSCONFIG_MIDLEMODE_SHIFT),
 			OMAP_UHH_SYSCONFIG);
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	}
+#endif
 
-	omap_usb_setup_ports(hcd);
 
-	reset_delay = 0;
-	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		if (data->num_ports > i)
-			reset_delay = reset_delay > data->port_data[i].reset_delay ?
-				reset_delay : data->port_data[i].reset_delay;
-	}
-	if (reset_delay)
-		udelay(reset_delay);
+#ifdef CONFIG_OMAP_EHCI_PHY_MODE
+	/* Bypass the TLL module for PHY mode operation */
+	omap_writel((0 << OMAP_UHH_HOSTCONFIG_P1_ULPI_BYPASS_SHIFT)|
+						(0 << OMAP_UHH_HOSTCONFIG_P2_ULPI_BYPASS_SHIFT)
+						(1<<OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN_SHIFT)|
+						(1<<OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN_SHIFT)|
+						(1<<OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN_SHIFT)|
+						(0<<OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN_SHIFT),
+						OMAP_UHH_HOSTCONFIG);
+	/* Ensure that BYPASS is set */
+	while (omap_readl(OMAP_UHH_HOSTCONFIG) &
+	       ((1 << OMAP_UHH_HOSTCONFIG_P1_ULPI_BYPASS_SHIFT) | (1 << OMAP_UHH_HOSTCONFIG_P2_ULPI_BYPASS_SHIFT)))
+		cpu_relax();
 
-	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		if ((data->num_ports > i) && (data->port_data[i].reset))
-			data->port_data[i].reset(dev, i, 1);
-	}
+	dev_dbg(hcd->self.controller, "Entered ULPI PHY MODE: success\n");
 
-	if (data->flags & OMAP_USB_FLAG_VBUS_INTERNAL_CHARGEPUMP) {
-		/* Refer ISSUE2: LINK assumes external charge pump */
+#else
+	/* Enable UTMI mode for all 3 TLL channels */
+	omap_usb_utmi_init(hcd,
+		OMAP_TLL_CHANNEL_3_EN_MASK
+		);
+#endif
 
-		/* use Port1 VBUS to charge externally Port2:
-		 *	So for PHY mode operation use Port2 only
-		 */
-		omap_writel((0xA << EHCI_INSNREG05_ULPI_REGADD_SHIFT) |/* OTG ctrl reg*/
-			    (2 << EHCI_INSNREG05_ULPI_OPSEL_SHIFT) |/*   Write */
-			    (1 << EHCI_INSNREG05_ULPI_PORTSEL_SHIFT) |/* Port1 */
-			    (1 << EHCI_INSNREG05_ULPI_CONTROL_SHIFT) |/* Start */
-			    (0x26),
-			    EHCI_INSNREG05_ULPI);
-
-		while (!(omap_readl(EHCI_INSNREG05_ULPI)
-			 & (1<<EHCI_INSNREG05_ULPI_CONTROL_SHIFT)))
-			cpu_relax();
-	}
+#ifdef EXTERNAL_PHY_RESET
+	/* Refer ISSUE1:
+	 * Hold the PHY in RESET for enough time till PHY is settled and ready
+	 */
+	udelay(EXT_PHY_RESET_DELAY);
+#ifndef CONFIG_MACH_MAPPHONE
+	omap_set_gpio_dataout(EXT_PHY_RESET_GPIO_PORT1, 0);
+	omap_set_gpio_dataout(EXT_PHY_RESET_GPIO_PORT2, 0);
+#elif defined(CONFIG_MOT_FEAT_GPIO_API)
+        gpio_set_value(GPIO_SIGNAL_USB_IPC_RESET_PHY, 1);
+#else
+        omap_set_gpio_dataout(EXT_PHY_RESET_GPIO_PORT, 1);
+#endif /* CONFIG_MACH_MAPPHONE */
+#endif
 
-	return 0;
+#if defined(CONFIG_MACH_MAPPHONE)
+	/* Refer ISSUE2: LINK assumes external charge pump */
+
+	/* use Port1 VBUS to charge externally Port2:
+	 * 	So for PHY mode operation use Port2 only
+	 */
+        omap_writel((0xA << EHCI_INSNREG05_ULPI_REGADD_SHIFT) |/* OTG ctrl reg*/
+                        (2 << EHCI_INSNREG05_ULPI_OPSEL_SHIFT) |/*   Write */
+                        (2 << EHCI_INSNREG05_ULPI_PORTSEL_SHIFT) |/* Port1 */
+                        (1 << EHCI_INSNREG05_ULPI_CONTROL_SHIFT) |/* Start */
+                        (0x26),
+                        EHCI_INSNREG05_ULPI);
+
+	while (!(omap_readl(EHCI_INSNREG05_ULPI) &
+		(1<<EHCI_INSNREG05_ULPI_CONTROL_SHIFT)));
+#endif /* CONFIG_MACH_MAPPHONE */
+
+        return 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -530,8 +436,6 @@ static int omap_start_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 static void omap_stop_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 {
 	struct ehci_omap_clock_defs *ehci_clocks;
-	struct omap_usb_platform_data *data = dev->dev.platform_data;
-	int i;
 
 	ehci_clocks = (struct ehci_omap_clock_defs *)
 			(((char *)hcd_to_ehci(hcd)) + sizeof(struct ehci_hcd));
@@ -561,6 +465,8 @@ static void omap_stop_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 		ehci_clocks->usbtll_fck_clk = NULL;
 	}
 
+	usbtll_fclk_enabled = 0;
+
 	if (ehci_clocks->usbhost_ick_clk != NULL) {
 		clk_disable(ehci_clocks->usbhost_ick_clk);
 		clk_put(ehci_clocks->usbhost_ick_clk);
@@ -585,10 +491,11 @@ static void omap_stop_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 		ehci_clocks->usbtll_ick_clk = NULL;
 	}
 
-	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
-		if ((data->num_ports > i) && (data->port_data[i].shutdown))
-			data->port_data[i].shutdown(dev, i);
-	}
+
+#ifdef EXTERNAL_PHY_RESET
+	omap_free_gpio(EXT_PHY_RESET_GPIO_PORT1);
+	omap_free_gpio(EXT_PHY_RESET_GPIO_PORT2);
+#endif
 
 	dev_dbg(hcd->self.controller,
 		"Clock to USB host has been disabled\n");
@@ -597,6 +504,274 @@ static void omap_stop_ehc(struct platform_device *dev, struct usb_hcd *hcd)
 static const struct hc_driver ehci_omap_hc_driver;
 
 /*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_PM
+#define OHCI_BASE_ADDR 0x48064400
+#define OHCI_HC_CONTROL		(OHCI_BASE_ADDR + 0x4)
+#define OHCI_HC_CTRL_SUSPEND	(3 << 6)
+#define OHCI_HC_CTRL_RESUME	(1 << 6)
+
+static int omap_ehci_bus_suspend(struct usb_hcd *hcd)
+{
+	struct ehci_omap_clock_defs *ehci_clocks;
+	int ret = 0;
+	unsigned long flags;
+	u32 status;
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+#if defined(CONFIG_ARCH_OMAP34XX)
+	int res = 0;
+	struct omap_usb_platform_data *config = hcd->self.controller->platform_data;
+#endif
+	/* mask interrupt 77 to avoid race condition with ehci_irq */
+	omap_writel(0x2000, 0x482000cc);
+
+	ehci_clocks = (struct ehci_omap_clock_defs *)
+			(((char *)hcd_to_ehci(hcd)) + sizeof(struct ehci_hcd));
+	ret = ehci_bus_suspend(hcd);
+	if (ret < 0)
+		goto end;
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	if (!is_cdma_phone() && !ehci_clocks->suspended) {
+#else
+	if (!ehci_clocks->suspended) {
+#endif
+		/* We need to suspend OHCI as well, before the domain
+		 * can transition
+		 */
+		omap_writel(OHCI_HC_CTRL_SUSPEND, OHCI_HC_CONTROL);
+		mdelay(8); /* MSTANDBY assertion is delayed by ~8ms */
+
+#if defined(CONFIG_ARCH_OMAP34XX)
+		if (config->usbhost_standby_status)
+			res = config->usbhost_standby_status();
+
+		if (res == 0) {
+			printk(KERN_ERR "ehci: suspend failed!\n");
+			ehci_bus_resume(hcd);
+			ret = -EBUSY;
+			goto end;
+		}
+#endif
+
+		/* Ports suspended: Stop All Clks */
+#if 0
+		/* ICKs are Autoidled. No need for explicit control*/
+		clk_disable(ehci_clocks->usbhost_ick_clk);
+		clk_disable(ehci_clocks->usbtll_ick_clk);
+#endif
+		spin_lock_irqsave(&usbtll_clock_lock, flags);
+		status = ehci_readl(ehci, &ehci->regs->status);
+		if (status & INTR_MASK) {
+			/* pending irq, resume */
+			ret = -EBUSY;
+			goto resume;
+		}
+		omap_writel(omap_readl(OMAP_TLL_SHARED_CONF) & ~(1),
+				OMAP_TLL_SHARED_CONF);
+/* Enable the interrupt so that the remote-wakeup can be detected */
+#ifdef CONFIG_MOT_FEAT_IPC_CORERETENTION
+                if (disable_irq_value)
+                  {
+                    omap_writel(6, OMAP_USBTLL_IRQSTATUS);
+                    omap_writel(0, OMAP_USBTLL_IRQENABLE);
+                    printk("disable usbtll irq in omap_ehci_bus_suspend()\n");
+                  }
+                else
+                  {
+#endif
+                    omap_writel(7, OMAP_USBTLL_IRQSTATUS);
+                    omap_writel(1, OMAP_USBTLL_IRQENABLE);
+#ifdef CONFIG_MOT_FEAT_IPC_CORERETENTION
+                  }
+#endif
+		ehci_clocks->suspended = 1;
+		usbtll_fclk_enabled = 0;
+		clk_disable(ehci_clocks->usbhost1_48m_fck_clk);
+		clk_disable(ehci_clocks->usbhost2_120m_fck_clk);
+		clk_disable(ehci_clocks->usbtll_fck_clk);
+		spin_unlock_irqrestore(&usbtll_clock_lock, flags);
+	}
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_unlock(&ehci->wake_lock_ehci_pm);
+#endif
+	goto end;
+
+resume:
+	omap_writel(OHCI_HC_CTRL_RESUME, OHCI_HC_CONTROL);
+	spin_unlock_irqrestore(&usbtll_clock_lock, flags);
+	ehci_bus_resume(hcd);
+
+end:
+	/* unmask irq 77 */
+	omap_writel(0x2000, 0x482000c8);
+	return ret;
+}
+
+static int omap_ehci_bus_resume(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci;
+	struct ehci_omap_clock_defs *ehci_clocks;
+	int ret = 0;
+	unsigned long flags;
+
+	ehci = hcd_to_ehci(hcd);
+	ehci_clocks = (struct ehci_omap_clock_defs *)
+			(((char *)hcd_to_ehci(hcd)) + sizeof(struct ehci_hcd));
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock(&ehci->wake_lock_ehci_pm);
+#endif
+	spin_lock_irqsave(&usbtll_clock_lock, flags);
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	if (!is_cdma_phone() && ehci_clocks->suspended) {
+#else
+	if (ehci_clocks->suspended) {
+#endif
+		/* Enable clks before accessing the controller */
+#if 0
+		/* ICLKs are Autoidled. No need for explicit control */
+		clk_enable(ehci_clocks->usbtll_ick_clk);
+		clk_enable(ehci_clocks->usbhost_ick_clk);
+#endif
+/* If the host initiated this resume, then the TLL handler may not get called
+ * so the clock will need to be turned on explicitly
+ */
+		if (!usbtll_fclk_enabled) {
+			clk_enable(ehci_clocks->usbtll_fck_clk);
+			/* Disable usbtll irq to prevent race condition */
+			omap_writel(7, OMAP_USBTLL_IRQSTATUS);
+			omap_writel(0, OMAP_USBTLL_IRQENABLE);
+			omap_writel(1 | omap_readl(OMAP_TLL_SHARED_CONF),
+					OMAP_TLL_SHARED_CONF);
+			usbtll_fclk_enabled = 1;
+			clk_enable(ehci_clocks->usbhost2_120m_fck_clk);
+			clk_enable(ehci_clocks->usbhost1_48m_fck_clk);
+			omap_writel(OHCI_HC_CTRL_RESUME, OHCI_HC_CONTROL);
+			ehci_clocks->suspended = 0;
+		}
+	}
+	spin_unlock_irqrestore(&usbtll_clock_lock, flags);
+	/* Wakeup ports by resume */
+	ret = ehci_bus_resume(hcd);
+
+	return ret;
+}
+static void omap_ehci_shutdown(struct usb_hcd *hcd)
+{
+	struct ehci_omap_clock_defs *ehci_clocks;
+	unsigned long flags;
+
+	ehci_clocks = (struct ehci_omap_clock_defs *)
+			((char *)hcd_to_ehci(hcd) + sizeof(struct ehci_hcd));
+	spin_lock_irqsave(&usbtll_clock_lock, flags);
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+	if (!is_cdma_phone() && ehci_clocks->suspended) {
+#else
+	if (ehci_clocks->suspended) {
+#endif
+
+#if 0
+		/* ICLKs are Autoidled. No need for explicit control */
+		clk_enable(ehci_clocks->usbtll_ick_clk);
+		clk_enable(ehci_clocks->usbhost_ick_clk);
+#endif
+		if (!usbtll_fclk_enabled) {
+			clk_enable(ehci_clocks->usbtll_fck_clk);
+			usbtll_fclk_enabled = 1;
+		}
+		clk_enable(ehci_clocks->usbhost1_48m_fck_clk);
+		clk_enable(ehci_clocks->usbhost2_120m_fck_clk);
+		ehci_clocks->suspended = 0;
+	}
+	spin_unlock_irqrestore(&usbtll_clock_lock, flags);
+	ehci_shutdown(hcd);
+}
+
+#endif
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ehci_omap_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "OMAP-EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd)
+				+ sizeof(struct ehci_omap_clock_defs),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_init,
+	.start = ehci_run,
+	.stop = ehci_stop,
+#ifdef CONFIG_PM
+	.shutdown = omap_ehci_shutdown,
+#else
+	.shutdown = ehci_shutdown,
+#endif
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend = omap_ehci_bus_suspend,
+	.bus_resume = omap_ehci_bus_resume,
+#endif
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+};
+
+static irqreturn_t usbtll_irq(int irq, void *tll)
+{
+	u32 usbtll_irqstatus;
+	struct ehci_omap_clock_defs *ehci_clocks;
+	struct ehci_hcd *ehci = hcd_to_ehci(ghcd);
+	ehci_clocks = (struct ehci_omap_clock_defs *)
+			((char *)hcd_to_ehci(ghcd) + sizeof(struct ehci_hcd));
+
+	usbtll_irqstatus = omap_readl(OMAP_USBTLL_IRQSTATUS);
+
+	if (usbtll_irqstatus & 1) {
+#ifdef CONFIG_HAS_WAKELOCK
+		wake_lock_timeout(&ehci->wake_lock_ehci_rwu, HZ/2);
+#endif
+		clk_enable(ehci_clocks->usbtll_fck_clk);
+		usbtll_fclk_enabled = 1;
+		/* Disable usbtll irq to prevent race condition in suspend */
+		omap_writel(1 | omap_readl(OMAP_TLL_SHARED_CONF),
+				OMAP_TLL_SHARED_CONF);
+		omap_writel(usbtll_irqstatus, OMAP_USBTLL_IRQSTATUS);
+		clk_enable(ehci_clocks->usbhost1_48m_fck_clk);
+		clk_enable(ehci_clocks->usbhost2_120m_fck_clk);
+		omap_writel(OHCI_HC_CTRL_RESUME, OHCI_HC_CONTROL);
+		ehci_clocks->suspended = 0;
+		omap_writel(0, OMAP_USBTLL_IRQENABLE);
+	}
+
+	return IRQ_HANDLED;
+}
+/*-------------------------------------------------------------------------*/
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
 
@@ -620,15 +795,27 @@ static int ehci_hcd_omap_drv_probe(struct platform_device *dev)
 	if (usb_disabled())
 		return -ENODEV;
 
+	retval = request_irq(78, usbtll_irq, IRQF_DISABLED | IRQF_SHARED,
+			"usbtll", &dev->dev);
+
+	if (retval < 0) {
+		printk(KERN_ERR "\nCan't get USBTLL IRQ\n");
+		return -ENODEV;
+	}
 	if (dev->resource[1].flags != IORESOURCE_IRQ) {
 		dev_dbg(&dev->dev, "resource[1] is not IORESOURCE_IRQ\n");
 		retval = -ENOMEM;
 	}
+#ifdef CONFIG_MOT_FEAT_IPC_CORERETENTION
+        retval = sysfs_create_file(power_kobj, &usbtll_disable_irq_attr.attr);
+        if (retval)
+          printk("create usbtll_disable_irq_attr failed\n");
+        else
+          printk("create usbtll_disable_irq_attr successfully\n");
+#endif
 
-	if (dev->dev.platform_data == NULL)
-		dev->dev.platform_data = &default_usb_platform_data;
-
-	hcd = usb_create_hcd(&ehci_omap_hc_driver, &dev->dev, dev->dev.bus_id);
+	ghcd = hcd = usb_create_hcd(&ehci_omap_hc_driver,
+					&dev->dev, dev->dev.bus_id);
 	if (!hcd)
 		return -ENOMEM;
 
@@ -649,10 +836,19 @@ static int ehci_hcd_omap_drv_probe(struct platform_device *dev)
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = hcd->regs;
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_init(&ehci->wake_lock_ehci_rwu,
+			WAKE_LOCK_SUSPEND, "ehci_rwu");
+	wake_lock_init(&ehci->wake_lock_ehci_pm,
+			WAKE_LOCK_SUSPEND, "ehci_pm");
+#endif
 
 	ehci->sbrn = 0x20;
 
 	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = readl(&ehci->caps->hcs_params);
 
@@ -690,142 +886,59 @@ static int ehci_hcd_omap_drv_probe(struct platform_device *dev)
 static int ehci_hcd_omap_drv_remove(struct platform_device *dev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	struct ehci_omap_clock_defs *ehci_clocks;
+	struct ehci_hcd *ehci;
+	unsigned long flags;
 
-	dev_dbg(&dev->dev, "ehci_hcd_omap_drv_remove()\n");
-
-	iounmap(hcd->regs);
-	usb_remove_hcd(hcd);
-	usb_put_hcd(hcd);
-	omap_stop_ehc(dev, hcd);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int ehci_omap_bus_suspend(struct usb_hcd *hcd)
-{
-	int ret = 0;
-	dev_dbg(hcd->self.controller, "%s %ld %lu\n", __func__,
-		in_interrupt(), jiffies);
-	ret = ehci_bus_suspend(hcd);
-
-	if (ret)
-		return ret;
-
-	clk_disable(clk_get(NULL, "usbtll_fck"));
-	clk_disable(clk_get(NULL, "usbhost_120m_fck"));
-	clk_disable(clk_get(NULL, "usbhost_48m_fck"));
-
-	/* the omap usb host auto-idle is not fully functional,
-	 * manually enable/disable usbtll_ick during
-	 * the suspend/resume time.
-	 */
-	clk_disable(clk_get(NULL, "usbtll_ick"));
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	return ret;
-}
-
-static int ehci_omap_bus_resume(struct usb_hcd *hcd)
-{
-	int ret = 0;
-
-	dev_dbg(hcd->self.controller, "%s %ld %lu\n", __func__,
-	in_interrupt(), jiffies);
-
-	/* the omap usb host auto-idle is not fully functional,
-	 * manually enable/disable usbtll_ick during
-	 * the suspend/resume time.
-	 */
-	clk_enable(clk_get(NULL, "usbtll_ick"));
-	clk_enable(clk_get(NULL, "usbtll_fck"));
-	clk_enable(clk_get(NULL, "usbhost_120m_fck"));
-	clk_enable(clk_get(NULL, "usbhost_48m_fck"));
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-
-	/* Wakeup ports by resume */
-	ret = ehci_bus_resume(hcd);
-
-	return ret;
-}
+	ehci = hcd_to_ehci(hcd);
+	ehci_clocks = (struct ehci_omap_clock_defs *)
+			(((char *)hcd_to_ehci(hcd)) + sizeof(struct ehci_hcd));
 
-static void ehci_omap_shutdown(struct usb_hcd *hcd)
-{
-	dev_dbg(hcd->self.controller, "%s %lu\n", __func__, jiffies);
-	clk_enable(clk_get(NULL, "usbtll_fck"));
-	clk_enable(clk_get(NULL, "usbhost_120m_fck"));
-	clk_enable(clk_get(NULL, "usbhost_48m_fck"));
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-	ehci_shutdown(hcd);
-}
+	dev_dbg(&dev->dev, "ehci_hcd_omap_drv_remove()\n");
 
+	spin_lock_irqsave(&usbtll_clock_lock, flags);
+       if (ehci_clocks->suspended) {
+#if 0
+		/* ICLKs are Autoidled. No need for explicit control */
+		clk_enable(ehci_clocks->usbtll_ick_clk);
+		clk_enable(ehci_clocks->usbhost_ick_clk);
 #endif
+		/* Enable All F-clks now before accessing controller */
+		if (!usbtll_fclk_enabled) {
+			clk_enable(ehci_clocks->usbtll_fck_clk);
+			usbtll_fclk_enabled = 1;
+		}
+		clk_enable(ehci_clocks->usbhost1_48m_fck_clk);
+		clk_enable(ehci_clocks->usbhost2_120m_fck_clk);
+		ehci_clocks->suspended = 0;
+	}
+	spin_unlock_irqrestore(&usbtll_clock_lock, flags);
 
-
-static const struct hc_driver ehci_omap_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "OMAP-EHCI Host Controller",
-	.hcd_priv_size = sizeof(struct ehci_hcd)
-				+ sizeof(struct ehci_omap_clock_defs),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset = ehci_init,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_omap_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-#ifdef	CONFIG_PM
-	.bus_suspend = ehci_omap_bus_suspend,
-	.bus_resume = ehci_omap_bus_resume,
+#ifdef CONFIG_HAS_WAKELOCK
+	wake_lock_destroy(&ehci->wake_lock_ehci_rwu);
+	wake_lock_destroy(&ehci->wake_lock_ehci_pm);
 #endif
-};
 
-/*-------------------------------------------------------------------------*/
-#ifdef CONFIG_PM
-static int ehci_omap_suspend(struct platform_device *dev, pm_message_t message)
-{
-       return 0;
-}
+	iounmap(hcd->regs);
+	usb_remove_hcd(hcd);
+	omap_stop_ehc(dev, hcd);
+	usb_put_hcd(hcd);
 
-static int ehci_omap_resume(struct platform_device *dev, pm_message_t message)
-{
-       return 0;
-}
+#ifdef CONFIG_MOT_FEAT_IPC_CORERETENTION
+        sysfs_remove_file(power_kobj, &usbtll_disable_irq_attr.attr);
 #endif
 
+	return 0;
+}
 
+/*-------------------------------------------------------------------------*/
 MODULE_ALIAS("platform:omap-ehci");
 static struct platform_driver ehci_hcd_omap_driver = {
 	.probe = ehci_hcd_omap_drv_probe,
 	.remove = ehci_hcd_omap_drv_remove,
 	.shutdown = usb_hcd_platform_shutdown,
-	.suspend      = ehci_omap_suspend,
-	.resume       = ehci_omap_resume,
+	/*.suspend      = ehci_hcd_omap_drv_suspend, */
+	/*.resume       = ehci_hcd_omap_drv_resume, */
 	.driver = {
 		.name = "ehci-omap",
 		.bus = &platform_bus_type
diff --git a/drivers/usb/host/ehci-omap.h b/drivers/usb/host/ehci-omap.h
index 736421c..062265d 100644
--- a/drivers/usb/host/ehci-omap.h
+++ b/drivers/usb/host/ehci-omap.h
@@ -2,6 +2,7 @@
  * ehci-omap.h - register definitions for USBHOST in OMAP 34xx
  *
  * Copyright (C) 2007-2008 Texas Instruments, Inc.
+ * Copyright (C) 2009 Motorola, Inc.
  * 	Author: Vikram Pandita <vikram.pandita@ti.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -18,6 +19,13 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  *
+ *
+ * Revision History:
+ *
+ * Date         Author    Comment
+ * ----------   --------  ----------------------------
+ * 03/25/2009   Motorola  Define more USBHOST Registers
+ *
  */
 
 #ifndef __EHCI_OMAP_H
@@ -58,7 +66,6 @@
 
 #define	OMAP_TLL_CHANNEL_CONF(num)\
 			(OMAP_USBHOST_TLL_BASE + (0x040 + 0x004 * num))
-	#define	OMAP_TLL_CHANNEL_CONF_FSLSMODE(x)		(((x)&0xf)<<24)
 	#define	OMAP_TLL_CHANNEL_CONF_FSLSMODE_SHIFT		24
 	#define	OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF_SHIFT	11
 	#define	OMAP_TLL_CHANNEL_CONF_ULPI_ULPIAUTOIDLE_SHIFT	10
@@ -103,6 +110,9 @@
 	#define	OMAP_UHH_SYSCONFIG_AUTOIDLE_SHIFT	0
 
 #define	OMAP_UHH_SYSSTATUS	(OMAP_USBHOST_UHH_BASE + 0x14)
+	#define OMAP_UHH_SYSSTATUS_EHCI_RESETDONE_SHIFT	2
+	#define OMAP_UHH_SYSSTATUS_OHCI_RESETDONE_SHIFT	1
+	#define OMAP_UHH_SYSSTATUS_RESETDONE_SHIFT	0
 #define	OMAP_UHH_HOSTCONFIG	(OMAP_USBHOST_UHH_BASE + 0x40)
 	#define	OMAP_UHH_HOSTCONFIG_P1_ULPI_BYPASS_SHIFT	0
 	#define	OMAP_UHH_HOSTCONFIG_P2_ULPI_BYPASS_SHIFT	11
@@ -111,10 +121,6 @@
 	#define OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN_SHIFT	3
 	#define OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN_SHIFT	4
 	#define OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN_SHIFT	5
-	#define	OMAP_UHH_HOSTCONFIG_ULPI_BYPASS_MASK		\
-	((1<<OMAP_UHH_HOSTCONFIG_P1_ULPI_BYPASS_SHIFT) | \
-	 (1<<OMAP_UHH_HOSTCONFIG_P2_ULPI_BYPASS_SHIFT) | \
-	 (1<<OMAP_UHH_HOSTCONFIG_P3_ULPI_BYPASS_SHIFT))
 
 #define	OMAP_UHH_DEBUG_CSR	(OMAP_USBHOST_UHH_BASE + 0x44)
 
diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
index 9d48790..5416cf9 100644
--- a/drivers/usb/host/ehci-orion.c
+++ b/drivers/usb/host/ehci-orion.c
@@ -33,9 +33,8 @@
 /*
  * Implement Orion USB controller specification guidelines
  */
-static void orion_usb_phy_v1_setup(struct usb_hcd *hcd)
+static void orion_usb_setup(struct usb_hcd *hcd)
 {
-	/* The below GLs are according to the Orion Errata document */
 	/*
 	 * Clear interrupt cause and mask
 	 */
@@ -259,19 +258,9 @@ static int __init ehci_orion_drv_probe(struct platform_device *pdev)
 		ehci_orion_conf_mbus_windows(hcd, pd->dram);
 
 	/*
-	 * setup Orion USB controller.
+	 * setup Orion USB controller
 	 */
-	switch (pd->phy_version) {
-	case EHCI_PHY_NA:	/* dont change USB phy settings */
-		break;
-	case EHCI_PHY_ORION:
-		orion_usb_phy_v1_setup(hcd);
-		break;
-	case EHCI_PHY_DD:
-	case EHCI_PHY_KW:
-	default:
-		printk(KERN_WARNING "Orion ehci -USB phy version isn't supported.\n");
-	}
+	orion_usb_setup(hcd);
 
 	err = usb_add_hcd(hcd, irq, IRQF_SHARED | IRQF_DISABLED);
 	if (err)
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index abb9a77..36864f9 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -219,19 +219,15 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &ehci->sbrn);
 
-	/* Keep this around for a while just in case some EHCI
-	 * implementation uses legacy PCI PM support.  This test
-	 * can be removed on 17 Dec 2009 if the dev_warn() hasn't
-	 * been triggered by then.
+	/* Workaround current PCI init glitch:  wakeup bits aren't
+	 * being set from PCI PM capability.
 	 */
 	if (!device_can_wakeup(&pdev->dev)) {
 		u16	port_wake;
 
 		pci_read_config_word(pdev, 0x62, &port_wake);
-		if (port_wake & 0x0001) {
-			dev_warn(&pdev->dev, "Enabling legacy PCI PM\n");
-			device_set_wakeup_capable(&pdev->dev, 1);
-		}
+		if (port_wake & 0x0001)
+			device_init_wakeup(&pdev->dev, 1);
 	}
 
 #ifdef	CONFIG_USB_SUSPEND
diff --git a/drivers/usb/host/ehci-ppc-of.c b/drivers/usb/host/ehci-ppc-of.c
index ef732b7..b018dee 100644
--- a/drivers/usb/host/ehci-ppc-of.c
+++ b/drivers/usb/host/ehci-ppc-of.c
@@ -107,13 +107,11 @@ ehci_hcd_ppc_of_probe(struct of_device *op, const struct of_device_id *match)
 {
 	struct device_node *dn = op->node;
 	struct usb_hcd *hcd;
-	struct ehci_hcd	*ehci = NULL;
+	struct ehci_hcd	*ehci;
 	struct resource res;
 	int irq;
 	int rv;
 
-	struct device_node *np;
-
 	if (usb_disabled())
 		return -ENODEV;
 
@@ -151,20 +149,6 @@ ehci_hcd_ppc_of_probe(struct of_device *op, const struct of_device_id *match)
 	}
 
 	ehci = hcd_to_ehci(hcd);
-	np = of_find_compatible_node(NULL, NULL, "ibm,usb-ohci-440epx");
-	if (np != NULL) {
-		/* claim we really affected by usb23 erratum */
-		if (!of_address_to_resource(np, 0, &res))
-			ehci->ohci_hcctrl_reg = ioremap(res.start +
-					OHCI_HCCTRL_OFFSET, OHCI_HCCTRL_LEN);
-		else
-			pr_debug(__FILE__ ": no ohci offset in fdt\n");
-		if (!ehci->ohci_hcctrl_reg) {
-			pr_debug(__FILE__ ": ioremap for ohci hcctrl failed\n");
-		} else {
-			ehci->has_amcc_usb23 = 1;
-		}
-	}
 
 	if (of_get_property(dn, "big-endian", NULL)) {
 		ehci->big_endian_mmio = 1;
@@ -197,9 +181,6 @@ err_ioremap:
 	irq_dispose_mapping(irq);
 err_irq:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-
-	if (ehci->has_amcc_usb23)
-		iounmap(ehci->ohci_hcctrl_reg);
 err_rmr:
 	usb_put_hcd(hcd);
 
@@ -210,11 +191,6 @@ err_rmr:
 static int ehci_hcd_ppc_of_remove(struct of_device *op)
 {
 	struct usb_hcd *hcd = dev_get_drvdata(&op->dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-
-	struct device_node *np;
-	struct resource res;
-
 	dev_set_drvdata(&op->dev, NULL);
 
 	dev_dbg(&op->dev, "stopping PPC-OF USB Controller\n");
@@ -225,25 +201,6 @@ static int ehci_hcd_ppc_of_remove(struct of_device *op)
 	irq_dispose_mapping(hcd->irq);
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 
-	/* use request_mem_region to test if the ohci driver is loaded.  if so
-	 * ensure the ohci core is operational.
-	 */
-	if (ehci->has_amcc_usb23) {
-		np = of_find_compatible_node(NULL, NULL, "ibm,usb-ohci-440epx");
-		if (np != NULL) {
-			if (!of_address_to_resource(np, 0, &res))
-				if (!request_mem_region(res.start,
-							    0x4, hcd_name))
-					set_ohci_hcfs(ehci, 1);
-				else
-					release_mem_region(res.start, 0x4);
-			else
-				pr_debug(__FILE__ ": no ohci offset in fdt\n");
-			of_node_put(np);
-		}
-
-		iounmap(ehci->ohci_hcctrl_reg);
-	}
 	usb_put_hcd(hcd);
 
 	return 0;
diff --git a/drivers/usb/host/ehci-ppc-soc.c b/drivers/usb/host/ehci-ppc-soc.c
new file mode 100644
index 0000000..529590e
--- /dev/null
+++ b/drivers/usb/host/ehci-ppc-soc.c
@@ -0,0 +1,201 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 2006-2007 Stefan Roese <sr@denx.de>, DENX Software Engineering
+ *
+ * Bus Glue for PPC On-Chip EHCI driver
+ * Tested on AMCC 440EPx
+ *
+ * Based on "ehci-au1xxx.c" by K.Boge <karsten.boge@amd.com>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+
+extern int usb_disabled(void);
+
+/* called during probe() after chip reset completes */
+static int ehci_ppc_soc_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
+	int		retval;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci->sbrn = 0x20;
+	return ehci_reset(ehci);
+}
+
+/**
+ * usb_ehci_ppc_soc_probe - initialize PPC-SoC-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_ehci_ppc_soc_probe(const struct hc_driver *driver,
+			   struct usb_hcd **hcd_out,
+			   struct platform_device *dev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+
+	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+		pr_debug("resource[1] is not IORESOURCE_IRQ");
+		retval = -ENOMEM;
+	}
+	hcd = usb_create_hcd(driver, &dev->dev, "PPC-SOC EHCI");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		pr_debug("ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->big_endian_mmio = 1;
+	ehci->big_endian_desc = 1;
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+#if defined(CONFIG_440EPX)
+	/*
+	 * 440EPx Errata USBH_3
+	 * Fix: Enable Break Memory Transfer (BMT) in INSNREG3
+	 */
+	out_be32((void *)((ulong)(&ehci->regs->command) + 0x8c), (1 << 0));
+	ehci_dbg(ehci, "Break Memory Transfer (BMT) has beed enabled!\n");
+#endif
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED);
+	if (retval == 0)
+		return retval;
+
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_ehci_hcd_ppc_soc_remove - shutdown processing for PPC-SoC-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_ehci_hcd_ppc_soc_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_ehci_ppc_soc_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+static const struct hc_driver ehci_ppc_soc_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "PPC-SOC EHCI",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_ppc_soc_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+};
+
+static int ehci_hcd_ppc_soc_drv_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = NULL;
+	int ret;
+
+	pr_debug("In ehci_hcd_ppc_soc_drv_probe\n");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	/* FIXME we only want one one probe() not two */
+	ret = usb_ehci_ppc_soc_probe(&ehci_ppc_soc_hc_driver, &hcd, pdev);
+	return ret;
+}
+
+static int ehci_hcd_ppc_soc_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	/* FIXME we only want one one remove() not two */
+	usb_ehci_ppc_soc_remove(hcd, pdev);
+	return 0;
+}
+
+MODULE_ALIAS("platform:ppc-soc-ehci");
+static struct platform_driver ehci_ppc_soc_driver = {
+	.probe = ehci_hcd_ppc_soc_drv_probe,
+	.remove = ehci_hcd_ppc_soc_drv_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "ppc-soc-ehci",
+	}
+};
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index ecc9b66..3712b92 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1095,8 +1095,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	prev->qh_next = qh->qh_next;
 	wmb ();
 
-	/* If the controller isn't running, we don't have to wait for it */
-	if (unlikely(!HC_IS_RUNNING(ehci_to_hcd(ehci)->state))) {
+	if (unlikely (ehci_to_hcd(ehci)->state == HC_STATE_HALT)) {
 		/* if (unlikely (qh->reclaim != 0))
 		 *	this will recurse, probably not much
 		 */
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1d0b49e..a081ee6 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1004,8 +1004,7 @@ iso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)
 
 		is_in = (stream->bEndpointAddress & USB_DIR_IN) ? 0x10 : 0;
 		stream->bEndpointAddress &= 0x0f;
-		if (stream->ep)
-			stream->ep->hcpriv = NULL;
+		stream->ep->hcpriv = NULL;
 
 		if (stream->rescheduled) {
 			ehci_info (ehci, "ep%d%s-iso rescheduled "
@@ -1536,7 +1535,7 @@ itd_link_urb (
 					struct ehci_itd, itd_list);
 			list_move_tail (&itd->itd_list, &stream->td_list);
 			itd->stream = iso_stream_get (stream);
-			itd->urb = urb;
+			itd->urb = usb_get_urb (urb);
 			itd_init (ehci, stream, itd);
 		}
 
@@ -1645,7 +1644,7 @@ itd_complete (
 	(void) disable_periodic(ehci);
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
-	if (unlikely(list_is_singular(&stream->td_list))) {
+	if (unlikely (list_empty (&stream->td_list))) {
 		ehci_to_hcd(ehci)->self.bandwidth_allocated
 				-= stream->bandwidth;
 		ehci_vdbg (ehci,
@@ -1654,27 +1653,14 @@ itd_complete (
 			(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");
 	}
 	iso_stream_put (ehci, stream);
-
+	/* OK to recycle this ITD now that its completion callback ran. */
 done:
+	usb_put_urb(urb);
 	itd->urb = NULL;
-	if (ehci->clock_frame != itd->frame || itd->index[7] != -1) {
-		/* OK to recycle this ITD now. */
-		itd->stream = NULL;
-		list_move(&itd->itd_list, &stream->free_list);
-		iso_stream_put(ehci, stream);
-	} else {
-		/* HW might remember this ITD, so we can't recycle it yet.
-		 * Move it to a safe place until a new frame starts.
-		 */
-		list_move(&itd->itd_list, &ehci->cached_itd_list);
-		if (stream->refcount == 2) {
-			/* If iso_stream_put() were called here, stream
-			 * would be freed.  Instead, just prevent reuse.
-			 */
-			stream->ep->hcpriv = NULL;
-			stream->ep = NULL;
-		}
-	}
+	itd->stream = NULL;
+	list_move(&itd->itd_list, &stream->free_list);
+	iso_stream_put(ehci, stream);
+
 	return retval;
 }
 
@@ -1948,7 +1934,7 @@ sitd_link_urb (
 				struct ehci_sitd, sitd_list);
 		list_move_tail (&sitd->sitd_list, &stream->td_list);
 		sitd->stream = iso_stream_get (stream);
-		sitd->urb = urb;
+		sitd->urb = usb_get_urb (urb);
 
 		sitd_patch(ehci, stream, sitd, sched, packet);
 		sitd_link (ehci, (next_uframe >> 3) % ehci->periodic_size,
@@ -2033,7 +2019,7 @@ sitd_complete (
 	(void) disable_periodic(ehci);
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
-	if (list_is_singular(&stream->td_list)) {
+	if (list_empty (&stream->td_list)) {
 		ehci_to_hcd(ehci)->self.bandwidth_allocated
 				-= stream->bandwidth;
 		ehci_vdbg (ehci,
@@ -2044,6 +2030,7 @@ sitd_complete (
 	iso_stream_put (ehci, stream);
 	/* OK to recycle this SITD now that its completion callback ran. */
 done:
+	usb_put_urb(urb);
 	sitd->urb = NULL;
 	sitd->stream = NULL;
 	list_move(&sitd->sitd_list, &stream->free_list);
@@ -2114,20 +2101,6 @@ done:
 
 /*-------------------------------------------------------------------------*/
 
-static void free_cached_itd_list(struct ehci_hcd *ehci)
-{
-	struct ehci_itd *itd, *n;
-
-	list_for_each_entry_safe(itd, n, &ehci->cached_itd_list, itd_list) {
-		struct ehci_iso_stream	*stream = itd->stream;
-		itd->stream = NULL;
-		list_move(&itd->itd_list, &stream->free_list);
-		iso_stream_put(ehci, stream);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
 static void
 scan_periodic (struct ehci_hcd *ehci)
 {
@@ -2142,17 +2115,10 @@ scan_periodic (struct ehci_hcd *ehci)
 	 * Touches as few pages as possible:  cache-friendly.
 	 */
 	now_uframe = ehci->next_uframe;
-	if (HC_IS_RUNNING(ehci_to_hcd(ehci)->state)) {
+	if (HC_IS_RUNNING (ehci_to_hcd(ehci)->state))
 		clock = ehci_readl(ehci, &ehci->regs->frame_index);
-		clock_frame = (clock >> 3) % ehci->periodic_size;
-	} else  {
+	else
 		clock = now_uframe + mod - 1;
-		clock_frame = -1;
-	}
-	if (ehci->clock_frame != clock_frame) {
-		free_cached_itd_list(ehci);
-		ehci->clock_frame = clock_frame;
-	}
 	clock %= mod;
 	clock_frame = clock >> 3;
 
@@ -2311,10 +2277,6 @@ restart:
 			/* rescan the rest of this frame, then ... */
 			clock = now;
 			clock_frame = clock >> 3;
-			if (ehci->clock_frame != clock_frame) {
-				free_cached_itd_list(ehci);
-				ehci->clock_frame = clock_frame;
-			}
 		} else {
 			now_uframe++;
 			now_uframe %= mod;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 262b00c..c684b3c 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -19,6 +19,10 @@
 #ifndef __LINUX_EHCI_HCD_H
 #define __LINUX_EHCI_HCD_H
 
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+
 /* definitions used for the EHCI driver */
 
 /*
@@ -87,10 +91,6 @@ struct ehci_hcd {			/* one per controller */
 	int			next_uframe;	/* scan periodic, start here */
 	unsigned		periodic_sched;	/* periodic activity count */
 
-	/* list of itds completed while clock_frame was still active */
-	struct list_head	cached_itd_list;
-	unsigned		clock_frame;
-
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
 
@@ -103,8 +103,6 @@ struct ehci_hcd {			/* one per controller */
 			owned by the companion during a bus suspend */
 	unsigned long		port_c_suspend;		/* which ports have
 			the change-suspend feature turned on */
-	unsigned long		suspended_ports;	/* which ports are
-			suspended */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */
@@ -124,16 +122,6 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		has_fsl_port_bug:1; /* FreeScale */
 	unsigned		big_endian_mmio:1;
 	unsigned		big_endian_desc:1;
-	unsigned		has_amcc_usb23:1;
-
-	/* required for usb32 quirk */
-	#define OHCI_CTRL_HCFS          (3 << 6)
-	#define OHCI_USB_OPER           (2 << 6)
-	#define OHCI_USB_SUSPEND        (3 << 6)
-
-	#define OHCI_HCCTRL_OFFSET      0x4
-	#define OHCI_HCCTRL_LEN         0x4
-	__hc32			*ohci_hcctrl_reg;
 
 	u8			sbrn;		/* packed release number */
 
@@ -152,6 +140,12 @@ struct ehci_hcd {			/* one per controller */
 	struct dentry		*debug_periodic;
 	struct dentry		*debug_registers;
 #endif
+#ifdef CONFIG_HAS_WAKELOCK
+	struct wake_lock	wake_lock_ehci_rwu;
+					/* wakelock for remote wakeup */
+	struct wake_lock	wake_lock_ehci_pm;
+					/* wakelock for suspend/resume */
+#endif
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
@@ -224,11 +218,145 @@ timer_action (struct ehci_hcd *ehci, enum ehci_timer_action action)
 	}
 }
 
-static void free_cached_itd_list(struct ehci_hcd *ehci);
-
 /*-------------------------------------------------------------------------*/
 
-#include <linux/usb/ehci_def.h>
+/* EHCI register interface, corresponds to EHCI Revision 0.95 specification */
+
+/* Section 2.2 Host Controller Capability Registers */
+struct ehci_caps {
+	/* these fields are specified as 8 and 16 bit registers,
+	 * but some hosts can't perform 8 or 16 bit PCI accesses.
+	 */
+	u32		hc_capbase;
+#define HC_LENGTH(p)		(((p)>>00)&0x00ff)	/* bits 7:0 */
+#define HC_VERSION(p)		(((p)>>16)&0xffff)	/* bits 31:16 */
+	u32		hcs_params;     /* HCSPARAMS - offset 0x4 */
+#define HCS_DEBUG_PORT(p)	(((p)>>20)&0xf)	/* bits 23:20, debug port? */
+#define HCS_INDICATOR(p)	((p)&(1 << 16))	/* true: has port indicators */
+#define HCS_N_CC(p)		(((p)>>12)&0xf)	/* bits 15:12, #companion HCs */
+#define HCS_N_PCC(p)		(((p)>>8)&0xf)	/* bits 11:8, ports per CC */
+#define HCS_PORTROUTED(p)	((p)&(1 << 7))	/* true: port routing */
+#define HCS_PPC(p)		((p)&(1 << 4))	/* true: port power control */
+#define HCS_N_PORTS(p)		(((p)>>0)&0xf)	/* bits 3:0, ports on HC */
+
+	u32		hcc_params;      /* HCCPARAMS - offset 0x8 */
+#define HCC_EXT_CAPS(p)		(((p)>>8)&0xff)	/* for pci extended caps */
+#define HCC_ISOC_CACHE(p)       ((p)&(1 << 7))  /* true: can cache isoc frame */
+#define HCC_ISOC_THRES(p)       (((p)>>4)&0x7)  /* bits 6:4, uframes cached */
+#define HCC_CANPARK(p)		((p)&(1 << 2))  /* true: can park on async qh */
+#define HCC_PGM_FRAMELISTLEN(p) ((p)&(1 << 1))  /* true: periodic_size changes*/
+#define HCC_64BIT_ADDR(p)       ((p)&(1))       /* true: can use 64-bit addr */
+	u8		portroute [8];	 /* nibbles for routing - offset 0xC */
+} __attribute__ ((packed));
+
+
+/* Section 2.3 Host Controller Operational Registers */
+struct ehci_regs {
+
+	/* USBCMD: offset 0x00 */
+	u32		command;
+/* 23:16 is r/w intr rate, in microframes; default "8" == 1/msec */
+#define CMD_PARK	(1<<11)		/* enable "park" on async qh */
+#define CMD_PARK_CNT(c)	(((c)>>8)&3)	/* how many transfers to park for */
+#define CMD_LRESET	(1<<7)		/* partial reset (no ports, etc) */
+#define CMD_IAAD	(1<<6)		/* "doorbell" interrupt async advance */
+#define CMD_ASE		(1<<5)		/* async schedule enable */
+#define CMD_PSE		(1<<4)		/* periodic schedule enable */
+/* 3:2 is periodic frame list size */
+#define CMD_RESET	(1<<1)		/* reset HC not bus */
+#define CMD_RUN		(1<<0)		/* start/stop HC */
+
+	/* USBSTS: offset 0x04 */
+	u32		status;
+#define STS_ASS		(1<<15)		/* Async Schedule Status */
+#define STS_PSS		(1<<14)		/* Periodic Schedule Status */
+#define STS_RECL	(1<<13)		/* Reclamation */
+#define STS_HALT	(1<<12)		/* Not running (any reason) */
+/* some bits reserved */
+	/* these STS_* flags are also intr_enable bits (USBINTR) */
+#define STS_IAA		(1<<5)		/* Interrupted on async advance */
+#define STS_FATAL	(1<<4)		/* such as some PCI access errors */
+#define STS_FLR		(1<<3)		/* frame list rolled over */
+#define STS_PCD		(1<<2)		/* port change detect */
+#define STS_ERR		(1<<1)		/* "error" completion (overflow, ...) */
+#define STS_INT		(1<<0)		/* "normal" completion (short, ...) */
+
+	/* USBINTR: offset 0x08 */
+	u32		intr_enable;
+
+	/* FRINDEX: offset 0x0C */
+	u32		frame_index;	/* current microframe number */
+	/* CTRLDSSEGMENT: offset 0x10 */
+	u32		segment;	/* address bits 63:32 if needed */
+	/* PERIODICLISTBASE: offset 0x14 */
+	u32		frame_list;	/* points to periodic list */
+	/* ASYNCLISTADDR: offset 0x18 */
+	u32		async_next;	/* address of next async queue head */
+
+	u32		reserved [9];
+
+	/* CONFIGFLAG: offset 0x40 */
+	u32		configured_flag;
+#define FLAG_CF		(1<<0)		/* true: we'll support "high speed" */
+
+	/* PORTSC: offset 0x44 */
+	u32		port_status [0];	/* up to N_PORTS */
+/* 31:23 reserved */
+#define PORT_WKOC_E	(1<<22)		/* wake on overcurrent (enable) */
+#define PORT_WKDISC_E	(1<<21)		/* wake on disconnect (enable) */
+#define PORT_WKCONN_E	(1<<20)		/* wake on connect (enable) */
+/* 19:16 for port testing */
+#define PORT_LED_OFF	(0<<14)
+#define PORT_LED_AMBER	(1<<14)
+#define PORT_LED_GREEN	(2<<14)
+#define PORT_LED_MASK	(3<<14)
+#define PORT_OWNER	(1<<13)		/* true: companion hc owns this port */
+#define PORT_POWER	(1<<12)		/* true: has power (see PPC) */
+#define PORT_USB11(x) (((x)&(3<<10))==(1<<10))	/* USB 1.1 device */
+/* 11:10 for detecting lowspeed devices (reset vs release ownership) */
+/* 9 reserved */
+#define PORT_RESET	(1<<8)		/* reset port */
+#define PORT_SUSPEND	(1<<7)		/* suspend port */
+#define PORT_RESUME	(1<<6)		/* resume it */
+#define PORT_OCC	(1<<5)		/* over current change */
+#define PORT_OC		(1<<4)		/* over current active */
+#define PORT_PEC	(1<<3)		/* port enable change */
+#define PORT_PE		(1<<2)		/* port enable */
+#define PORT_CSC	(1<<1)		/* connect status change */
+#define PORT_CONNECT	(1<<0)		/* device connected */
+#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)
+} __attribute__ ((packed));
+
+#define USBMODE		0x68		/* USB Device mode */
+#define USBMODE_SDIS	(1<<3)		/* Stream disable */
+#define USBMODE_BE	(1<<2)		/* BE/LE endianness select */
+#define USBMODE_CM_HC	(3<<0)		/* host controller mode */
+#define USBMODE_CM_IDLE	(0<<0)		/* idle state */
+
+/* Appendix C, Debug port ... intended for use with special "debug devices"
+ * that can help if there's no serial console.  (nonstandard enumeration.)
+ */
+struct ehci_dbg_port {
+	u32	control;
+#define DBGP_OWNER	(1<<30)
+#define DBGP_ENABLED	(1<<28)
+#define DBGP_DONE	(1<<16)
+#define DBGP_INUSE	(1<<10)
+#define DBGP_ERRCODE(x)	(((x)>>7)&0x07)
+#	define DBGP_ERR_BAD	1
+#	define DBGP_ERR_SIGNAL	2
+#define DBGP_ERROR	(1<<6)
+#define DBGP_GO		(1<<5)
+#define DBGP_OUT	(1<<4)
+#define DBGP_LEN(x)	(((x)>>0)&0x0f)
+	u32	pids;
+#define DBGP_PID_GET(x)		(((x)>>16)&0xff)
+#define DBGP_PID_SET(data,tok)	(((data)<<8)|(tok))
+	u32	data03;
+	u32	data47;
+	u32	address;
+#define DBGP_EPADDR(dev,ep)	(((dev)<<8)|(ep))
+} __attribute__ ((packed));
 
 /*-------------------------------------------------------------------------*/
 
@@ -622,7 +750,16 @@ ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)
 /*
  * Big-endian read/write functions are arch-specific.
  * Other arches can be added if/when they're needed.
+ *
+ * REVISIT: arch/powerpc now has readl/writel_be, so the
+ * definition below can die once the 4xx support is
+ * finally ported over.
  */
+#if defined(CONFIG_PPC) && !defined(CONFIG_PPC_MERGE)
+#define readl_be(addr)		in_be32((__force unsigned *)addr)
+#define writel_be(val, addr)	out_be32((__force unsigned *)addr, val)
+#endif
+
 #if defined(CONFIG_ARM) && defined(CONFIG_ARCH_IXP4XX)
 #define readl_be(addr)		__raw_readl((__force unsigned *)addr)
 #define writel_be(val, addr)	__raw_writel(val, (__force unsigned *)addr)
@@ -652,30 +789,6 @@ static inline void ehci_writel(const struct ehci_hcd *ehci,
 #endif
 }
 
-/*
- * On certain ppc-44x SoC there is a HW issue, that could only worked around with
- * explicit suspend/operate of OHCI. This function hereby makes sense only on that arch.
- * Other common bits are dependant on has_amcc_usb23 quirk flag.
- */
-#ifdef CONFIG_44x
-static inline void set_ohci_hcfs(struct ehci_hcd *ehci, int operational)
-{
-	u32 hc_control;
-
-	hc_control = (readl_be(ehci->ohci_hcctrl_reg) & ~OHCI_CTRL_HCFS);
-	if (operational)
-		hc_control |= OHCI_USB_OPER;
-	else
-		hc_control |= OHCI_USB_SUSPEND;
-
-	writel_be(hc_control, ehci->ohci_hcctrl_reg);
-	(void) readl_be(ehci->ohci_hcctrl_reg);
-}
-#else
-static inline void set_ohci_hcfs(struct ehci_hcd *ehci, int operational)
-{ }
-#endif
-
 /*-------------------------------------------------------------------------*/
 
 /*
diff --git a/drivers/usb/ipchost/Kconfig b/drivers/usb/ipchost/Kconfig
new file mode 100644
index 0000000..1cbc759
--- /dev/null
+++ b/drivers/usb/ipchost/Kconfig
@@ -0,0 +1,25 @@
+#
+# USB IPC driver configuration
+#
+
+comment "NOTE: USB_IPC enables AP-BP data transfer"
+	depends on USB
+
+config USB_IPC
+	tristate "USB IPC support"
+	depends on USB
+	---help---
+	  Say Y here if you want to enable AP-BP data transfer.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called usb-ipc.
+
+config USB_IPC_TEST
+        tristate "USB IPC TEST support"
+        depends on USB_IPC
+        ---help---
+          Say Y here if you want to build IPC test module.
+
+          To compile this driver as a module, choose M here: the
+          module will be called usb-ipc-test.
+
diff --git a/drivers/usb/ipchost/Makefile b/drivers/usb/ipchost/Makefile
new file mode 100644
index 0000000..00c76a1
--- /dev/null
+++ b/drivers/usb/ipchost/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the USB IPC drivers.
+#
+obj-$(CONFIG_USB_IPC)	+= usb-ipc.o
+usb-ipc-objs :=	ipc_log.o ipc_data.o ipc_api.o ipc_dma.o
+
+obj-$(CONFIG_USB_IPC_TEST)   += usb-ipc-test.o
+usb-ipc-test-objs :=	ipc_api_test.o
+
+
diff --git a/drivers/usb/ipchost/ipc_api.c b/drivers/usb/ipchost/ipc_api.c
new file mode 100644
index 0000000..3287c5b
--- /dev/null
+++ b/drivers/usb/ipchost/ipc_api.c
@@ -0,0 +1,1303 @@
+/*
+ * Copyright (c) 2007 - 2008 Motorola, Inc, All Rights Reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Changelog:
+ * Date               Author           Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007      Motorola        USB-IPC initial
+ * 03/22/2008      Motorola        USB-IPC header support
+ * 07/09/2008      Motorola        Change multi-node sending for Phase 1
+ * 11/03/2008      Motorola        Support sequence number
+ * 
+ */
+ 
+/*!
+ * @file drivers/usb/ipchost/ipc_api.c
+ * @brief USB-IPC Descriptor Set
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/circ_buf.h>
+#include <linux/uio.h>
+#include <linux/poll.h>
+#include <linux/usb.h>
+#include <linux/usb_ipc.h>
+#include <linux/ipc_api.h>
+
+#define DEBUG(args...) //printk(args)
+#define	ENTER_FUNC() DEBUG("Enter %s\n", __FUNCTION__)	
+
+#if defined(USE_IPC_FRAME_HEADER) && defined(IPC_USE_TEMP_BUFFER)
+Error:  Can not define both USE_IPC_FRAME_HEADER and IPC_USE_TEMP_BUFFER
+#endif
+
+/* IPC API channels, define IPC APIs supported channels */
+USB_IPC_API_PARAMS               usb_ipc_channels[MAX_USB_IPC_CHANNELS];
+unsigned char 	sent_sequence_number;
+unsigned char 	recv_sequence_number;
+
+#ifdef USE_OMAP_SDMA
+//#define USB_DMA_COHERENT_ALLOC_FREE
+#define USB_BUF_PHYS_ADDR(x)    virt_to_phys(x)
+extern void ipc_dma_memcpy_buf2node(USB_IPC_API_PARAMS *ipc_ch);
+extern int ipc_dma_memcpy_node2buf(USB_IPC_API_PARAMS *ipc_ch,  HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *ctrl_ptr);
+#endif
+
+#define IPC_USB_WRITE_ERROR(channel, status)                   \
+       DEBUG("%s: Submit URB error\n", __FUNCTION__);          \
+       channel.write_flag = 0;                                 \
+       channel.write_ptr.end_flag = 0;                         \
+       channel.cfg.notify_callback(&status);                   \
+       SEM_UNLOCK(&channel.write_ptr.write_mutex); 
+
+#ifdef IPC_USE_TEMP_BUFFER
+/*
+ * copy date from node buffer to temporary buffer
+ */
+static int usb_ipc_write_cpy_node2buf(int ch_index)
+{
+	int num, index;
+	HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *node_ptr;
+
+        num = 0;
+        index = usb_ipc_channels[ch_index].write_ptr.node_index;
+	node_ptr = usb_ipc_channels[ch_index].write_ptr.node_ptr;
+
+        for(; index < usb_ipc_channels[ch_index].write_ptr.node_num; index ++ )  {
+                if((num + node_ptr[index].length) <= MAX_FRAME_SIZE)  {
+	                memcpy((void *)((unsigned long)(usb_ipc_channels[ch_index].write_ptr.temp_buff) + num), node_ptr[index].data_ptr, node_ptr[index].length);
+                        node_ptr[index].comand |= NODE_DESCRIPTOR_DONE_BIT;
+                        num += node_ptr[index].length;
+                } else {
+                        break;
+                }
+                /* detect whether the current node_ptr has LAST or END bit */
+                if( node_ptr[index].comand & (NODE_DESCRIPTOR_END_BIT ) )  {
+                        index ++;
+                        break;
+                }
+        }
+        usb_ipc_channels[ch_index].write_ptr.temp_buff_flag = 1;
+
+	/* After copy data from node to temporary buffer, node_index always pointer to the next not-copied buffer */
+        usb_ipc_channels[ch_index].write_ptr.node_index = index;
+
+	return num;
+}
+#endif /*  */
+
+/*
+ * this function will be called by USB URB OUT callback ...
+ */
+void usb_ipc_api_write_callback(USB_IPC_CHANNEL_INDEX ch_index, int trans_flag, int trans_size)
+{
+	HW_CTRL_IPC_WRITE_STATUS_T  ipc_status;
+	HW_CTRL_IPC_NOTIFY_STATUS_T ipc_notify_status;
+	USB_IPC_IFS_STRUCT          *usb_ifs;
+#ifndef USE_IPC_FRAME_HEADER
+        HW_CTRL_IPC_LINKED_LIST_T   *temp_list;
+        HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *node_ptr;
+        int ret, index;
+#ifdef IPC_USE_TEMP_BUFFER
+	int num;
+#endif
+#endif
+	ENTER_FUNC();	
+	DEBUG("\n%s: trans_size = %d\n", __FUNCTION__, trans_size);
+
+        ipc_notify_status.channel = &usb_ipc_channels[ch_index].ch;
+        ipc_notify_status.status  = HW_CTRL_IPC_STATUS_ERROR;
+
+	usb_ifs = usb_ipc_channels[ch_index].usb_ifs;
+
+	/* Error, notify callback, and return */
+	if( (trans_flag != 0) || (usb_ifs == NULL))  	{
+		IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+	} else 	{   /* the previous submit URB is ok */
+	        /* update the totally transmitted data number */
+        	//usb_ipc_channels[ch_index].write_ptr.total_num += trans_size;
+#ifdef USE_IPC_FRAME_HEADER
+		/* sent_sequence_number will increase 1 on every read operation, and modulo 256 by using wrap around on a unsigned char.*/
+		sent_sequence_number++;
+
+		if (usb_ipc_channels[ch_index].write_ptr.total_num > trans_size)
+			usb_ipc_channels[ch_index].write_ptr.total_num = trans_size;
+#else 
+        	usb_ipc_channels[ch_index].write_ptr.total_num += trans_size;
+#endif
+                /* init write callback argument */
+                ipc_status.channel  = &usb_ipc_channels[ch_index].ch;
+
+		/* all transmitted is done */
+		if(usb_ipc_channels[ch_index].write_ptr.end_flag) {
+			usb_ipc_channels[ch_index].write_flag = 0;
+			usb_ipc_channels[ch_index].write_ptr.end_flag = 0;
+
+			ipc_status.nb_bytes =  usb_ipc_channels[ch_index].write_ptr.total_num;
+                        if(usb_ipc_channels[ch_index].cfg.write_callback != NULL)  {
+                                usb_ipc_channels[ch_index].cfg.write_callback(&ipc_status);
+                        } else {
+                                SEM_UNLOCK(&usb_ipc_channels[ch_index].write_ptr.write_mutex);
+                        }
+			return;
+		}
+
+#ifdef USE_IPC_FRAME_HEADER
+#ifdef IPC_USE_ZERO_LEN_FRAME
+                        /* send extra zero packet */
+                        usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+                        ret =  usb_ifs->usb_write(usb_ipc_channels[ch_index].write_ptr.temp_buff, 0);
+                        if(ret != 0)  {  /* Error */
+                                IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+                        }
+#endif  /* IPC_USE_ZERO_LEN_FRAME */
+
+#else //
+		/* if general write operation, call write_callback ... */
+		if(usb_ipc_channels[ch_index].write_type == HW_CTRL_IPC_WRITE_TYPE) {
+#ifdef IPC_USE_ZERO_LEN_FRAME
+			/* send extra zero packet */
+			usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+			ret =  usb_ifs->usb_write(usb_ipc_channels[ch_index].write_ptr.temp_buff, 0);
+			if(ret != 0)  {  /* Error */
+				IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+			}
+#endif  /* IPC_USE_ZERO_LEN_FRAME */
+		}
+		/* if contiguous buffer write operation, call write_callback ... */ 
+		else if (usb_ipc_channels[ch_index].write_type == HW_CTRL_IPC_WRITE_EX_CONT_TYPE) {
+#ifdef IPC_USE_ZERO_LEN_FRAME
+                        /* send extra zero packet */
+                        usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+                        ret = usb_ifs->usb_write(usb_ipc_channels[ch_index].write_ptr.temp_buff, 0);
+                        if(ret != 0)  {  /* Error */
+				IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+                        }
+#endif  /* IPC_USE_ZERO_LEN_FRAME */
+		}
+		/* if list buffer, need transfer the next list ... */ 
+		else if (usb_ipc_channels[ch_index].write_type == HW_CTRL_IPC_WRITE_EX_LIST_TYPE) {
+			temp_list = usb_ipc_channels[ch_index].write_ptr.list_ptr->next;
+			/* all lists are transfered, send zero package */
+			if(temp_list == NULL) {
+#ifdef IPC_USE_ZERO_LEN_FRAME
+	                        /* send extra zero packet */
+	                        usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+        	                ret = usb_ifs->usb_write(usb_ipc_channels[ch_index].write_ptr.temp_buff, 0);
+                	        if(ret != 0)  {  /* Error */
+					IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+                        	}
+#endif  /* IPC_USE_ZERO_LEN_FRAME */
+			} else {   /* re-start the next list transfer */
+				usb_ipc_channels[ch_index].write_ptr.list_ptr = temp_list;
+#ifndef IPC_USE_ZERO_LEN_FRAME
+				if(temp_list->next == NULL)  { // last frame	
+	                        	usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+				}
+#endif  /* !IPC_USE_ZERO_LEN_FRAME */
+				ret = usb_ifs->usb_write(temp_list->data_ptr, temp_list->length);
+				if(ret != 0)  {  /* Error, call notify */
+					IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+				}
+			}
+		}
+		/* if node descriptor ... */ 
+		else if (usb_ipc_channels[ch_index].write_type == HW_CTRL_IPC_WRITE_EX2_TYPE) {
+			/* After copy data from node to temporary buffer, node_index always pointer to the next not-copied buffer.  If not used temporary buffer, node_index always pointer to the current transmitted buffer */
+			index = usb_ipc_channels[ch_index].write_ptr.node_index;
+			node_ptr = usb_ipc_channels[ch_index].write_ptr.node_ptr;
+#ifdef IPC_USE_TEMP_BUFFER
+			if(usb_ipc_channels[ch_index].write_ptr.temp_buff_flag == 0)  {   /*  */
+	                 	node_ptr[index].comand |= NODE_DESCRIPTOR_DONE_BIT;
+				index ++;
+			} else {
+				usb_ipc_channels[ch_index].write_ptr.temp_buff_flag = 0;
+			}
+#else   /* IPC_USE_TEMP_BUFFER */
+	               	node_ptr[index].comand |= NODE_DESCRIPTOR_DONE_BIT;
+			index ++;
+#endif  /* IPC_USE_TEMP_BUFFER */
+			/* detect whether all nodes have been transfered */
+			if(index >= usb_ipc_channels[ch_index].write_ptr.node_num)   {
+#ifdef IPC_USE_ZERO_LEN_FRAME
+                                /* send extra zero packet */
+                                usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+                                ret = usb_ifs->usb_write(usb_ipc_channels[ch_index].write_ptr.temp_buff, 0); 
+                                if(ret != 0)  {  /* Error */
+					IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+                                }
+#endif /* IPC_USE_ZERO_LEN_FRAME */
+			} else {
+				usb_ipc_channels[ch_index].write_ptr.node_index = index;
+#ifdef IPC_USE_TEMP_BUFFER
+		                /* if current buffer is: (1) last one (2) one frame (3) size is bigger than MAX_FRAME_SIZE, using this buffer for URB transfer  */
+                		if( (node_ptr[index].comand & (NODE_DESCRIPTOR_END_BIT ) ) || (node_ptr[index].length >= MAX_FRAME_SIZE ) ) {
+#endif /* IPC_USE_TEMP_BUFFER */
+
+#ifndef IPC_USE_ZERO_LEN_FRAME
+					if((index + 1) >= usb_ipc_channels[ch_index].write_ptr.node_num) { // last frame 
+	                        		usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+					}
+#endif  /* !IPC_USE_ZERO_LEN_FRAME */
+					ret = usb_ifs->usb_write(node_ptr[index].data_ptr, node_ptr[index].length);
+                                	if(ret != 0)  {  /* Error */
+						IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+					}
+#ifdef IPC_USE_TEMP_BUFFER 
+		                } else {  /* using temporary buffer for write ... */
+					num = usb_ipc_write_cpy_node2buf(ch_index);
+#ifndef IPC_USE_ZERO_LEN_FRAME
+                                        if( usb_ipc_channels[ch_index].write_ptr.node_index >= usb_ipc_channels[ch_index].write_ptr.node_num) { // last frame
+                                                usb_ipc_channels[ch_index].write_ptr.end_flag = 1;
+                                        }
+#endif  /* !IPC_USE_ZERO_LEN_FRAME */					
+                                        ret = usb_ifs->usb_write(usb_ipc_channels[ch_index].write_ptr.temp_buff, num);
+                                        if(ret != 0)  {  /* Error */
+						IPC_USB_WRITE_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+                                        }
+				}
+#endif  /* IPC_USE_TEMP_BUFFER */
+                	}
+		} 
+#endif //
+	}
+}
+
+/*
+ * The following macro is called if submit call USB read error
+ */
+#define IPC_USB_READ_ERROR(channel, status)                    \
+       DEBUG("%s: Submit URB error\n", __FUNCTION__);          \
+       channel.read_flag = 0;                                  \
+       channel.cfg.notify_callback(&status);                   \
+       SEM_UNLOCK(&channel.read_ptr.read_mutex);	       \
+       return;
+
+void usb_ipc_exchange_endian16(unsigned short *data)
+{
+	unsigned char ch;
+	ch = ((unsigned char *)data)[0];
+	((unsigned char *)data)[0] = ((unsigned char *)data)[1];
+	((unsigned char *)data)[1] = ch;
+}
+
+/*
+ * called by USB URB IN callback ...
+ */
+void usb_ipc_api_read_callback(USB_IPC_CHANNEL_INDEX ch_index, int read_flag, int real_size)
+{
+	HW_CTRL_IPC_READ_STATUS_T           ipc_status;
+	HW_CTRL_IPC_NOTIFY_STATUS_T         ipc_notify_status;
+	USB_IPC_IFS_STRUCT                  *usb_ifs;
+	int  ret;
+#ifdef USE_IPC_FRAME_HEADER
+	IPC_DATA_HEADER * header;
+        int i;
+#ifndef USE_OMAP_SDMA
+	int size, len, num;
+#endif
+#else
+	HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *node_ptr;
+        int index;
+#ifdef IPC_USE_TEMP_BUFFER
+	int size, len, num;
+#endif
+#endif
+
+	ENTER_FUNC();	
+
+	/* initialize notify callback argument */
+        ipc_notify_status.channel = &usb_ipc_channels[ch_index].ch;
+        ipc_notify_status.status = HW_CTRL_IPC_STATUS_ERROR;
+
+	/* initialize read callback argument */
+	ipc_status.channel  = &usb_ipc_channels[ch_index].ch;
+	usb_ifs = usb_ipc_channels[ch_index].usb_ifs;
+	if(usb_ifs == NULL) {
+		IPC_USB_READ_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+	}
+
+#ifdef USE_IPC_FRAME_HEADER
+
+        if(real_size == 0)  {  // if return is 0, re-call usb_read to receiving data
+            ret = usb_ifs->usb_read(usb_ipc_channels[ch_index].read_ptr.temp_buff, usb_ipc_channels[ch_index].max_temp_buff_size);
+            if( ret != 0) { // error
+                IPC_USB_READ_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+            }
+		ipc_dbg_array[ipc_dbg_index++] = 0x12;
+		if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+			ipc_dbg_index = 0;
+            return;
+        }
+
+
+	header = (IPC_DATA_HEADER *)usb_ipc_channels[ch_index].read_ptr.temp_buff;
+//change for endian
+	if( (real_size >= sizeof(IPC_DATA_HEADER_INDEX) ) ) {
+		usb_ipc_exchange_endian16(&(header->version));
+		usb_ipc_exchange_endian16(&(header->nb_frame));
+#if defined(USE_IPC_FRAME_HEADER_CHECKSUM)
+		usb_ipc_exchange_endian16(&(header->checksum));
+		/*TODO: calculate checksum here*/
+#else
+
+#endif
+		if (header->nb_frame > 0)
+		for (i = 0; i < header->nb_frame; i++)
+			usb_ipc_exchange_endian16(&(header->frames[i].length));
+		
+	}
+//change for endian end
+	if ((header->version != IPC_FRAME_VERSION) ||
+	    (header->sequence_number != recv_sequence_number)) {
+		if (header->version != IPC_FRAME_VERSION)
+			printk(KERN_INFO "Wrong IPC Frame Header Version\n");
+		else
+			printk(KERN_INFO "Wrong Frame Sequence Number\n");
+		printk(KERN_INFO "channel:%d, buffer:%08x,\
+			header:%08x\n", ch_index,
+			(unsigned int)
+				usb_ipc_channels[ch_index].read_ptr.temp_buff,
+			(unsigned int) header);
+		printk(KERN_INFO "version:%04x, nb_frame:%04x,\
+			sequence:%02x, options:%02x, checksum:%04x\n",
+			header->version, header->nb_frame,
+			header->sequence_number, header->options,
+			header->checksum);
+		panic("panic for wrong verion or sequence number");
+	}
+	DEBUG("%s:version(0x%x), sequence number(%d)\n", __FUNCTION__, header->version, header->sequence_number);
+	/* recv_sequence_number will increase 1 on every read operation, and modulo 256 by using wrap around on a unsigned char.*/
+	recv_sequence_number++;
+
+	if( (real_size <= sizeof(IPC_DATA_HEADER_INDEX) ) && (header->nb_frame <= 0)) {
+		IPC_USB_READ_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+	}
+
+#ifdef USE_OMAP_SDMA
+	ipc_dbg_array[ipc_dbg_index++] = 0x13;
+	if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+		ipc_dbg_index = 0;
+        ipc_dma_memcpy_buf2node(&usb_ipc_channels[ch_index]);
+#else
+        size = header->frames[0].length;
+	len  = sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame));
+        /* copy data from temporary buffer to scatter buffers */
+        for(index = 0, frame_index = 0; index < usb_ipc_channels[ch_index].read_ptr.node_num; index ++) {
+                num = (size > usb_ipc_channels[ch_index].read_ptr.node_ptr[index].length) ? usb_ipc_channels[ch_index].read_ptr.node_ptr[index].length : size;
+                memcpy(usb_ipc_channels[ch_index].read_ptr.node_ptr[index].data_ptr, &(usb_ipc_channels[ch_index].read_ptr.temp_buff[len]), num);
+		usb_ipc_channels[ch_index].read_ptr.total_num += num;
+                /* set flag to indicate received data is filled ... */
+                usb_ipc_channels[ch_index].read_ptr.node_ptr[index].comand |= NODE_DESCRIPTOR_DONE_BIT;
+                size -= num;
+                len  += num;
+                if( size == 0 ) {
+                        usb_ipc_channels[ch_index].read_ptr.node_ptr[index].length = num;
+                        usb_ipc_channels[ch_index].read_ptr.node_ptr[index].comand |= NODE_DESCRIPTOR_LAST_BIT;
+                        frame_index ++;
+                        if(frame_index >= header->nb_frame) {
+                                 break;
+                        }
+                        size = header->frames[frame_index].length;
+                }
+        }
+
+        if( index < usb_ipc_channels[ch_index].read_ptr.node_num ) {
+            usb_ipc_channels[ch_index].read_ptr.node_ptr[index].comand |= NODE_DESCRIPTOR_END_BIT;
+        }
+        else {
+            usb_ipc_channels[ch_index].read_ptr.node_ptr[index - 1].comand |= NODE_DESCRIPTOR_END_BIT;
+        }
+
+        /* clear flag to indicate API read function call is done */
+        usb_ipc_channels[ch_index].read_flag = 0;
+        if(usb_ipc_channels[ch_index].cfg.read_callback != NULL)  {
+                 ipc_status.nb_bytes = usb_ipc_channels[ch_index].read_ptr.total_num;
+                 usb_ipc_channels[ch_index].cfg.read_callback(&ipc_status);
+        } else {
+                 SEM_UNLOCK(&usb_ipc_channels[ch_index].read_ptr.read_mutex);
+        }
+#endif
+#else //
+	/* if general read operation, call read_callback to notice upper layer */
+	if(usb_ipc_channels[ch_index].read_type == HW_CTRL_IPC_READ_TYPE) {
+		if(real_size == 0)  {  /* 0 size, re-start read */
+			ret = usb_ifs->usb_read(usb_ipc_channels[ch_index].read_ptr.gen_ptr.buf, usb_ipc_channels[ch_index].read_ptr.gen_ptr.nb_bytes);
+			if(ret != 0)  {  /* Error */
+				IPC_USB_READ_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+			}
+		}  else {
+			ipc_status.nb_bytes = real_size;
+        		usb_ipc_channels[ch_index].read_flag = 0;
+			if( usb_ipc_channels[ch_index].cfg.read_callback != NULL) {
+				usb_ipc_channels[ch_index].cfg.read_callback(&ipc_status);
+			} else {
+				SEM_UNLOCK(&usb_ipc_channels[ch_index].read_ptr.read_mutex);
+			}
+		}
+	}
+	/* if node descriptor read, ... */ 
+	else if(usb_ipc_channels[ch_index].read_type == HW_CTRL_IPC_READ_EX2_TYPE) {
+		/* get current buffer node index that data had been saved in it ...  */
+		index = usb_ipc_channels[ch_index].read_ptr.node_index;
+		node_ptr = usb_ipc_channels[ch_index].read_ptr.node_ptr;	
+		if(real_size > 0)   {   /* zero-length means all frames are received */
+#ifdef IPC_USE_TEMP_BUFFER
+			/* the temporary buffer is used because of scatter buffer is too short ... */
+			if(usb_ipc_channels[ch_index].read_ptr.temp_buff_flag == 1)  {
+				/* clear temporary read buffer flag */
+				usb_ipc_channels[ch_index].read_ptr.temp_buff_flag = 0;
+				size = real_size;
+				len  = 0;
+				/* copy data from temporary buffer to scatter buffers */
+				for(; index <  usb_ipc_channels[ch_index].read_ptr.node_num; index ++) {
+					num = (size > node_ptr[index].length) ? node_ptr[index].length : size;
+					memcpy(node_ptr[index].data_ptr, (void *)((unsigned long)(usb_ipc_channels[ch_index].read_ptr.temp_buff) + len), num);
+					node_ptr[index].length = num;
+					/* set flag to indicate received data is filled ... */
+					node_ptr[index].comand |= NODE_DESCRIPTOR_DONE_BIT;
+
+					usb_ipc_channels[ch_index].read_ptr.total_num  += num;
+					size -= num;
+					len += num;
+					/* all received data have been copied to scatter buffers */
+					if(size == 0) {
+						/* set frame flag */
+					        node_ptr[index].comand |= NODE_DESCRIPTOR_LAST_BIT;
+				        	index ++;
+						break;
+					}
+				}
+			} else {
+#endif /* IPC_USE_TEMP_BUFFER */
+				/* set done flag and frame last flag */
+				usb_ipc_channels[ch_index].read_ptr.total_num += real_size;
+				node_ptr[index].length = real_size;
+				node_ptr[index].comand |= NODE_DESCRIPTOR_DONE_BIT;
+		        	node_ptr[index].comand |= NODE_DESCRIPTOR_LAST_BIT;
+			        index ++;
+#ifdef IPC_USE_TEMP_BUFFER
+			}
+#endif
+		}	
+		/* call read callback, if (1) all read node buffer are filled (2) zero length is received */
+		if((index >= usb_ipc_channels[ch_index].read_ptr.node_num) || ( (real_size == 0) && (index != 0) ) ) {
+		       	node_ptr[index - 1].comand |= NODE_DESCRIPTOR_END_BIT;
+        		usb_ipc_channels[ch_index].read_flag = 0;
+			if(usb_ipc_channels[ch_index].cfg.read_callback != NULL)  {
+				ipc_status.nb_bytes = usb_ipc_channels[ch_index].read_ptr.total_num;
+				usb_ipc_channels[ch_index].cfg.read_callback(&ipc_status);
+			} else {
+				SEM_UNLOCK(&usb_ipc_channels[ch_index].read_ptr.read_mutex);
+			}
+		} else { 
+			usb_ipc_channels[ch_index].read_ptr.node_index = index;
+#ifdef IPC_USE_TEMP_BUFFER
+                	if( node_ptr[index].length >= MAX_FRAME_SIZE ) {
+#endif  /* IPC_USE_TEMP_BUFFER */
+                        	ret = usb_ifs->usb_read(node_ptr[index].data_ptr, node_ptr[index].length);
+#ifdef IPC_USE_TEMP_BUFFER
+	                } else {
+        	                /* use the temporary buffer for URB transfer */
+                	        usb_ipc_channels[ch_index].read_ptr.temp_buff_flag = 1;
+                       		ret = usb_ifs->usb_read(usb_ipc_channels[ch_index].read_ptr.temp_buff, MAX_FRAME_SIZE);
+                	}
+#endif /* IPC_USE_TEMP_BUFFER */
+                        if(ret != 0)  {  /* Error */
+                                IPC_USB_READ_ERROR(usb_ipc_channels[ch_index], ipc_notify_status);
+                        }
+		}
+	}
+#endif //
+}
+
+/*!
+ * Opens an IPC link. This functions can be called directly by kernel
+ * modules. POSIX implementation of the IPC Driver also calls it.
+ *
+ * @param config        Pointer to a struct containing configuration para
+ *                      meters for the channel to open (type of channel,
+ *                      callbacks, etc)
+ *
+ * @return              returns a virtual channel handler on success, a NULL
+ *                      pointer otherwise.
+ */
+HW_CTRL_IPC_CHANNEL_T *hw_ctrl_ipc_open(const HW_CTRL_IPC_OPEN_T * config)
+{
+	USB_IPC_CHANNEL_INDEX      channel;
+#ifdef USE_IPC_FRAME_HEADER
+	IPC_DATA_HEADER *header = NULL;
+#endif
+	
+	ENTER_FUNC();	
+	switch (config->type) {
+	case HW_CTRL_IPC_PACKET_DATA:
+		channel = IPC_DATA_CH_NUM;
+		break;
+	case HW_CTRL_IPC_CHANNEL_LOG:
+		channel = IPC_LOG_CH_NUM;
+		break;
+	default:
+		return NULL;
+	}
+
+	if( (usb_ipc_channels[channel].open_flag != 0) || (usb_ipc_channels[channel].usb_ifs == 0) ) {
+		return NULL;
+	} 
+	
+	/* init USB class driver IPC callback */	
+        usb_ipc_channels[channel].usb_ifs->ipc_read_cb   = usb_ipc_api_read_callback;
+        usb_ipc_channels[channel].usb_ifs->ipc_write_cb  = usb_ipc_api_write_callback;
+
+	/* init IPC API channel parameters */
+	usb_ipc_channels[channel].ch.channel_nb = (int)channel;
+	memcpy((void *)&(usb_ipc_channels[channel].cfg), (void *)config, sizeof(HW_CTRL_IPC_OPEN_T));
+	usb_ipc_channels[channel].max_node_num = MAX_IPC_EX2_NODE_NUM;
+#ifdef USE_IPC_FRAME_HEADER
+	usb_ipc_channels[channel].max_temp_buff_size = (MAX_FRAME_SIZE * MAX_FRAME_NUM) + sizeof(IPC_DATA_HEADER);
+
+
+#ifdef USB_DMA_COHERENT_ALLOC_FREE
+        usb_ipc_channels[channel].read_ptr.temp_buff = dma_alloc_coherent(NULL, usb_ipc_channels[channel].max_temp_buff_size, &(usb_ipc_channels[channel].read_ptr.temp_buff_phy_addr), GFP_KERNEL);
+#else
+        usb_ipc_channels[channel].read_ptr.temp_buff = kmalloc(usb_ipc_channels[channel].max_temp_buff_size, GFP_ATOMIC|GFP_DMA);
+#endif
+        if(usb_ipc_channels[channel].read_ptr.temp_buff == NULL) {
+                printk("%s: alloc temporary buffer for NODE DESCRIPTOR read transfer is failed\n", __FUNCTION__);
+                return NULL;
+        }
+#if defined(USE_OMAP_SDMA) && (!defined(USB_DMA_COHERENT_ALLOC_FREE))
+	usb_ipc_channels[channel].read_ptr.temp_buff_phy_addr = USB_BUF_PHYS_ADDR(usb_ipc_channels[channel].read_ptr.temp_buff);
+#endif
+
+#ifdef USB_DMA_COHERENT_ALLOC_FREE
+        usb_ipc_channels[channel].write_ptr.temp_buff = dma_alloc_coherent(NULL, usb_ipc_channels[channel].max_temp_buff_size, &(usb_ipc_channels[channel].write_ptr.temp_buff_phy_addr), GFP_KERNEL);
+#else
+        usb_ipc_channels[channel].write_ptr.temp_buff = kmalloc( usb_ipc_channels[channel].max_temp_buff_size , GFP_ATOMIC|GFP_DMA);
+#endif
+        if(usb_ipc_channels[channel].write_ptr.temp_buff == NULL) {
+#ifdef USB_DMA_COHERENT_ALLOC_FREE
+                dma_free_coherent(NULL, usb_ipc_channels[channel].max_temp_buff_size, usb_ipc_channels[channel].read_ptr.temp_buff, usb_ipc_channels[channel].read_ptr.temp_buff_phy_addr);
+#else
+                kfree(usb_ipc_channels[channel].read_ptr.temp_buff);
+#endif
+                printk("%s: alloc temporary buffer for NODE DESCRIPTOR write transfer is failed\n", __FUNCTION__);
+                return NULL;
+        }
+#if defined(USE_OMAP_SDMA) && (!defined(USB_DMA_COHERENT_ALLOC_FREE))
+	usb_ipc_channels[channel].write_ptr.temp_buff_phy_addr = USB_BUF_PHYS_ADDR(usb_ipc_channels[channel].write_ptr.temp_buff);
+#endif
+
+	/* read header init */
+	header = (IPC_DATA_HEADER *) usb_ipc_channels[channel].read_ptr.temp_buff;
+	header->version  = IPC_FRAME_VERSION;
+	header->nb_frame = 0;
+	header->sequence_number = sent_sequence_number = 0;
+#if defined(USE_IPC_FRAME_HEADER_CHECKSUM)
+	header->options = 1;
+#else
+	header->options = 0;
+#endif
+
+	/* write header init */
+	header = (IPC_DATA_HEADER *) usb_ipc_channels[channel].write_ptr.temp_buff;
+	header->version = IPC_FRAME_VERSION;
+	header->nb_frame = 0;
+	header->sequence_number = recv_sequence_number = 0;
+#if defined(USE_IPC_FRAME_HEADER_CHECKSUM)
+	header->options = 1;
+#else
+	header->options = 0;
+#endif
+#else //
+
+#ifdef IPC_USE_TEMP_BUFFER	
+	usb_ipc_channels[channel].read_ptr.temp_buff_flag = 0;
+	usb_ipc_channels[channel].write_ptr.temp_buff_flag = 0;
+
+	usb_ipc_channels[channel].read_ptr.temp_buff = kmalloc(MAX_FRAME_SIZE, GFP_KERNEL);
+	if(usb_ipc_channels[channel].read_ptr.temp_buff == NULL) {
+		printk("%s: alloc temporary buffer for NODE DESCRIPTOR read transfer is failed\n", __FUNCTION__);
+		return NULL;
+	}
+	usb_ipc_channels[channel].write_ptr.temp_buff = kmalloc(MAX_FRAME_SIZE, GFP_KERNEL);
+	if(usb_ipc_channels[channel].write_ptr.temp_buff == NULL) {
+		kfree(usb_ipc_channels[channel].read_ptr.temp_buff);
+		printk("%s: alloc temporary buffer for NODE DESCRIPTOR write transfer is failed\n", __FUNCTION__);
+		return NULL;
+	}
+#endif /* IPC_USE_TEMP_BUFFER */
+#endif //
+        /* set flag to indicate this channel is opened */
+        usb_ipc_channels[channel].open_flag  = 1;
+
+	return &usb_ipc_channels[channel].ch;
+}
+
+/*!
+ * Close an IPC link. This functions can be called directly by kernel
+ * modules.
+ *
+ * @param channel       handler to the virtual channel to close.
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_close(HW_CTRL_IPC_CHANNEL_T * channel)
+{
+	DEBUG("%s: channel_nb = %d\n", __FUNCTION__, channel->channel_nb);
+	if( (usb_ipc_channels[channel->channel_nb].open_flag == 0) || (usb_ipc_channels[channel->channel_nb].write_flag) || (usb_ipc_channels[channel->channel_nb].read_flag) ){
+		return HW_CTRL_IPC_STATUS_ERROR; 
+	}
+#ifdef USE_IPC_FRAME_HEADER
+	if(usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff != 0) {
+#ifdef USB_DMA_COHERENT_ALLOC_FREE
+                dma_free_coherent(NULL, usb_ipc_channels[channel->channel_nb].max_temp_buff_size, usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff, usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff_phy_addr);
+#else
+		kfree(usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff);
+#endif
+		usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff = 0;
+	}
+	if(usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff != 0) {
+#ifdef USB_DMA_COHERENT_ALLOC_FREE
+                dma_free_coherent(NULL, usb_ipc_channels[channel->channel_nb].max_temp_buff_size, usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff, usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff_phy_addr);
+#else
+		kfree(usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff);
+#endif
+		usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff = 0;
+	}
+#else //
+
+#ifdef IPC_USE_TEMP_BUFFER	
+	if(usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff != 0)  {
+		kfree(usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff);
+		usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff = 0;
+	}
+	if(usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff != 0)  {	
+		kfree(usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff);
+		usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff = 0;
+	}
+#endif /* IPC_USE_TEMP_BUFFER */
+#endif
+	usb_ipc_channels[channel->channel_nb].open_flag = 0;
+	return HW_CTRL_IPC_STATUS_OK;
+}
+
+/*!
+ * Reads data from an IPC link. This functions can be called directly by kernel
+ * modules. POSIX implementation of the IPC Driver also calls it.
+ *
+ * @param channel       handler to the virtual channel where read has been requested
+ * @param buf           physical address of DMA'able read buffer to store data read from 
+ *                      the channel.
+ * @param nb_bytes      size of the buffer
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_read(HW_CTRL_IPC_CHANNEL_T * channel,
+				      unsigned char *buf,
+				      unsigned short nb_bytes)
+{
+	int ret = -1;
+	USB_IPC_IFS_STRUCT *usb_ifs;
+
+#ifdef USE_IPC_FRAME_HEADER
+        return HW_CTRL_IPC_STATUS_ERROR;
+#endif
+	
+	if(usb_ipc_channels[channel->channel_nb].open_flag == 0) {
+		return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+	}
+	if(usb_ipc_channels[channel->channel_nb].read_flag == 1) {
+		return HW_CTRL_IPC_STATUS_READ_ON_GOING;
+	}
+        
+	usb_ipc_channels[channel->channel_nb].read_flag = 1;
+
+	usb_ipc_channels[channel->channel_nb].read_ptr.total_num  = 0;
+
+        /* save the parameters and start read operation */	
+	usb_ipc_channels[channel->channel_nb].read_type = HW_CTRL_IPC_READ_TYPE;
+	usb_ipc_channels[channel->channel_nb].read_ptr.gen_ptr.buf      = buf;
+	usb_ipc_channels[channel->channel_nb].read_ptr.gen_ptr.nb_bytes = nb_bytes;
+
+	usb_ifs = usb_ipc_channels[channel->channel_nb].usb_ifs;
+        if((usb_ifs == NULL) || (usb_ifs->usb_read == NULL))  {
+                return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+        }
+
+	ret = usb_ifs->usb_read(buf, nb_bytes);
+	/* call USB driver read function to start data receiving */
+	if(ret != 0) {
+		usb_ipc_channels[channel->channel_nb].read_flag = 0;
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+        if(usb_ipc_channels[channel->channel_nb].cfg.read_callback == NULL)  {
+                SEM_LOCK(&usb_ipc_channels[channel->channel_nb].read_ptr.read_mutex);
+		usb_ipc_channels[channel->channel_nb].read_flag = 0;
+        }
+	
+	return HW_CTRL_IPC_STATUS_OK;
+}
+
+/*!
+ * Writes data to an IPC link. This functions can be called directly by kernel
+ * modules. POSIX implementation of the IPC Driver also calls it.
+ *
+ * @param channel       handler to the virtual channel where read has been requested.
+ * @param buf           physical address of DMA'able write buffer containing data to 
+ *                      be written on the channel.
+ * @param nb_bytes      size of the buffer
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_write(HW_CTRL_IPC_CHANNEL_T * channel,
+				       unsigned char *buf,
+				       unsigned short nb_bytes)
+{
+	int ret = -1;
+	USB_IPC_IFS_STRUCT *usb_ifs;
+
+	ENTER_FUNC();
+
+#ifdef USE_IPC_FRAME_HEADER
+        return HW_CTRL_IPC_STATUS_ERROR;
+#endif
+	
+	if(usb_ipc_channels[channel->channel_nb].open_flag == 0) {
+		printk("Error HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE\n");
+		return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+	}
+	if(usb_ipc_channels[channel->channel_nb].write_flag == 1) {
+		printk("Error HW_CTRL_IPC_STATUS_WRITE_ON_GOING\n");
+		return HW_CTRL_IPC_STATUS_WRITE_ON_GOING;
+	}
+
+	usb_ipc_channels[channel->channel_nb].write_flag = 1;
+	usb_ipc_channels[channel->channel_nb].write_ptr.total_num  = 0;
+
+        /* save the parameters and start write operation */	
+	usb_ipc_channels[channel->channel_nb].write_type = HW_CTRL_IPC_WRITE_TYPE;
+	usb_ipc_channels[channel->channel_nb].write_ptr.gen_ptr.buf      = buf;
+	usb_ipc_channels[channel->channel_nb].write_ptr.gen_ptr.nb_bytes = nb_bytes;
+	
+	usb_ifs = usb_ipc_channels[channel->channel_nb].usb_ifs;
+
+        if((usb_ifs == NULL) || (usb_ifs->usb_write == NULL))  {
+                return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+        }
+
+#ifdef IPC_USE_ZERO_LEN_FRAME
+        usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 0;
+#else  /* IPC_USE_ZERO_LEN_FRAME */
+        usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 1;
+#endif /* IPC_USE_ZERO_LEN_FRAME */
+
+	ret = usb_ifs->usb_write(buf, nb_bytes);
+	if(ret != 0) {
+		printk("Error HW_CTRL_IPC_STATUS_ERROR\n");
+		usb_ipc_channels[channel->channel_nb].write_flag = 0;
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+        if(usb_ipc_channels[channel->channel_nb].cfg.write_callback == NULL)  {
+                SEM_LOCK(&usb_ipc_channels[channel->channel_nb].write_ptr.write_mutex);
+                usb_ipc_channels[channel->channel_nb].write_flag = 0;
+        }
+
+	return HW_CTRL_IPC_STATUS_OK;
+}
+
+/*!
+ * Writes data to an IPC link. This function can be called directly by kernel
+ * modules. It accepts a linked list or contiguous data.
+ *
+ * @param channel       handler to the virtual channel where read has
+ *                      been requested.
+ * @param mem_ptr       pointer of type HW_CTRL_IPC_WRITE_PARAMS_T. Each element 
+ *                      points to the physical address of a DMA'able buffer
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_write_ex(HW_CTRL_IPC_CHANNEL_T * channel,
+					  HW_CTRL_IPC_WRITE_PARAMS_T * mem_ptr)
+{
+	int  ret = -1;
+	USB_IPC_IFS_STRUCT        *usb_ifs;
+	HW_CTRL_IPC_CONTIGUOUS_T  *temp_cont;
+	HW_CTRL_IPC_LINKED_LIST_T *temp_list;
+
+#ifdef USE_IPC_FRAME_HEADER
+	return HW_CTRL_IPC_STATUS_ERROR;
+#endif
+	
+	if(usb_ipc_channels[channel->channel_nb].open_flag == 0) {
+		return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+	}
+	if(usb_ipc_channels[channel->channel_nb].write_flag == 1) {
+		return HW_CTRL_IPC_STATUS_WRITE_ON_GOING;
+	}
+
+	usb_ifs = usb_ipc_channels[channel->channel_nb].usb_ifs;
+        if((usb_ifs == NULL) || (usb_ifs->usb_write == NULL))  {
+                return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+        }
+
+        usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 0;
+	usb_ipc_channels[channel->channel_nb].write_ptr.total_num  = 0;
+
+	usb_ipc_channels[channel->channel_nb].write_flag = 1;
+        /* save the parameters and start write operation */	
+	if (mem_ptr->ipc_memory_read_mode == HW_CTRL_IPC_MODE_CONTIGUOUS) {
+		usb_ipc_channels[channel->channel_nb].write_type = HW_CTRL_IPC_WRITE_EX_CONT_TYPE;
+		usb_ipc_channels[channel->channel_nb].write_ptr.cont_ptr = mem_ptr->read.cont_ptr;
+		temp_cont = mem_ptr->read.cont_ptr;
+		if(temp_cont == NULL) {
+                        usb_ipc_channels[channel->channel_nb].write_flag = 0;
+                        return HW_CTRL_IPC_STATUS_ERROR;
+		}
+#ifndef IPC_USE_ZERO_LEN_FRAME
+        	usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 1;
+#endif  /* !IPC_USE_ZERO_LEN_FRAME */
+		ret = usb_ifs->usb_write(temp_cont->data_ptr, temp_cont->length);
+	} else {
+		usb_ipc_channels[channel->channel_nb].write_type = HW_CTRL_IPC_WRITE_EX_LIST_TYPE;
+		usb_ipc_channels[channel->channel_nb].write_ptr.list_ptr = mem_ptr->read.list_ptr;
+		temp_list = mem_ptr->read.list_ptr;
+		if(temp_list == NULL)  {
+			usb_ipc_channels[channel->channel_nb].write_flag = 0;
+			return HW_CTRL_IPC_STATUS_ERROR;
+		}
+#ifndef IPC_USE_ZERO_LEN_FRAME
+		if(temp_list->next == NULL) {   // last frame
+	        	usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 1;
+		}
+#endif /* !IPC_USE_ZERO_LEN_FRAME */
+		ret = usb_ifs->usb_write(temp_list->data_ptr, temp_list->length);
+	}
+	
+	if(ret != 0) {
+		usb_ipc_channels[channel->channel_nb].write_flag = 0;
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+        if(usb_ipc_channels[channel->channel_nb].cfg.write_callback == NULL)  {
+                SEM_LOCK(&usb_ipc_channels[channel->channel_nb].write_ptr.write_mutex);
+                usb_ipc_channels[channel->channel_nb].write_flag = 0;
+        }
+
+	return HW_CTRL_IPC_STATUS_OK;
+}
+
+/*!
+ * Used to set various channel parameters
+ *
+ * @param channel handler to the virtual channel where read has
+ *                been requested.
+ * @param action  IPC driver control action to perform.
+ * @param param   parameters required to complete the requested action
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_ioctl(HW_CTRL_IPC_CHANNEL_T * channel,
+				       HW_CTRL_IPC_IOCTL_ACTION_T action,
+				       void *param)
+{
+        /* detect channel */
+	if (usb_ipc_channels[channel->channel_nb].open_flag == 0) {
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+	switch (action) {
+	case HW_CTRL_IPC_SET_READ_CALLBACK:
+		usb_ipc_channels[channel->channel_nb].cfg.read_callback = param;
+		break;
+	case HW_CTRL_IPC_SET_WRITE_CALLBACK:
+		usb_ipc_channels[channel->channel_nb].cfg.write_callback = param;
+		break;
+	case HW_CTRL_IPC_SET_NOTIFY_CALLBACK:
+		usb_ipc_channels[channel->channel_nb].cfg.notify_callback = param;
+		break;
+	case HW_CTRL_IPC_SET_MAX_CTRL_STRUCT_NB:
+		usb_ipc_channels[channel->channel_nb].max_node_num = *(int *)param;
+		break;
+	default:
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+	return HW_CTRL_IPC_STATUS_OK;
+}
+
+/*!
+ * This function is a variant on the write() function, and is used to send a
+ * group of frames made of various pieces each to the IPC driver.
+ * It is mandatory to allow high throughput on IPC while minimizing the time
+ * spent in the drivers / interrupts.
+ *
+ * @param channel       handler to the virtual channel where read has
+ *                      been requested.
+ * @param ctrl_ptr      Pointer on the control structure.
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_write_ex2(HW_CTRL_IPC_CHANNEL_T * channel,
+					   HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *
+					   ctrl_ptr)
+{
+	int ret = -1;
+	int i;
+        USB_IPC_IFS_STRUCT *usb_ifs;
+#ifdef USE_IPC_FRAME_HEADER
+	IPC_DATA_HEADER *header = NULL;
+#endif
+#ifdef IPC_USE_TEMP_BUFFER
+	int num;
+#endif
+	
+	ENTER_FUNC();
+
+	if(usb_ipc_channels[channel->channel_nb].open_flag == 0) {
+		printk("%s: Error: channel unavailable\n", __FUNCTION__);
+		return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+	}
+	if(usb_ipc_channels[channel->channel_nb].write_flag == 1) {
+		printk("%s: Error: channel write ongoing\n", __FUNCTION__);
+		return HW_CTRL_IPC_STATUS_WRITE_ON_GOING;
+	}
+
+	if((ctrl_ptr == NULL) || (channel == NULL)) {
+		printk("%s: Error: Input arguments\n", __FUNCTION__);
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+	
+	usb_ipc_channels[channel->channel_nb].write_flag = 1;
+
+        /* save the parameters and start write operation */	
+	usb_ipc_channels[channel->channel_nb].write_type = HW_CTRL_IPC_WRITE_EX2_TYPE;
+	usb_ipc_channels[channel->channel_nb].write_ptr.node_ptr   = ctrl_ptr;
+	usb_ipc_channels[channel->channel_nb].write_ptr.node_index = 0;
+	
+	for(i = 0; i < usb_ipc_channels[channel->channel_nb].max_node_num; i++) {
+		if(ctrl_ptr[i].comand & NODE_DESCRIPTOR_END_BIT) {
+			break;
+		}
+	}
+	usb_ipc_channels[channel->channel_nb].write_ptr.node_num   = i + 1;
+	usb_ipc_channels[channel->channel_nb].write_ptr.total_num  = 0;
+	usb_ipc_channels[channel->channel_nb].write_ptr.end_flag   = 0;
+
+	usb_ifs = usb_ipc_channels[channel->channel_nb].usb_ifs;
+
+        if((usb_ifs == NULL) || (usb_ifs->usb_write == NULL))  {
+		printk("%s: Error: channel unavailable\n", __FUNCTION__);
+                return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+        }
+
+#ifdef USE_IPC_FRAME_HEADER
+	header = (IPC_DATA_HEADER *)usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff;
+	/* This re-assign is for avoiding wrong version in next sending */
+	header->version  = IPC_FRAME_VERSION;
+	/* get frame num */
+	header->nb_frame = 0;
+	header->sequence_number = sent_sequence_number;
+	DEBUG("%s:version(0x%x), sequence number(%d)\n", __FUNCTION__,  header->version, header->sequence_number);
+	for(i = 0; i < usb_ipc_channels[channel->channel_nb].write_ptr.node_num; i++) {
+		if( ctrl_ptr[i].comand & NODE_DESCRIPTOR_LAST_BIT )  {
+			header->nb_frame ++;
+			if( header->nb_frame >= MAX_FRAME_NUM)  {
+				break;
+			}
+		}
+	}
+
+#ifdef USE_OMAP_SDMA
+        ret = ipc_dma_memcpy_node2buf(&usb_ipc_channels[channel->channel_nb], ctrl_ptr);
+#else
+	/* copy data into write URB buffer */
+	frame_size = 0; 
+	frame_index = 0;
+	len = sizeof(IPC_DATA_HEADER_INDEX) + ((header->nb_frame) * sizeof(IPC_FRAME_DESCRIPTOR));
+	for(i = 0; i < usb_ipc_channels[channel->channel_nb].max_node_num; i++) {
+		if( (len + ctrl_ptr[i].length) > usb_ipc_channels[channel->channel_nb].max_temp_buff_size ) {
+			break;
+		}
+		memcpy(&usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff[len], ctrl_ptr[i].data_ptr, ctrl_ptr[i].length);
+		frame_size += ctrl_ptr[i].length;
+		len        += ctrl_ptr[i].length;
+		ctrl_ptr[i].comand |= NODE_DESCRIPTOR_DONE_BIT;
+		usb_ipc_channels[channel->channel_nb].write_ptr.total_num  += ctrl_ptr[i].length;
+		if( ctrl_ptr[i].comand & NODE_DESCRIPTOR_LAST_BIT )  {
+			header->frames[frame_index].length = frame_size;
+			frame_index ++;
+			frame_size = 0;	
+		} 
+                if(ctrl_ptr[i].comand & NODE_DESCRIPTOR_END_BIT) {
+                        break;
+                }
+	}
+//change for endian
+	usb_ipc_exchange_endian16(&(header->version));
+	if (header->nb_frame > 0) {
+		for (i = 0; i < header->nb_frame; i++)
+			usb_ipc_exchange_endian16(&(header->frames[i].length));
+		usb_ipc_exchange_endian16(&(header->nb_frame));
+	}
+//change for endian end
+#ifndef IPC_USE_ZERO_LEN_FRAME
+        usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 1;
+#endif /* !IPC_USE_ZERO_LEN_FRAME */
+        ret = usb_ifs->usb_write(usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff, len);
+#endif
+#else //
+
+#ifdef IPC_USE_TEMP_BUFFER
+	usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff_flag = 0;
+
+        /* if current buffer is: (1) last one (2) one frame (3) size is bigger than MAX_FRAME_SIZE, using this buffer for URB transfer  */
+        if( (ctrl_ptr[0].comand & (NODE_DESCRIPTOR_END_BIT ) ) || (ctrl_ptr[0].length >= MAX_FRAME_SIZE) )  {
+#endif /* IPC_USE_TEMP_BUFFER */
+
+#ifndef IPC_USE_ZERO_LEN_FRAME
+                if(usb_ipc_channels[channel->channel_nb].write_ptr.node_num == 1) {   // last frame
+                        usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 1;
+                }
+#endif /* !IPC_USE_ZERO_LEN_FRAME */
+                ret = usb_ifs->usb_write(ctrl_ptr[0].data_ptr, ctrl_ptr[0].length);
+#ifdef IPC_USE_TEMP_BUFFER
+        } else {  /* using temporary buffer for write ... */
+
+                num = usb_ipc_write_cpy_node2buf(channel->channel_nb);
+
+#ifndef IPC_USE_ZERO_LEN_FRAME
+                if(usb_ipc_channels[channel->channel_nb].write_ptr.node_index == usb_ipc_channels[channel->channel_nb].write_ptr.node_num ) {   // last frame
+                        usb_ipc_channels[channel->channel_nb].write_ptr.end_flag = 1;
+                }
+#endif /* !IPC_USE_ZERO_LEN_FRAME */
+                ret = usb_ifs->usb_write(usb_ipc_channels[channel->channel_nb].write_ptr.temp_buff, num);
+        }
+#endif  /* IPC_USE_TEMP_BUFFER */
+#endif //
+	if(ret != 0) {
+                usb_ipc_channels[channel->channel_nb].write_flag = 0;
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+        if(usb_ipc_channels[channel->channel_nb].cfg.write_callback == NULL)  {
+                SEM_LOCK(&usb_ipc_channels[channel->channel_nb].write_ptr.write_mutex);
+                usb_ipc_channels[channel->channel_nb].write_flag = 0;
+        }
+
+	return HW_CTRL_IPC_STATUS_OK;
+}
+
+/*
+ * This function is used to give a set of buffers to the IPC and enable data
+ * transfers.
+ *
+ * @param channel       handler to the virtual channel where read has
+ *                      been requested.
+ * @param ctrl_ptr      Pointer on the control structure.
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_read_ex2(HW_CTRL_IPC_CHANNEL_T * channel,
+					  HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *
+					  ctrl_ptr)
+{
+	int ret = -1;
+	int  i;
+        USB_IPC_IFS_STRUCT *usb_ifs;
+
+	ENTER_FUNC();
+	
+	if((channel == NULL) || (ctrl_ptr == NULL)) {
+		printk("%s: Error: Input arguments\n", __FUNCTION__);
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+	if(usb_ipc_channels[channel->channel_nb].open_flag == 0) {
+		printk("%s: Error: channel unavailable\n", __FUNCTION__);
+		return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+	}
+	if(usb_ipc_channels[channel->channel_nb].read_flag == 1) {
+		printk("%s: Error: channel read onging\n", __FUNCTION__);
+		return HW_CTRL_IPC_STATUS_READ_ON_GOING;
+	}
+	
+	usb_ipc_channels[channel->channel_nb].read_flag = 1;	
+
+        /* save the parameters and start read operation */	
+	usb_ipc_channels[channel->channel_nb].read_type = HW_CTRL_IPC_READ_EX2_TYPE;
+	usb_ipc_channels[channel->channel_nb].read_ptr.node_ptr   = ctrl_ptr;
+	usb_ipc_channels[channel->channel_nb].read_ptr.node_index = 0;
+	
+	for(i = 0; i < usb_ipc_channels[channel->channel_nb].max_node_num; i++) {
+		if(ctrl_ptr[i].comand & NODE_DESCRIPTOR_END_BIT) {
+			break;
+		}
+	}
+	usb_ipc_channels[channel->channel_nb].read_ptr.node_num = i + 1;
+	usb_ipc_channels[channel->channel_nb].read_ptr.total_num  = 0;
+	
+	usb_ifs = usb_ipc_channels[channel->channel_nb].usb_ifs;
+        if((usb_ifs == NULL) || (usb_ifs->usb_read == NULL))  {
+		printk("%s: Error: channel unavailable\n", __FUNCTION__);
+                return HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE;
+        }
+
+#ifdef USE_IPC_FRAME_HEADER
+        ret = usb_ifs->usb_read(usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff, usb_ipc_channels[channel->channel_nb].max_temp_buff_size);
+#else // USE_IPC_FRAME_HEADER
+
+#ifdef IPC_USE_TEMP_BUFFER
+	usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff_flag = 0;
+        if( ctrl_ptr[0].length >= MAX_FRAME_SIZE ) {
+#endif /* IPC_USE_TEMP_BUFFER */
+                ret = usb_ifs->usb_read(ctrl_ptr[0].data_ptr ,ctrl_ptr[0].length);
+#ifdef IPC_USE_TEMP_BUFFER
+        } else {
+                /* use the temporary buffer for URB transfer */
+                usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff_flag = 1;
+                ret = usb_ifs->usb_read(usb_ipc_channels[channel->channel_nb].read_ptr.temp_buff, MAX_FRAME_SIZE);
+        }
+#endif /* IPC_USE_TEMP_BUFFER */
+#endif // USE_IPC_FRAME_HEADER
+	if(ret != 0) {
+                usb_ipc_channels[channel->channel_nb].read_flag = 0;
+		return HW_CTRL_IPC_STATUS_ERROR;
+	}
+
+	/* No callback, waiting receiving is done */
+        if(usb_ipc_channels[channel->channel_nb].cfg.read_callback == NULL)  {
+                SEM_LOCK(&usb_ipc_channels[channel->channel_nb].read_ptr.read_mutex);
+                usb_ipc_channels[channel->channel_nb].read_flag = 0;
+        }
+	return HW_CTRL_IPC_STATUS_OK;
+}
+
+/*
+ * This function is used by netmux_linkdriver to register a callback function,
+ * the IPC could call this callback when BP enumerate.
+ *
+ * @param cb            the callback function
+ */
+
+#define LINK_DRIVER_CB_DELAY	(MSEC_PER_SEC/2)
+struct delayed_work link_driver_work;
+struct workqueue_struct *klink_driver_wq;
+void (*link_driver_cb)(void) = NULL;
+void hw_ctrl_ipc_register(void * param)
+{
+    link_driver_cb = param;
+    if (usb_ipc_channels[IPC_DATA_CH_NUM].usb_ifs != 0)
+    {
+        queue_delayed_work(klink_driver_wq, &link_driver_work, msecs_to_jiffies(LINK_DRIVER_CB_DELAY));
+    }
+}
+
+static void link_driver_work_handler(struct work_struct *work)
+{
+    if (link_driver_cb)
+    {
+        DEBUG("%s:jiffies=%lu execute link_driver callback function\n", __FUNCTION__, jiffies);
+        link_driver_cb();
+    }
+}
+
+/*
+ * this function will be called by probe function of USB class driver.
+ */
+void ipc_api_usb_probe(USB_IPC_CHANNEL_INDEX ch_index, USB_IPC_IFS_STRUCT *usb_ifs)
+{
+        /* save the relevant USB class driver paramters */
+        usb_ipc_channels[ch_index].usb_ifs = usb_ifs;
+
+        if (link_driver_cb != NULL)
+        {
+                queue_delayed_work(klink_driver_wq, &link_driver_work, msecs_to_jiffies(LINK_DRIVER_CB_DELAY));
+        }
+}
+
+/*
+ * this function will be called by disconnect function of USB class driver.
+ */
+void ipc_api_usb_disconnect(USB_IPC_CHANNEL_INDEX ch_index)
+{
+        /* clear the relevant USB class driver paramters */
+        usb_ipc_channels[ch_index].usb_ifs = 0;
+
+        cancel_delayed_work_sync(&link_driver_work);
+        destroy_workqueue(klink_driver_wq);
+}
+
+/*
+ * IPC API module init function
+ */
+void ipc_api_init(void)
+{
+	int i;
+
+	for(i = 0; i < MAX_USB_IPC_CHANNELS; i++) { 
+	        memset((void *)&usb_ipc_channels[i], 0, sizeof(USB_IPC_API_PARAMS));
+	        /* initialize the semphores */
+        	SEM_LOCK_INIT(&usb_ipc_channels[i].write_ptr.write_mutex);
+	        SEM_LOCK_INIT(&usb_ipc_channels[i].read_ptr.read_mutex);
+	}
+    INIT_DELAYED_WORK(&link_driver_work, link_driver_work_handler);
+    klink_driver_wq = create_singlethread_workqueue("klink_driver_wq");
+}
+
+/*
+ * IPC API module exit function
+ */
+void ipc_api_exit(void)
+{
+}
+
+/*  */
+EXPORT_SYMBOL(hw_ctrl_ipc_open);
+EXPORT_SYMBOL(hw_ctrl_ipc_close);
+EXPORT_SYMBOL(hw_ctrl_ipc_read);
+EXPORT_SYMBOL(hw_ctrl_ipc_write);
+EXPORT_SYMBOL(hw_ctrl_ipc_write_ex);
+EXPORT_SYMBOL(hw_ctrl_ipc_write_ex2);
+EXPORT_SYMBOL(hw_ctrl_ipc_read_ex2);
+EXPORT_SYMBOL(hw_ctrl_ipc_ioctl);
+EXPORT_SYMBOL(hw_ctrl_ipc_register);
diff --git a/drivers/usb/ipchost/ipc_api_test.c b/drivers/usb/ipchost/ipc_api_test.c
new file mode 100644
index 0000000..e82bfc9
--- /dev/null
+++ b/drivers/usb/ipchost/ipc_api_test.c
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) 2007-2008 Motorola, Inc
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * Changelog:
+ * Date               Author           Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007      Motorola        USB-IPC initial
+ * 03/22/2007      Motorola        USB-IPC header support
+ * 05/09/2008      Motorola        Change Copyright and Changelog
+ * 
+ */
+ 
+/*!
+ * @file drivers/usb/ipchost/ipc_api_test.c
+ * @brief USB-IPC test Set
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/kthread.h>
+#include <linux/circ_buf.h>
+#include <linux/uio.h>
+#include <linux/poll.h>
+#include <linux/usb.h>
+#include <linux/usb_ipc.h>
+#include <linux/ipc_api.h>
+
+
+/* Module */
+MODULE_DESCRIPTION("OMAP SAM IPC Test Module");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
+
+
+#define DEBUG(args...)  //printk(args)
+#define ENTER_FUNC()    DEBUG("Enter: %s\n", __FUNCTION__)
+
+#define API_DATA_CH_MINOR_NUM       240  /*  */
+#define API_SHORT_CH_MINOR_NUM      241  /*  */
+
+#define MAX_DATA_WRITE_BUF_SIZE     MAX_FRAME_SIZE 
+#define MAX_DATA_READ_BUF_SIZE      MAX_FRAME_SIZE 
+
+HW_CTRL_IPC_CHANNEL_T   *ipc_data_ch  = NULL;
+HW_CTRL_IPC_CHANNEL_T   *ipc_short_ch = NULL;
+HW_CTRL_IPC_OPEN_T      ipc_data_ch_desc;
+HW_CTRL_IPC_OPEN_T      ipc_short_ch_desc;
+
+IPC_CHANNEL_ACCESS_TYPE ipc_data_ch_read_type = HW_CTRL_IPC_READ_TYPE;
+IPC_CHANNEL_ACCESS_TYPE ipc_data_ch_write_type = HW_CTRL_IPC_WRITE_TYPE;
+
+IPC_CHANNEL_ACCESS_TYPE ipc_short_ch_read_type = HW_CTRL_IPC_READ_TYPE; 
+IPC_CHANNEL_ACCESS_TYPE ipc_short_ch_write_type = HW_CTRL_IPC_WRITE_TYPE;
+
+int	ipc_data_read_actual_length = 0;
+int     ipc_data_write_actual_length = 0;
+unsigned char ipc_data_read_buffer[MAX_FRAME_NUM][MAX_DATA_READ_BUF_SIZE];
+unsigned char ipc_data_write_buffer[MAX_FRAME_NUM][MAX_DATA_WRITE_BUF_SIZE];
+
+static struct semaphore ipc_data_read_wait;
+static struct semaphore ipc_data_write_wait;
+
+#define NODE_DESCRIPTOR_END_BIT  0x4000
+#define NODE_DESCRIPTOR_LAST_BIT 0x8000
+#define NODE_DESCRIPTOR_DONE_BIT 0x2000
+
+/* file operation for USB DATA test */
+static int ipc_api_data_open(struct inode * inode, struct file * file)
+{
+	ENTER_FUNC();
+//	HW_CTRL_IPC_CHANNEL_T *temp_ch;
+
+	if(ipc_data_ch != NULL) {
+		return -EBUSY;
+	}
+	ipc_data_ch = hw_ctrl_ipc_open(&ipc_data_ch_desc);
+	if(ipc_data_ch == NULL) {
+		return -ENOMEM;
+	}
+
+//	temp_ch = hw_ctrl_ipc_open(&ipc_data_ch_desc);
+//	if(temp_ch != NULL) {
+//		ipc_data_ch = temp_ch;
+//	}
+
+	return 0;
+}
+
+static int ipc_api_data_release(struct inode * inode, struct file * file)
+{
+	ENTER_FUNC();
+	hw_ctrl_ipc_close(ipc_data_ch);
+	ipc_data_ch = NULL;
+	return 0;
+}
+
+static ssize_t ipc_api_data_read(struct file * filp, char __user * buf, size_t count, loff_t * l)
+{
+	HW_CTRL_IPC_STATUS_T status;
+	int size, ret, num;
+	HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T temp_desc[MAX_FRAME_NUM];
+#if defined(USE_IPC_FRAME_HEADER)
+	int i;
+#endif
+
+	ENTER_FUNC();
+
+	ipc_data_read_actual_length = 0;	
+	size = count > MAX_DATA_READ_BUF_SIZE ? MAX_DATA_READ_BUF_SIZE : count;
+
+#if defined(USE_IPC_FRAME_HEADER)
+	for(i=0; i < MAX_FRAME_NUM; i++) {
+		temp_desc[i].comand = 0; 
+		temp_desc[i].length   = MAX_DATA_READ_BUF_SIZE;	
+		temp_desc[i].data_ptr = &(ipc_data_read_buffer[i][0]);	
+	}
+	temp_desc[MAX_FRAME_NUM - 1].comand = NODE_DESCRIPTOR_END_BIT; 
+#else
+	temp_desc[0].comand   = NODE_DESCRIPTOR_END_BIT; 
+	temp_desc[0].length   = size;	
+	temp_desc[0].data_ptr = &(ipc_data_read_buffer[0]);	
+
+#endif
+	status = hw_ctrl_ipc_read_ex2(ipc_data_ch, &temp_desc[0]);
+	if(status == HW_CTRL_IPC_STATUS_OK) {
+		down(&ipc_data_read_wait);
+	}
+	num = ipc_data_read_actual_length;
+	if(num > count) {
+		num = count;
+	}
+	ret = copy_to_user(buf, ipc_data_read_buffer, num);
+	return ipc_data_read_actual_length;
+}
+
+//HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T temp_desc[4];
+static ssize_t ipc_api_data_write(struct file * filp, const char * buf, size_t count, loff_t * l)
+{
+        HW_CTRL_IPC_STATUS_T status = HW_CTRL_IPC_STATUS_ERROR;
+#if defined(USE_IPC_FRAME_HEADER)
+        int i, j;
+	unsigned short temp_buf[MAX_FRAME_NUM + 1];
+#else
+	int size;
+#endif
+        HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T temp_desc[MAX_FRAME_NUM];
+        int ret;
+
+	ENTER_FUNC();
+
+	ipc_data_write_actual_length = 0;
+#if defined(USE_IPC_FRAME_HEADER)
+	ret = copy_from_user((void *)&temp_buf[0], buf, 2 * MAX_FRAME_NUM + 2);
+
+	for(i=0; (i< MAX_FRAME_NUM) && (i < temp_buf[0]); i++) {
+                temp_desc[i].comand = NODE_DESCRIPTOR_LAST_BIT;
+                temp_desc[i].length   = temp_buf[i+1];
+		for(j = 0; j < temp_buf[i+1]; j++) {
+			ipc_data_write_buffer[i][j] = j & 0xff;
+		}
+                temp_desc[i].data_ptr = &(ipc_data_write_buffer[i][0]);
+	}
+	if(i > 0) {
+	        temp_desc[i-1].comand = NODE_DESCRIPTOR_END_BIT | NODE_DESCRIPTOR_LAST_BIT;
+	}
+#else
+        size = count > MAX_DATA_WRITE_BUF_SIZE ? MAX_DATA_WRITE_BUF_SIZE : count;
+        ret = copy_from_user(ipc_data_write_buffer, buf, size);
+        temp_desc[0].comand = NODE_DESCRIPTOR_END_BIT | NODE_DESCRIPTOR_LAST_BIT;
+        temp_desc[0].length   = size;
+        temp_desc[0].data_ptr = &(ipc_data_write_buffer[0]);
+#endif
+        status = hw_ctrl_ipc_write_ex2(ipc_data_ch, &(temp_desc[0]));
+	if(status == HW_CTRL_IPC_STATUS_OK) {
+               	down(&ipc_data_write_wait);
+	}
+
+	return ipc_data_write_actual_length;
+}
+
+static int ipc_api_data_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	if(arg == 0x01) {
+		ipc_data_ch_read_type = HW_CTRL_IPC_READ_TYPE;
+	} else if(arg == 0x02) {
+		ipc_data_ch_read_type = HW_CTRL_IPC_READ_EX2_TYPE;
+        } else if(arg == 0x11) {
+                ipc_data_ch_write_type = HW_CTRL_IPC_WRITE_TYPE;
+        } else if(arg == 0x12) {
+                ipc_data_ch_write_type = HW_CTRL_IPC_WRITE_EX_CONT_TYPE;
+        } else if(arg == 0x13) {
+                ipc_data_ch_write_type = HW_CTRL_IPC_WRITE_EX_LIST_TYPE;
+        } else if(arg == 0x14) {
+                ipc_data_ch_write_type = HW_CTRL_IPC_WRITE_EX2_TYPE;
+        } else {
+		printk("%s: Error IOCTL cmd\n", __FUNCTION__);
+                return -EIO;
+	}
+
+        return 0;
+}
+
+/* file operation struction for IPC API DATA channel */
+static struct file_operations ipc_api_data_fops = {
+        owner:          THIS_MODULE,
+        open:           ipc_api_data_open,
+        release:        ipc_api_data_release,
+        read:           ipc_api_data_read,
+        ioctl:          ipc_api_data_ioctl,
+        write:          ipc_api_data_write,
+};
+static struct miscdevice ipc_api_data_device = {
+        API_DATA_CH_MINOR_NUM, "ipc_api_data", &ipc_api_data_fops
+};
+
+/* file operation for USB DATA test */
+static int ipc_api_short_open(struct inode * inode, struct file * file)
+{
+        ENTER_FUNC();
+        return 0;
+}
+
+static int ipc_api_short_release(struct inode * inode, struct file * file)
+{
+        ENTER_FUNC();
+        return 0;
+}
+
+static ssize_t ipc_api_short_read(struct file * filp, char __user * buf, size_t count, loff_t * l)
+{
+        ENTER_FUNC();
+        return 0;
+}
+
+static ssize_t ipc_api_short_write(struct file * filp, const char * buf, size_t count, loff_t * l)
+{
+        ENTER_FUNC();
+        return 0;
+}
+
+static int ipc_api_short_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+        ENTER_FUNC();
+        return 0;
+}
+
+/* file operation struction for IPC API SHORT channel */
+static struct file_operations ipc_api_short_fops = {
+        owner:          THIS_MODULE,
+        open:           ipc_api_short_open,
+        release:        ipc_api_short_release,
+        read:           ipc_api_short_read,
+        write:          ipc_api_short_write,
+        ioctl:          ipc_api_short_ioctl,
+};
+static struct miscdevice ipc_api_short_device = {
+        API_SHORT_CH_MINOR_NUM, "ipc_api_short", &ipc_api_short_fops
+};
+
+void shortmsg_read_callback(HW_CTRL_IPC_READ_STATUS_T *status)
+{
+	ENTER_FUNC();
+}
+
+void shortmsg_write_callback(HW_CTRL_IPC_WRITE_STATUS_T *status)
+{
+	ENTER_FUNC();
+}
+
+void shortmsg_notify_callback(HW_CTRL_IPC_NOTIFY_STATUS_T *status)
+{
+	ENTER_FUNC();
+}
+
+void data_read_callback(HW_CTRL_IPC_READ_STATUS_T *status)
+{
+	ENTER_FUNC();
+	ipc_data_read_actual_length = status->nb_bytes;
+	up(&ipc_data_read_wait);
+}
+
+void data_write_callback(HW_CTRL_IPC_WRITE_STATUS_T *status)
+{
+	ENTER_FUNC();
+	ipc_data_write_actual_length =  status->nb_bytes;
+        up(&ipc_data_write_wait);
+}
+
+void data_notify_callback(HW_CTRL_IPC_NOTIFY_STATUS_T *status)
+{
+	ENTER_FUNC();
+}
+
+/*
+ * driver module init/exit functions
+ */
+static int __init ipc_api_test_init(void)
+{
+        int retval;
+
+        sema_init(&ipc_data_read_wait, 0);
+        sema_init(&ipc_data_write_wait, 0);
+
+	ENTER_FUNC();
+
+	retval  = misc_register( &ipc_api_data_device);
+        if( retval )   {
+                printk("%s: Register IPC API DATA device failed\n", __FUNCTION__);
+                return -ENODEV;
+        }
+
+	retval  = misc_register( &ipc_api_short_device);
+        if( retval )   {
+                printk("%s: Register IPC API Short device failed\n", __FUNCTION__);
+                return -ENODEV;
+        }
+	
+	ipc_short_ch_desc.type  = HW_CTRL_IPC_SHORT_MSG;
+	ipc_short_ch_desc.index = 0;
+	ipc_short_ch_desc.read_callback   = &shortmsg_read_callback;
+	ipc_short_ch_desc.write_callback  = &shortmsg_write_callback;
+	ipc_short_ch_desc.notify_callback = &shortmsg_notify_callback;
+
+        ipc_data_ch_desc.type  = HW_CTRL_IPC_PACKET_DATA;
+        ipc_data_ch_desc.index = 0;
+        ipc_data_ch_desc.read_callback   = &data_read_callback;
+        ipc_data_ch_desc.write_callback  = &data_write_callback;
+        ipc_data_ch_desc.notify_callback = &data_notify_callback;
+
+        return retval;
+}
+
+static void __exit ipc_api_test_exit(void)
+{
+	ENTER_FUNC();
+	misc_deregister( &ipc_api_data_device);
+	misc_deregister( &ipc_api_short_device);
+}
+
+/* the module entry declaration of this driver */
+module_init(ipc_api_test_init);
+module_exit(ipc_api_test_exit);
+
+
diff --git a/drivers/usb/ipchost/ipc_data.c b/drivers/usb/ipchost/ipc_data.c
new file mode 100644
index 0000000..735280d
--- /dev/null
+++ b/drivers/usb/ipchost/ipc_data.c
@@ -0,0 +1,893 @@
+/*
+ * Copyright (c) 2007 - 2008 Motorola, Inc, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * 
+ * Changelog:
+ * Date               Author           Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007      Motorola        USB-IPC initial
+ * 03/22/2008      Motorola        USB-IPC header support
+ * 10/09/2008      Motorola        USB-IPC suspend/resume support
+ * 
+ */
+ 
+/*!
+ * @file drivers/usb/ipchost/ipc_data.c
+ * @brief USB-IPC Descriptor Set
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <mach/hardware.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/usb_ipc.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+
+#ifdef USE_OMAP_SDMA
+#include <mach/dma.h>
+#endif
+
+/* For debug only */
+#include <linux/io.h>
+#include <mach/io.h>
+
+/* Module */
+MODULE_DESCRIPTION("OMAP SAM IPC Test Module");
+MODULE_AUTHOR("Motorola");
+MODULE_LICENSE("GPL");
+
+#define DEBUG(args...) //printk(args)
+
+//#define USB_DATA_LOG
+
+static struct usb_device_id usb_ipc_id_table [] = {
+	{ USB_DEVICE(MOTO_USBIPC_VID, MOTO_USBIPC_PID) },
+	{ }						/* Terminating entry */
+};
+
+// USB endpoint detection
+#define IS_EP_BULK(ep)     (((ep)->bmAttributes) == USB_ENDPOINT_XFER_BULK ? 1 : 0)
+#define IS_EP_BULK_IN(ep)  (IS_EP_BULK(ep) && (((ep)->bEndpointAddress) & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+#define IS_EP_BULK_OUT(ep) (IS_EP_BULK(ep) && (((ep)->bEndpointAddress) & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+
+/* Wakes up kipcd */
+static struct task_struct *kipcd_task;
+DEFINE_SPINLOCK(ipc_event_lock);
+DECLARE_WAIT_QUEUE_HEAD(kipcd_wait);
+
+/*  */
+USB_IPC_IFS_STRUCT usb_ipc_data_param;
+
+#ifdef CONFIG_PM
+extern USB_LOG_IFS_STRUCT ipc_log_param;
+#endif // CONFIG_PM
+
+/******************************************************/
+
+//#define USB_STACK_SEND_ZERO_PACKET
+
+#ifndef USB_STACK_SEND_ZERO_PACKET
+static int ipc_data_urb_actual_len = 0;
+#endif
+
+int ipc_dbg_index;
+char ipc_dbg_array[IPC_DBG_ARRAY_SIZE];
+unsigned int dma_vsrc;
+unsigned int dma_psrc;
+unsigned int dma_vdest;
+unsigned int dma_pdest;
+unsigned int dma_size;
+unsigned int dma_ch;
+
+#ifdef CONFIG_PM
+static void ipc_suspend_work(struct work_struct *work)
+{
+  unsigned long flags;
+  USB_IPC_IFS_STRUCT *usb_ifs = container_of(work, USB_IPC_IFS_STRUCT, suspend_work.work);
+  if(usb_ifs->sleeping == 0) {
+    spin_lock_irqsave(&ipc_event_lock, flags);
+    usb_ipc_data_param.ipc_events |= IPC_PM_SUSPEND;
+    spin_unlock_irqrestore(&ipc_event_lock, flags);
+    wake_up(&kipcd_wait);
+  }
+}
+
+static void ipc_resume_work(struct work_struct *work)
+{
+  unsigned long flags;
+  USB_IPC_IFS_STRUCT *usb_ifs = container_of(work, USB_IPC_IFS_STRUCT, wakeup_work);
+  if(usb_ifs->sleeping == 1) {
+    spin_lock_irqsave(&ipc_event_lock, flags);
+    usb_ipc_data_param.ipc_events |= IPC_PM_RESUME;
+    spin_unlock_irqrestore(&ipc_event_lock, flags);
+    wake_up(&kipcd_wait);
+  }
+}
+#endif
+
+/*
+ * write buffer
+ */
+static int ipc_data_write_buffer(unsigned char *buff, int size)
+{
+  int ret = 0;
+  unsigned long flags;
+
+#ifndef USB_STACK_SEND_ZERO_PACKET
+  ipc_data_urb_actual_len = 0;
+#endif
+
+#ifdef USB_DATA_LOG
+  printk("Enter %s:   size = %d\n", __FUNCTION__, size);
+  for(ret = 0; ret < size; ret ++) {
+    printk("0x%x, ", buff[ret]);
+    if( ((ret + 1) % 10) == 0) {
+      printk ("\n");
+    }
+  }
+  ret = 0;
+#endif
+
+#ifdef USB_STACK_SEND_ZERO_PACKET
+  usb_ipc_data_param.write_urb.transfer_flags |= URB_ZERO_PACKET;
+#endif
+  usb_ipc_data_param.write_urb.transfer_buffer = buff;
+  usb_ipc_data_param.write_urb.transfer_buffer_length = size;
+  usb_ipc_data_param.write_urb.dev = usb_ipc_data_param.udev;
+
+  spin_lock_irqsave(&ipc_event_lock, flags);
+  usb_ipc_data_param.ipc_events |= IPC_DATA_WR;
+  spin_unlock_irqrestore(&ipc_event_lock, flags);
+  wake_up(&kipcd_wait);
+
+  return ret; 
+}
+
+/*
+ * read buffer
+ */
+static int ipc_data_read_buffer(unsigned char *buff, int size)
+{
+  int ret = 0;
+  unsigned long flags;
+
+  usb_ipc_data_param.read_urb.transfer_buffer = buff;
+  usb_ipc_data_param.read_urb.transfer_buffer_length = size;
+  usb_ipc_data_param.read_urb.dev = usb_ipc_data_param.udev;
+
+  spin_lock_irqsave(&ipc_event_lock, flags);
+  usb_ipc_data_param.ipc_events |= IPC_DATA_RD;
+  spin_unlock_irqrestore(&ipc_event_lock, flags);
+  wake_up(&kipcd_wait);
+	ipc_dbg_array[ipc_dbg_index++] = 0x1;
+	if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+		ipc_dbg_index = 0;
+
+  return ret;
+}
+
+/*
+ *  BULK IN callback
+ */
+static void ipc_data_read_callback(struct urb *urb)
+{
+  unsigned long flags;
+  DEBUG("\n%s: received %d bytes @ jiffies = %lu\n", __FUNCTION__, urb->actual_length, jiffies);
+
+#ifdef USB_DATA_LOG
+  int ret;
+  char * buff;
+  buff = (char *)urb->transfer_buffer;
+  for(ret = 0; ret < urb->actual_length; ret ++) {
+    printk("0x%x, ", buff[ret]); 
+    if(((ret + 1) % 10) == 0) {
+      printk ("\n");
+    }
+  }
+#endif
+
+  spin_lock_irqsave(&ipc_event_lock, flags);
+  usb_ipc_data_param.ipc_events |= IPC_DATA_RD_CB;
+  spin_unlock_irqrestore(&ipc_event_lock, flags);
+  wake_up(&kipcd_wait);
+	ipc_dbg_array[ipc_dbg_index++] = 0x11;
+	if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+		ipc_dbg_index = 0;
+}
+
+/*
+ *  BULK OUT callback
+ */
+static void ipc_data_write_callback(struct urb *urb)
+{
+  unsigned long flags;
+  DEBUG("\n%s: transmitted %d bytes @ jiffies = %lu\n", __FUNCTION__, urb->actual_length, jiffies);
+
+  /* if the last transmit is not zero, but it is multiple of MaxPacketSize, send zero package */
+#ifndef USB_STACK_SEND_ZERO_PACKET
+  ipc_data_urb_actual_len += urb->actual_length;
+
+  if((usb_ipc_data_param.write_urb.transfer_buffer_length != 0) &&
+     ((usb_ipc_data_param.write_urb.transfer_buffer_length % usb_ipc_data_param.write_wMaxPacketSize) ==0)) {
+    usb_ipc_data_param.write_urb.transfer_buffer_length = 0;
+    usb_ipc_data_param.write_urb.dev = usb_ipc_data_param.udev;
+    usb_submit_urb(&usb_ipc_data_param.write_urb, GFP_ATOMIC|GFP_DMA);
+  }
+  else {
+    spin_lock_irqsave(&ipc_event_lock, flags);
+    usb_ipc_data_param.ipc_events |= IPC_DATA_WR_CB;
+    spin_unlock_irqrestore(&ipc_event_lock, flags);
+    wake_up(&kipcd_wait);
+  }
+#else /* USB_STACK_SEND_ZERO_PACKET */
+  spin_lock_irqsave(&ipc_event_lock, flags);
+  usb_ipc_data_param.ipc_events |= IPC_DATA_WR_CB;
+  spin_unlock_irqrestore(&ipc_event_lock, flags);
+  wake_up(&kipcd_wait);
+#endif /* USB_STACK_SEND_ZERO_PACKET */
+}
+
+static void ipc_events(void)
+{
+  int ret = 0;
+  int pending_events;
+  unsigned long flags;
+
+  spin_lock_irqsave(&ipc_event_lock, flags);
+  pending_events = usb_ipc_data_param.ipc_events;
+  usb_ipc_data_param.ipc_events = 0;
+  spin_unlock_irqrestore(&ipc_event_lock, flags);
+
+  while((pending_events != 0) && (ret == 0)) {
+    /* process ipc_data_write_buffer */
+    if(pending_events & IPC_DATA_WR) {
+      pending_events &= ~IPC_DATA_WR;
+#ifdef CONFIG_PM
+      cancel_delayed_work_sync(&usb_ipc_data_param.suspend_work);
+      spin_lock_bh(&usb_ipc_data_param.pm_lock);
+      if(usb_ipc_data_param.sleeping == 0) {
+        usb_ipc_data_param.working = 1;
+        ret = usb_submit_urb(&usb_ipc_data_param.write_urb, GFP_ATOMIC|GFP_DMA);
+        spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+        pending_events &= ~IPC_PM_SUSPEND;
+        spin_lock_irqsave(&ipc_event_lock, flags);
+        usb_ipc_data_param.ipc_events &= ~IPC_PM_SUSPEND;
+        spin_unlock_irqrestore(&ipc_event_lock, flags);
+      }
+      else {
+        usb_ipc_data_param.write_urb_used = 1;
+        spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+        usb_autopm_get_interface(usb_ifnum_to_if(usb_ipc_data_param.udev, IPC_DATA_CH_NUM));
+      }
+#else
+      ret = usb_submit_urb(&usb_ipc_data_param.write_urb, GFP_ATOMIC|GFP_DMA);
+#endif
+    }
+    /* process ipc_data_read_buffer */
+    if(pending_events & IPC_DATA_RD) {
+      pending_events &= ~IPC_DATA_RD;
+#ifdef CONFIG_PM
+      spin_lock_bh(&usb_ipc_data_param.pm_lock);
+      if(usb_ipc_data_param.sleeping == 0) {
+        ret = usb_submit_urb(&usb_ipc_data_param.read_urb, GFP_ATOMIC|GFP_DMA);
+        spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+	ipc_dbg_array[ipc_dbg_index++] = 0x2;
+	if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+		ipc_dbg_index = 0;
+      }
+      else {
+        usb_ipc_data_param.read_urb_used = 1;
+        spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+	ipc_dbg_array[ipc_dbg_index++] = 0x3;
+	if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+		ipc_dbg_index = 0;
+      }
+#else
+      ret = usb_submit_urb(&usb_ipc_data_param.read_urb, GFP_ATOMIC|GFP_DMA);
+#endif
+    }
+    /* process ipc_data_write_callback */
+    if(pending_events & IPC_DATA_WR_CB) {
+      pending_events &= ~IPC_DATA_WR_CB;
+#ifdef CONFIG_PM
+      spin_lock_bh(&usb_ipc_data_param.pm_lock);
+      usb_ipc_data_param.working = 0;
+      if(usb_ipc_data_param.sleeping == 0) {
+        spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+        pending_events &= ~IPC_PM_SUSPEND;
+        spin_lock_irqsave(&ipc_event_lock, flags);
+        usb_ipc_data_param.ipc_events &= ~IPC_PM_SUSPEND;
+        spin_unlock_irqrestore(&ipc_event_lock, flags);
+        cancel_delayed_work_sync(&usb_ipc_data_param.suspend_work);
+        queue_delayed_work(usb_ipc_data_param.ksuspend_usb_wq, &usb_ipc_data_param.suspend_work,
+                           msecs_to_jiffies(USB_IPC_SUSPEND_DELAY));
+      }
+      else spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+#endif /* CONFIG_PM */
+#ifndef USB_STACK_SEND_ZERO_PACKET
+      if(usb_ipc_data_param.ipc_write_cb != NULL) {
+        usb_ipc_data_param.ipc_write_cb(IPC_DATA_CH_NUM, 0, ipc_data_urb_actual_len);
+      }
+#else /* USB_STACK_SEND_ZERO_PACKET */
+      if(usb_ipc_data_param.ipc_write_cb != NULL) {
+        usb_ipc_data_param.ipc_write_cb(IPC_DATA_CH_NUM, 0, usb_ipc_data_param.write_urb.actual_length);
+      }
+#endif /* USB_STACK_SEND_ZERO_PACKET */
+    }
+    /* process ipc_data_read_callback */
+    if(pending_events & IPC_DATA_RD_CB) {
+      pending_events &= ~IPC_DATA_RD_CB;
+#ifdef CONFIG_PM
+      spin_lock_bh(&usb_ipc_data_param.pm_lock);
+      if(usb_ipc_data_param.sleeping == 0) {
+        spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+        pending_events &= ~IPC_PM_SUSPEND;
+        spin_lock_irqsave(&ipc_event_lock, flags);
+        usb_ipc_data_param.ipc_events &= ~IPC_PM_SUSPEND;
+        spin_unlock_irqrestore(&ipc_event_lock, flags);
+        cancel_delayed_work_sync(&usb_ipc_data_param.suspend_work);
+        queue_delayed_work(usb_ipc_data_param.ksuspend_usb_wq, &usb_ipc_data_param.suspend_work,
+                           msecs_to_jiffies(USB_IPC_SUSPEND_DELAY));
+      }
+      else spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+#endif
+	if ((usb_ipc_data_param.read_urb.status < 0) &&
+	    (usb_ipc_data_param.read_urb.actual_length != 0)) {
+		printk(KERN_INFO "incomplete IN transfer status%d length%d\n",
+			usb_ipc_data_param.read_urb.status,
+			usb_ipc_data_param.read_urb.actual_length);
+		if (usb_ipc_data_param.truncated_buf == NULL)
+			usb_ipc_data_param.truncated_buf = (char *)
+				usb_ipc_data_param.read_urb.transfer_buffer;
+		usb_ipc_data_param.truncated_size +=
+			usb_ipc_data_param.read_urb.actual_length;
+		usb_ipc_data_param.read_urb.transfer_buffer =
+			usb_ipc_data_param.truncated_buf
+				+ usb_ipc_data_param.truncated_size;
+		usb_ipc_data_param.read_urb.transfer_buffer_length -=
+			usb_ipc_data_param.read_urb.actual_length;
+		spin_lock_bh(&usb_ipc_data_param.pm_lock);
+		if (usb_ipc_data_param.sleeping == 1) {
+			spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+			usb_ipc_data_param.read_urb_used = 1;
+		} else {
+			spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+			ret = usb_submit_urb(&usb_ipc_data_param.read_urb,
+					     GFP_ATOMIC|GFP_DMA);
+		}
+	} else {
+		if ((usb_ipc_data_param.truncated_buf != NULL) &&
+		    (usb_ipc_data_param.truncated_size != 0)) {
+			printk(KERN_INFO "trying to re-assemble \
+				incomplete IN transfer\n");
+			usb_ipc_data_param.read_urb.transfer_buffer =
+				usb_ipc_data_param.truncated_buf;
+			usb_ipc_data_param.read_urb.actual_length +=
+				usb_ipc_data_param.truncated_size;
+			usb_ipc_data_param.truncated_buf = NULL;
+			usb_ipc_data_param.truncated_size = 0;
+		}
+		if (usb_ipc_data_param.ipc_read_cb != NULL)
+			usb_ipc_data_param.ipc_read_cb(IPC_DATA_CH_NUM,
+				0, usb_ipc_data_param.read_urb.actual_length);
+	}
+    }
+    /* process ipc_log_read_callback */
+    if(pending_events & IPC_LOG_RD_CB) {
+      pending_events &= ~IPC_LOG_RD_CB;
+#ifdef CONFIG_PM
+      spin_lock_bh(&usb_ipc_data_param.pm_lock);
+      if(usb_ipc_data_param.sleeping == 0) {
+        spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+        pending_events &= ~IPC_PM_SUSPEND;
+        spin_lock_irqsave(&ipc_event_lock, flags);
+        usb_ipc_data_param.ipc_events &= ~IPC_PM_SUSPEND;
+        spin_unlock_irqrestore(&ipc_event_lock, flags);
+        cancel_delayed_work_sync(&usb_ipc_data_param.suspend_work);
+        queue_delayed_work(usb_ipc_data_param.ksuspend_usb_wq, &usb_ipc_data_param.suspend_work,
+                           msecs_to_jiffies(USB_IPC_SUSPEND_DELAY));
+      }
+      else spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+#endif
+    }
+#ifdef CONFIG_PM
+    if(pending_events & IPC_PM_SUSPEND) {
+      pending_events &= ~IPC_PM_SUSPEND;
+      DEBUG("%s @ jiffies=%lu\n", __FUNCTION__, jiffies);
+	usb_ipc_data_param.allow_suspend = 1;
+      usb_autopm_put_interface(usb_ifnum_to_if(usb_ipc_data_param.udev, IPC_DATA_CH_NUM));
+    }
+    if(pending_events & IPC_PM_RESUME) {
+      pending_events &= ~IPC_PM_RESUME;
+      DEBUG("%s @ jiffies=%lu\n", __FUNCTION__, jiffies);
+      usb_autopm_get_interface(usb_ifnum_to_if(usb_ipc_data_param.udev, IPC_DATA_CH_NUM));
+    }
+#endif
+
+    spin_lock_irqsave(&ipc_event_lock, flags);
+    pending_events = usb_ipc_data_param.ipc_events;
+    usb_ipc_data_param.ipc_events = 0;
+    spin_unlock_irqrestore(&ipc_event_lock, flags);
+  }
+}
+
+static int ipc_thread(void *__unused)
+{
+  set_freezable();
+  do {
+    ipc_events();
+    wait_event_freezable(kipcd_wait,
+                         (usb_ipc_data_param.ipc_events != 0) ||
+                         kthread_should_stop());
+  } while (!kthread_should_stop() || (usb_ipc_data_param.ipc_events != 0));
+
+  return 0;
+}
+
+/*
+ * usb ipc data driver probe function 
+ */
+int usb_ipc_data_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{	
+  struct usb_endpoint_descriptor  *ipc_endpoint;		
+  struct usb_device *dev = interface_to_usbdev (intf);
+
+  usb_ipc_data_param.udev = dev;
+
+#ifdef USE_OMAP_SDMA
+	if (0 != omap_request_dma(IPC_DMA_NODE2BUF_ID, NULL,
+				  ipc_dma_node2buf_callback, NULL,
+				  &ipc_memcpy_node2buf.dma_ch)) {
+		printk(KERN_ERR \
+			"%s: Failed to allocate DMA channel for IPC write\n",
+			__func__);
+		ipc_memcpy_node2buf.dma_ch = -1;
+	}
+	if (0 != omap_request_dma(IPC_DMA_BUF2NODE_ID, NULL,
+				  ipc_dma_buf2node_callback, NULL,
+				  &ipc_memcpy_buf2node.dma_ch)) {
+		printk(KERN_ERR \
+			"%s: Failed to allocate DMA channel for IPC read\n",
+			__func__);
+		ipc_memcpy_buf2node.dma_ch = -1;
+	}
+	printk(KERN_INFO "IPC DMA: ch%d for read, ch%d for write\n",
+		ipc_memcpy_buf2node.dma_ch, ipc_memcpy_node2buf.dma_ch);
+#endif
+
+  /* endpoint bulk in*/
+  ipc_endpoint = &(intf->cur_altsetting->endpoint[0].desc);
+
+  //DEBUG("%s: ep num = %d, ep bulk in Attr=0x%x, Addr = 0x%x\n", __FUNCTION__, intf->cur_altsetting->desc.bNumEndpoints, ipc_endpoint->bmAttributes, ipc_endpoint->bEndpointAddress);
+
+  if ( (!IS_EP_BULK_IN(ipc_endpoint)) ) {
+    printk("%s: Bulk endpoint bulk in type error\n", __FUNCTION__);
+    return -ENOMEM;
+  }
+
+  usb_set_intfdata (intf, &usb_ipc_data_param);	
+  /* generate read URB */
+  /* urb size is the max value of ep MaxPacksize or FrameSize */
+  usb_ipc_data_param.read_wMaxPacketSize = ipc_endpoint->wMaxPacketSize;
+  usb_fill_bulk_urb(&usb_ipc_data_param.read_urb, dev, usb_rcvbulkpipe(dev,ipc_endpoint->bEndpointAddress), 0, 0, ipc_data_read_callback, 0);
+
+  /* endpoint bulk out*/
+  ipc_endpoint = &(intf->cur_altsetting->endpoint[1].desc);
+
+  //DEBUG("%s: ep bulk out Attr=0x%x, Addr = 0x%x\n", __FUNCTION__, ipc_endpoint->bmAttributes, ipc_endpoint->bEndpointAddress);
+
+  if ( (!IS_EP_BULK_OUT(ipc_endpoint)) ) {
+    printk("%s: Bulk endpoint bulk out type error\n", __FUNCTION__);
+    return -ENOMEM;
+  }
+
+  /* generate write URB */
+  usb_ipc_data_param.write_wMaxPacketSize = ipc_endpoint->wMaxPacketSize;
+  usb_fill_bulk_urb(&usb_ipc_data_param.write_urb, dev, usb_sndbulkpipe(dev,ipc_endpoint->bEndpointAddress), 0, 0, ipc_data_write_callback, 0);
+
+	/* initialize parameters in IPC APIs, register this driver to IPC APIs */
+  ipc_api_usb_probe(IPC_DATA_CH_NUM, &usb_ipc_data_param);
+
+#ifdef CONFIG_PM
+  spin_lock_init(&usb_ipc_data_param.pm_lock);
+  INIT_WORK(&usb_ipc_data_param.wakeup_work, ipc_resume_work);
+  INIT_DELAYED_WORK(&usb_ipc_data_param.suspend_work, ipc_suspend_work);
+
+  usb_ipc_data_param.kwakeup_usb_wq = create_singlethread_workqueue("kwakeup_usb_ipcd");
+  usb_ipc_data_param.ksuspend_usb_wq = create_singlethread_workqueue("ksuspend_usb_ipcd");
+
+  usb_ipc_data_param.sleeping = 0;
+  usb_ipc_data_param.working = 0;
+  usb_ipc_data_param.write_urb_used = usb_ipc_data_param.read_urb_used = 0;
+  //DEBUG("%s:ipc_probe try to suspend\n", __FUNCTION__);
+  usb_autopm_set_interface(usb_ifnum_to_if(usb_ipc_data_param.udev, IPC_DATA_CH_NUM));
+#endif
+  usb_ipc_data_param.ipc_events = 0;
+  kipcd_task = kthread_run(ipc_thread, NULL, "kipcd");
+
+  return 0;
+}
+
+/*
+ * usb ipc data disconnect
+ */
+void usb_ipc_data_disconnect(struct usb_interface *intf)
+{
+	int i;
+	unsigned int dma_rev, dma_sys_st, dma_ocp_sys_conf, dma_gcr;
+	unsigned int dma_irq_st_0, dma_irq_st_1, dma_irq_st_2, dma_irq_st_3;
+	unsigned int dma_irq_en_0, dma_irq_en_1, dma_irq_en_2, dma_irq_en_3;
+	unsigned int dma_caps_0, dma_caps_1, dma_caps_2, dma_caps_3;
+	unsigned int dma_ccr, dma_clnk_ctrl, dma_cicr, dma_csr;
+	unsigned int dma_csdp, dma_cen, dma_cfn, dma_cssa, dma_cdsa;
+	unsigned int dma_csei, dma_csfi, dma_cdei, dma_cdfi, dma_csac;
+	unsigned int dma_cdac, dma_ccen, dma_ccfn, dma_color;
+	unsigned int intc_itr_0, intc_itr_1, intc_itr_2;
+	unsigned int intc_mir_0, intc_mir_1, intc_mir_2;
+
+  //DEBUG("Enter %s\n", __FUNCTION__);
+  /* unlink URBs */
+  kthread_stop(kipcd_task);
+#ifdef CONFIG_PM
+  cancel_work_sync(&usb_ipc_data_param.wakeup_work);
+  cancel_delayed_work_sync(&usb_ipc_data_param.suspend_work);
+  destroy_workqueue(usb_ipc_data_param.kwakeup_usb_wq);
+  destroy_workqueue(usb_ipc_data_param.ksuspend_usb_wq);
+#endif
+
+  usb_unlink_urb (&usb_ipc_data_param.read_urb);
+  usb_unlink_urb (&usb_ipc_data_param.write_urb);
+
+	dma_rev = omap_readl(0x48056000);
+	dma_irq_st_0 = omap_readl(0x48056008);
+	dma_irq_st_1 = omap_readl(0x4805600c);
+	dma_irq_st_2 = omap_readl(0x48056010);
+	dma_irq_st_3 = omap_readl(0x48056014);
+	dma_irq_en_0 = omap_readl(0x48056018);
+	dma_irq_en_1 = omap_readl(0x4805601c);
+	dma_irq_en_2 = omap_readl(0x48056020);
+	dma_irq_en_3 = omap_readl(0x48056024);
+	dma_sys_st = omap_readl(0x48056028);
+	dma_ocp_sys_conf = omap_readl(0x4805602c);
+	dma_caps_0 = omap_readl(0x48056064);
+	dma_caps_1 = omap_readl(0x4805606c);
+	dma_caps_2 = omap_readl(0x48056070);
+	dma_caps_3 = omap_readl(0x48056074);
+	dma_gcr = omap_readl(0x48056078);
+	dma_ccr = omap_readl(0x48056080 + 0x60 * dma_ch);
+	dma_clnk_ctrl = omap_readl(0x48056084 + 0x60 * dma_ch);
+	dma_cicr = omap_readl(0x48056088 + 0x60 * dma_ch);
+	dma_csr = omap_readl(0x4805608c + 0x60 * dma_ch);
+	dma_csdp = omap_readl(0x48056090 + 0x60 * dma_ch);
+	dma_cen = omap_readl(0x48056094 + 0x60 * dma_ch);
+	dma_cfn = omap_readl(0x48056098 + 0x60 * dma_ch);
+	dma_cssa = omap_readl(0x4805609c + 0x60 * dma_ch);
+	dma_cdsa = omap_readl(0x480560a0 + 0x60 * dma_ch);
+	dma_csei = omap_readl(0x480560a4 + 0x60 * dma_ch);
+	dma_csfi = omap_readl(0x480560a8 + 0x60 * dma_ch);
+	dma_cdei = omap_readl(0x480560ac + 0x60 * dma_ch);
+	dma_cdfi = omap_readl(0x480560b0 + 0x60 * dma_ch);
+	dma_csac = omap_readl(0x480560b4 + 0x60 * dma_ch);
+	dma_cdac = omap_readl(0x480560b8 + 0x60 * dma_ch);
+	dma_ccen = omap_readl(0x480560bc + 0x60 * dma_ch);
+	dma_ccfn = omap_readl(0x480560c0 + 0x60 * dma_ch);
+	dma_color = omap_readl(0x480560c4 + 0x60 * dma_ch);
+	intc_itr_0 = omap_readl(0x48200080);
+	intc_itr_1 = omap_readl(0x48200080 + 0x20);
+	intc_itr_2 = omap_readl(0x48200080 + 0x40);
+	intc_mir_0 = omap_readl(0x48200084);
+	intc_mir_1 = omap_readl(0x48200084 + 0x20);
+	intc_mir_2 = omap_readl(0x48200084 + 0x40);
+	for (i = 0; i < IPC_DBG_ARRAY_SIZE; i++) {
+		printk(KERN_INFO "\t0x%02x\n",
+			(unsigned int)ipc_dbg_array[ipc_dbg_index++]);
+		if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+			ipc_dbg_index = 0;
+	}
+	printk(KERN_INFO "Current index: %d\n", ipc_dbg_index);
+	printk(KERN_INFO \
+		"dma_psrc = 0x%08x\n"
+		"dma_vdest = 0x%08x\n"
+		"dma_pdest = 0x%08x\n"
+		"dma_size = %u\n"
+		"dma_ch = %u\n",
+		dma_psrc, dma_vdest, dma_pdest, dma_size, dma_ch);
+	printk(KERN_INFO "DMA Register Dump:\n"
+		"dma_rev = 0x%08x\t\tdma_sys_st = 0x%08x\n"
+		"dma_irq_st_0 = 0x%08x\tdma_irq_st_1 = 0x%08x\n"
+		"dma_irq_st_2 = 0x%08x\tdma_irq_st_3 = 0x%08x\n"
+		"dma_irq_en_0 = 0x%08x\tdma_irq_en_1 = 0x%08x\n"
+		"dma_irq_en_2 = 0x%08x\tdma_irq_en_3 = 0x%08x\n"
+		"dma_caps_0 = 0x%08x\t\tdma_caps_1 = 0x%08x\n"
+		"dma_caps_2 = 0x%08x\t\tdma_caps_3 = 0x%08x\n"
+		"dma_ocp_sys_conf = 0x%08x\n"
+		"dma_gcr = 0x%08x\n",
+		dma_rev, dma_sys_st, dma_irq_st_0, dma_irq_st_1,
+		dma_irq_st_2, dma_irq_st_3, dma_irq_en_0, dma_irq_en_1,
+		dma_irq_en_2, dma_irq_en_3, dma_caps_0, dma_caps_1,
+		dma_caps_2, dma_caps_3, dma_ocp_sys_conf, dma_gcr);
+	printk(KERN_INFO "DMA Channel Register Dump:\n"
+		"dma_ccr = 0x%08x\tdma_clnk_ctrl = 0x%08x\n"
+		"dma_cicr = 0x%08x\tdma_csr = 0x%08x\n"
+		"dma_csdp = 0x%08x\tdma_cen = 0x%08x\n"
+		"dma_cfn = 0x%08x\tdma_cssa = 0x%08x\n"
+		"dma_cdsa = 0x%08x\tdma_csei = 0x%08x\n"
+		"dma_csfi = 0x%08x\tdma_cdei = 0x%08x\n"
+		"dma_cdfi = 0x%08x\tdma_csac = 0x%08x\n"
+		"dma_cdac = 0x%08x\tdma_ccen = 0x%08x\n"
+		"dma_ccfn = 0x%08x\tdma_color = 0x%08x\n",
+		dma_ccr, dma_clnk_ctrl, dma_cicr, dma_csr, dma_csdp,
+		dma_cen, dma_cfn, dma_cssa, dma_cdsa, dma_csei, dma_csfi,
+		dma_cdei, dma_cdfi, dma_csac, dma_cdac, dma_ccen, dma_ccfn,
+		dma_color);
+	printk(KERN_INFO "INTC Status and Mask register Dump:\n"
+		"intc_itr_0 = 0x%08x\tintc_itr_1 = 0x%08x\n"
+		"intc_itr_2 = 0x%08x\tintc_mir_0 = 0x%08x\n"
+		"intc_mir_1 = 0x%08x\tintc_mir_2 = 0x%08x\n",
+		intc_itr_0, intc_itr_1, intc_itr_2,
+		intc_mir_0, intc_mir_1, intc_mir_2);
+
+  usb_set_intfdata (intf, NULL);
+
+  ipc_api_usb_disconnect(IPC_DATA_CH_NUM);
+
+#ifdef USE_OMAP_SDMA
+	omap_stop_dma(ipc_memcpy_node2buf.dma_ch);
+	omap_free_dma(ipc_memcpy_node2buf.dma_ch);
+	omap_stop_dma(ipc_memcpy_buf2node.dma_ch);
+	omap_free_dma(ipc_memcpy_buf2node.dma_ch);
+	ipc_memcpy_node2buf.dma_ch = -1;
+	ipc_memcpy_buf2node.dma_ch = -1;
+#endif
+
+  /* re-init "usb_ipc_data_param" */
+  usb_ipc_data_init();
+}
+
+int usb_ipc_data_init(void)
+{
+  memset((void *)&usb_ipc_data_param, 0, sizeof(usb_ipc_data_param));
+  usb_ipc_data_param.usb_read  = ipc_data_read_buffer;
+  usb_ipc_data_param.usb_write = ipc_data_write_buffer;
+  usb_init_urb (&usb_ipc_data_param.read_urb);
+  usb_init_urb (&usb_ipc_data_param.write_urb);
+
+  return 0;
+}
+
+/*
+ * driver exit function
+ */
+void usb_ipc_data_exit(void)
+{
+}
+
+/************************************************************************
+ * IPC USB DRIVER REGISTER 
+ ************************************************************************/
+
+/*
+ * usb ipc disconnect
+ */
+static void usb_ipc_disconnect(struct usb_interface *intf)
+{
+  if(intf->cur_altsetting->desc.bInterfaceNumber == USB_IPC_DATA_IF_NUM) {
+    usb_ipc_data_disconnect(intf);
+  }
+  if(intf->cur_altsetting->desc.bInterfaceNumber == USB_IPC_LOG_IF_NUM) {
+    usb_ipc_log_disconnect(intf);
+  }
+}
+
+/*
+ * usb ipc probe
+ */
+static int usb_ipc_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+  /* according to interface number to detect whether this is IPC DATA/LOG MSG interface */
+  if(intf->cur_altsetting->desc.bInterfaceNumber == USB_IPC_DATA_IF_NUM) {
+    return usb_ipc_data_probe(intf, id);
+  }
+
+  if(intf->cur_altsetting->desc.bInterfaceNumber == USB_IPC_LOG_IF_NUM) {
+    return usb_ipc_log_probe(intf, id);
+  }
+
+  return -ENOMEM;
+}
+
+MODULE_DEVICE_TABLE (usb, usb_ipc_id_table);
+
+#ifdef CONFIG_PM
+static int usb_ipc_suspend(struct usb_interface *iface, pm_message_t message)
+{
+	DEBUG("%s:sleeping=%d working=%d\n", __func__,
+		usb_ipc_data_param.sleeping, usb_ipc_data_param.working);
+	spin_lock_bh(&usb_ipc_data_param.pm_lock);
+	if (!usb_ipc_data_param.allow_suspend) {
+		spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+		return -EBUSY;
+	}
+	if (usb_ipc_data_param.working == 1) {
+		spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+		DEBUG("%s:working, can not suspend\n", __func__);
+		return -1;
+	}
+	if (iface->cur_altsetting->desc.bInterfaceNumber ==
+		USB_IPC_DATA_IF_NUM) {
+		if (usb_ipc_data_param.sleeping == 1) {
+			DEBUG("%s:data interface has already suspended\n",
+				__func__);
+		} else {
+			usb_ipc_data_param.sleeping = 1;
+			DEBUG("%s:suspend ipc data interface @ jiffies=%lu\n",
+				__func__, jiffies);
+		}
+	} else if (iface->cur_altsetting->desc.bInterfaceNumber ==
+		USB_IPC_LOG_IF_NUM) {
+		DEBUG("%s:suspend ipc log interface @ jiffies=%lu\n",
+			__func__, jiffies);
+	}
+	spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+
+	return 0;
+}
+
+static int usb_ipc_resume(struct usb_interface *iface)
+{
+	int ret;
+	DEBUG("%s:sleeping=%d working=%d\n", __func__,
+		usb_ipc_data_param.sleeping, usb_ipc_data_param.working);
+	spin_lock_bh(&usb_ipc_data_param.pm_lock);
+	usb_ipc_data_param.allow_suspend = 0;
+	if (iface->cur_altsetting->desc.bInterfaceNumber
+		== USB_IPC_DATA_IF_NUM) {
+		if (usb_ipc_data_param.sleeping == 0) {
+			DEBUG("%s:data interface has already resumed\n",
+				__func__);
+			spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+			return -1;
+		} else {
+			usb_ipc_data_param.sleeping = 0;
+			DEBUG("%s:resume ipc data interface @ jiffies=%lu\n",
+				__func__, jiffies);
+		}
+		if (usb_ipc_data_param.read_urb_used) {
+			ret = usb_submit_urb(&usb_ipc_data_param.read_urb,
+				GFP_ATOMIC|GFP_DMA);
+			usb_ipc_data_param.read_urb_used = 0;
+			ipc_dbg_array[ipc_dbg_index++] = 0x4;
+			if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+				ipc_dbg_index = 0;
+			DEBUG("data read urb restarted, ret=%d.\n", ret);
+		}
+		if (usb_ipc_data_param.write_urb_used) {
+			usb_ipc_data_param.working = 1;
+			ret = usb_submit_urb(&usb_ipc_data_param.write_urb,
+				GFP_ATOMIC|GFP_DMA);
+			usb_ipc_data_param.write_urb_used = 0;
+			DEBUG("data write urb restarted, ret=%d.\n", ret);
+		}
+	} else if (iface->cur_altsetting->desc.bInterfaceNumber ==
+		USB_IPC_LOG_IF_NUM) {
+		DEBUG("%s:resume ipc log interface @ jiffies=%lu\n",
+			__func__, jiffies);
+		if ((ipc_log_param.write_buf != NULL)
+			&& (ipc_log_param.urb_flag == 0)) {
+			ipc_log_param.read_urb.transfer_buffer =
+				ipc_log_param.write_buf->ptr;
+			ipc_log_param.read_urb.transfer_buffer_length =
+				ipc_log_param.read_bufsize;
+			ret = usb_submit_urb(&ipc_log_param.read_urb,
+				GFP_KERNEL);
+			if (!ret)
+				ipc_log_param.urb_flag = 1;
+			DEBUG("log read urb restarted, ret=%d.\n", ret);
+		}
+	}
+	spin_unlock_bh(&usb_ipc_data_param.pm_lock);
+
+	return 0;
+}
+#endif
+
+/* USB host stack entry fucntion for this driver */
+static struct usb_driver usb_ipc_driver = {
+	name:		"usb_ipc_data",
+	probe:		usb_ipc_probe,
+	disconnect:	usb_ipc_disconnect,
+	id_table:	usb_ipc_id_table,
+#ifdef CONFIG_PM
+	supports_autosuspend:	1,
+	suspend:	usb_ipc_suspend,
+	resume:		usb_ipc_resume,
+#endif
+};
+
+/*
+ * driver module init/exit functions
+ */
+static int __init usb_ipc_init(void)
+{
+  int result;
+
+	ipc_dbg_index = 0;
+	memset((void *)ipc_dbg_array, 0xff, IPC_DBG_ARRAY_SIZE);
+
+  /* IPC API relevant initialization */
+  ipc_api_init();
+
+  /* ipc DATA interface relevant initialization */
+  result = usb_ipc_data_init();
+  if(result != 0) {
+    return result;
+  }
+
+  /* ipc DATA interface log initialization */
+  result = usb_ipc_log_init();
+  if(result != 0) {
+    usb_ipc_data_exit();
+    return result;
+  }
+
+  result = usb_register(&usb_ipc_driver);
+  if (result < 0) {
+    usb_ipc_data_exit();
+    usb_ipc_log_exit();
+    printk("%s: Register USB IPC driver failed", __FUNCTION__);
+    return -1;
+  }
+
+  return 0;
+}
+
+/*
+ * driver exit function
+ */
+static void __exit usb_ipc_exit(void)
+{
+  /* IPC API relevant exit */
+  ipc_api_exit();
+
+  /* USB IPC DATA driver exit */
+  usb_ipc_data_exit();
+
+  /* USB IPC LOG driver exit */
+  usb_ipc_log_exit();
+
+  /* unregister USB IPC driver */
+  usb_deregister(&usb_ipc_driver);
+}
+
+/* the module entry declaration of this driver */
+module_init(usb_ipc_init);
+module_exit(usb_ipc_exit);
+
diff --git a/drivers/usb/ipchost/ipc_dma.c b/drivers/usb/ipchost/ipc_dma.c
new file mode 100644
index 0000000..cf8ba95
--- /dev/null
+++ b/drivers/usb/ipchost/ipc_dma.c
@@ -0,0 +1,454 @@
+/*
+ * Copyright (C) 2007-2008 Motorola, Inc
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Changelog:
+ * Date               Author           Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007      Motorola        USB-IPC initial
+ * 03/22/2008      Motorola        USB-IPC header support
+ * 05/09/2008      Motorola        Change Copyright and Changelog
+ * 07/09/2008      Motorola        upmerge for 23.5
+ * 11/03/2008      Motorola        Support sequence number
+ * 
+ */
+ 
+/*!
+ * @file drivers/usb/ipchost/ipc_dma.c
+ * @brief USB-IPC Descriptor Set
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/circ_buf.h>
+#include <linux/uio.h>
+#include <linux/poll.h>
+#include <linux/usb.h>
+#include <linux/usb_ipc.h>
+#include <linux/ipc_api.h>
+#include <linux/dma-mapping.h>
+
+#include <mach/dma.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+
+#if defined(USE_OMAP_SDMA)
+
+#define DEBUG(args...)  //printk(args)
+
+struct IPC_DMA_MEMCPY ipc_memcpy_node2buf;
+struct IPC_DMA_MEMCPY ipc_memcpy_buf2node;
+
+extern USB_IPC_API_PARAMS  usb_ipc_channels[MAX_USB_IPC_CHANNELS];
+
+extern void usb_ipc_exchange_endian16(unsigned short *data);
+//extern void consistent_sync(const void *start, size_t size, int direction);
+extern void dma_cache_maint(const void *start, size_t size, int direction);
+
+#define NODE_BUF_PHYS_ADDR(x)   virt_to_phys(x)
+#define USB_BUF_PHYS_ADDR(x)    virt_to_phys(x)
+
+/* Start DMA data transfer from memory to memory */
+#define OMAP_DMA_MEM2MEM_START(ch, src, dest, len)                                              \
+    DEBUG("\n%s: dest = 0x%lx, src=0x%lx\n", __FUNCTION__, dest, src);   \
+    omap_set_dma_transfer_params(ch, OMAP_DMA_DATA_TYPE_S8, 1, len, OMAP_DMA_SYNC_FRAME, 0, 0); \
+    omap_set_dma_dest_params(ch, 0, OMAP_DMA_AMODE_POST_INC, dest, 0, 0);     \
+    omap_set_dma_src_params(ch, 0, OMAP_DMA_AMODE_POST_INC, src, 0, 0);       \
+    omap_start_dma(ch);
+
+/*
+ *  Node 2 Buffer DMA callback
+ */
+void ipc_dma_node2buf_callback (int lch, u16 ch_status, void *data)
+{
+	int ret, i;
+	USB_IPC_API_PARAMS *ipc_ch;	
+	IPC_DATA_HEADER *header;
+
+	DEBUG("%s\n", __FUNCTION__);
+
+	ipc_ch = ipc_memcpy_node2buf.ipc_ch;
+	/* Set DONE bit. If all node buffer are copied to URB buffer, finished */
+	ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].comand  |= NODE_DESCRIPTOR_DONE_BIT;
+
+	ipc_memcpy_node2buf.buf_phy += ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length;
+	ipc_memcpy_node2buf.total_size +=  ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length;
+	ipc_ch->write_ptr.total_num += ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length;
+
+	if ( ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].comand & NODE_DESCRIPTOR_LAST_BIT)
+		ipc_memcpy_node2buf.frame_index ++;
+
+	header = (IPC_DATA_HEADER *)ipc_ch->write_ptr.temp_buff;
+
+        if( (ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].comand & NODE_DESCRIPTOR_END_BIT) || (ipc_memcpy_node2buf.node_index >= (ipc_memcpy_node2buf.ipc_ch->max_node_num) ) || ipc_memcpy_node2buf.frame_index >= header->nb_frame ) {
+                omap_stop_dma(ipc_memcpy_node2buf.dma_ch);
+
+		//consistent_sync (ipc_ch->write_ptr.temp_buff, ipc_ch->max_temp_buff_size, DMA_FROM_DEVICE);
+		dma_cache_maint((void *)ipc_ch->write_ptr.temp_buff, ipc_ch->max_temp_buff_size, DMA_FROM_DEVICE);
+
+//change for endian
+		header = (IPC_DATA_HEADER *)ipc_ch->write_ptr.temp_buff;
+		DEBUG("DMA copy ok:header->version=%x header->nb_frame=%d total_size=%d total_num=%d\n", header->version, header->nb_frame, ipc_memcpy_node2buf.total_size, ipc_ch->write_ptr.total_num);
+                usb_ipc_exchange_endian16(&(header->version));
+                if (header->nb_frame > 0) {
+		        for (i = 0; i < header->nb_frame; i++)
+			        usb_ipc_exchange_endian16(&(header->frames[i].length));
+		        usb_ipc_exchange_endian16(&(header->nb_frame));
+#if defined(USE_IPC_FRAME_HEADER_CHECKSUM)
+			if(header->options == 1) {
+			/*TODO: calculate checksum here*/
+			    usb_ipc_exchange_endian16(&(header->checksum));
+			}
+#endif
+                }
+//change for endian end
+
+#ifndef IPC_USE_ZERO_LEN_FRAME
+                ipc_ch->write_ptr.end_flag = 1;
+#endif /* !IPC_USE_ZERO_LEN_FRAME */
+		dma_cache_maint((const void *)ipc_ch->write_ptr.temp_buff, sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame)), DMA_TO_DEVICE);
+                if (!ipc_ch->usb_ifs) 
+                        return;
+                ret = ipc_ch->usb_ifs->usb_write((unsigned char *)ipc_ch->write_ptr.temp_buff, ipc_memcpy_node2buf.total_size);
+                if(ret != 0) {
+                        ipc_ch->write_flag = 0;
+                }
+		return;
+        }
+
+	ipc_memcpy_node2buf.node_index ++;
+
+	//consistent_sync (ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].data_ptr, ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length, DMA_TO_DEVICE);
+	dma_cache_maint(ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].data_ptr, ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length, DMA_TO_DEVICE);
+
+	DEBUG("Continue DMA:buf_phy=%lx total_size=%d node_index=%d\n", ipc_memcpy_node2buf.buf_phy, ipc_memcpy_node2buf.total_size, ipc_memcpy_node2buf.node_index);
+	OMAP_DMA_MEM2MEM_START(ipc_memcpy_node2buf.dma_ch, NODE_BUF_PHYS_ADDR(ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].data_ptr), ipc_memcpy_node2buf.buf_phy, ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length);
+}
+
+/*
+ *  Node 2 Buffer DMA transfer
+ */
+int ipc_dma_memcpy_node2buf(USB_IPC_API_PARAMS *ipc_ch, HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *ctrl_ptr)
+{
+	int ret, i;
+	int frame_size, frame_index, len;
+	IPC_DATA_HEADER *header;
+
+	DEBUG("%s\n", __FUNCTION__);
+
+	if (ipc_memcpy_node2buf.dma_ch == -1)   { /* error: using memcpy */
+	        /* copy data into write URB buffer */
+        	frame_size = 0;
+	        frame_index = 0;
+        	//len = sizeof(IPC_DATA_HEADER);
+		header = (IPC_DATA_HEADER *)ipc_ch->write_ptr.temp_buff;
+	        len = sizeof(IPC_DATA_HEADER_INDEX) + ((header->nb_frame) * sizeof(IPC_FRAME_DESCRIPTOR));
+	        for(i = 0; i < ipc_ch->max_node_num; i++) {
+        	        if( (len + ctrl_ptr[i].length) > ipc_ch->max_temp_buff_size ) {
+                	        break;
+                	}
+	                memcpy((void *)&ipc_ch->write_ptr.temp_buff[len], ctrl_ptr[i].data_ptr, ctrl_ptr[i].length);
+	                frame_size += ctrl_ptr[i].length;
+        	        len        += ctrl_ptr[i].length;
+                	ctrl_ptr[i].comand |= NODE_DESCRIPTOR_DONE_BIT;
+			ipc_ch->write_ptr.total_num +=ctrl_ptr[i].length ;
+	                if( ctrl_ptr[i].comand & NODE_DESCRIPTOR_LAST_BIT )  {
+        	                header->frames[frame_index].length = frame_size;
+                	        frame_index ++;
+                        	frame_size = 0;
+	                }
+        	        if(ctrl_ptr[i].comand & NODE_DESCRIPTOR_END_BIT) {
+                	        break;
+	                }
+        	}
+	        header->nb_frame = frame_index;
+//change for endian
+                usb_ipc_exchange_endian16(&(header->version));
+                if (header->nb_frame > 0) {
+		        for (i = 0; i < header->nb_frame; i++)
+			        usb_ipc_exchange_endian16(&(header->frames[i].length));
+		        usb_ipc_exchange_endian16(&(header->nb_frame));
+                }
+//change for endian end
+#ifndef IPC_USE_ZERO_LEN_FRAME
+                ipc_ch->write_ptr.end_flag = 1;
+#endif /* !IPC_USE_ZERO_LEN_FRAME */
+                if (!ipc_ch->usb_ifs) 
+                        return 0;
+                ret = ipc_ch->usb_ifs->usb_write((unsigned char *)ipc_ch->write_ptr.temp_buff, len);
+                if(ret != 0) {
+                        ipc_ch->write_flag = 0;
+                }
+
+	        return 0;
+	}
+
+        /* generate header */
+	header = (IPC_DATA_HEADER *)ipc_ch->write_ptr.temp_buff;
+        frame_size = 0;
+        frame_index = 0;
+	len = sizeof(IPC_DATA_HEADER_INDEX) + ((header->nb_frame) * sizeof(IPC_FRAME_DESCRIPTOR));
+        for(i = 0; i < ipc_ch->max_node_num; i++) {
+        	if( ((len + ctrl_ptr[i].length) > ipc_ch->max_temp_buff_size) || (ctrl_ptr[i].length <= 0) || (ctrl_ptr[i].length > MAX_FRAME_SIZE)) {
+                        break;
+                }
+                frame_size += ctrl_ptr[i].length;
+		len        += ctrl_ptr[i].length;
+                if( ctrl_ptr[i].comand & NODE_DESCRIPTOR_LAST_BIT )  {
+                        header->frames[frame_index].length = frame_size;
+			DEBUG("header->frames[%d]=%d\n", frame_index, frame_size);
+                        frame_index ++;
+                        frame_size = 0;
+                }
+                if(ctrl_ptr[i].comand & NODE_DESCRIPTOR_END_BIT) {
+                        break;
+                }
+        }
+        header->nb_frame = frame_index;
+	if (frame_index == 0) {
+		omap_free_dma(ipc_memcpy_node2buf.dma_ch);
+                usb_ipc_exchange_endian16(&(header->version));
+#ifndef IPC_USE_ZERO_LEN_FRAME
+                ipc_ch->write_ptr.end_flag = 1;
+#endif /* !IPC_USE_ZERO_LEN_FRAME */
+                //ret = ipc_ch->usb_ifs->usb_write(ipc_ch->write_ptr.temp_buff, 0);
+                //if(ret != 0) {
+                //        ipc_ch->write_flag = 0;
+                //}
+		return -1;
+	}
+	DEBUG("header->version=%x header->nb_frame=%d write_ptr.temp_buff_phy_addr=%x\n", header->version, header->nb_frame, ipc_ch->write_ptr.temp_buff_phy_addr);
+
+	ipc_memcpy_node2buf.ipc_ch        = ipc_ch;
+	ipc_memcpy_node2buf.node_index    = 0;
+	ipc_memcpy_node2buf.frame_index    = 0;
+	ipc_memcpy_node2buf.node_ptr      = ctrl_ptr;
+	ipc_memcpy_node2buf.total_size    = sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame));
+	//ipc_memcpy_node2buf.total_size    = 0;
+	ipc_memcpy_node2buf.buf_phy       = ipc_ch->write_ptr.temp_buff_phy_addr + 
+                             (sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame)));
+
+	DEBUG("Start DMA:buf_phy=%lx total_size=%d node_index=%d\n", ipc_memcpy_node2buf.buf_phy, ipc_memcpy_node2buf.total_size, ipc_memcpy_node2buf.node_index);
+
+	//consistent_sync (ipc_ch->write_ptr.temp_buff, sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame)), DMA_TO_DEVICE);
+	dma_cache_maint((void *)ipc_ch->write_ptr.temp_buff, sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame)), DMA_TO_DEVICE);
+	//consistent_sync (ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].data_ptr, ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length, DMA_TO_DEVICE);
+	dma_cache_maint(ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].data_ptr, ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length, DMA_TO_DEVICE);
+
+	/* set DMA parameters, then start DMA transfer */
+        OMAP_DMA_MEM2MEM_START(ipc_memcpy_node2buf.dma_ch, NODE_BUF_PHYS_ADDR(ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].data_ptr), ipc_memcpy_node2buf.buf_phy, ipc_memcpy_node2buf.node_ptr[ipc_memcpy_node2buf.node_index].length);
+	return 0;
+}
+
+/*
+ *  Buffer 2 Node DMA callback
+ */
+void ipc_dma_buf2node_callback (int lch, u16 ch_status, void *data)
+{
+	int size;
+        HW_CTRL_IPC_WRITE_STATUS_T  ipc_status;
+	USB_IPC_API_PARAMS *ipc_ch;
+
+	DEBUG("%s\n", __FUNCTION__);
+
+	ipc_ch = ipc_memcpy_buf2node.ipc_ch;
+        /* Set DONE bit. If all node buffer are copied to URB buffer, finished */
+        ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].comand  |= NODE_DESCRIPTOR_DONE_BIT;
+	ipc_memcpy_buf2node.buf_phy += ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].length;
+	ipc_memcpy_buf2node.header->frames[ipc_memcpy_buf2node.frame_index].length -= ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].length;
+        if(ipc_memcpy_buf2node.header->frames[ipc_memcpy_buf2node.frame_index].length == 0) {
+		ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].comand  |= NODE_DESCRIPTOR_LAST_BIT;
+		ipc_memcpy_buf2node.frame_index ++;
+	}
+
+	dma_cache_maint(ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].data_ptr, ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].length, DMA_FROM_DEVICE);
+
+	ipc_memcpy_buf2node.total_size +=  ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].length;
+
+	ipc_memcpy_buf2node.node_index ++;
+        if( (ipc_memcpy_buf2node.node_index >= ipc_memcpy_buf2node.ipc_ch->read_ptr.node_num) || 
+	    (ipc_memcpy_buf2node.frame_index >= ipc_memcpy_buf2node.header->nb_frame) ) {
+                omap_stop_dma(ipc_memcpy_buf2node.dma_ch);
+
+                ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index - 1].comand  |= NODE_DESCRIPTOR_END_BIT;
+
+		DEBUG("DMA copy ok:header->version=%x header->nb_frame=%d\n", ipc_memcpy_buf2node.header->version, ipc_memcpy_buf2node.header->nb_frame);
+	        DEBUG("buf_phy=%lx total_size=%d node_index=%d frame_index=%d\n", ipc_memcpy_buf2node.buf_phy, ipc_memcpy_buf2node.total_size, ipc_memcpy_buf2node.node_index, ipc_memcpy_buf2node.frame_index);
+
+		/*
+		for (i=0;i<ipc_memcpy_buf2node.node_index;i++)
+			DEBUG("node_ptr[%d].comand=%x length=%d\n", i, ipc_ch->read_ptr.node_ptr[i].comand, ipc_ch->read_ptr.node_ptr[i].length);
+		for (i=0;i<ipc_memcpy_buf2node.total_size;i++)
+			DEBUG("temp_buf[%d]=%x, temp_buf_phy_addr[%d]=%x\n", i, ipc_ch->read_ptr.temp_buff[i], i, ((unsigned char *)(phys_to_virt(ipc_ch->read_ptr.temp_buff_phy_addr)))[i]);
+		*/
+		/* clear flag to indicate API read function call is done */
+	        ipc_memcpy_buf2node.ipc_ch->read_flag = 0;
+
+        	/* read callback, ... */
+	        if(ipc_memcpy_buf2node.ipc_ch->cfg.read_callback != NULL)  {
+        	        ipc_status.nb_bytes = ipc_memcpy_buf2node.total_size;
+                	ipc_status.channel  = &ipc_memcpy_buf2node.ipc_ch->ch;
+			ipc_dbg_array[ipc_dbg_index++] = 0x16;
+			if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+				ipc_dbg_index = 0;
+	                ipc_memcpy_buf2node.ipc_ch->cfg.read_callback(&ipc_status);
+        	} else {
+			ipc_dbg_array[ipc_dbg_index++] = 0x1E;
+			if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+				ipc_dbg_index = 0;
+                	//up(&ipc_memcpy_buf2node.ipc_ch->read_ptr.read_mutex);
+                	SEM_UNLOCK(&ipc_memcpy_buf2node.ipc_ch->read_ptr.read_mutex);
+	        }
+                return;
+        }
+
+        /* set DMA parameters, then start DMA transfer */
+        size = ipc_memcpy_buf2node.header->frames[ipc_memcpy_buf2node.frame_index].length;
+        if( size > ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].length) {
+                size = ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].length;
+        }
+        ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].length = size;
+
+	DEBUG("Continue DMA:buf_phy=%lx total_size=%d node_index=%d frame_index=%d\n", ipc_memcpy_buf2node.buf_phy, ipc_memcpy_buf2node.total_size, ipc_memcpy_buf2node.node_index, ipc_memcpy_buf2node.frame_index);
+        /* set DMA parameters, then start DMA transfer */
+        OMAP_DMA_MEM2MEM_START(ipc_memcpy_buf2node.dma_ch, ipc_memcpy_buf2node.buf_phy, NODE_BUF_PHYS_ADDR(ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].data_ptr), size);
+	dma_psrc = (unsigned int)ipc_memcpy_buf2node.buf_phy;
+	dma_vdest = (unsigned int)ipc_ch->read_ptr.node_ptr[\
+			ipc_memcpy_buf2node.node_index].data_ptr;
+	dma_pdest = (unsigned int)NODE_BUF_PHYS_ADDR(ipc_ch->read_ptr.node_ptr[\
+			ipc_memcpy_buf2node.node_index].data_ptr);
+	dma_size = size;
+	dma_ch = (unsigned int)ipc_memcpy_buf2node.dma_ch;
+	ipc_dbg_array[ipc_dbg_index++] = 0x15;
+	if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+		ipc_dbg_index = 0;
+}
+
+/*
+ *  Buffer 2 Node DMA transfer
+ */
+void ipc_dma_memcpy_buf2node(USB_IPC_API_PARAMS *ipc_ch)
+{
+        int size, len, index, frame_index, num;
+        IPC_DATA_HEADER *header;
+        HW_CTRL_IPC_WRITE_STATUS_T  ipc_status;
+
+	DEBUG("%s\n", __FUNCTION__);
+
+	if (ipc_memcpy_buf2node.dma_ch == -1)   { /* error: using memcpy */
+		header = (IPC_DATA_HEADER *)(ipc_ch->read_ptr.temp_buff);
+	        size = header->frames[0].length;
+        	//len  = sizeof(IPC_DATA_HEADER);
+                len  = sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame));
+	        /* copy data from temporary buffer to scatter buffers */
+        	for(index = 0, frame_index = 0; index < ipc_ch->read_ptr.node_num; index ++) {
+                	num = (size > (ipc_ch->read_ptr.node_ptr)[index].length) ? (ipc_ch->read_ptr.node_ptr)[index].length : size;
+	                memcpy((ipc_ch->read_ptr.node_ptr)[index].data_ptr, (void *)&((ipc_ch->read_ptr.temp_buff)[len]), num);
+		        ipc_ch->read_ptr.total_num += num;
+        	        /* set flag to indicate received data is filled ... */
+                	(ipc_ch->read_ptr.node_ptr)[index].comand |= NODE_DESCRIPTOR_DONE_BIT;
+	                size -= num;
+        	        len  += num;
+                	if( size == 0 ) {
+                        	(ipc_ch->read_ptr.node_ptr)[index].length = num;
+	                        (ipc_ch->read_ptr.node_ptr)[index].comand |= NODE_DESCRIPTOR_LAST_BIT;
+        	                frame_index ++;
+                	        if(frame_index >= header->nb_frame) {
+                        	         break;
+	                        }
+        	                size = header->frames[frame_index].length;
+                	}
+        	}
+                if( index < ipc_ch->read_ptr.node_num ) {
+                        ipc_ch->read_ptr.node_ptr[index].comand |= NODE_DESCRIPTOR_END_BIT;
+                }
+                else {
+                        ipc_ch->read_ptr.node_ptr[index - 1].comand |= NODE_DESCRIPTOR_END_BIT;
+                }
+
+		/* clear flag to indicate API read function call is done */
+	        ipc_ch->read_flag = 0;
+		if(ipc_ch->cfg.read_callback != NULL)  {
+			ipc_dbg_array[ipc_dbg_index++] = 0x1F;
+			if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+				ipc_dbg_index = 0;
+			 ipc_status.nb_bytes = ipc_ch->read_ptr.total_num;
+                	 ipc_status.channel  = &ipc_ch->ch;
+			 ipc_ch->cfg.read_callback(&ipc_status);
+		} else {
+			 SEM_UNLOCK(&ipc_ch->read_ptr.read_mutex);
+		}
+		return;
+	}
+
+	header = (IPC_DATA_HEADER *)(ipc_ch->read_ptr.temp_buff);
+	DEBUG("header->version=%x header->nb_frame=%d read_ptr.temp_buff_phy_addr=%x\n", header->version, header->nb_frame, ipc_ch->read_ptr.temp_buff_phy_addr);
+
+        ipc_memcpy_buf2node.node_index    = 0;
+        ipc_memcpy_buf2node.frame_index   = 0;
+	//ipc_memcpy_buf2node.total_size    = sizeof(IPC_DATA_HEADER_INDEX) + sizeof(IPC_FRAME_DESCRIPTOR) * (ipc_memcpy_buf2node.header->nb_frame);
+	ipc_memcpy_buf2node.total_size    = 0;
+        ipc_memcpy_buf2node.ipc_ch        = ipc_ch;
+        ipc_memcpy_buf2node.header        = (IPC_DATA_HEADER *)(ipc_ch->read_ptr.temp_buff);
+        ipc_memcpy_buf2node.buf_phy       = ipc_ch->read_ptr.temp_buff_phy_addr + 
+        (sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (ipc_memcpy_buf2node.header->nb_frame)));
+
+        /* set DMA parameters, then start DMA transfer */
+        size = ipc_memcpy_buf2node.header->frames[ipc_memcpy_buf2node.frame_index].length;
+        if( size > ipc_ch->read_ptr.node_ptr[0].length) {
+                size = ipc_ch->read_ptr.node_ptr[0].length;
+        }
+
+        ipc_ch->read_ptr.node_ptr[0].length = size;
+
+	DEBUG("Start DMA:buf_phy=%lx total_size=%d node_index=%d frame_index=%d\n", ipc_memcpy_buf2node.buf_phy, ipc_memcpy_buf2node.total_size, ipc_memcpy_buf2node.node_index, ipc_memcpy_buf2node.frame_index);
+
+	//consistent_sync (ipc_ch->read_ptr.temp_buff, sizeof(IPC_DATA_HEADER_INDEX) + (sizeof(IPC_FRAME_DESCRIPTOR) * (header->nb_frame)), DMA_TO_DEVICE);
+
+        /* set DMA parameters, then start DMA transfer */
+        OMAP_DMA_MEM2MEM_START(ipc_memcpy_buf2node.dma_ch, ipc_memcpy_buf2node.buf_phy, NODE_BUF_PHYS_ADDR(ipc_ch->read_ptr.node_ptr[ipc_memcpy_buf2node.node_index].data_ptr), size);
+	dma_psrc = (unsigned int)ipc_memcpy_buf2node.buf_phy;
+	dma_vdest = (unsigned int)ipc_ch->read_ptr.node_ptr[\
+			ipc_memcpy_buf2node.node_index].data_ptr;
+	dma_pdest = (unsigned int)NODE_BUF_PHYS_ADDR(ipc_ch->read_ptr.node_ptr[\
+			ipc_memcpy_buf2node.node_index].data_ptr);
+	dma_size = size;
+	dma_ch = ipc_memcpy_buf2node.dma_ch;
+	ipc_dbg_array[ipc_dbg_index++] = 0x14;
+	if (ipc_dbg_index >= IPC_DBG_ARRAY_SIZE)
+		ipc_dbg_index = 0;
+}
+#endif
diff --git a/drivers/usb/ipchost/ipc_log.c b/drivers/usb/ipchost/ipc_log.c
new file mode 100644
index 0000000..309c0b5
--- /dev/null
+++ b/drivers/usb/ipchost/ipc_log.c
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2007 - 2008 Motorola, Inc, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * Changelog:
+ * Date			Author			Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007		Motorola		USB-IPC initial
+ * 03/22/2007		Motorola		USB-IPC header support
+ * 05/09/2008		Motorola		Change Copyright and Changelog
+ *
+ */
+
+/*!
+ * @file drivers/usb/ipchost/ipc_log.c
+ * @brief USB-IPC Descriptor Set
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+/*
+ *	usb_ipc_log.c
+ *	USB IPC Log driver
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/uaccess.h>
+#include <mach/hardware.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/major.h>
+#include <linux/usb_ipc.h>
+#include <linux/ipc_api.h>
+#include <linux/kthread.h>
+
+#define DEBUG(args...) //printk(args)
+
+/* USB endpoint detectio */
+#define IS_EP_BULK(ep)		(((ep)->bmAttributes) == \
+				USB_ENDPOINT_XFER_BULK ? 1 : 0)
+#define IS_EP_BULK_IN(ep)	(IS_EP_BULK(ep) && (((ep)->bEndpointAddress) & \
+				USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+
+static DEFINE_SPINLOCK(ipc_log_spinlock);
+static DECLARE_WAIT_QUEUE_HEAD(ipc_log_wait_q);
+
+USB_LOG_IFS_STRUCT ipc_log_param;
+
+/*
+ * "mknod /dev/logger c 180 250" to generate USB IPC Log device node
+ */
+
+/******************************************************************************
+ * Function Name: ipc_log_read_buffer
+ *****************************************************************************/
+int ipc_log_fill_user_buf(unsigned char *buf, int count)
+{
+	int i, size, num, ret;
+	IPC_LOG_DATA_BUFFER *read_buf;
+
+	DEBUG("%s: Enter count=%d\n", __func__, count);
+
+	size = 0;
+	/* loop all Buffer ... */
+	for (i = 0; i < ipc_log_param.buf_num; i++) {
+		/* all data in buffer is retrieved or input "buf" is full */
+		if ((ipc_log_param.read_buf == ipc_log_param.write_buf) ||
+			 (count <= 0)) {
+			DEBUG("%s: break\n", __func__);
+			break;
+		}
+		/*	*/
+		num = count > (ipc_log_param.read_buf->data_num -
+			ipc_log_param.read_buf->read_num) ?
+			(ipc_log_param.read_buf->data_num -
+			ipc_log_param.read_buf->read_num) : count;
+		ret = copy_to_user((unsigned char *)((unsigned long)buf + size),
+			(unsigned char *)&(ipc_log_param.read_buf->ptr[
+			ipc_log_param.read_buf->read_num]), num);
+		count -= num;
+		ipc_log_param.read_buf->read_num += num;
+		size += num;
+		/* current buffer is empty, move it to the tail of list */
+		if (ipc_log_param.read_buf->data_num <=
+			ipc_log_param.read_buf->read_num) {
+			DEBUG("%s: Move from head to the tail\n", __func__);
+			spin_lock(&ipc_log_spinlock);
+			read_buf = ipc_log_param.read_buf;
+			read_buf->read_num	= 0;
+			read_buf->data_num	= 0;
+			if (ipc_log_param.read_buf != ipc_log_param.end_buf) {
+				ipc_log_param.read_buf	= read_buf->next;
+				ipc_log_param.end_buf->next = read_buf;
+				ipc_log_param.end_buf		= read_buf;
+				read_buf->next				= 0;
+			}
+			if (ipc_log_param.write_buf == NULL)
+				ipc_log_param.write_buf = read_buf;
+
+			spin_unlock(&ipc_log_spinlock);
+		}
+	}
+
+	DEBUG("%s: return %d\n", __func__, size);
+
+	return size;
+}
+
+/* alloc buffer */
+IPC_LOG_DATA_BUFFER *ipc_log_alloc_read_buffer(void)
+{
+	IPC_LOG_DATA_BUFFER *temp_buf;
+
+	DEBUG("%s: Enter\n", __func__);
+
+	temp_buf = kmalloc(sizeof(IPC_LOG_DATA_BUFFER), GFP_ATOMIC);
+	if (temp_buf == NULL)
+		return NULL;
+
+	temp_buf->ptr = kmalloc(ipc_log_param.read_bufsize, GFP_ATOMIC);
+	if (temp_buf->ptr == NULL) {
+		kfree(temp_buf);
+		return NULL;
+	}
+	temp_buf->data_num = 0;
+	temp_buf->read_num = 0;
+	temp_buf->next	 = 0;
+
+	ipc_log_param.buf_num++;
+
+	DEBUG("%s alloc buffer %d, %d\n", __func__, ipc_log_param.buf_num,
+		ipc_log_param.read_bufsize);
+	return temp_buf;
+}
+
+#define IPC_LOG_URB_START()	\
+	do {					\
+		spin_lock(&ipc_log_spinlock);	\
+		DEBUG("submit urb %d ... \n", ipc_log_param.urb_flag);\
+		if ((ipc_log_param.write_buf != NULL) && 	\
+			(ipc_log_param.urb_flag == 0) && 		\
+			(usb_ipc_data_param.sleeping == 0)) { 	\
+			ipc_log_param.read_urb.transfer_buffer	= \
+				 ipc_log_param.write_buf->ptr;	\
+			ipc_log_param.read_urb.transfer_buffer_length =\
+			 ipc_log_param.read_bufsize;	\
+			if (usb_submit_urb(&ipc_log_param.read_urb,\
+				 GFP_KERNEL)) {\
+				DEBUG("submit urb is error \n");\
+			}				\
+			else {			\
+				DEBUG("submit urb is OK \n");\
+				ipc_log_param.urb_flag = 1;	\
+			}	\
+		}		\
+		spin_unlock(&ipc_log_spinlock);	\
+	} while (0);
+
+/******************************************************************************
+ * Function Name: usb_ipc_log_open
+ *****************************************************************************/
+static int usb_ipc_log_open(struct inode *inode, struct file *file)
+{
+	DEBUG("Enter %s\n", __func__);
+	if ((ipc_log_param.isopen) || (ipc_log_param.probe_flag == 0)) {
+		DEBUG("%s: USB IPC LOG open error\n", __func__);
+		return -EBUSY;
+	}
+
+	ipc_log_param.isopen = 1;
+
+	return 0;
+}
+
+/******************************************************************************
+ * Function Name: usb_ipc_log_release
+ *****************************************************************************/
+static int usb_ipc_log_release(struct inode *inode, struct file *filp)
+{
+	if (!ipc_log_param.isopen)
+		return 0;
+
+	ipc_log_param.isopen = 0;
+
+	return 0;
+}
+
+/******************************************************************************
+ * Function Name: usb_ipc_log_poll
+ *****************************************************************************/
+static unsigned int usb_ipc_log_poll(struct file *file,
+	struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+
+	DEBUG("Enter %s\n", __func__);
+	if ((ipc_log_param.isopen == 0) || (ipc_log_param.probe_flag == 0)) {
+		DEBUG("%s: USB IPC LOG calling poll error\n", __func__);
+		return -EBUSY;
+	}
+
+	poll_wait(file, &ipc_log_wait_q, wait);
+
+	if (ipc_log_param.read_buf == ipc_log_param.write_buf) {
+		IPC_LOG_URB_START();
+	} else
+		mask = (POLLIN | POLLRDNORM);
+
+	DEBUG("%s: return mask=%d\n", __func__, mask);
+
+	return mask;
+}
+
+/******************************************************************************
+ * Function Name: usb_ipc_log_read
+ *****************************************************************************/
+static ssize_t usb_ipc_log_read(struct file *filp,
+		char __user *buf, size_t count, loff_t *l)
+{
+	int size;
+
+	DEBUG("%s: Enter count=%d\n", __func__, count);
+
+	if (!ipc_log_param.isopen) {
+		DEBUG("%s: Not Opend\n", __func__);
+		return 0;
+	}
+
+	/* detect whether resume is need */
+
+	/* detect whether BP is ready? */
+
+	if (count <= 0) {	/* read buffer is 0 */
+		return 0;
+	}
+
+	/* get out the received data */
+	size = ipc_log_fill_user_buf(buf, count);
+	/*init_MUTEX_LOCKED(&ipc_log_param.mutex);*/
+
+	DEBUG("%s: return %d\n", __func__, size);
+
+	return size;
+}
+
+/* file operation struction */
+static const struct file_operations usb_ipc_log_fops = {
+	.owner	=	THIS_MODULE,
+	open	:	usb_ipc_log_open,
+	release	:	usb_ipc_log_release,
+	read	:	usb_ipc_log_read,
+	poll	:	usb_ipc_log_poll,
+};
+static struct usb_class_driver usb_ipc_log_device = {
+	.name = USB_IPC_LOG_DRV_NAME,
+	.fops = &usb_ipc_log_fops,
+	.minor_base = USB_IPC_LOG_MINOR_NUM,
+};
+
+/*
+ *	USB class driver Functions
+ */
+static void ipc_log_read_callback(struct urb *urb)
+{
+	unsigned long flags;
+	IPC_LOG_DATA_BUFFER	*temp_buf;
+
+	DEBUG("%s: %d\n", __func__, urb->actual_length);
+
+	if (urb->actual_length != 0)	{
+		ipc_log_param.write_buf->read_num = 0;
+		ipc_log_param.write_buf->data_num = urb->actual_length;
+
+		ipc_log_param.write_buf = ipc_log_param.write_buf->next;
+		/*"write_buf->next = NULL" is same with "write_buf = end_buf"*/
+		if ((ipc_log_param.write_buf == NULL) &&
+			(ipc_log_param.buf_num < MAX_LOG_BUF_NUM)) {
+			DEBUG("%s: alloc read buffer \n", __func__);
+			temp_buf = ipc_log_alloc_read_buffer();
+			if (temp_buf == NULL)	{
+				/* alloc new buffer is failed */
+				DEBUG("%s: Error alloc read buffer\n",
+					 __func__);
+				/*up(&ipc_log_param.mutex);*/
+				wake_up_interruptible(&ipc_log_wait_q);
+				ipc_log_param.urb_flag = 0;
+				return;
+			}
+			/* add new buffer to buffer list .... */
+			spin_lock(&ipc_log_spinlock);
+			ipc_log_param.end_buf->next = temp_buf;
+			ipc_log_param.end_buf		= temp_buf;
+			ipc_log_param.write_buf	 = temp_buf;
+			spin_unlock(&ipc_log_spinlock);
+		}
+		/*up(&ipc_log_param.mutex);*/
+		wake_up_interruptible(&ipc_log_wait_q);
+	}
+
+	/* start URB */
+	if ((ipc_log_param.isopen == 0) || (ipc_log_param.probe_flag == 0)) {
+		DEBUG("%s: USB IPC LOG callback error\n", __func__);
+		return;
+	}
+
+	ipc_log_param.urb_flag = 0;
+	IPC_LOG_URB_START();
+
+	spin_lock_irqsave(&ipc_event_lock, flags);
+	usb_ipc_data_param.ipc_events |= IPC_LOG_RD_CB;
+	spin_unlock_irqrestore(&ipc_event_lock, flags);
+	wake_up(&kipcd_wait);
+}
+
+/*
+ * usb ipc data driver probe function
+ */
+int usb_ipc_log_probe(struct usb_interface *intf,
+	const struct usb_device_id *id)
+{
+	struct usb_endpoint_descriptor	*ipc_endpoint;
+	struct usb_device *dev = interface_to_usbdev(intf);
+	int retval;
+	IPC_LOG_DATA_BUFFER *temp_buf;
+
+	ipc_endpoint = &(intf->cur_altsetting->endpoint[0].desc);
+
+	DEBUG("%s: ep num = %d, ep Attr=0x%x, Addr = 0x%x\n", __func__,
+		intf->cur_altsetting->desc.bNumEndpoints,
+	ipc_endpoint->bmAttributes, ipc_endpoint->bEndpointAddress);
+
+	/* generate read URB */
+	/* urb size is the max value of ep MaxPacksize or FrameSize */
+	if (!IS_EP_BULK_IN(ipc_endpoint)) 	{
+		DEBUG("%s: Undetected IN endpoint\n", __func__);
+		/* Shouldn't ever get here unless we have something weird */
+		return -ENOMEM;
+	}
+	ipc_log_param.udev = dev;
+	ipc_log_param.read_bufsize = (MAX_LOG_BUF_SIZE >
+		ipc_endpoint->wMaxPacketSize) ? MAX_LOG_BUF_SIZE :
+		ipc_endpoint->wMaxPacketSize;
+	temp_buf = ipc_log_alloc_read_buffer();
+	if (temp_buf == NULL)
+		return -ENODEV;
+
+	ipc_log_param.read_buf	= temp_buf;
+	ipc_log_param.end_buf	= temp_buf;
+	ipc_log_param.write_buf = temp_buf;
+
+	usb_set_intfdata(intf, &ipc_log_param);
+
+	retval = usb_register_dev(intf, &usb_ipc_log_device);
+	if (retval) {
+		DEBUG("%s: Register USB Log device failed\n", __func__);
+		return -ENODEV;
+	}
+
+	usb_fill_bulk_urb(&ipc_log_param.read_urb, dev,
+		usb_rcvbulkpipe(dev, ipc_endpoint->bEndpointAddress),
+			0, 0, ipc_log_read_callback, 0);
+
+	ipc_log_param.probe_flag = 1;
+
+	return 0;
+}
+
+/*
+ * usb ipc data disconnect
+ */
+void usb_ipc_log_disconnect(struct usb_interface *intf)
+{
+	int i;
+	IPC_LOG_DATA_BUFFER *temp_buf;
+
+	if (ipc_log_param.probe_flag != 0)	{
+		DEBUG("%s: deregister USB device\n", __func__);
+
+		/* remove device node */
+		usb_deregister_dev(intf, &usb_ipc_log_device);
+
+		DEBUG("%s:	Free URB\n", __func__);
+		/* unlink URBs */
+		usb_unlink_urb(&ipc_log_param.read_urb);
+
+		/* free memory */
+		for (i = 0 ; i < ipc_log_param.buf_num; i++) {
+			temp_buf = ipc_log_param.read_buf->next;
+			kfree(ipc_log_param.read_buf->ptr);
+			kfree(ipc_log_param.read_buf);
+			ipc_log_param.read_buf = temp_buf;
+		}
+
+		ipc_log_param.probe_flag = 0;
+
+		usb_set_intfdata(intf, NULL);
+
+		/* re-initialize "ipc_log_param" */
+		usb_ipc_log_init();
+	}
+}
+
+/*
+ * driver init function
+ */
+int usb_ipc_log_init(void)
+{
+	memset((void *)&ipc_log_param, 0, sizeof(ipc_log_param));
+	usb_init_urb(&ipc_log_param.read_urb);
+	/* init_MUTEX_LOCKED(&ipc_log_param.mutex); */
+	return 0;
+}
+
+/*
+ * driver exit function
+ */
+void usb_ipc_log_exit(void)
+{
+}
+
diff --git a/drivers/usb/ipchost/ipc_shortmsg.c b/drivers/usb/ipchost/ipc_shortmsg.c
new file mode 100644
index 0000000..f5b8c0c
--- /dev/null
+++ b/drivers/usb/ipchost/ipc_shortmsg.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2007-2008 Motorola, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * 
+ * Changelog:
+ * Date               Author           Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007      Motorola        USB-IPC initial
+ * 05/09/2008      Motorola        Change Copyright and Changelog
+ * 
+ */
+ 
+/*!
+ * @file drivers/usb/ipchost/ipc_shortmsg.c
+ * @brief USB-IPC short message driver
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/usb.h>
+#include <linux/poll.h>
+#include <linux/major.h>
+#include <linux/usb_ipc.h>
+
+#define DEBUG(args...) printk(args)
+
+#define IPC_SHORT_FRAME_SIZE   50
+
+/* USB device ID information */
+static struct usb_device_id usb_ipc_id_table [] = {
+	{ USB_DEVICE(MOTO_USBIPC_VID, MOTO_USBIPC_PID) },
+	{ }						/* Terminating entry */
+};
+
+// USB endpoint detection
+#define IS_EP_INT(ep)     (((ep)->bmAttributes) == USB_ENDPOINT_XFER_INT ? 1 : 0)
+#define IS_EP_INT_IN(ep)  (IS_EP_INT(ep) && (((ep)->bEndpointAddress) & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+#define IS_EP_INT_OUT(ep) (IS_EP_INT(ep) && (((ep)->bEndpointAddress) & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT)
+
+
+
+/* setup packet */
+struct usb_ctrlrequest  usb_ipc_short_setup_pack = {
+//	USB_IPC_SHORT_CONTROL_REQUEST_TYPE,
+//	USB_IPC_SHORT_CONTROL_REQUEST,
+//	USB_IPC_SHORT_CONTROL_VALUE,
+//	USB_IPC_SHORT_CONTROL_INDEX,
+//	USB_IPC_SHORT_CONTROL_LENGTH
+};
+
+/* Short message class driver interfaces with IPC APIs  */
+USB_IPC_IFS_STRUCT usb_ipc_short_param;
+static int ipc_short_probe_flag = 0;
+
+/*
+ *  This function is used as the short message INT IN endpoint callback
+ */
+static void ipc_short_read_callback(struct urb *urb)
+{
+	DEBUG("Enter %s\n", __FUNCTION__);
+	if(usb_ipc_short_param.ipc_read_cb != NULL) {
+//		usb_ipc_short_param.ipc_read_cb(IPC_LOG_CH_NUM, urb);
+	}
+}
+
+/*
+ *  This function is used as the short message EP0 endpoint callback
+ */
+static void ipc_short_write_callback(struct urb *urb)
+{
+	DEBUG("Enter %s\n", __FUNCTION__);
+	if(usb_ipc_short_param.ipc_write_cb != NULL) {
+//		usb_ipc_short_param.ipc_write_cb(IPC_LOG_CH_NUM, urb);
+	}
+}
+
+/*
+ * usb ipc data driver probe function 
+ */
+int usb_ipc_short_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{	
+	struct usb_endpoint_descriptor  *ipc_endpoint;		
+	struct usb_device *dev = interface_to_usbdev (intf);
+
+	ipc_endpoint = &(intf->cur_altsetting->endpoint[0].desc);
+
+        DEBUG("%s: ep num = %d, ep Attr=0x%x, Addr = 0x%x\n", __FUNCTION__, intf->cur_altsetting->desc.bNumEndpoints, ipc_endpoint->bmAttributes, ipc_endpoint->bEndpointAddress);
+
+        if ( (!IS_EP_INT_IN(ipc_endpoint)) ) {
+                printk("%s: Int endpoint in type error\n", __FUNCTION__);
+                return -ENOMEM;
+        }
+
+	usb_ipc_short_param.udev = dev;
+	/* generate URB */
+	/* urb size is the max value of ep MaxPacksize or FrameSize */
+	usb_ipc_short_param.read_bufsize = (IPC_SHORT_FRAME_SIZE > ipc_endpoint->wMaxPacketSize)? IPC_SHORT_FRAME_SIZE : ipc_endpoint->wMaxPacketSize;
+	usb_fill_int_urb(&usb_ipc_short_param.read_urb, dev, usb_rcvintpipe(dev,ipc_endpoint->bEndpointAddress), 
+	                  0, 0, ipc_short_read_callback, 0, ipc_endpoint->bInterval);
+
+	/* control endpoint ep0 is used to send command */
+	usb_ipc_short_param.write_bufsize = (IPC_SHORT_FRAME_SIZE > dev->descriptor.bMaxPacketSize0)? IPC_SHORT_FRAME_SIZE : dev->descriptor.bMaxPacketSize0;
+	usb_fill_control_urb(&usb_ipc_short_param.write_urb, dev, usb_sndctrlpipe (dev, 0), (void *)&usb_ipc_short_setup_pack,
+	                  0, 0, ipc_short_write_callback, 0);
+
+	/* initialize parameters in IPC APIs, register this driver to IPC APIs */
+//	usb_ipc_api_initialization(IPC_SHORT_CH_NUM, &usb_ipc_short_param);
+
+	ipc_short_probe_flag = 1;
+	return 0;
+}
+
+/*
+ * usb ipc data disconnect
+ */
+void usb_ipc_short_disconnect(struct usb_interface *intf)
+{
+	if(ipc_short_probe_flag != 0)  	{
+		DEBUG("Enter %s\n", __FUNCTION__);
+		/* unlink URBs */
+		usb_unlink_urb (&usb_ipc_short_param.read_urb);
+		usb_unlink_urb (&usb_ipc_short_param.write_urb);
+		ipc_short_probe_flag = 0;
+	}
+}
+
+/*
+ * driver init function
+ */
+int usb_ipc_short_init(void)
+{
+	memset((void *)&usb_ipc_short_param, 0, sizeof(usb_ipc_short_param));
+	usb_init_urb(&usb_ipc_short_param.read_urb);	
+	usb_init_urb(&usb_ipc_short_param.write_urb);	
+	return 0;
+}
+
+/*
+ * driver exit function
+ */
+void usb_ipc_short_exit(void)
+{
+}
+
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 62e5a3e..5f6148e 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -44,6 +44,7 @@
 #include <linux/dma-mapping.h>
 
 #include "musb_core.h"
+#include "omap2430.h"
 
 
 /* MUSB PERIPHERAL status 3-mar-2006:
@@ -112,6 +113,16 @@ __acquires(ep->musb->lock)
 
 	req = to_musb_request(request);
 
+#ifdef CONFIG_USB_MOT_ANDROID
+	if (((&request->list)->prev == LIST_POISON2) ||
+		((&request->list)->next == LIST_POISON1)) {
+		dump_stack();
+		panic("%s():skip the request on ep %d\n",
+		 __func__, ep->current_epnum);
+		return;
+	}
+#endif
+
 	list_del(&request->list);
 	if (req->request.status == -EINPROGRESS)
 		req->request.status = status;
@@ -185,6 +196,9 @@ static void nuke(struct musb_ep *ep, const int status)
 		ep->dma = NULL;
 	}
 
+	printk(KERN_DEBUG "%s(): epnum=%d is_in=%d status=%d\n",
+	__func__, ep->current_epnum, ep->is_in, status);
+
 	while (!list_empty(&(ep->req_list))) {
 		req = container_of(ep->req_list.next, struct musb_request,
 				request.list);
@@ -419,6 +433,16 @@ void musb_g_tx(struct musb *musb, u8 epnum)
 
 	dma = is_dma_capable() ? musb_ep->dma : NULL;
 	do {
+		/* CSR cannot be zero. If we encounter this condition, just free
+			 the request and exit */
+		if ((dma != NULL) && !csr) {
+			printk(KERN_INFO "TXCSR is zero for %s \n",
+						 musb_ep->end_point.name);
+			if (request)
+				musb_g_giveback(musb_ep, request, -EPIPE);
+			break;
+		}
+
 		/* REVISIT for high bandwidth, MUSB_TXCSR_P_INCOMPTX
 		 * probably rates reporting as a host error
 		 */
@@ -1466,12 +1490,24 @@ musb_gadget_set_self_powered(struct usb_gadget *gadget, int is_selfpowered)
 static void musb_pullup(struct musb *musb, int is_on)
 {
 	u8 power;
+	u32 reg;
+
+	reg = omap_readl(OTG_SYSCONFIG);
 
 	power = musb_readb(musb->mregs, MUSB_POWER);
-	if (is_on)
+	if (is_on) {
+		reg &= ~SMARTSTDBY;    /* remove possible smartstdby */
+		reg |= NOSTDBY;        /* enable no standby */
+		reg |= NOIDLE;         /* enable no idle */
 		power |= MUSB_POWER_SOFTCONN;
-	else
+	} else {
+		reg |= SMARTSTDBY;        /* enable smart standby */
+		reg &= ~NOSTDBY;          /* remove possible nostdby */
+		reg &= ~NOIDLE;           /* remove possible noidle */
 		power &= ~MUSB_POWER_SOFTCONN;
+	}
+
+	omap_writel(reg, OTG_SYSCONFIG);
 
 	/* FIXME if on, HdrcStart; if off, HdrcStop */
 
diff --git a/drivers/usb/musb/musb_regs.h b/drivers/usb/musb/musb_regs.h
index de3b2f1..53346a6 100644
--- a/drivers/usb/musb/musb_regs.h
+++ b/drivers/usb/musb/musb_regs.h
@@ -333,7 +333,7 @@ static inline u16 musb_read_hwvers(void __iomem *mbase)
 
 static inline void __iomem *musb_read_target_reg_base(u8 i, void __iomem *mbase)
 {
-	return (MUSB_BUSCTL_OFFSET(i, 0) + mbase);
+	return MUSB_BUSCTL_OFFSET(i, 0) + mbase;
 }
 
 static inline void musb_write_rxfunaddr(void __iomem *ep_target_regs,
diff --git a/drivers/usb/serial/qsc6085_modem.c b/drivers/usb/serial/qsc6085_modem.c
index 55bbce8..88b38d4 100644
--- a/drivers/usb/serial/qsc6085_modem.c
+++ b/drivers/usb/serial/qsc6085_modem.c
@@ -483,6 +483,7 @@ static int modem_open(struct tty_struct *tty,
 	int i;
 	unsigned long flags;
 
+	printk("%s\n", __func__);
 	if (cdma_modem_debug)
 		dev_info(&port->dev, "%s: Enter. Open Port %d\n",
 				 __func__, port->number);
@@ -728,6 +729,7 @@ static void modem_close(struct tty_struct *tty,
 {
 	struct modem_port *modem_port_ptr;
 
+	printk("%s\n", __func__);
 	if (cdma_modem_debug)
 		dev_info(&port->dev, "%s: Enter. Close Port %d  \n",
 			 __func__, port->number);
diff --git a/drivers/video/omap2/displays/Kconfig b/drivers/video/omap2/displays/Kconfig
index 55d85c1..7ec9e4d 100644
--- a/drivers/video/omap2/displays/Kconfig
+++ b/drivers/video/omap2/displays/Kconfig
@@ -51,4 +51,10 @@ config PANEL_SHOLES
         help
 	  LCD Panel used in sholes
 
+# charlotte adding to support HDMI 
+config PANEL_HDTV
+        tristate "HDTV Panel"
+        help
+	  HDTV Panel
+
 endmenu
diff --git a/drivers/video/omap2/displays/Makefile b/drivers/video/omap2/displays/Makefile
index 81ec8b8..5acdc4d 100644
--- a/drivers/video/omap2/displays/Makefile
+++ b/drivers/video/omap2/displays/Makefile
@@ -7,4 +7,6 @@ obj-$(CONFIG_PANEL_N800) += panel-n800.o
 
 obj-$(CONFIG_PANEL_ACX565AKM) += panel-acx565akm.o
 obj-$(CONFIG_PANEL_SHOLES) += panel-sholes.o
+# charlotte adding to support HDMI
+obj-$(CONFIG_PANEL_HDTV) += panel-hdtv.o
 obj-$(CONFIG_PANEL_ZOOM2) += panel-zoom2.o
diff --git a/drivers/video/omap2/displays/panel-hdtv.c b/drivers/video/omap2/displays/panel-hdtv.c
new file mode 100644
index 0000000..dc04e9c
--- /dev/null
+++ b/drivers/video/omap2/displays/panel-hdtv.c
@@ -0,0 +1,185 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+
+#include <mach/display.h>
+#include <mach/dma.h>
+
+#define DEBUG
+
+#ifdef DEBUG
+#define DBG(format, ...) (\
+	printk(KERN_DEBUG "hdtv-panel: " format, ## __VA_ARGS__))
+#else
+#define DBG(format, ...)
+#endif
+
+/* 720X480, Virtual 858X525*/
+static struct omap_video_timings hdtv_480p_panel_timings = {
+	.x_res          = 720,
+	.y_res          = 480,
+	.pixel_clock    = 27027,
+	.hfp            = 16,
+	.hsw            = 62,
+	.hbp            = 60,
+	.vfp            = 9,
+	.vsw            = 6,
+	.vbp            = 30,
+};
+
+
+/* 1280X720, Virtual 1650X750*/
+static struct omap_video_timings hdtv_720p_panel_timings = {
+	.x_res					= 1280,
+	.y_res					= 270,
+	.pixel_clock		= 74250,
+	.hfp						= 63,
+	.hsw						= 52,
+	.hbp						= 255,
+	.vfp						= 5,
+	.vsw						= 4,
+	.vbp						= 20,
+};
+
+static int hdtv_panel_probe(struct omap_dss_device *dssdev)
+{
+	DBG("%s IN\n", __func__);
+    /* TODO: timings should be configured by EDID data */
+	dssdev->panel.timings = hdtv_480p_panel_timings;
+	DBG("%s OUT\n", __func__);
+	return 0;
+}
+
+static void hdtv_panel_remove(struct omap_dss_device *dssdev)
+{
+	DBG("%s not supported\n", __func__);
+	return;
+}
+
+static int hdtv_panel_enable(struct omap_dss_device *dssdev)
+{
+    int ret;
+
+	DBG("%s IN\n", __func__);
+
+	if (dssdev->platform_enable)
+		ret = dssdev->platform_enable(dssdev);
+	else
+		ret = 0;
+
+	DBG("%s OUT\n", __func__);
+	return ret;
+}
+
+static void hdtv_panel_disable(struct omap_dss_device *dssdev)
+{
+	DBG("%s IN\n", __func__);
+
+	if (dssdev->platform_disable)
+		dssdev->platform_disable(dssdev);
+
+	DBG("%s OUT\n", __func__);
+}
+
+static void hdtv_panel_setup_update(struct omap_dss_device *dssdev,
+				      u16 x, u16 y, u16 w, u16 h)
+{
+	DBG("%s not supported\n", __func__);
+}
+
+static int hdtv_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_rotate(struct omap_dss_device *display, u8 rotate)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_mirror(struct omap_dss_device *display, bool enable)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_run_test(struct omap_dss_device *display, int test_num)
+{
+	DBG("%s not supported\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_suspend(struct omap_dss_device *dssdev)
+{
+	DBG("%s IN\n", __func__);
+
+	hdtv_panel_disable(dssdev);
+
+	DBG("%s OUT\n", __func__);
+	return 0;
+}
+
+static int hdtv_panel_resume(struct omap_dss_device *dssdev)
+{
+    int ret;
+	DBG("%s IN\n", __func__);
+
+	ret = hdtv_panel_enable(dssdev);
+
+	DBG("%s OUT\n", __func__);
+    return ret;
+}
+
+static bool hdtv_panel_te_support(struct omap_dss_device *dssdev)
+{
+	DBG("%s not supported\n", __func__);
+	return true;
+}
+
+static struct omap_dss_driver hdtv_panel_driver = {
+	.probe = hdtv_panel_probe,
+	.remove = hdtv_panel_remove,
+
+	.enable = hdtv_panel_enable,
+	.disable = hdtv_panel_disable,
+	.suspend = hdtv_panel_suspend,
+	.resume = hdtv_panel_resume,
+	.setup_update = hdtv_panel_setup_update,
+	.enable_te = hdtv_panel_enable_te,
+	.te_support = hdtv_panel_te_support,
+	.set_rotate = hdtv_panel_rotate,
+	.set_mirror = hdtv_panel_mirror,
+	.run_test = hdtv_panel_run_test,
+
+	.driver = {
+		.name = "hdtv-panel",
+		.owner = THIS_MODULE,
+	},
+};
+
+
+static int __init hdtv_panel_init(void)
+{
+	DBG("%s IN\n", __func__);
+	omap_dss_register_driver(&hdtv_panel_driver);
+	DBG("%s OUT\n", __func__);
+	return 0;
+}
+
+static void __exit hdtv_panel_exit(void)
+{
+	DBG("%s IN\n", __func__);
+	omap_dss_unregister_driver(&hdtv_panel_driver);
+	DBG("%s OUT\n", __func__);
+}
+
+module_init(hdtv_panel_init);
+module_exit(hdtv_panel_exit);
+
+MODULE_AUTHOR("Motorola");
+MODULE_DESCRIPTION("Hdtv Panel Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/omap2/displays/panel-sholes.c b/drivers/video/omap2/displays/panel-sholes.c
index b04c2e2..3828bf2 100644
--- a/drivers/video/omap2/displays/panel-sholes.c
+++ b/drivers/video/omap2/displays/panel-sholes.c
@@ -3,14 +3,22 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
 #include <linux/workqueue.h>
 #include <linux/sched.h>
+#include <linux/panel-suppliers.h>
 
 #include <mach/display.h>
 #include <mach/dma.h>
 #include <asm/atomic.h>
 
-#define DEBUG
+#include "panel-sholes.h"
+
 #ifdef DEBUG
 #define DBG(format, ...) (printk(KERN_DEBUG "sholes-panel: " format, ## __VA_ARGS__))
 #else
@@ -25,7 +33,9 @@
 #define EDISCO_CMD_SET_COLUMN_ADDRESS	0x2A
 #define EDISCO_CMD_SET_PAGE_ADDRESS	0x2B
 #define EDISCO_CMD_SET_TEAR_ON		0x35
+#define EDISCO_CMD_SET_TEAR_OFF		0x34
 #define EDISCO_CMD_SET_TEAR_SCANLINE	0x44
+#define EDISCO_CMD_READ_DDB_START	0xA1
 
 #define EDISCO_CMD_VC   0
 #define EDISCO_VIDEO_VC 1
@@ -53,26 +63,74 @@ static struct omap_video_timings sholes_panel_timings = {
 
 atomic_t state;
 
-static int sholes_panel_probe(struct omap_dss_device *dssdev)
+#define DEVICE_NAME  "lcd-choles"
+struct sholes_panel_device {
+	struct mutex  mtx; /* Lock for all device accesses */
+
+	int major;
+	struct class *cls;
+	struct device *dev;
+
+	int opened;
+
+	int fod_en; /* Freeze-On-Display state */
+	int panel_en;   /* Panel hardware state */
+	int dss_en; /* Last DSS state request */
+};
+
+static struct sholes_panel_device *gDev;
+static struct omap_dss_device *gDssdev;
+
+static int sholes_panel_dss_probe(struct omap_dss_device *dssdev)
 {
 	DBG("probe\n");
 	dssdev->ctrl.pixel_size = 24;
 	dssdev->panel.config = OMAP_DSS_LCD_TFT;
 	dssdev->panel.config = OMAP_DSS_LCD_TFT;
 	dssdev->panel.timings = sholes_panel_timings;
+#ifdef CONFIG_FB_OMAP2_MTD_LOGO
+	atomic_set(&state, PANEL_OFF);
+#else
 	atomic_set(&state, PANEL_ON);
+#endif
 	return 0;
 }
 
-static void sholes_panel_remove(struct omap_dss_device *dssdev)
+static void sholes_panel_dss_remove(struct omap_dss_device *dssdev)
 {
 	return;
 }
+static u16 sholes_panel_read_supplier_id(void)
+{
+	static u16 id = SUPPLIER_ID_INVALID;
+	u8 data[2];
+
+	if (id == SUPPLIER_ID_AUO || id == SUPPLIER_ID_TMD)
+		goto end;
+
+	if (dsi_vc_set_max_rx_packet_size(EDISCO_CMD_VC, 2))
+		goto end;
+
+	if (dsi_vc_dcs_read(EDISCO_CMD_VC, EDISCO_CMD_READ_DDB_START, data, 2) != 2)
+		goto end;
+		
+	if (dsi_vc_set_max_rx_packet_size(EDISCO_CMD_VC, 1))
+		goto end;
+
+	id = (data[0] << 8) | data[1];
+	
+	if (id != SUPPLIER_ID_AUO && id != SUPPLIER_ID_TMD)
+		id = SUPPLIER_ID_INVALID;
+end:
+	return id;
+}
 
-static int sholes_panel_enable(struct omap_dss_device *dssdev)
+static int sholes_panel_dss_enable(struct omap_dss_device *dssdev)
 {
 	u8 data[7];
-	int ret;
+	u16 id = SUPPLIER_ID_INVALID;
+	
+	int ret = 0;
 
 	DBG("enable\n");
 	if (dssdev->platform_enable) {
@@ -81,65 +139,137 @@ static int sholes_panel_enable(struct omap_dss_device *dssdev)
 			return ret;
 	}
 
-	/* turn of mcs register acces protection */
-	data[0] = 0xb2;
-	data[1] = 0x00;
-	ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
-
-	/* enable lane setting and test registers*/
-	data[0] = 0xef;
-	data[1] = 0x01;
-	data[2] = 0x01;
-	ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
-
-	/* 2nd param 61 = 1 line; 63 = 2 lanes */
-	data[0] = 0xef;
-	data[1] = 0x60;
-	data[2] = 0x63;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 3);
+	mutex_lock(&gDev->mtx);
+	if (gDev->fod_en)
+		atomic_set(&state, PANEL_OFF);
+	gDev->dss_en = 1;
+	gDev->panel_en = 1;
+	mutex_unlock(&gDev->mtx);
+
+	id = sholes_panel_read_supplier_id();
+
+	if (id == SUPPLIER_ID_AUO) {
+		/* turn of mcs register acces protection */
+		data[0] = 0xb2;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* enable lane setting and test registers*/
+		data[0] = 0xef;
+		data[1] = 0x01;
+		data[2] = 0x01;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* 2nd param 61 = 1 line; 63 = 2 lanes */
+		data[0] = 0xef;
+		data[1] = 0x60;
+		data[2] = 0x63;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* Set dynamic backlight control PWM; D[7:4] = PWM_DIV[3:0];*/
+		/* D[3]=0 (PWM OFF);
+		 * D[2]=0 (auto BL control OFF);
+		 * D[1]=0 (Grama correction On);
+		 * D[0]=0 (Enhanced Image Correction OFF) */
+		data[0] = 0xb4;
+		data[1] = (id == SUPPLIER_ID_AUO ? 0x0F : 0x1F);
+		data[2] = 0x03;
+		data[3] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 4);
+
+		/* set page, column address */
+		data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
+		data[5] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 6);
+
+		data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
+		data[5] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 6);
+
+		/* turn it on */
+		data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = 0x00;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 4);
 
-	/* 2nd param 0 = WVGA; 1 = WQVGA */
-	data[0] = 0xb3;
-	data[1] = 0x00;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
+	}
+	else if (id == SUPPLIER_ID_TMD) {
+
+		/* turn of mcs register acces protection */
+		data[0] = 0xb2;
+		data[1] = 0x00;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
+		
+		/* enable lane setting and test registers*/
+		data[0] = 0xef;
+		data[1] = 0x01;
+		data[2] = 0x01;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
+
+		/* 2nd param 61 = 1 line; 63 = 2 lanes */
+		data[0] = 0xef;
+		data[1] = 0x60;
+		data[2] = 0x63;
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_LONG_WRITE, data, 3);
+
+		/* Set dynamic backlight control PWM; D[7:4] = PWM_DIV[3:0];*/
+		/* D[3]=0 (PWM OFF);
+		 * D[2]=0 (auto BL control OFF);
+		 * D[1]=0 (Grama correction On);
+		 * D[0]=0 (Enhanced Image Correction OFF) */
+		data[0] = 0xb4;
+		data[1] = (id == SUPPLIER_ID_AUO ? 0x0F : 0x1F);
+		ret |= dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_1, data, 2);
+
+		/* set page, column address */
+		data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
+
+		data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
+		data[1] = 0x00;
+		data[2] = 0x00;
+		data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
+		data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
+
+		/* turn it on */
+		data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
+		ret |= dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
 
-	/* Set dynamic backlight control and PWM; D[7:4] = PWM_DIV[3:0];*/
-	/* D[3]=0 (PWM OFF);
-	 * D[2]=0 (auto BL control OFF);
-	 * D[1]=0 (Grama correction On);
-	 * D[0]=0 (Enhanced Image Correction OFF) */
-	data[0] = 0xb4;
-	data[1] = 0x1f;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
+	}
+	else {
 
-	/* set page, column address */
-	data[0] = EDISCO_CMD_SET_PAGE_ADDRESS;
-	data[1] = 0x00;
-	data[2] = 0x00;
-	data[3] = (dssdev->panel.timings.y_res - 1) >> 8;
-	data[4] = (dssdev->panel.timings.y_res - 1) & 0xff;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
-	if (ret)
+		DBG("Panel not installed\n");
 		goto error;
+	}
 
-	data[0] = EDISCO_CMD_SET_COLUMN_ADDRESS;
-	data[1] = 0x00;
-	data[2] = 0x00;
-	data[3] = (dssdev->panel.timings.x_res - 1) >> 8;
-	data[4] = (dssdev->panel.timings.x_res - 1) & 0xff;
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 5);
-	if (ret)
-		goto error;
+	mdelay(200);
 
-	/* turn it on */
-	data[0] = EDISCO_CMD_EXIT_SLEEP_MODE;
-	//ret = dsi_vc_write(EDISCO_CMD_VC, EDISCO_SHORT_WRITE_0, data, 1);
-	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
+	DBG("supplier id: 0x%04x\n", (unsigned int)id);
 
-	mdelay(200);
+	if (ret)
+		goto error;
 
 	return 0;
 error:
+	atomic_set(&state, PANEL_OFF);
 	return -EINVAL;
 }
 
@@ -148,7 +278,6 @@ static void sholes_panel_disable(struct omap_dss_device *dssdev)
 	u8 data[1];
 	struct sholes_data *sholes_data = dssdev->data;
 
-	DBG("sholes_panel_ctrl_disable\n");
 
 	data[0] = EDISCO_CMD_SET_DISPLAY_OFF;
 	dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
@@ -164,19 +293,40 @@ static void sholes_panel_disable(struct omap_dss_device *dssdev)
 
 }
 
+static void sholes_panel_dss_disable(struct omap_dss_device *dssdev)
+{
+	DBG("sholes_panel_dss_disable\n");
+
+	mutex_lock(&gDev->mtx);
+
+	gDev->dss_en = 0;
+
+	if (gDev->fod_en) {
+		DBG("Freezing the last frame on the display\n");
+		mutex_unlock(&gDev->mtx);
+		return;
+	}
+
+	gDev->panel_en = 0;
+
+	mutex_unlock(&gDev->mtx);
+
+	sholes_panel_disable(dssdev);
+}
+
 static int sholes_panel_display_on(struct omap_dss_device *dssdev)
 {
 	u8 data = EDISCO_CMD_SET_DISPLAY_ON;
 
 	if (atomic_cmpxchg(&state, PANEL_OFF, PANEL_ON) ==
-	    PANEL_OFF) {
+		PANEL_OFF) {
 		return dsi_vc_dcs_write(EDISCO_CMD_VC, &data, 1);
 	}
 	return 0;
 }
 
-static void sholes_panel_setup_update(struct omap_dss_device *dssdev,
-				      u16 x, u16 y, u16 w, u16 h)
+static void sholes_panel_dss_setup_update(struct omap_dss_device *dssdev,
+					  u16 x, u16 y, u16 w, u16 h)
 {
 
 	u8 data[5];
@@ -202,11 +352,12 @@ static void sholes_panel_setup_update(struct omap_dss_device *dssdev,
 		return;
 }
 
-static int sholes_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
+static int sholes_panel_dss_enable_te(struct omap_dss_device *dssdev, bool enable)
 {
 	u8 data[3];
 	int ret;
 
+	if (enable) {
 	data[0] = EDISCO_CMD_SET_TEAR_ON;
 	data[1] = 0x00;
 	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 2);
@@ -219,6 +370,12 @@ static int sholes_panel_enable_te(struct omap_dss_device *dssdev, bool enable)
 	ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 3);
 	if (ret)
 		goto error;
+	} else {
+		data[0] = EDISCO_CMD_SET_TEAR_OFF;
+		ret = dsi_vc_dcs_write(EDISCO_CMD_VC, data, 1);
+		if (ret)
+			goto error;
+	}
 
 	DBG("edisco_ctrl_enable_te \n");
 	return 0;
@@ -227,46 +384,46 @@ error:
 	return -EINVAL;
 }
 
-static int sholes_panel_rotate(struct omap_dss_device *display, u8 rotate)
+static int sholes_panel_dss_rotate(struct omap_dss_device *display, u8 rotate)
 {
 	return 0;
 }
 
-static int sholes_panel_mirror(struct omap_dss_device *display, bool enable)
+static int sholes_panel_dss_mirror(struct omap_dss_device *display, bool enable)
 {
 	return 0;
 }
 
-static int sholes_panel_run_test(struct omap_dss_device *display, int test_num)
+static int sholes_panel_dss_run_test(struct omap_dss_device *display, int test_num)
 {
 	return 0;
 }
 
-static int sholes_panel_suspend(struct omap_dss_device *dssdev)
+static int sholes_panel_dss_suspend(struct omap_dss_device *dssdev)
 {
-	sholes_panel_disable(dssdev);
+	sholes_panel_dss_disable(dssdev);
 	return 0;
 }
 
-static int sholes_panel_resume(struct omap_dss_device *dssdev)
+static int sholes_panel_dss_resume(struct omap_dss_device *dssdev)
 {
-	return sholes_panel_enable(dssdev);
+	return sholes_panel_dss_enable(dssdev);
 }
 
-static struct omap_dss_driver sholes_panel_driver = {
-	.probe = sholes_panel_probe,
-	.remove = sholes_panel_remove,
+static struct omap_dss_driver sholes_panel_dss_driver = {
+	.probe = sholes_panel_dss_probe,
+	.remove = sholes_panel_dss_remove,
 
-	.enable = sholes_panel_enable,
+	.enable = sholes_panel_dss_enable,
 	.framedone = sholes_panel_display_on,
-	.disable = sholes_panel_disable,
-	.suspend = sholes_panel_suspend,
-	.resume = sholes_panel_resume,
-	.setup_update = sholes_panel_setup_update,
-	.enable_te = sholes_panel_enable_te,
-	.set_rotate = sholes_panel_rotate,
-	.set_mirror = sholes_panel_mirror,
-	.run_test = sholes_panel_run_test,
+	.disable = sholes_panel_dss_disable,
+	.suspend = sholes_panel_dss_suspend,
+	.resume = sholes_panel_dss_resume,
+	.setup_update = sholes_panel_dss_setup_update,
+	.enable_te = sholes_panel_dss_enable_te,
+	.set_rotate = sholes_panel_dss_rotate,
+	.set_mirror = sholes_panel_dss_mirror,
+	.run_test = sholes_panel_dss_run_test,
 
 	.driver = {
 		.name = "sholes-panel",
@@ -274,19 +431,248 @@ static struct omap_dss_driver sholes_panel_driver = {
 	},
 };
 
+static ssize_t show_panel_supplier(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u",
+			(unsigned int)sholes_panel_read_supplier_id());
+}
+
+static DEVICE_ATTR(panel_supplier, 0644, show_panel_supplier, NULL);
+
+/*=== Driver Interface Functions =======================================*/
+
+static int sholes_panel_set_fod(int *fod_en)
+{
+	int rc;
+	int en;
+
+	rc = copy_from_user(&en, fod_en, sizeof(int));
+	if (rc != 0) {
+		DBG("S_FOD copy from user failed\n");
+		goto failed;
+	}
+
+	en = (en) ? 1 : 0;
+
+	if (en != gDev->fod_en) {
+		gDev->fod_en = en;
+		if (!en && !gDev->dss_en && gDev->panel_en) {
+			dsi_bus_lock();
+			gDev->panel_en = 0;
+			sholes_panel_disable(gDssdev);
+			dsi_bus_unlock();
+		}
+	}
+
+failed:
+	return rc;
+}
+static int sholes_panel_open(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+
+	DBG("sholes_panel_open\n");
+
+	if (gDev == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&gDev->mtx);
+
+	/* We only support single open */
+	if (gDev->opened) {
+		DBG("Device already opened\n");
+		rc = -EBUSY;
+		goto failed;
+	}
+
+	gDev->opened = 1;
+
+failed:
+	mutex_unlock(&gDev->mtx);
+	return rc;
+}
+
+static int sholes_panel_release(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+
+	DBG("sholes_panel_release\n");
+
+	if (gDev == NULL) {
+		DBG("Invalid device\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&gDev->mtx);
+
+	gDev->opened = 0;
+
+	mutex_unlock(&gDev->mtx);
+
+	return rc;
+}
+
+static int sholes_panel_ioctl(struct inode *inode, struct file *file,
+							u_int cmd, u_long arg)
+{
+	int rc = 0;
+
+	if (unlikely(_IOC_TYPE(cmd) != SHOLES_IOCTL_MAGIC)) {
+		printk(KERN_ERR "Bad command value (%d)\n", cmd);
+		return -EINVAL;
+	}
+
+	mutex_lock(&gDev->mtx);
+
+	switch (cmd) {
+	case SHOLES_G_FOD:
+		rc = put_user(gDev->fod_en, (int *) arg);
+		break;
+	case SHOLES_S_FOD:
+		rc = sholes_panel_set_fod((int *) arg);
+		break;
+	default:
+		DBG("Invalid ioctl (%x)\n", cmd);
+		rc = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&gDev->mtx);
+
+	return rc;
+}
+
+static const struct file_operations sholes_panel_fops = {
+	.owner = THIS_MODULE,
+	.open = sholes_panel_open,
+	.release = sholes_panel_release,
+	.ioctl = sholes_panel_ioctl,
+};
+
+
+static int __init sholes_panel_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+
+	DBG("sholes_panel_probe\n");
+
+	gDev = kzalloc(sizeof(struct sholes_panel_device), GFP_KERNEL);
+	if (gDev == NULL)
+		return -ENOMEM;
+
+	memset(gDev, 0, sizeof(gDev));
+
+	mutex_init(&gDev->mtx);
+
+	gDev->opened = 0;
+
+	gDev->major = register_chrdev(0, DEVICE_NAME, &sholes_panel_fops);
+	if (gDev->major < 0) {
+		printk(KERN_ERR "failed chrdev register\n");
+		rc = -ENODEV;
+		goto failed_chrdev;
+	}
+
+	gDev->cls = class_create(THIS_MODULE, DEVICE_NAME);
+	if (IS_ERR(gDev->cls)) {
+		printk(KERN_DEBUG "failed class creation\n");
+		rc = PTR_ERR(gDev->cls);
+		goto failed_class;
+	}
+
+	gDev->dev = device_create(gDev->cls, gDev->dev, MKDEV(gDev->major, 0),
+							NULL, DEVICE_NAME);
+
+	rc = device_create_file(gDev->dev, &dev_attr_panel_supplier);
+	if (rc < 0) {
+		pr_err("%s:File device creation failed: %d\n", __func__, rc);
+		rc = -ENODEV;
+		goto failed_attribute;
+	}
+	return 0;
+
+failed_attribute:
+	device_remove_file(gDev->dev, &dev_attr_panel_supplier);
+failed_class:
+	unregister_chrdev(gDev->major, DEVICE_NAME);
+failed_chrdev:
+	kfree(gDev);
+	gDev = NULL;
+	return rc;
+}
+
+static int sholes_panel_remove(struct platform_device *pdev)
+{
+	struct sholes_panel_device *dsw = platform_get_drvdata(pdev);
+	
+	DBG("sholes panel remove\n");
+	
+	if(dsw) {
+		device_remove_file(dsw->dev, &dev_attr_panel_supplier);
+		class_destroy(dsw->cls);
+		unregister_chrdev(dsw->major, DEVICE_NAME);
+		kfree(dsw);
+	}
+	return 0;
+}
+
+static struct platform_device sholes_panel_dev = {
+	.name = DEVICE_NAME,
+	.id = -1,
+};
+
+static struct platform_driver sholes_panel_driver = {
+	.remove = sholes_panel_remove,
+	.driver = {
+		.name = DEVICE_NAME,
+	},
+};
+
+/*=== Driver Interface Functions =======================================*/
 
 static int __init sholes_panel_init(void)
 {
+	int rc = 0;
+	
 	DBG("sholes_panel_init\n");
-	omap_dss_register_driver(&sholes_panel_driver);
+
+	rc = platform_device_register(&sholes_panel_dev);
+	if(rc != 0) {
+		printk(KERN_ERR "failed panel device register %d\n", rc);
+		goto faildev;
+	}
+
+	rc = platform_driver_probe(&sholes_panel_driver, sholes_panel_probe);
+	if (rc != 0) {
+		printk(KERN_ERR "failed panel register/probe %d\n", rc);
+		goto faildrv;
+	}
+
+	rc = omap_dss_register_driver(&sholes_panel_dss_driver);
+	if(rc != 0) {
+		printk(KERN_ERR "failed panel dss register %d\n", rc);
+		goto faildss;
+	}
 	return 0;
+faildss:
+	platform_driver_unregister(&sholes_panel_driver);
+faildrv:
+	platform_device_unregister(&sholes_panel_dev);
+faildev:
+	return -ENODEV;
+
 }
 
 static void __exit sholes_panel_exit(void)
 {
 	DBG("sholes_panel_exit\n");
 
-	omap_dss_unregister_driver(&sholes_panel_driver);
+	omap_dss_unregister_driver(&sholes_panel_dss_driver);
+	platform_driver_unregister(&sholes_panel_driver);
+	platform_device_unregister(&sholes_panel_dev);
 }
 
 module_init(sholes_panel_init);
diff --git a/drivers/video/omap2/displays/panel-sholes.h b/drivers/video/omap2/displays/panel-sholes.h
new file mode 100644
index 0000000..86b3bce
--- /dev/null
+++ b/drivers/video/omap2/displays/panel-sholes.h
@@ -0,0 +1,13 @@
+#ifndef __PANEL_SHOLES_H__
+#define __PANEL_SHOLES_H__
+
+#define SHOLES_IOCTL_MAGIC  'g'
+#define SHOLES_IOCTL_BASE   0x60
+
+/* Freeze On Disable */
+#define SHOLES_G_FOD        _IOR(SHOLES_IOCTL_MAGIC, \
+                    SHOLES_IOCTL_BASE+0, int)
+#define SHOLES_S_FOD        _IOW(SHOLES_IOCTL_MAGIC, \
+                    SHOLES_IOCTL_BASE+1, int)
+
+#endif /* __PANEL_SHOLES_H__ */
diff --git a/drivers/video/omap2/dss/core.c b/drivers/video/omap2/dss/core.c
index be345db..b21e395 100644
--- a/drivers/video/omap2/dss/core.c
+++ b/drivers/video/omap2/dss/core.c
@@ -445,6 +445,8 @@ static int omap_dss_probe(struct platform_device *pdev)
 #ifdef CONFIG_FB_OMAP_BOOTLOADER_INIT
 	/* DISPC_CONTROL */
 	skip_init = 1;
+	if (omap_readl(0x48050440) & 1)	/* LCD enabled? */
+		skip_init = 1;
 #endif
 
 	r = dss_init(skip_init);
diff --git a/drivers/video/omap2/dss/dispc.c b/drivers/video/omap2/dss/dispc.c
index 4216466..06b6448 100644
--- a/drivers/video/omap2/dss/dispc.c
+++ b/drivers/video/omap2/dss/dispc.c
@@ -490,7 +490,6 @@ bool dispc_go_busy(enum omap_channel channel)
 		bit = 5; /* GOLCD */
 	else
 		bit = 6; /* GODIGIT */
-
 	enable_clocks(1);
 	ret = REG_GET(DISPC_CONTROL, bit, bit) == 1;
 	enable_clocks(0);
@@ -1938,6 +1937,7 @@ void dispc_enable_trans_key(enum omap_channel ch, bool enable)
 		REG_FLD_MOD(DISPC_CONFIG, enable, 12, 12);
 	enable_clocks(0);
 }
+
 void dispc_enable_alpha_blending(enum omap_channel ch, bool enable)
 {
 	enable_clocks(1);
@@ -1947,6 +1947,7 @@ void dispc_enable_alpha_blending(enum omap_channel ch, bool enable)
 		REG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);
 	enable_clocks(0);
 }
+
 bool dispc_alpha_blending_enabled(enum omap_channel ch)
 {
 	bool enabled;
@@ -1964,7 +1965,6 @@ bool dispc_alpha_blending_enabled(enum omap_channel ch)
 
 }
 
-
 bool dispc_trans_key_enabled(enum omap_channel ch)
 {
 	bool enabled;
diff --git a/drivers/video/omap2/dss/display.c b/drivers/video/omap2/dss/display.c
index fac6515..cd68868 100644
--- a/drivers/video/omap2/dss/display.c
+++ b/drivers/video/omap2/dss/display.c
@@ -277,16 +277,26 @@ static ssize_t display_wss_store(struct device *dev,
 	return size;
 }
 
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static DEVICE_ATTR(enabled, S_IRWXUGO|S_IWUSR,
+		display_enabled_show, display_enabled_store);
+#else
 static DEVICE_ATTR(enabled, S_IRUGO|S_IWUSR,
 		display_enabled_show, display_enabled_store);
+#endif
 static DEVICE_ATTR(update_mode, S_IRUGO|S_IWUSR,
 		display_upd_mode_show, display_upd_mode_store);
 static DEVICE_ATTR(tear_elim, S_IRUGO|S_IWUSR,
 		display_tear_show, display_tear_store);
 static DEVICE_ATTR(timings, S_IRUGO|S_IWUSR,
 		display_timings_show, display_timings_store);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static DEVICE_ATTR(rotate, S_IRWXUGO|S_IWUSR,
+		display_rotate_show, display_rotate_store);
+#else
 static DEVICE_ATTR(rotate, S_IRUGO|S_IWUSR,
 		display_rotate_show, display_rotate_store);
+#endif
 static DEVICE_ATTR(mirror, S_IRUGO|S_IWUSR,
 		display_mirror_show, display_mirror_store);
 static DEVICE_ATTR(wss, S_IRUGO|S_IWUSR,
diff --git a/drivers/video/omap2/dss/dsi.c b/drivers/video/omap2/dss/dsi.c
index b9d5d7d..eb4fc33 100644
--- a/drivers/video/omap2/dss/dsi.c
+++ b/drivers/video/omap2/dss/dsi.c
@@ -32,6 +32,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/kthread.h>
 #include <linux/wait.h>
+#include <linux/delay.h>
 
 #include <mach/board.h>
 #include <mach/display.h>
@@ -228,6 +229,8 @@ static struct
 	unsigned pll_locked;
 
 	struct completion bta_completion;
+	struct completion packet_sent_completion;
+	struct completion te_trigger_completion;
 
 	struct task_struct *thread;
 	wait_queue_head_t waitqueue;
@@ -547,13 +550,14 @@ void dsi_irq_handler(void)
 		dsi.errors |= irqstatus & DSI_IRQ_ERROR_MASK;
 		spin_unlock(&dsi.errors_lock);
 		if (irqstatus & DSI_IRQ_TA_TIMEOUT)
-		{
 			schedule_error_recovery();
-		}
 	} else if (debug_irq) {
 		print_irq_status(irqstatus);
 	}
 
+	if (irqstatus & DSI_IRQ_TE_TRIGGER)
+		complete(&dsi.te_trigger_completion);
+
 	for (i = 0; i < 4; ++i) {
 		if ((irqstatus & (1<<i)) == 0)
 			continue;
@@ -562,14 +566,13 @@ void dsi_irq_handler(void)
 
 		if (vcstatus & DSI_VC_IRQ_BTA)
 			complete(&dsi.bta_completion);
-
+		if (vcstatus & DSI_VC_IRQ_PACKET_SENT)
+			complete(&dsi.packet_sent_completion);
 		if (vcstatus & DSI_VC_IRQ_ERROR_MASK) {
 			DSSERR("DSI VC(%d) error, vc irqstatus %x\n",
 				       i, vcstatus);
 			if (vcstatus & DSI_VC_IRQ_BTA)
-			{
 				schedule_error_recovery();
-			}
 
 			print_irq_status_vc(i, vcstatus);
 		} else if (debug_irq) {
@@ -641,6 +644,24 @@ static u32 dsi_get_errors(void)
 	return e;
 }
 
+static void dsi_enable_te_irq(void)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_IRQENABLE);
+	l |= DSI_IRQ_TE_TRIGGER;
+	dsi_write_reg(DSI_IRQENABLE, l);
+}
+
+static void dsi_disable_te_irq(int channel)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_IRQENABLE);
+	l &= ~DSI_IRQ_TE_TRIGGER;
+	dsi_write_reg(DSI_IRQENABLE, l);
+}
+
 static void dsi_vc_enable_bta_irq(int channel)
 {
 	u32 l;
@@ -658,7 +679,23 @@ static void dsi_vc_disable_bta_irq(int channel)
 	l &= ~DSI_VC_IRQ_BTA;
 	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
 }
+static void dsi_vc_enable_packet_sent_irq(int channel)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_VC_IRQENABLE(channel));
+	l |= DSI_VC_IRQ_PACKET_SENT;
+	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
+}
 
+static void dsi_vc_disable_packet_sent_irq(int channel)
+{
+	u32 l;
+
+	l = dsi_read_reg(DSI_VC_IRQENABLE(channel));
+	l &= ~DSI_VC_IRQ_PACKET_SENT;
+	dsi_write_reg(DSI_VC_IRQENABLE(channel), l);
+}
 /* DSI func clock. this could also be DSI2_PLL_FCLK */
 static inline void enable_clocks(bool enable)
 {
@@ -771,6 +808,8 @@ static int dsi_set_lp_clk_divisor(struct omap_dss_device *dssdev)
 	if (dsi_fclk > 30*1000*1000)
 		REG_FLD_MOD(DSI_CLK_CTRL, 1, 21, 21); /* LP_RX_SYNCHRO_ENABLE */
 
+	REG_FLD_MOD(DSI_CLK_CTRL, 0, 13, 13);	/* NON CONTINUOUS CLK MODE */
+
 	return 0;
 }
 
@@ -933,9 +972,9 @@ found:
 	return 0;
 }
 
-static int dsi_pll_calc_ddrfreq( struct omap_dss_device *dssdev,
-				 unsigned long clk_freq,
-				 struct dsi_clock_info *cinfo)
+static int dsi_pll_calc_ddrfreq(struct omap_dss_device *dssdev,
+				unsigned long clk_freq,
+				struct dsi_clock_info *cinfo)
 {
 	struct dsi_clock_info cur, best;
 	const bool use_dss2_fck = 1;
@@ -952,7 +991,7 @@ static int dsi_pll_calc_ddrfreq( struct omap_dss_device *dssdev,
 		*cinfo = dsi.cache_cinfo;
 #if CONFIG_OMAP2_DSS_USE_DSI_PLL
 		dispc_set_lcd_divisor(dsi.cache_cinfo.lck_div,
-				      dsi.cache_cinfo.pck_div);
+			dsi.cache_cinfo.pck_div);
 #endif
 		return 0;
 	}
@@ -1056,7 +1095,6 @@ found:
 	return 0;
 }
 
-
 int dsi_pll_program(struct dsi_clock_info *cinfo)
 {
 	int r = 0;
@@ -1210,7 +1248,6 @@ int dsi_pll_init(bool enable_hsclk, bool enable_hsdiv)
 
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
-
 	DSSDBG("PLL init done\n");
 
 	return 0;
@@ -1437,13 +1474,13 @@ static void dsi_complexio_timings(void)
 
 	/* calculate timings */
 
-	/* 1 * DDR_CLK = 2 * UI */
+	/* DDR_CLK = 1 / (2 * UI) */
 
 	/* min 40ns + 4*UI	max 85ns + 6*UI */
 	ths_prepare = ns2ddr(70) + 2;
 
-	/* min 145ns + 10*UI */
-	ths_prepare_ths_zero = ns2ddr(175) + 2;
+	/* min 145ns + 10*UI for TMD, min 480ns for AUO */
+	ths_prepare_ths_zero = ns2ddr(175 + 425) + 2;
 
 	/* min max(8*UI, 60ns+4*UI) */
 	ths_trail = ns2ddr(60) + 5;
@@ -1452,7 +1489,10 @@ static void dsi_complexio_timings(void)
 	ths_exit = ns2ddr(145);
 
 	/* tlpx min 50n */
+	/* AUO experiment it's less than 50ns 
 	tlpx_half = ns2ddr(25);
+	*/
+	tlpx_half = ns2ddr(30);
 
 	/* min 60ns */
 	tclk_trail = ns2ddr(60) + 2;
@@ -1852,6 +1892,8 @@ static int dsi_vc_send_bta(int channel)
 		dsi_vc_flush_receive_data(channel);
 	}
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
 	REG_FLD_MOD(DSI_VC_CTRL(channel), 1, 6, 6); /* BTA_EN */
 
 	tmo = jiffies + msecs_to_jiffies(10);
@@ -1897,7 +1939,6 @@ static int dsi_vc_send_bta_sync(int channel)
 	}
 err:
 	dsi_vc_disable_bta_irq(channel);
-
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
 
@@ -1918,6 +1959,8 @@ static inline void dsi_vc_write_long_header(int channel, u8 data_type,
 	val = FLD_VAL(data_id, 7, 0) | FLD_VAL(len, 23, 8) |
 		FLD_VAL(ecc, 31, 24);
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
 	dsi_write_reg(DSI_VC_LONG_PACKET_HEADER(channel), val);
 }
 
@@ -1954,7 +1997,8 @@ static int dsi_vc_send_long(int channel, u8 data_type, u8 *data, u16 len,
 
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
-
+	INIT_COMPLETION(dsi.packet_sent_completion);
+	dsi_vc_enable_packet_sent_irq(channel);
 	dsi_vc_write_long_header(channel, data_type, len, ecc);
 
 	/*dsi_vc_print_status(0); */
@@ -1998,6 +2042,12 @@ static int dsi_vc_send_long(int channel, u8 data_type, u8 *data, u16 len,
 		dsi_vc_write_long_payload(channel, b1, b2, b3, 0);
 	}
 
+	if (wait_for_completion_timeout(&dsi.packet_sent_completion, msecs_to_jiffies(10)) == 0) {
+		DSSERR("Failed to send long packet\n");
+	}
+
+	dsi_vc_disable_packet_sent_irq(channel);
+
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
 
@@ -2028,7 +2078,16 @@ static int dsi_vc_send_short(int channel, u8 data_type, u16 data, u8 ecc)
 
 	r = (data_id << 0) | (data << 8) | (ecc << 24);
 
+	udelay(1); /* Make sure the packet to packet interval for AUO 3.7 */
+	
+	INIT_COMPLETION(dsi.packet_sent_completion);
+	dsi_vc_enable_packet_sent_irq(channel);
 	dsi_write_reg(DSI_VC_SHORT_PACKET_HEADER(channel), r);
+	if (wait_for_completion_timeout(&dsi.packet_sent_completion, msecs_to_jiffies(10)) == 0) {
+		DSSERR("Failed to send short packet\n");
+	}
+
+	dsi_vc_disable_packet_sent_irq(channel);
 
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
@@ -2067,6 +2126,7 @@ int dsi_vc_write(int channel, u8 data_type, u8 *data, int len)
 	r = dsi_vc_write_nosync(channel, data_type, data, len);
 	if (r)
 		return r;
+
 	r = dsi_vc_send_bta_sync(channel);
 
 	return r;
@@ -2099,6 +2159,7 @@ int dsi_vc_dcs_write(int channel, u8 *data, int len)
 	if (r)
 		return r;
 
+
 	/* Some devices need time to process the msg in low power mode.
 	   This also makes the write synchronous, and checks that
 	   the peripheral is still alive */
@@ -2200,7 +2261,6 @@ int dsi_vc_dcs_read(int channel, u8 dcs_cmd, u8 *buf, int buflen)
 }
 EXPORT_SYMBOL(dsi_vc_dcs_read);
 
-
 int dsi_vc_set_max_rx_packet_size(int channel, u16 len)
 {
 	return dsi_vc_send_short(channel, DSI_DT_SET_MAX_RET_PKG_SIZE,
@@ -2491,6 +2551,22 @@ static void dsi_proto_timings(struct omap_dss_device *dssdev)
 			DSI_FLUSH(ch); \
 	} while (0)
 
+static int dsi_core_init(void)
+{
+	/* Autoidle */
+	REG_FLD_MOD(DSI_SYSCONFIG, 1, 0, 0);
+
+	/* ENWAKEUP */
+	REG_FLD_MOD(DSI_SYSCONFIG, 1, 2, 2);
+
+	/* SIDLEMODE smart-idle */
+	REG_FLD_MOD(DSI_SYSCONFIG, 2, 4, 3);
+
+	_dsi_initialize_irq();
+
+	return 0;
+}
+
 static int dsi_update_screen_l4(struct omap_dss_device *dssdev,
 			int x, int y, int w, int h)
 {
@@ -2672,8 +2748,21 @@ static void dsi_update_screen_dispc(struct omap_dss_device *dssdev,
 
 	dss_start_update(dssdev);
 
-	if (use_te_trigger)
+	if (use_te_trigger) {
+		dssdev->driver->enable_te(dssdev, 1);
+
+		INIT_COMPLETION(dsi.te_trigger_completion);
+		dsi_enable_te_irq();
+
 		dsi_vc_send_bta(1);
+
+		if (wait_for_completion_timeout(&dsi.te_trigger_completion,
+			msecs_to_jiffies(25)) == 0) {
+			dssdev->driver->enable_te(dssdev, 1);
+			dsi_vc_send_bta(1);
+			/* DSSERR("Retry sending TE trigger request\n"); */
+		}
+	}
 }
 
 static void dsi_framedone_irq_callback(void *data, u32 mask)
@@ -2983,9 +3072,15 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 {
 	struct dsi_clock_info cinfo;
 	int r;
+	int cnt = 0;
 
 	_dsi_print_reset_status();
 
+	/* disable interface first */
+	dsi_vc_enable(0, 0);
+	dsi_vc_enable(1, 0);
+	dsi_if_enable(0);
+
 #if CONFIG_OMAP2_DSS_USE_DSI_PLL
 	r = dsi_pll_init(1, 1);
 #else
@@ -3013,8 +3108,7 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 	dsi_proto_timings(dssdev);
 	dsi_set_lp_clk_divisor(dssdev);
 
-	if (1)
-		_dsi_print_reset_status();
+	_dsi_print_reset_status();
 
 	r = dsi_proto_config(dssdev);
 	if (r)
@@ -3027,9 +3121,57 @@ static int dsi_display_init_dsi(struct omap_dss_device *dssdev)
 	dsi_force_tx_stop_mode_io();
 
 	if (dssdev->driver->enable) {
-		r = dssdev->driver->enable(dssdev);
-		if (r)
+		while (1) {
+			r = dssdev->driver->enable(dssdev);
+			if((r == 0) || (cnt++ >= 2))
+				break;
+
+			DSSERR("Failed Init, 1. SW Rst DSI-block\n");
+
+			_dsi_reset();
+
+			dsi_core_init();
+
+#if CONFIG_OMAP2_DSS_USE_DSI_PLL
+			r = dsi_pll_init(1, 1);
+#else
+			r = dsi_pll_init(1, 0);
+#endif
+			if (r)
+				goto err0;
+
+			r = dsi_pll_calc_ddrfreq(dssdev, dssdev->phy.dsi.ddr_clk_hz, &cinfo);
+			if (r)
+				goto err1;
+
+			r = dsi_pll_program(&cinfo);
+			if (r)
+				goto err1;
+
+			r = dsi_complexio_init(dssdev);
+			if (r)
+				goto err1;
+
+			dsi_proto_timings(dssdev);
+			dsi_set_lp_clk_divisor(dssdev);
+
+			r = dsi_proto_config(dssdev);
+			if (r)
+				goto err2;
+
+			/* enable interface */
+			dsi_vc_enable(0, 1);
+			dsi_vc_enable(1, 1);
+			dsi_if_enable(1);
+			dsi_force_tx_stop_mode_io();
+
+			DSSERR("Failed Init, 2. Hard Rst Panel\n");
+
+		}
+		
+		if (cnt > 2)
 			goto err3;
+
 	}
 
 	/* enable high-speed after initial config */
@@ -3055,22 +3197,6 @@ static void dsi_display_uninit_dsi(struct omap_dss_device *dssdev)
 	dsi_pll_uninit();
 }
 
-static int dsi_core_init(void)
-{
-	/* Autoidle */
-	REG_FLD_MOD(DSI_SYSCONFIG, 1, 0, 0);
-
-	/* ENWAKEUP */
-	REG_FLD_MOD(DSI_SYSCONFIG, 1, 2, 2);
-
-	/* SIDLEMODE smart-idle */
-	REG_FLD_MOD(DSI_SYSCONFIG, 2, 4, 3);
-
-	_dsi_initialize_irq();
-
-	return 0;
-}
-
 static int dsi_display_enable(struct omap_dss_device *dssdev)
 {
 	int r = 0;
@@ -3094,11 +3220,11 @@ static int dsi_display_enable(struct omap_dss_device *dssdev)
 
 	enable_clocks(1);
 	dsi_enable_pll_clock(1);
-
+/* Skip to keep the DSI configuration of bootloader ==
 	r = _dsi_reset();
 	if (r)
 		goto err2;
-
+====================================================*/
 	dsi_core_init();
 
 	r = dsi_display_init_dispc(dssdev);
@@ -3112,7 +3238,19 @@ static int dsi_display_enable(struct omap_dss_device *dssdev)
 	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 
 	dsi.use_ext_te = dssdev->phy.dsi.ext_te;
+
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
 	dsi_set_te(dssdev, dsi.te_enabled);
+	*/
+	if (!dsi.use_ext_te) {
+		if (dsi.te_enabled) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
 
 	dsi.update_mode = dsi.user_update_mode;
 	if (dsi.update_mode == OMAP_DSS_UPDATE_AUTO)
@@ -3152,7 +3290,7 @@ static void dsi_display_disable(struct omap_dss_device *dssdev)
 	cancel_work_sync(&dsi.error_recovery.work);
 
 	complete_all(&dsi.update_completion);
-
+	complete_all(&dsi.packet_sent_completion);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED ||
 			dssdev->state == OMAP_DSS_DISPLAY_SUSPENDED)
 		goto end;
@@ -3187,7 +3325,7 @@ static int dsi_display_suspend(struct omap_dss_device *dssdev)
 	cancel_work_sync(&dsi.error_recovery.work);
 
 	complete_all(&dsi.update_completion);
-
+	complete_all(&dsi.packet_sent_completion);
 	if (dssdev->state == OMAP_DSS_DISPLAY_DISABLED ||
 			dssdev->state == OMAP_DSS_DISPLAY_SUSPENDED)
 		goto end;
@@ -3245,8 +3383,19 @@ static int dsi_display_resume(struct omap_dss_device *dssdev)
 
 	dssdev->state = OMAP_DSS_DISPLAY_ACTIVE;
 
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
 	dsi_set_te(dssdev, dsi.te_enabled);
-
+	*/
+	if (!dsi.use_ext_te) {
+		if (dsi.te_enabled) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
+	
 	dsi.update_mode = dsi.user_update_mode;
 	if (dsi.update_mode == OMAP_DSS_UPDATE_AUTO)
 		dsi_start_auto_update(dssdev);
@@ -3407,7 +3556,19 @@ static int dsi_display_enable_te(struct omap_dss_device *dssdev, bool enable)
 	if (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)
 		goto end;
 
-	dsi_set_te(dssdev, enable);
+	/* Don't send TE DCS but modify LP_RX_TO for AUO 3.7
+ 	dsi_set_te(dssdev, enable);
+	*/
+	if (!dsi.use_ext_te) {
+		if (enable) {
+			/* disable LP_RX_TO, so that we can receive TE.  Time
+			 * to wait for TE is longer than the timer allows */
+			REG_FLD_MOD(DSI_TIMING2, 0, 15, 15); /* LP_RX_TO */
+		} else {
+			REG_FLD_MOD(DSI_TIMING2, 1, 15, 15); /* LP_RX_TO */
+		}
+	}
+
 end:
 	enable_clocks(0);
 	dsi_enable_pll_clock(0);
@@ -3590,7 +3751,7 @@ static void dsi_error_recovery_worker(struct work_struct *work)
 	mutex_lock(&dsi.lock);
 
 	if (!dsi.error_recovery.enabled)
-               goto end;
+		goto end;
 
 	dsi_bus_lock();
 
@@ -3635,9 +3796,11 @@ int dsi_init(struct platform_device *pdev)
 	dsi.errors = 0;
 
 	/* XXX fail properly */
-
+	printk(KERN_INFO "ASK036 TEST\n");
 	init_completion(&dsi.bta_completion);
+	init_completion(&dsi.packet_sent_completion);
 	init_completion(&dsi.update_completion);
+	init_completion(&dsi.te_trigger_completion);
 
 	dsi.thread = kthread_create(dsi_update_thread, NULL, "dsi");
 	if (IS_ERR(dsi.thread)) {
diff --git a/drivers/video/omap2/dss/manager.c b/drivers/video/omap2/dss/manager.c
index 704a655..f8d2aa3 100644
--- a/drivers/video/omap2/dss/manager.c
+++ b/drivers/video/omap2/dss/manager.c
@@ -284,8 +284,13 @@ struct manager_attribute {
 	__ATTR(_name, _mode, _show, _store)
 
 static MANAGER_ATTR(name, S_IRUGO, manager_name_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static MANAGER_ATTR(display, S_IRWXUGO|S_IWUSR,
+		manager_display_show, manager_display_store);
+#else
 static MANAGER_ATTR(display, S_IRUGO|S_IWUSR,
 		manager_display_show, manager_display_store);
+#endif
 static MANAGER_ATTR(default_color, S_IRUGO|S_IWUSR,
 		manager_default_color_show, manager_default_color_store);
 static MANAGER_ATTR(trans_key_type, S_IRUGO|S_IWUSR,
@@ -1359,6 +1364,12 @@ static void omap_dss_add_overlay_manager(struct omap_overlay_manager *manager)
 	list_add_tail(&manager->list, &manager_list);
 }
 
+static void omap_dss_mgr_enable_alpha_blending(struct omap_overlay_manager *mgr,
+		bool enable)
+{
+	dispc_enable_alpha_blending(mgr->id, enable);
+}
+
 int dss_init_overlay_managers(struct platform_device *pdev)
 {
 	int i, r;
@@ -1396,6 +1407,8 @@ int dss_init_overlay_managers(struct platform_device *pdev)
 		mgr->set_manager_info = &omap_dss_mgr_set_info;
 		mgr->get_manager_info = &omap_dss_mgr_get_info;
 		mgr->wait_for_go = &dss_mgr_wait_for_go;
+		mgr->enable_alpha_blending =
+			&omap_dss_mgr_enable_alpha_blending,
 
 		mgr->caps = OMAP_DSS_OVL_MGR_CAP_DISPC;
 
diff --git a/drivers/video/omap2/dss/overlay.c b/drivers/video/omap2/dss/overlay.c
index 3652106..4e67394 100644
--- a/drivers/video/omap2/dss/overlay.c
+++ b/drivers/video/omap2/dss/overlay.c
@@ -263,16 +263,30 @@ struct overlay_attribute {
 	__ATTR(_name, _mode, _show, _store)
 
 static OVERLAY_ATTR(name, S_IRUGO, overlay_name_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static OVERLAY_ATTR(manager, S_IRWXUGO|S_IWUSR,
+		overlay_manager_show, overlay_manager_store);
+#else
 static OVERLAY_ATTR(manager, S_IRUGO|S_IWUSR,
 		overlay_manager_show, overlay_manager_store);
+#endif
 static OVERLAY_ATTR(input_size, S_IRUGO, overlay_input_size_show, NULL);
 static OVERLAY_ATTR(screen_width, S_IRUGO, overlay_screen_width_show, NULL);
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+static OVERLAY_ATTR(position, S_IRWXUGO|S_IWUSR,
+		overlay_position_show, overlay_position_store);
+static OVERLAY_ATTR(output_size, S_IRWXUGO|S_IWUSR,
+		overlay_output_size_show, overlay_output_size_store);
+static OVERLAY_ATTR(enabled, S_IRWXUGO|S_IWUSR,
+		overlay_enabled_show, overlay_enabled_store);
+#else
 static OVERLAY_ATTR(position, S_IRUGO|S_IWUSR,
 		overlay_position_show, overlay_position_store);
 static OVERLAY_ATTR(output_size, S_IRUGO|S_IWUSR,
 		overlay_output_size_show, overlay_output_size_store);
 static OVERLAY_ATTR(enabled, S_IRUGO|S_IWUSR,
 		overlay_enabled_show, overlay_enabled_store);
+#endif
 static OVERLAY_ATTR(global_alpha, S_IRUGO|S_IWUSR,
 		overlay_global_alpha_show, overlay_global_alpha_store);
 
@@ -372,6 +386,28 @@ int dss_check_overlay(struct omap_overlay *ovl, struct omap_dss_device *dssdev)
 			outh = info->out_height;
 	}
 
+#ifdef CONFIG_PANEL_HDTV /* BANG Hacked start */
+	if (info->out_width > dw || info->out_height > dh || info->width > dw || info->height > dh) {
+		printk(" The panel is changed from prev_dw,prev_dh=%d,%d to dw,dh\ = %d, %d \n",
+			info->out_width, info->out_height, dw, dh);
+		/* we start to switch panel */
+		if (dw < info->out_width) {
+			printk(" Overwrite overlay info for width \n");
+			info->out_width = dw;
+			info->width = dw;
+			outw = dw;
+		} 
+
+
+		if (dh < info->out_height) {
+			printk(" Overwrite overlay info for height \n");
+                        info->out_height = dh;
+			info->height = dh;
+                        outh = dh;				
+		}
+	}
+#endif /* BANG Hacked end */
+
 	if (dw < info->pos_x + outw) {
 		DSSDBG("check_overlay failed 1: %d < %d + %d\n",
 				dw, info->pos_x, outw);
diff --git a/drivers/video/omap2/omapfb/omapfb-sysfs.c b/drivers/video/omap2/omapfb/omapfb-sysfs.c
index ef30e0e..288a98f 100644
--- a/drivers/video/omap2/omapfb/omapfb-sysfs.c
+++ b/drivers/video/omap2/omapfb/omapfb-sysfs.c
@@ -463,9 +463,15 @@ static struct device_attribute omapfb_attrs[] = {
 			store_rotate_type),
 	__ATTR(mirror, S_IRUGO | S_IWUSR, show_mirror, store_mirror),
 	__ATTR(size, S_IRUGO | S_IWUSR, show_size, store_size),
+#ifdef CONFIG_PANEL_HDTV /* charlotte change permission S_IRUGO->S_IRWXUGO */
+	__ATTR(overlays, S_IRWXUGO | S_IWUSR, show_overlays, store_overlays),
+	__ATTR(overlays_rotate, S_IRWXUGO | S_IWUSR, show_overlays_rotate,
+			store_overlays_rotate),
+#else
 	__ATTR(overlays, S_IRUGO | S_IWUSR, show_overlays, store_overlays),
 	__ATTR(overlays_rotate, S_IRUGO | S_IWUSR, show_overlays_rotate,
 			store_overlays_rotate),
+#endif
 	__ATTR(phys_addr, S_IRUGO, show_phys, NULL),
 	__ATTR(virt_addr, S_IRUGO, show_virt, NULL),
 };
diff --git a/drivers/w1/w1.c b/drivers/w1/w1.c
index acc7e3b..ae464b0 100644
--- a/drivers/w1/w1.c
+++ b/drivers/w1/w1.c
@@ -517,10 +517,10 @@ static W1_MASTER_ATTR_RO(max_slave_count, S_IRUGO);
 static W1_MASTER_ATTR_RO(attempts, S_IRUGO);
 static W1_MASTER_ATTR_RO(timeout, S_IRUGO);
 static W1_MASTER_ATTR_RO(pointer, S_IRUGO);
-static W1_MASTER_ATTR_RW(search, S_IRUGO | S_IWUGO);
-static W1_MASTER_ATTR_RW(pullup, S_IRUGO | S_IWUGO);
-static W1_MASTER_ATTR_RW(add, S_IRUGO | S_IWUGO);
-static W1_MASTER_ATTR_RW(remove, S_IRUGO | S_IWUGO);
+static W1_MASTER_ATTR_RW(search, S_IRUSR|S_IRGRP | S_IWUSR|S_IWGRP);
+static W1_MASTER_ATTR_RW(pullup, S_IRUSR|S_IRGRP | S_IWUSR|S_IWGRP);
+static W1_MASTER_ATTR_RW(add, S_IRUSR|S_IRGRP | S_IWUSR|S_IWGRP);
+static W1_MASTER_ATTR_RW(remove, S_IRUSR|S_IRGRP | S_IWUSR|S_IWGRP);
 
 static struct attribute *w1_master_default_attrs[] = {
 	&w1_master_attribute_name.attr,
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 3915baa..32510ac 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -197,9 +197,23 @@ config OMAP_WATCHDOG_AUTOPET
 	depends on OMAP_WATCHDOG
 	default n
 	help
-	  Select if you want the kernel to auto-enable and pet the watchdog 
+	  Select if you want the kernel to auto-enable and pet the watchdog
 	  itself.
 
+config OMAP_WATCHDOG_FIQ
+	bool "FIQ watchdog based on timer"
+	depends on OMAP_WATCHDOG && NON_NESTED_FIQ
+	default n
+	help
+	  Select if you want to debug watchdog reset.
+
+config OMAP_WATCHDOG_CONTROL
+    bool "Control watchdog disable from user space"
+	depends on OMAP_WATCHDOG
+	default n
+	help
+	 Select if you want to control watchdog at debug Mode.
+
 config PNX4008_WATCHDOG
 	tristate "PNX4008 Watchdog"
 	depends on ARCH_PNX4008
diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c
index b994df6..caad365 100644
--- a/drivers/watchdog/omap_wdt.c
+++ b/drivers/watchdog/omap_wdt.c
@@ -24,6 +24,7 @@
  *
  * Copyright (c) 2005 David Brownell
  *	Use the driver model and standard identifiers; handle bigger timeouts.
+ *
  */
 
 #include <linux/module.h>
@@ -44,7 +45,14 @@
 #include <linux/uaccess.h>
 #ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
 #include <linux/timer.h>
-#include <linux/workqueue.h>
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+#include <mach/dmtimer.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#endif
+#endif
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+#include <linux/debugfs.h>
 #endif
 #include <mach/hardware.h>
 #include <mach/prcm.h>
@@ -53,6 +61,11 @@
 
 static struct platform_device *omap_wdt_dev;
 
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+static unsigned int cntrl_flag = ~CLOSE_WDT;
+static int wdt_cntrl_set(void *data, u64 val);
+#endif
+
 static unsigned timer_margin;
 module_param(timer_margin, uint, 0);
 MODULE_PARM_DESC(timer_margin, "initial watchdog timeout (in seconds)");
@@ -70,13 +83,45 @@ struct omap_wdt_dev {
 	struct resource *mem;
 	struct miscdevice omap_wdt_miscdev;
 #ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-	struct work_struct work;
 	struct timer_list autopet_timer;
 	unsigned long  jiffies_start;
 	unsigned long  jiffies_exp;
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+	struct omap_dm_timer *wdt_debug_timer;
+#endif
 #endif
 };
 
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+#define DEBUG_PERIOD_SECONDS	(55)
+static unsigned wdt_debug_period;
+
+static fiqreturn_t wdt_fiq_handler(struct pt_regs *regs)
+{
+	int irq_num;
+	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
+
+	local_irq_disable();
+	irq_num = omap_readl(0x48200044) & 0x7f;
+	if (irq_num == omap_dm_timer_get_irq(wdev->wdt_debug_timer)) {
+		omap_dm_timer_write_status(wdev->wdt_debug_timer,
+				OMAP_TIMER_INT_OVERFLOW);
+		omap_dm_timer_stop(wdev->wdt_debug_timer);
+		/* Clear all interrupt flags for Timer12 */
+		omap_writel(0x0, 0x4830401c);
+	}
+	/* NEWFIQAGR reset FIQ output and enable new FIQ generation */
+	omap_writel(0x3, 0x48200048);
+
+	show_regs(regs);
+	printk(KERN_INFO "\nBacktrace:\n");
+	c_backtrace(regs->ARM_fp, processor_mode(regs));
+	local_irq_enable();
+	panic("FIQ!\n");
+	return IRQ_HANDLED;
+}
+#endif
+
 static void omap_wdt_ping(struct omap_wdt_dev *wdev)
 {
 	void __iomem    *base = wdev->base;
@@ -101,9 +146,7 @@ static int omap_wdt_panic(struct notifier_block *this, unsigned long event,
 	unsigned long flags;
 
 	spin_lock_irqsave(&wdt_lock, flags);
-#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-	del_timer(&wdev->autopet_timer);
-#endif
+
 	if (wdev && wdev->omap_wdt_users > 0)
 		omap_wdt_ping(wdev);
 
@@ -208,7 +251,6 @@ static int omap_wdt_open(struct inode *inode, struct file *file)
 static int omap_wdt_release(struct inode *inode, struct file *file)
 {
 	struct omap_wdt_dev *wdev = file->private_data;
-
 	/*
 	 *      Shut off the timer unless NOWAYOUT is defined.
 	 */
@@ -309,14 +351,8 @@ static const struct file_operations omap_wdt_fops = {
 #ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
 static void autopet_handler(unsigned long data)
 {
-	struct omap_wdt_dev *wdev = (struct omap_wdt_dev *) data;
-	schedule_work(&wdev->work);
-}
-
-static void omap_wdt_work_func(struct work_struct *work)
-{
 	unsigned long flags;
-	struct omap_wdt_dev *wdev = container_of(work, struct omap_wdt_dev, work);
+	struct omap_wdt_dev *wdev = (struct omap_wdt_dev *) data;
 
 	spin_lock_irqsave(&wdt_lock, flags);
 	omap_wdt_ping(wdev);
@@ -324,6 +360,10 @@ static void omap_wdt_work_func(struct work_struct *work)
 	wdev->jiffies_start = jiffies;
 	wdev->jiffies_exp = (HZ * TIMER_AUTOPET_FREQ);
 	mod_timer(&wdev->autopet_timer, jiffies + wdev->jiffies_exp);
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+	omap_dm_timer_set_load_start(wdev->wdt_debug_timer, 0,
+		(0xffffffff - wdt_debug_period));
+#endif
 }
 #endif
 
@@ -429,7 +469,7 @@ static int __init omap_wdt_probe(struct platform_device *pdev)
 	omap_wdt_dev = pdev;
 
 #ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-	INIT_WORK(&wdev->work, omap_wdt_work_func);
+	omap_wdt_ping(wdev);
 	setup_timer(&wdev->autopet_timer, autopet_handler,
 		    (unsigned long) wdev);
 	test_and_set_bit(1, (unsigned long *)&(wdev->omap_wdt_users));
@@ -441,7 +481,24 @@ static int __init omap_wdt_probe(struct platform_device *pdev)
 	omap_wdt_enable(wdev);
 	pr_info("Watchdog auto-pet enabled at %d sec intervals\n",
 		TIMER_AUTOPET_FREQ);
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+	wdev->wdt_debug_timer = omap_dm_timer_request_specific(12);
+	omap_writel(omap_readl(0x48304010) | 0x2, 0x48304010);
+	omap_dm_timer_set_int_enable(wdev->wdt_debug_timer,
+		OMAP_TIMER_INT_OVERFLOW);
+	wdt_debug_period = DEBUG_PERIOD_SECONDS
+		* clk_get_rate(omap_dm_timer_get_fclk(wdev->wdt_debug_timer));
+	omap_dm_timer_set_load_start(wdev->wdt_debug_timer, 0,
+		(0xffffffff - wdt_debug_period));
+	set_fiq_handler(wdt_fiq_handler);
+#endif
 #endif
+
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+	if (CLOSE_WDT == cntrl_flag)
+		wdt_cntrl_set(NULL, 0);
+#endif
+
 	return 0;
 
 err_misc:
@@ -519,16 +576,25 @@ static int omap_wdt_remove(struct platform_device *pdev)
  * may not play well enough with NOWAYOUT...
  */
 
-int omap_wdt_suspend(void)
+int omap_wdt_suspend(pm_message_t state)
 {
 	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
 
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+	if (CLOSE_WDT == cntrl_flag)
+		return 0;
+#endif
+
 	if (wdev->omap_wdt_users) {
+#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
 		wdev->jiffies_exp -= jiffies - wdev->jiffies_start;
 		del_timer(&wdev->autopet_timer);
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+		omap_dm_timer_stop(wdev->wdt_debug_timer);
+#endif
+#endif
 		omap_wdt_disable(wdev);
 	}
-
 	return 0;
 }
 
@@ -536,8 +602,18 @@ int omap_wdt_resume(void)
 {
 	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
 
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+	if (CLOSE_WDT == cntrl_flag)
+		return 0;
+#endif
+
 	if (wdev->omap_wdt_users) {
+#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
 		mod_timer(&wdev->autopet_timer, jiffies + wdev->jiffies_exp);
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+		omap_dm_timer_start(wdev->wdt_debug_timer);
+#endif
+#endif
 		omap_wdt_enable(wdev);
 	}
 
@@ -553,8 +629,10 @@ static struct platform_driver omap_wdt_driver = {
 	.probe		= omap_wdt_probe,
 	.remove		= omap_wdt_remove,
 	.shutdown	= omap_wdt_shutdown,
-//	.suspend	= omap_wdt_suspend,
-//	.resume		= omap_wdt_resume,
+/*
+	.suspend	= omap_wdt_suspend,
+	.resume		= omap_wdt_resume,
+*/
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "omap_wdt",
@@ -565,9 +643,62 @@ static struct notifier_block panic_blk = {
 	.notifier_call  = omap_wdt_panic,
 };
 
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+static int wdt_cntrl_set(void *data, u64 val)
+{
+	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
+
+	if (wdev->omap_wdt_users) {
+		cntrl_flag = CLOSE_WDT;
+#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
+		wdev->jiffies_exp -= jiffies - wdev->jiffies_start;
+		del_timer(&wdev->autopet_timer);
+
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+		omap_dm_timer_stop(wdev->wdt_debug_timer);
+#endif
+#endif
+		omap_wdt_disable(wdev);
+	}
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(wdt_cntrl_fops, NULL, wdt_cntrl_set, "%llu\n");
+
+static int __init wdt_ctrl_init(char *s)
+{
+	if (!strncmp(s, "off", 3))
+		cntrl_flag = CLOSE_WDT;
+
+	return 0;
+}
+__setup("wdt_stat=", wdt_ctrl_init);
+#endif
+
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+static int fire_wdt_reset_set(void *data, u64 val)
+{
+	local_irq_disable();
+	while (1);
+
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(fire_wdt_reset_fops,
+				NULL, fire_wdt_reset_set, "%llu\n");
+#endif
+
 static int __init omap_wdt_init(void)
 {
 	spin_lock_init(&wdt_lock);
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+	debugfs_create_file("diswdt", 0644, NULL,
+			NULL, &wdt_cntrl_fops);
+#endif
+#ifdef CONFIG_OMAP_WATCHDOG_FIQ
+	debugfs_create_file("fire_wdt_reset", 0222,
+			NULL, NULL, &fire_wdt_reset_fops);
+#endif
 	return platform_driver_register(&omap_wdt_driver);
 }
 
@@ -581,7 +712,9 @@ module_exit(omap_wdt_exit);
 
 static int __init omap_wdt_panic_init(void)
 {
-	return atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
+
+	return 0;
 }
 
 arch_initcall(omap_wdt_panic_init);
diff --git a/drivers/watchdog/omap_wdt.h b/drivers/watchdog/omap_wdt.h
index 87b224f..75563f4 100644
--- a/drivers/watchdog/omap_wdt.h
+++ b/drivers/watchdog/omap_wdt.h
@@ -48,6 +48,10 @@
 #define TIMER_MARGIN_DEFAULT	60	/* 60 secs */
 #define TIMER_MARGIN_MIN	1
 
+#ifdef CONFIG_OMAP_WATCHDOG_CONTROL
+#define CLOSE_WDT 0
+#endif
+
 #ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
 #define TIMER_AUTOPET_FREQ	45
 #endif
diff --git a/firmware/Makefile b/firmware/Makefile
index 466106f..302fffb 100644
--- a/firmware/Makefile
+++ b/firmware/Makefile
@@ -89,6 +89,7 @@ fw-shipped-$(CONFIG_USB_SERIAL_KEYSPAN_PDA) += keyspan_pda/keyspan_pda.fw
 fw-shipped-$(CONFIG_USB_SERIAL_XIRCOM) += keyspan_pda/xircom_pgs.fw
 fw-shipped-$(CONFIG_USB_VICAM) += vicam/firmware.fw
 fw-shipped-$(CONFIG_VIDEO_CPIA2) += cpia2/stv0672_vp4.bin
+fw-shipped-$(CONFIG_MFD_CPCAP) += cpcap/firmware_1_2x.fw
 
 fw-shipped-all := $(fw-shipped-y) $(fw-shipped-m) $(fw-shipped-)
 
diff --git a/firmware/cpcap/firmware_1_2x.H16 b/firmware/cpcap/firmware_1_2x.H16
new file mode 100644
index 0000000..c6c2760
--- /dev/null
+++ b/firmware/cpcap/firmware_1_2x.H16
@@ -0,0 +1,3 @@
+:03E0913000917A918C2400000401000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012005030001E410F82A1000052A1000041301200503000B0410F82A1000052A10000413040B20040531A40B20040532640B20080532840B20020532A40B20020532C43829160438291624382916443829166438291684382916A4382916C40B2006990E640B2005990E840B2005190EA40B2A12090EC40B2000790EE43829170438291724382917443C2917843C291794382916E43C2917643D29177D0B201000110C0B201000108C0B2040000C0C0B2040000C640B20C80018440B200100180435C52A100004130120A435AB0B201009FA428041200503001623C0412005030000C4C4A4A4C413A52A100004130B0B2002011022C13B0B204000100280DB0B208000102280993C29176240843C29176D0B2002001C83C0243D29176B0B2004011022C22539291629292916E9162281C93C29177200AD3921806D3921808D392180A403F0003435E3C09C3921806C3921808C392180A403F0012434E4EC291774F82916E43829162B0B2008011022C06539291642405D0B2008001C843829164B0B2010011022C095392916690B2000A91662805D0B2010001C843829166B0B2020011022C095392916890B2001491682805D0B2020001C843829168B0B2040011022C095392916A90B2003C916A2805D0B2040001C84382916AB0B2100011022C295392916C90B20258916C280940B29000030040B2D17303024382916C3C0790B20257916C2003D0B240000302120050300102934C240243D29179B0B2080011022C0693C291792405D0B2080001C843C29179435C52A10000413080310020410C403E9140403D001012005030010CC0B240000302403E03FF4E0CF21C03044C810000438100024E0CF21C03064C810004438100064E0CF21C03084C8100084381000A4E0CF21C030A4C81000C4381000E4E0CF21C030C4C810010438100124E0CF21C030E4C810014438100164E0CF21C03104C8100184381001AF21E03124E81001C4381001E41A29174421F91749F8290EA280343E291783C16425E91789F8290E82805934E200343D291783C0C9F8290E62C07934E240543C2917843D291793C04934E240243D291795031002052A100004130421F150C421E150A4E0C4F0D821C9170721D9172930D3404E33CE33D531C630D921D90EE280C2003921C90EC28084E8291704F829172435C52A100004130434C52A100004130120C4EBC0000532C831D23FB413C52A1000041304C0F5D0F3C0343CC0000531C9F0C23FB52A100004130403C9160403D001A12005030FFDC00008A
+:0002901800913095
+:0000000001FF
diff --git a/fs/Kconfig b/fs/Kconfig
index 747092d..788179d 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -4,6 +4,11 @@
 
 menu "File systems"
 
+config CORE_DUMP_PERMISSION
+# open core dump permission
+    bool "Core dump permission"
+	default n
+
 if BLOCK
 
 source "fs/ext2/Kconfig"
diff --git a/fs/exec.c b/fs/exec.c
index 929b580..d68c003 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -50,6 +50,7 @@
 #include <linux/cn_proc.h>
 #include <linux/audit.h>
 #include <linux/tracehook.h>
+#include <linux/lttlite-events.h>
 #include <linux/kmod.h>
 #include <linux/fsnotify.h>
 
@@ -1336,6 +1337,11 @@ int do_execve(char * filename,
 	if (retval < 0)
 		goto out;
 
+#ifdef CONFIG_LTT_LITE
+	/* Trace only if exec has been successful */
+	ltt_lite_ev_process(LTT_LITE_EV_PROCESS_EXEC, current);
+#endif
+
 	/* execve succeeded */
 	mutex_unlock(&current->cred_exec_mutex);
 	acct_update_integrals(current);
@@ -1831,12 +1837,16 @@ void do_coredump(long signr, int exit_code, struct pt_regs *regs)
 	   but keep the previous behaviour for now. */
 	if (!ispipe && !S_ISREG(inode->i_mode))
 		goto close_fail;
+
+#ifndef CONFIG_CORE_DUMP_PERMISSION	
 	/*
 	 * Dont allow local users get cute and trick others to coredump
 	 * into their pre-created files:
 	 */
 	if (inode->i_uid != current_fsuid())
 		goto close_fail;
+#endif
+
 	if (!file->f_op)
 		goto close_fail;
 	if (!file->f_op->write)
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 240ec639..7ed888c 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -15,6 +15,7 @@
 #include <linux/uaccess.h>
 #include <linux/writeback.h>
 #include <linux/buffer_head.h>
+#include <linux/lttlite-events.h>
 
 #include <asm/ioctls.h>
 
@@ -488,6 +489,17 @@ int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 {
 	int error = 0;
 	int __user *argp = (int __user *)arg;
+#ifdef CONFIG_LTT_LITE
+	char ltt_string[LTT_LITE_MAX_LOG_STRING_SIZE];
+
+	sprintf(ltt_string, "fd=%X/cmd=%X/arg=%X/pid=%d\n", fd,
+		cmd, (int)arg, current->pid);
+	ltt_lite_syscall_param(LTT_EV_FILE_SYSTEM_IOCTL, ltt_string,
+		strlen(ltt_string));
+	sprintf(ltt_string, "f_op=%X/pid=%d\n", (int)filp->f_op, current->pid);
+	ltt_lite_syscall_param(LTT_EV_FILE_SYSTEM_IOCTL, ltt_string,
+		strlen(ltt_string));
+#endif
 
 	switch (cmd) {
 	case FIOCLEX:
diff --git a/fs/yaffs2/yaffs_checkptrw.c b/fs/yaffs2/yaffs_checkptrw.c
index 7b69a64..e4b681f 100644
--- a/fs/yaffs2/yaffs_checkptrw.c
+++ b/fs/yaffs2/yaffs_checkptrw.c
@@ -171,7 +171,7 @@ int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting)
 		dev->blocksInCheckpoint = 0;
 		dev->checkpointMaxBlocks = (dev->internalEndBlock - dev->internalStartBlock)/16 + 2;
 		dev->checkpointBlockList = YMALLOC(sizeof(int) * dev->checkpointMaxBlocks);
-		if(!dev->checkpointBlockList)
+		if (!dev->checkpointBlockList)
 			return 0;
 
 		for (i = 0; i < dev->checkpointMaxBlocks; i++)
@@ -314,7 +314,6 @@ int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes)
 					dev->checkpointCurrentChunk;
 
 				realignedChunk = chunk - dev->chunkOffset;
-				
 				dev->nPageReads++;
 
 				/* read in the next chunk */
diff --git a/fs/yaffs2/yaffs_fs.c b/fs/yaffs2/yaffs_fs.c
index aece2cf..729731d 100644
--- a/fs/yaffs2/yaffs_fs.c
+++ b/fs/yaffs2/yaffs_fs.c
@@ -165,8 +165,8 @@ static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
 
 #define update_dir_time(dir) do {\
 			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
-		} while(0)
-		
+		} while (0)
+
 static void yaffs_put_super(struct super_block *sb);
 
 static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
@@ -377,6 +377,122 @@ static void yaffs_GrossUnlock(yaffs_Device *dev)
 	up(&dev->grossLock);
 }
 
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the removeObjectCallback to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each yaffs_Device has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_SearchContext {
+	yaffs_Device *dev;
+	yaffs_Object *dirObj;
+	yaffs_Object *nextReturn;
+	struct ylist_head others;
+};
+
+/*
+ * yaffs_NewSearch() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_SearchContext * yaffs_NewSearch(yaffs_Object *dir)
+{
+	yaffs_Device *dev = dir->myDev;
+	struct yaffs_SearchContext *sc = YMALLOC(sizeof(struct yaffs_SearchContext));
+	if(sc){
+		sc->dirObj = dir;
+		sc->dev = dev;
+		if( ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+			sc->nextReturn = NULL;
+		else
+			sc->nextReturn = ylist_entry(
+                                dir->variant.directoryVariant.children.next,
+				yaffs_Object,siblings);
+		YINIT_LIST_HEAD(&sc->others);
+		ylist_add(&sc->others,&dev->searchContexts);
+	}
+	return sc;
+}
+
+/*
+ * yaffs_EndSearch() disposes of a search context and cleans up.
+ */
+static void yaffs_EndSearch(struct yaffs_SearchContext * sc)
+{
+	if(sc){
+		ylist_del(&sc->others);
+		YFREE(sc);
+	}
+}
+
+/*
+ * yaffs_SearchAdvance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_SearchAdvance(struct yaffs_SearchContext *sc)
+{
+        if(!sc)
+                return;
+
+        if( sc->nextReturn == NULL ||
+                ylist_empty(&sc->dirObj->variant.directoryVariant.children))
+                sc->nextReturn = NULL;
+        else {
+                struct ylist_head *next = sc->nextReturn->siblings.next;
+
+                if( next == &sc->dirObj->variant.directoryVariant.children)
+                        sc->nextReturn = NULL; /* end of list */
+                else
+                        sc->nextReturn = ylist_entry(next,yaffs_Object,siblings);
+        }
+}
+
+/*
+ * yaffs_RemoveObjectCallback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_RemoveObjectCallback(yaffs_Object *obj)
+{
+
+        struct ylist_head *i;
+        struct yaffs_SearchContext *sc;
+        struct ylist_head *search_contexts = &obj->myDev->searchContexts;
+
+
+        /* Iterate through the directory search contexts.
+         * If any are currently on the object being removed, then advance
+         * the search context to the next object to prevent a hanging pointer.
+         */
+         ylist_for_each(i, search_contexts) {
+                if (i) {
+                        sc = ylist_entry(i, struct yaffs_SearchContext,others);
+                        if(sc->nextReturn == obj)
+                                yaffs_SearchAdvance(sc);
+                }
+	}
+
+}
+
+
+/*-----------------------------------------------------------------*/
+
 static int yaffs_readlink(struct dentry *dentry, char __user *buffer,
 			int buflen)
 {
@@ -1127,10 +1243,11 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 {
 	yaffs_Object *obj;
 	yaffs_Device *dev;
+        struct yaffs_SearchContext *sc;
 	struct inode *inode = f->f_dentry->d_inode;
 	unsigned long offset, curoffs;
-	struct ylist_head *i;
 	yaffs_Object *l;
+        int retVal = 0;
 
 	char name[YAFFS_MAX_NAME_LENGTH + 1];
 
@@ -1141,14 +1258,22 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 
 	offset = f->f_pos;
 
+        sc = yaffs_NewSearch(obj);
+        if(!sc){
+                retVal = -ENOMEM;
+                goto unlock_out;
+        }
+
 	T(YAFFS_TRACE_OS, ("yaffs_readdir: starting at %d\n", (int)offset));
 
 	if (offset == 0) {
 		T(YAFFS_TRACE_OS,
 			("yaffs_readdir: entry . ino %d \n",
 			(int)inode->i_ino));
+		yaffs_GrossUnlock(dev);
 		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0)
 			goto out;
+		yaffs_GrossLock(dev);
 		offset++;
 		f->f_pos++;
 	}
@@ -1156,9 +1281,11 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 		T(YAFFS_TRACE_OS,
 			("yaffs_readdir: entry .. ino %d \n",
 			(int)f->f_dentry->d_parent->d_inode->i_ino));
+		yaffs_GrossUnlock(dev);
 		if (filldir(dirent, "..", 2, offset,
 			f->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0)
 			goto out;
+		yaffs_GrossLock(dev);
 		offset++;
 		f->f_pos++;
 	}
@@ -1174,10 +1301,12 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 		f->f_version = inode->i_version;
 	}
 
-	ylist_for_each(i, &obj->variant.directoryVariant.children) {
+	while(sc->nextReturn){
 		curoffs++;
+                l = sc->nextReturn;
 		if (curoffs >= offset) {
-			l = ylist_entry(i, yaffs_Object, siblings);
+                        int this_inode = yaffs_GetObjectInode(l);
+                        int this_type = yaffs_GetObjectType(l);
 
 			yaffs_GetObjectName(l, name,
 					    YAFFS_MAX_NAME_LENGTH + 1);
@@ -1185,24 +1314,30 @@ static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 			  ("yaffs_readdir: %s inode %d\n", name,
 			   yaffs_GetObjectInode(l)));
 
+                        yaffs_GrossUnlock(dev);
+
 			if (filldir(dirent,
 					name,
 					strlen(name),
 					offset,
-					yaffs_GetObjectInode(l),
-					yaffs_GetObjectType(l)) < 0)
-				goto up_and_out;
+					this_inode,
+					this_type) < 0)
+				goto out;
+
+                        yaffs_GrossLock(dev);
 
 			offset++;
 			f->f_pos++;
 		}
+                yaffs_SearchAdvance(sc);
 	}
 
-up_and_out:
-out:
+unlock_out:
 	yaffs_GrossUnlock(dev);
+out:
+        yaffs_EndSearch(sc);
 
-	return 0;
+	return retVal;
 }
 
 /*
@@ -1385,7 +1520,7 @@ static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
 
 	yaffs_GrossUnlock(dev);
 
-	if (link){
+	if (link) {
 		update_dir_time(dir);
 		return 0;
 	}
@@ -1487,9 +1622,9 @@ static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
 			new_dentry->d_inode->i_nlink--;
 			mark_inode_dirty(new_dentry->d_inode);
 		}
-		
+
 		update_dir_time(old_dir);
-		if(old_dir != new_dir)
+		if (old_dir != new_dir)
 			update_dir_time(new_dir);
 		return 0;
 	} else {
@@ -2125,6 +2260,10 @@ static struct super_block *yaffs_internal_read_super(int yaffsVersion,
 	/* we assume this is protected by lock_kernel() in mount/umount */
 	ylist_add_tail(&dev->devList, &yaffs_dev_list);
 
+        /* Directory search handling...*/
+        YINIT_LIST_HEAD(&dev->searchContexts);
+        dev->removeObjectCallback = yaffs_RemoveObjectCallback;
+
 	init_MUTEX(&dev->grossLock);
 
 	yaffs_GrossLock(dev);
diff --git a/fs/yaffs2/yaffs_guts.c b/fs/yaffs2/yaffs_guts.c
index a565b08..0a04f6a 100644
--- a/fs/yaffs2/yaffs_guts.c
+++ b/fs/yaffs2/yaffs_guts.c
@@ -1544,12 +1544,12 @@ static int yaffs_FindChunkInGroup(yaffs_Device *dev, int theChunk,
 	for (j = 0; theChunk && j < dev->chunkGroupSize; j++) {
 		if (yaffs_CheckChunkBit(dev, theChunk / dev->nChunksPerBlock,
 				theChunk % dev->nChunksPerBlock)) {
-			
-			if(dev->chunkGroupSize == 1)
+
+			if (dev->chunkGroupSize == 1)
 				return theChunk;
 			else {
-				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,
-								tags);
+				yaffs_ReadChunkWithTagsFromNAND(dev, theChunk,
+								NULL, tags);
 				if (yaffs_TagsMatch(tags, objectId, chunkInInode)) {
 					/* found it; */
 					return theChunk;
@@ -2465,6 +2465,8 @@ int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
 	yaffs_Object *obj = NULL;
 	yaffs_Object *existingTarget = NULL;
 	int force = 0;
+	int result;
+	yaffs_Device *dev;
 
 
 	if (!oldDir || oldDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
@@ -2472,6 +2474,8 @@ int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
 	if (!newDir || newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
 		YBUG();
 
+	dev = oldDir->myDev;
+
 #ifdef CONFIG_YAFFS_CASE_INSENSITIVE
 	/* Special case for case insemsitive systems (eg. WinCE).
 	 * While look-up is case insensitive, the name isn't.
@@ -2481,7 +2485,7 @@ int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
 		force = 1;
 #endif
 
-	else if (yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)
+	if(yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)
 		/* ENAMETOOLONG */
 		return YAFFS_FAIL;
 
@@ -2499,17 +2503,26 @@ int yaffs_RenameObject(yaffs_Object *oldDir, const YCHAR *oldName,
 			return YAFFS_FAIL;	/* EEXIST or ENOTEMPTY */
 		} else if (existingTarget && existingTarget != obj) {
 			/* Nuke the target first, using shadowing,
-			 * but only if it isn't the same object
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc otherwise it can mess up the shadowing.
+			 *
 			 */
+			dev->isDoingGC=1;
 			yaffs_ChangeObjectName(obj, newDir, newName, force,
 						existingTarget->objectId);
+			existingTarget->isShadowed = 1;
 			yaffs_UnlinkObject(existingTarget);
+			dev->isDoingGC=0;
 		}
+
+		result = yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);
+
 		yaffs_UpdateParent(oldDir);
-		if(newDir != oldDir)
+		if (newDir != oldDir)
 			yaffs_UpdateParent(newDir);
 
-		return yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);
+		return result;
 	}
 	return YAFFS_FAIL;
 }
@@ -2983,15 +2996,15 @@ static int yaffs_GarbageCollectBlock(yaffs_Device *dev, int block,
 
 	/*yaffs_VerifyFreeChunks(dev); */
 
-	if(bi->blockState == YAFFS_BLOCK_STATE_FULL)
+	if (bi->blockState == YAFFS_BLOCK_STATE_FULL)
 		bi->blockState = YAFFS_BLOCK_STATE_COLLECTING;
-	
+
 	bi->hasShrinkHeader = 0;	/* clear the flag so that the block can erase */
 
 	/* Take off the number of soft deleted entries because
 	 * they're going to get really deleted during GC.
 	 */
-	if(dev->gcChunk == 0) /* first time through for this block */
+	if (dev->gcChunk == 0) /* first time through for this block */
 		dev->nFreeChunks -= bi->softDeletions;
 
 	dev->isDoingGC = 1;
@@ -3108,6 +3121,7 @@ static int yaffs_GarbageCollectBlock(yaffs_Device *dev, int block,
 					if (tags.chunkId == 0) {
 						/* It is an object Id,
 						 * We need to nuke the shrinkheader flags first
+						 * Also need to clean up shadowing.
 						 * We no longer want the shrinkHeader flag since its work is done
 						 * and if it is left in place it will mess up scanning.
 						 */
@@ -3116,6 +3130,9 @@ static int yaffs_GarbageCollectBlock(yaffs_Device *dev, int block,
 						oh = (yaffs_ObjectHeader *)buffer;
 						oh->isShrink = 0;
 						tags.extraIsShrinkHeader = 0;
+						oh->shadowsObject = 0;
+						oh->inbandShadowsObject = 0;
+						tags.extraShadows = 0;
 
 						yaffs_VerifyObjectHeader(object, oh, &tags, 1);
 					}
@@ -3796,7 +3813,7 @@ int yaffs_UpdateObjectHeader(yaffs_Object *in, const YCHAR *name, int force,
 		/* Create new chunk in NAND */
 		newChunkId =
 		    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
-						      (prevChunkId > 0) ? 1 : 0);
+						(prevChunkId > 0) ? 1 : 0);
 
 		if (newChunkId >= 0) {
 
@@ -5030,11 +5047,13 @@ int yaffs_ResizeFile(yaffs_Object *in, loff_t newSize)
 	}
 
 
-	/* Write a new object header.
+	/* Write a new object header to reflect the resize.
 	 * show we've shrunk the file, if need be
-	 * Do this only if the file is not in the deleted directories.
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
 	 */
 	if (in->parent &&
+	    !in->isShadowed &&
 	    in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
 	    in->parent->objectId != YAFFS_OBJECTID_DELETED)
 		yaffs_UpdateObjectHeader(in, NULL, 0,
@@ -5247,7 +5266,7 @@ static int yaffs_UnlinkWorker(yaffs_Object *obj)
 		immediateDeletion = 1;
 #endif
 
-	if(obj)
+	if (obj)
 		yaffs_UpdateParent(obj->parent);
 
 	if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
@@ -5304,7 +5323,7 @@ static int yaffs_UnlinkWorker(yaffs_Object *obj)
 		default:
 			return YAFFS_FAIL;
 		}
-	} else if(yaffs_IsNonEmptyDirectory(obj))
+	} else if (yaffs_IsNonEmptyDirectory(obj))
 		return YAFFS_FAIL;
 	else
 		return yaffs_ChangeObjectName(obj, obj->myDev->unlinkedDir,
@@ -5345,7 +5364,8 @@ static void yaffs_HandleShadowedObject(yaffs_Device *dev, int objId,
 		/* Handle YAFFS2 case (backward scanning)
 		 * If the shadowed object exists then ignore.
 		 */
-		if (yaffs_FindObjectByNumber(dev, objId))
+		obj = yaffs_FindObjectByNumber(dev, objId);
+		if(obj)
 			return;
 	}
 
@@ -5357,6 +5377,7 @@ static void yaffs_HandleShadowedObject(yaffs_Device *dev, int objId,
 					     YAFFS_OBJECT_TYPE_FILE);
 	if (!obj)
 		return;
+	obj->isShadowed = 1;
 	yaffs_AddObjectToDirectory(dev->unlinkedDir, obj);
 	obj->variant.fileVariant.shrinkSize = 0;
 	obj->valid = 1;		/* So that we don't read any other info for this file */
@@ -6816,16 +6837,15 @@ static void yaffs_VerifyDirectory(yaffs_Object *directory)
  *   rm dir/a:   update dir's mtime/ctime
  *   modify dir/a: don't update dir's mtimme/ctime
  */
- 
 static void yaffs_UpdateParent(yaffs_Object *obj)
 {
-	if(!obj)
+	if (!obj)
 		return;
 
 	obj->dirty = 1;
 	obj->yst_mtime = obj->yst_ctime = Y_CURRENT_TIME;
 
-	yaffs_UpdateObjectHeader(obj,NULL,0,0,0);
+	yaffs_UpdateObjectHeader(obj, NULL, 0, 0, 0);
 }
 
 static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj)
@@ -6844,7 +6864,7 @@ static void yaffs_RemoveObjectFromDirectory(yaffs_Object *obj)
 
 	ylist_del_init(&obj->siblings);
 	obj->parent = NULL;
-	
+
 	yaffs_VerifyDirectory(parent);
 }
 
diff --git a/fs/yaffs2/yaffs_guts.h b/fs/yaffs2/yaffs_guts.h
index 3dce95f..5240581 100644
--- a/fs/yaffs2/yaffs_guts.h
+++ b/fs/yaffs2/yaffs_guts.h
@@ -424,6 +424,7 @@ struct yaffs_ObjectStruct {
 				 * until the inode is released.
 				 */
 	__u8 beingCreated:1;	/* This object is still being created so skip some checks. */
+	__u8 isShadowed:1;      /* This object is shadowed on the way to being renamed. */
 
 	__u8 serial;		/* serial number of chunk in NAND. Cached here */
 	__u16 sum;		/* sum of the name to speed searching */
@@ -557,7 +558,9 @@ struct yaffs_DeviceStruct {
 
 	int useHeaderFileSize;	/* Flag to determine if we should use file sizes from the header */
 
-	int emptyLostAndFound;  /* Flasg to determine if lst+found should be emptied on init */
+	int emptyLostAndFound;  /* Flasg to determine if lst+found should be
+				 * emptied on init
+				 */
 
 	int useNANDECC;		/* Flag to decide whether or not to use NANDECC */
 
@@ -594,8 +597,9 @@ struct yaffs_DeviceStruct {
 	int isYaffs2;
 
 	/* The removeObjectCallback function must be supplied by OS flavours that
-	 * need it. The Linux kernel does not use this, but yaffs direct does use
-	 * it to implement the faster readdir
+	 * need it.
+         * yaffs direct uses it to implement the faster readdir.
+         * Linux uses it to protect the directory during unlocking.
 	 */
 	void (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);
 
@@ -638,10 +642,14 @@ struct yaffs_DeviceStruct {
 
 	struct semaphore sem;	/* Semaphore for waiting on erasure.*/
 	struct semaphore grossLock;	/* Gross locking semaphore */
+	struct rw_semaphore dirLock; /* Lock the directory structure */
 	__u8 *spareBuffer;	/* For mtdif2 use. Don't know the size of the buffer
 				 * at compile time so we have to allocate it.
+
 				 */
 	void (*putSuperFunc) (struct super_block *sb);
+        struct ylist_head searchContexts;
+
 #endif
 
 	int isMounted;
diff --git a/fs/yaffs2/yaffs_mtdif2.c b/fs/yaffs2/yaffs_mtdif2.c
index bc00481..f151377 100644
--- a/fs/yaffs2/yaffs_mtdif2.c
+++ b/fs/yaffs2/yaffs_mtdif2.c
@@ -188,7 +188,6 @@ int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device *dev, int chunkInNAND,
 		dev->eccUnfixed++;
 	}
 	if (tags && retval == -EUCLEAN && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
-		tags->eccResult = YAFFS_ECC_RESULT_FIXED;
 		dev->eccFixed++;
 	}
 	if (retval == 0)
diff --git a/include/asm-generic/vmlinux.lds.h b/include/asm-generic/vmlinux.lds.h
index c61fab1..a34bc02 100644
--- a/include/asm-generic/vmlinux.lds.h
+++ b/include/asm-generic/vmlinux.lds.h
@@ -439,3 +439,21 @@
 		*(.data.percpu.shared_aligned)				\
 	}								\
 	VMLINUX_SYMBOL(__per_cpu_end) = .;
+
+
+#define SORT(x)		x
+
+#define CONSTRUCTORS							\
+		__CTOR_LIST__ = .;					\
+		LONG((__CTOR_END__ - __CTOR_LIST__) /			\
+			(__CTOR_LIST2__ - __CTOR_LIST__) - 2)		\
+		__CTOR_LIST2__ = .;					\
+		*(SORT(.init_array))						\
+		LONG(0)							\
+		__CTOR_END__ = .;					\
+		__DTOR_LIST__ = .;					\
+		LONG((__DTOR_END__ - __DTOR_LIST__) /			\
+			(__CTOR_LIST2__ - __CTOR_LIST__) - 2)		\
+		*(SORT(.dtors))						\
+		LONG(0)							\
+		__DTOR_END__ = .;
diff --git a/include/linux/android_pmem.h b/include/linux/android_pmem.h
index 398997c..8e9fc1d 100644
--- a/include/linux/android_pmem.h
+++ b/include/linux/android_pmem.h
@@ -62,7 +62,7 @@ int get_pmem_file(int fd, unsigned long *start, unsigned long *vstart,
 		  unsigned long *end, struct file **filp);
 int get_pmem_user_addr(struct file *file, unsigned long *start,
 		       unsigned long *end);
-void put_pmem_file(struct file* file);
+void put_pmem_file(struct file *file);
 void flush_pmem_file(struct file *file, unsigned long start, unsigned long len);
 int pmem_setup(struct android_pmem_platform_data *pdata,
 	       long (*ioctl)(struct file *, unsigned int, unsigned long),
@@ -77,7 +77,7 @@ static inline int get_pmem_file(int fd, unsigned long *start,
 				struct file **filp) { return -ENOSYS; }
 static inline int get_pmem_user_addr(struct file *file, unsigned long *start,
 				     unsigned long *end) { return -ENOSYS; }
-static inline void put_pmem_file(struct file* file) { return; }
+static inline void put_pmem_file(struct file *file) { return; }
 static inline void flush_pmem_file(struct file *file, unsigned long start,
 				   unsigned long len) { return; }
 static inline int pmem_setup(struct android_pmem_platform_data *pdata,
diff --git a/include/linux/gcov.h b/include/linux/gcov.h
new file mode 100644
index 0000000..971398d
--- /dev/null
+++ b/include/linux/gcov.h
@@ -0,0 +1,243 @@
+/*
+ * include/linux/gcov.h
+ *
+ * Type declarations and macros used by GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2003
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
+ */
+
+#ifndef GCOV_H
+#define GCOV_H GCOV_H
+
+#include <linux/module.h>
+#include <linux/semaphore.h>
+#include <asm/types.h>
+
+#define GCC_VERSION_LOWER(major, minor) ((__GNUC__ < major) || \
+					 (__GNUC__ == major) && \
+					 (__GNUC_MINOR__ < minor))
+#define GCC_VERSION_EQUAL(major, minor)	 (__GNUC__ == major) && \
+					 (__GNUC_MINOR__ == minor)
+
+#if GCC_VERSION_LOWER(3, 1)
+
+/*
+ * Profiling types for GCC prior to version 3.1
+ */
+
+typedef long gcov_type;
+
+/* Same as gcc/libgcc2.c */
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	long *counts;
+	long ncounts;
+	struct bb *next;
+	const unsigned long *addresses;
+	long nwords;
+	const char **functions;
+	const long *line_nums;
+	const char **filenames;
+	char *flags;
+};
+
+#elif GCC_VERSION_LOWER(3, 3)
+
+/*
+ * Profiling types for GCC 3.1 to 3.2
+ */
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+/* Same as gcc/libgcc2.c */
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	gcov_type *counts;
+	long ncounts;
+	struct bb *next;
+	const unsigned long *addresses;
+	long nwords;
+	const char **functions;
+	const long *line_nums;
+	const char **filenames;
+	char *flags;
+};
+
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+
+/*
+ * Profiling types for modified GCC 3.3 (hammer patch)
+ */
+
+#define GCOV_DATA_MAGIC		0x67636f76
+#define GCOV_TAG_FUNCTION	0x01000000
+
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+struct counter_section
+{
+	unsigned int tag;
+	unsigned int n_counters;
+};
+
+struct counter_section_data
+{
+	unsigned int tag;
+	unsigned int n_counters;
+	gcov_type *counters;
+};
+
+struct function_info
+{
+	const char *name;
+	unsigned int checksum;
+	unsigned int n_counter_sections;
+	const struct counter_section *counter_sections;
+};
+
+struct bb /* should be 'struct gcov_info' but we're sticking with the old name
+	   * so we can reuse some of our pre-3.4 functions */
+{
+	unsigned long version;
+	struct bb *next;
+	const char *filename;
+	long wkspc;
+	unsigned int n_functions;
+	const struct function_info *functions;
+	unsigned int n_counter_sections;
+	const struct counter_section_data *counter_sections;
+};
+
+extern unsigned long gcov_version;
+#elif GCC_VERSION_LOWER(3, 4)
+
+/*
+ * Profiling types for vanilla GCC 3.3
+ */
+
+typedef long long gcov_type;
+
+/* Same as gcc/libgcc2.c */
+struct bb_function_info
+{
+	long checksum;
+	int arc_count;
+	const char *name;
+};
+
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	gcov_type *counts;
+	long ncounts;
+	struct bb *next;
+	long sizeof_bb;
+	struct bb_function_info *function_infos;
+};
+
+#else /* GCC_VERSION */
+
+/*
+ * Profiling types for GCC 3.4 and above (see gcc-3.4/gcc/gcov-io.h)
+ */
+
+#define GCOV_COUNTERS		5
+#define GCOV_DATA_MAGIC		((gcov_unsigned_t) 0x67636461)
+#define GCOV_TAG_FUNCTION	((gcov_unsigned_t) 0x01000000)
+#define GCOV_TAG_COUNTER_BASE	((gcov_unsigned_t) 0x01a10000)
+#define GCOV_TAG_FOR_COUNTER(COUNT)					\
+	(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t) (COUNT) << 17))
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+typedef unsigned int gcov_unsigned_t;
+typedef unsigned int gcov_position_t;
+
+typedef void (*gcov_merge_fn) (gcov_type *, gcov_unsigned_t);
+
+struct gcov_fn_info
+{
+	gcov_unsigned_t ident;
+	gcov_unsigned_t checksum;
+	unsigned int n_ctrs[0];			/* Note: the number of bits
+						 * set in bb->ctr_mask decides
+						 * how big this array is. */
+};
+
+struct gcov_ctr_info
+{
+	gcov_unsigned_t num;
+	gcov_type *values;
+	gcov_merge_fn merge;
+};
+
+struct bb /* should be 'struct gcov_info' but we're sticking with the old name
+	   * so we can reuse some of our pre-3.4 functions */
+{
+	gcov_unsigned_t version;
+	struct bb *next;
+	gcov_unsigned_t stamp;
+	const char *filename;
+	unsigned int n_functions;
+	const struct gcov_fn_info *functions;
+	unsigned int ctr_mask;
+	struct gcov_ctr_info counts[0];		/* Note: the number of bits
+						 * set in ctr_mask decides
+						 * how big this array is. */
+};
+
+extern gcov_unsigned_t gcov_version;
+#endif /* GCC_VERSION */
+
+enum gcov_cmd {
+	gcov_add,
+	gcov_remove
+};
+
+typedef void (*ctor_t)(void);
+
+extern struct bb *bb_head;
+extern const char *gcov_sourcepath;
+extern const char *gcov_objectpath;
+extern struct semaphore gcov_core_lock;
+
+extern void do_global_ctors(ctor_t[], unsigned long, struct module *);
+extern void (*gcov_callback)(enum gcov_cmd, struct bb *);
+extern void remove_bb_link(struct module *);
+
+#endif /* GCOV_H */
diff --git a/include/linux/gpio_event.h b/include/linux/gpio_event.h
index 360b4dd..a62bec2 100644
--- a/include/linux/gpio_event.h
+++ b/include/linux/gpio_event.h
@@ -80,6 +80,7 @@ struct gpio_event_matrix_info {
 	const unsigned short *keymap;
 	unsigned int *input_gpios;
 	unsigned int *output_gpios;
+	int (*sw_fixup)(int index);
 	unsigned int ninputs;
 	unsigned int noutputs;
 	/* time to wait before reading inputs after driving each output */
diff --git a/include/linux/gpio_mapping.h b/include/linux/gpio_mapping.h
new file mode 100644
index 0000000..f95ec9e
--- /dev/null
+++ b/include/linux/gpio_mapping.h
@@ -0,0 +1,44 @@
+/*
+ * linux-2.6.x/include/linux/gpio_mapping.h
+ *
+ * Prototypes and definitions used for the implementation of the
+ * GPIO API.
+ *
+ * Copyright (C) 2009 Motorola, Inc.
+ *
+ * Initial code: Motorola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/* Date        Author          Comment
+ * ----------  --------------  ----------------------------------------------
+ * 23/06/2009  Motorola        Initial revision.
+ */
+
+#ifndef __LINUX_GPIO_MAPPING_H
+#define __LINUX_GPIO_MAPPING_H
+
+#define GPIO_MAP_NAME_SIZE 20
+
+struct gpio_mapping {
+	u32 used;
+	u32 pin_num;
+	char name[GPIO_MAP_NAME_SIZE];
+};
+
+extern void __init gpio_mapping_init(struct gpio_mapping *table, int size);
+extern int get_gpio_by_name(char *name);
+
+#endif /* __LINUX_GPIO_MAPPING_H */
diff --git a/include/linux/gpiodev.h b/include/linux/gpiodev.h
new file mode 100644
index 0000000..b8b2514
--- /dev/null
+++ b/include/linux/gpiodev.h
@@ -0,0 +1,149 @@
+/* 
+ * GPIODev                                       gpiodev.h
+ *
+ * Copyright 2006-2009 Motorola, Inc.
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
+ * USA
+ *
+ */
+
+#ifndef _GPIODEV_H_
+#define _GPIODEV_H_
+
+#include <linux/ioctl.h>
+
+/*
+ * GPIODev state flags
+ */
+#define GPIODEV_FLAG_OPEN           (0x1 << 0)
+#define GPIODEV_FLAG_LOWLEVELACCESS (0x1 << 1)
+#define GPIODEV_FLAG_CONFIGURABLE   (0x1 << 2)
+#define GPIODEV_FLAG_INTERRUPTED    (0x1 << 3)
+
+#define GPIO_DEVICE_NAME_LEN 20
+#define GPIO_DEVICE_DEV_NAME "gpio-device"
+
+/*
+ * gpio_device defines a GPIO
+ *     pin_nr - pin number of the GPIO
+ *     device_name - name which shows up in /dev
+ *     init_config - the default configuration of a GPIO
+ *     current_config - the current configuration the GPIO
+ *     flags -  status of the device node (see GPIODev state flags above)
+ *     event_queue - queue to sleep on while waiting for an interrupt
+ */
+struct gpio_device {
+	u32 pin_nr;
+	char device_name[GPIO_DEVICE_NAME_LEN];
+	u32 init_config;
+	u32 current_config;
+	u32 flags;
+	wait_queue_head_t event_queue;
+	struct mutex lock;
+};
+
+struct gpio_device_platform_data {
+	const char *name;
+	struct gpio_device *info;
+	size_t info_count;
+};
+
+/*
+ * GPIODEV_LOWLEVEL_CONFIG is used to specify the low level configuration
+ * of a device. This structure is passed as a parameter to an ioctl()
+ * with the type of either GPIODEV_GET_LOWLEVELCONFIG or
+ * GPIODEV_SET_LOWLEVEL_CONFIG. 
+ *
+ * config - GPIO configuration: invalid, normal GPIO, interruptable GPIO
+ * int_trigger - trigger condition if interruptable GPIO 
+ */
+typedef struct GPIODEV_LOWLEVEL_CONFIG {
+	unsigned char config;
+} GPIODEV_LOWLEVEL_CONFIG;
+
+
+#define GPIODEV_BASE 'g'
+/*
+ * Definition of supported ioctl()'s 
+ *
+ * GPIODEV_GET_CONFIG - Get the configuration byte of a particular device.
+ *                      The configuration byte is a bit mask of the various
+ *                      defines described below.
+ *
+ * GPIODEV_SET_CONFIG - Set the configuration byte of a particular device.
+ *                      The ioctl() will return an error if the configuration
+ *                      could not be set. The configuration byte is a bit mask
+ *                      of the various defines described below.
+ *
+ * GPIODEV_INT_REENABLE - After an interrupt is received, this ioctl() must be
+ *                        performed before another interrupt from the same device
+ *                        can be received.
+ *
+ * GPIODEV_GET_LOWLEVELCONFIG - Get the low level configuration of a device.
+ *                              An error will be returned if this operation is
+ *                              not allowed on a particular GPIO.
+ *
+ * GPIODEV_SET_LOWLEVELCONFIG - Set the low level configuartion of a device.
+ *                              An error will be returned if this operation is
+ *                              not allowed on a particular GPIO.
+ *
+ * GPIODEV_INT_POLL - Monitor the specified GPIO interrupt event.
+ */
+#define GPIODEV_GET_CONFIG         _IOR(GPIODEV_BASE, 0, int*)
+#define GPIODEV_SET_CONFIG         _IOW(GPIODEV_BASE, 1, int*)
+#define GPIODEV_INT_REENABLE       _IO(GPIODEV_BASE, 2)
+#define GPIODEV_GET_LOWLEVELCONFIG _IOR(GPIODEV_BASE, 3, GPIODEV_LOWLEVEL_CONFIG*)
+#define GPIODEV_SET_LOWLEVELCONFIG _IOW(GPIODEV_BASE, 4, GPIODEV_LOWLEVEL_CONFIG*)
+#define GPIODEV_INT_POLL           _IO(GPIODEV_BASE, 5)
+
+/*
+ * Definition of the format of the interrupt trigger configuration byte
+ *
+ * GPIODEV_*INTTYPE_LLEV - Sets the interrupt type as level low sensitive 
+ * GPIODEV_*INTTYPE_HLEV - Sets the interrupt type as level high sensitive
+ * GPIODEV_*INTTYPE_BEDG - Sets the interrupt type as both edge sensitive 
+ * GPIODEV_*INTTYPE_REDG - Sets the interrupt type as rising edge sensitive
+ * GPIODEV_*INTTYPE_FEDG - Sets the interrupt type as falling edge sensitive
+ *
+ */
+enum gpiodev_int_type {
+	GPIODEV_INTTYPE_NONE = 0,
+	GPIODEV_INTTYPE_REDG = 1,
+	GPIODEV_INTTYPE_FEDG = 2,
+	GPIODEV_INTTYPE_HLEV = 3,
+	GPIODEV_INTTYPE_LLEV = 4,
+	GPIODEV_INTTYPE_MAX
+};
+
+/*
+ * Definition of the format of GPIODev configuraion options
+ */
+#define GPIODEV_CONFIG_INVALID        (0x1 << 0)
+#define GPIODEV_CONFIG_INPUT          (0x1 << 1)
+#define GPIODEV_CONFIG_OUTPUT_HIGH    (0x1 << 2)
+#define GPIODEV_CONFIG_OUTPUT_LOW     (0x1 << 3)
+
+#define GPIODEV_CONFIG_INT_MASK_OFFSET 8
+#define GPIODEV_CONFIG_INT_NONE        (GPIODEV_INTTYPE_NONE << GPIODEV_CONFIG_INT_MASK_OFFSET)
+#define GPIODEV_CONFIG_INT_REDG        (GPIODEV_INTTYPE_REDG << GPIODEV_CONFIG_INT_MASK_OFFSET)
+#define GPIODEV_CONFIG_INT_FEDG        (GPIODEV_INTTYPE_FEDG << GPIODEV_CONFIG_INT_MASK_OFFSET)
+#define GPIODEV_CONFIG_INT_HLEV        (GPIODEV_INTTYPE_HLEV << GPIODEV_CONFIG_INT_MASK_OFFSET)
+#define GPIODEV_CONFIG_INT_LLEV        (GPIODEV_INTTYPE_LLEV << GPIODEV_CONFIG_INT_MASK_OFFSET)
+#define GPIODEV_CONFIG_INT_MASK        (0xFF << GPIODEV_CONFIG_INT_MASK_OFFSET)
+
+#endif				/* #ifndef _GPIODEV_H_ */
diff --git a/include/linux/i2c/lp3907_i2c.h b/include/linux/i2c/lp3907_i2c.h
new file mode 100644
index 0000000..2563113
--- /dev/null
+++ b/include/linux/i2c/lp3907_i2c.h
@@ -0,0 +1,41 @@
+/*
+ * include/lp3907_i2c.h
+ *
+ * Configuration for LP3907 TDMB tuner regulator
+ */
+
+#ifndef __LINUX_LP3907_I2C_H
+#define __LINUX_LP3907_I2C_H
+
+#include <linux/ioctl.h>
+
+/*
+typedef struct {
+
+} __attribute__((packed)) lp3907_info;
+*/
+
+struct lp3907_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+/* LP3907 indicator */
+#define LP3907_DRIVER_NAME 	     "lp3907"
+#define LP3907_DEVICE_NAME         "/dev/lp3907"
+
+/* ****************************************************************************
+ *   Command ID
+ * ************************************************************************** */
+
+#define LP3907_MAGIC    'l'
+
+#define LP3907_PWR_OFF_CMD          _IO(LP3907_MAGIC, 0)
+#define	LP3907_PWR_ON_CMD    	      _IO(LP3907_MAGIC, 1)
+
+#define LP3907_MAXNR                 2
+
+
+#endif /* __LINUX_LP3907_I2C_H */
diff --git a/include/linux/if_pppox.h b/include/linux/if_pppox.h
index 179d674..9786aa7 100644
--- a/include/linux/if_pppox.h
+++ b/include/linux/if_pppox.h
@@ -150,12 +150,15 @@ struct pppolac_opt {
 	__u32	remote;
 	__u16	sequence;
 	__u8	sequencing;
+	int	(*backlog_rcv)(struct sock *sk_udp, struct sk_buff *skb);
 };
 
 struct pppopns_opt {
 	__u16	local;
 	__u16	remote;
 	__u32	sequence;
+	void	(*data_ready)(struct sock *sk_raw, int length);
+	int	(*backlog_rcv)(struct sock *sk_raw, struct sk_buff *skb);
 };
 
 #include <net/sock.h>
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 9127f6b..a4c42a3 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -59,6 +59,12 @@
 #define IRQF_NOBALANCING	0x00000800
 #define IRQF_IRQPOLL		0x00001000
 
+typedef int fiqreturn_t;
+
+typedef fiqreturn_t (*fiq_handler_t)(struct pt_regs *);
+
+void set_fiq_handler(fiq_handler_t fiq_handler);
+
 typedef irqreturn_t (*irq_handler_t)(int, void *);
 
 struct irqaction {
diff --git a/include/linux/ipc_api.h b/include/linux/ipc_api.h
new file mode 100644
index 0000000..323c0dd
--- /dev/null
+++ b/include/linux/ipc_api.h
@@ -0,0 +1,439 @@
+/*
+ * Copyright (C) 2007-2008 Motorola, Inc
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * Changelog:
+ * Date               Author           Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007      Motorola        USB-IPC initial
+ * 03/22/2008      Motorola        USB-IPC header support
+ * 05/09/2008      Motorola        Change Copyright and Changelog
+ * 07/09/2008      Motorola        Change MAX_FRAME_SIZE for Phase 1
+ * 11/03/2008      Motorola        Support sequence number
+ * 
+ */
+ 
+/*!
+ * @file ipc_api.h
+ * @brief Header file for USB-IPC
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+#ifndef __IPC_API_H__
+#define __IPC_API_H__
+
+/* the following macros shall be same with BP and NetMux */
+#define MAX_FRAME_SIZE           1552
+#define MAX_FRAME_NUM            10
+
+/* supported max node number for write_ex2/read_ex2 */
+#define MAX_IPC_EX2_NODE_NUM     50
+
+/* bits for node comand */
+#define NODE_DESCRIPTOR_END_BIT  0x4000
+#define NODE_DESCRIPTOR_LAST_BIT 0x8000
+#define NODE_DESCRIPTOR_DONE_BIT 0x2000
+
+/* Log buffer in AP */
+#define MAX_LOG_BUF_NUM   20
+/* Max buffer size for each Log BULK IN transfer: 3K for 2 frames */
+#define MAX_LOG_BUF_SIZE  3072 
+
+/* the extra-header will be used for DATA channel */
+#define IPC_FRAME_VERSION   0x0200
+typedef struct {
+	unsigned short length;
+} IPC_FRAME_DESCRIPTOR;
+
+typedef struct {
+        unsigned short       version;
+        unsigned short       nb_frame;
+        unsigned char        sequence_number;
+        unsigned char        options;
+        unsigned short       checksum; 		 
+        IPC_FRAME_DESCRIPTOR frames[MAX_FRAME_NUM];
+} IPC_DATA_HEADER;
+
+typedef struct {
+        unsigned short       version;
+        unsigned short       nb_frame;
+        unsigned char        sequence_number;
+        unsigned char        options;
+        unsigned short       checksum; 		 
+} IPC_DATA_HEADER_INDEX;
+
+
+/*!
+ * This enum defines the different status of an IPC link
+ */
+typedef enum {
+	HW_CTRL_IPC_STATUS_OK = 0,
+	HW_CTRL_IPC_STATUS_CHANNEL_UNAVAILABLE,
+	HW_CTRL_IPC_STATUS_IPC_SUSPENDED,
+	HW_CTRL_IPC_STATUS_READ_ON_GOING,
+	HW_CTRL_IPC_STATUS_WRITE_ON_GOING,
+	HW_CTRL_IPC_STATUS_INIT_ALREADY_CALLED,
+	HW_CTRL_IPC_STATUS_ERROR
+} HW_CTRL_IPC_STATUS_T;
+
+/*!
+ * This typedef defines the ioctls available
+ * for kernel modules using IPC.
+ */
+typedef enum {
+	HW_CTRL_IPC_SET_READ_CALLBACK = 0,
+	HW_CTRL_IPC_SET_WRITE_CALLBACK,
+	HW_CTRL_IPC_SET_NOTIFY_CALLBACK,
+	HW_CTRL_IPC_SET_MAX_CTRL_STRUCT_NB
+} HW_CTRL_IPC_IOCTL_ACTION_T;
+
+/*!
+ * Definition of IPC channel types
+ *
+ * There are currently three types of channels:
+ *
+ * - Short Message channels. Used to transfer 32-bits
+ *   messages from MCU to DSP and vice versa
+ *
+ * - Packet Data channels. Useful to transfer data between
+ *   the two cores.
+ *
+ * - Logging channel. This type of channel is read-only from
+ *   the MCU. It is used to report log events to the MCU.
+ *
+ */
+typedef enum {
+	HW_CTRL_IPC_PACKET_DATA = 0,
+	HW_CTRL_IPC_CHANNEL_LOG,
+	HW_CTRL_IPC_SHORT_MSG
+} HW_CTRL_IPC_CHANNEL_TYPE_T;
+
+/*!
+ * This enum defines the write modes IPC can support.
+ *
+ * - Contigous mode: All data is stored in a contigous
+ *   memory zone.
+ *
+ * - LinkedList mode: Data can be presented in chunks of
+ *   non-contiguous memory. Up to 11 chunks can be processed
+ *   by this mode.
+ *
+ *  Note that only Packet Data channels can support LinkedList mode.
+ */
+typedef enum {
+	HW_CTRL_IPC_MODE_CONTIGUOUS = 0,
+	HW_CTRL_IPC_MODE_LINKED_LIST
+} HW_CTRL_IPC_MODE_T;
+
+typedef struct {
+} HW_CTRL_IPC_INIT_T;
+
+typedef struct {
+	/*!
+	 * the channel from which data was read
+	 */
+	int channel_nb;
+} HW_CTRL_IPC_CHANNEL_T;
+
+/*!
+ * A structure of this type is passed as parameter when a read
+ * callback is invoked. This normally happens when a read transfer has been
+ * completed.
+ */
+typedef struct {
+	/*!
+	 * the channel handler from which data was read
+	 */
+	HW_CTRL_IPC_CHANNEL_T *channel;
+
+	/*!
+	 * number of bytes read.
+	 */
+	int nb_bytes;
+} HW_CTRL_IPC_READ_STATUS_T;
+
+/*!
+ * A structure of this type is passed as parameter when a write
+ * callback is invoked. This normally happens when a write transfer has been
+ * completed.
+ */
+#define HW_CTRL_IPC_WRITE_STATUS_T     HW_CTRL_IPC_READ_STATUS_T
+
+/*!
+ * A structure of this type is passed as parameter when a notify
+ * callback is invoked. This happens only when a transfer has been
+ * abnormally terminated.
+ */
+typedef struct {
+	/*!
+	 * the channel handler from which data was read
+	 */
+	HW_CTRL_IPC_CHANNEL_T *channel;
+
+	/*!
+	 * status code
+	 */
+	HW_CTRL_IPC_STATUS_T status;
+} HW_CTRL_IPC_NOTIFY_STATUS_T;
+
+/*
+ * This struct defines parameters needed to
+ * execute a write using the linked list mode
+ */
+typedef struct HW_CTRL_IPC_LINKED_LIST_T {
+	/*!
+	 * pointer to data to be transfered
+	 */
+	unsigned char *data_ptr;
+
+	/*!
+	 * Lenght of data
+	 */
+	unsigned int length;
+
+	/*!
+	 * Pointer to the next chunk of memory containing data
+	 * to be transferred
+	 */
+	struct HW_CTRL_IPC_LINKED_LIST_T *next;
+} HW_CTRL_IPC_LINKED_LIST_T;
+
+/*
+ * This struct defines parameters needed to
+ * execute a write using the normal mode
+ */
+typedef struct {
+	/*!
+	 * pointer to data to be transfered
+	 */
+	unsigned char *data_ptr;
+
+	/*!
+	 * Lenght of data
+	 */
+	unsigned int length;
+} HW_CTRL_IPC_CONTIGUOUS_T;
+
+/*
+ * This structure is used by the write_ex function
+ * which is in charge of execute the LinkedList mode
+ * transfer.
+ */
+typedef struct {
+	/*!
+	 * Type of transfer to execute
+	 */
+	HW_CTRL_IPC_MODE_T ipc_memory_read_mode;
+
+	/*!
+	 * Pointer to a buffer holding all data to
+	 * transfer orpointer to a buffer holding
+	 * first chunk of data to transfer
+	 */
+	union {
+		HW_CTRL_IPC_CONTIGUOUS_T *cont_ptr;
+		HW_CTRL_IPC_LINKED_LIST_T *list_ptr;
+	} read;
+} HW_CTRL_IPC_WRITE_PARAMS_T;
+
+/*
+ * Structure used to pass configuration parameters needed
+ * to open an IPC channel.
+ */
+typedef struct {
+	/*!
+	 * type of IPC channel to open
+	 */
+	HW_CTRL_IPC_CHANNEL_TYPE_T type;
+
+	/*!
+	 * index defining the physical channel
+	 * that will be used for this IPC channel
+	 */
+	int index;
+
+	/*!
+	 * read callback provided by the user, called when a read
+	 * transfer has been finished
+	 */
+	void (*read_callback) (HW_CTRL_IPC_READ_STATUS_T * status);
+
+	/*!
+	 * write callback provided by the user, called when a write
+	 * transfer has been finished
+	 */
+	void (*write_callback) (HW_CTRL_IPC_WRITE_STATUS_T * status);
+
+	/*!
+	 * notify callback provided by the user, called when an error
+	 * occurs during a transfer.
+	 */
+	void (*notify_callback) (HW_CTRL_IPC_NOTIFY_STATUS_T * status);
+} HW_CTRL_IPC_OPEN_T;
+
+/*!@param *data_control_struct_ipcv2 
+ *   Data Node Descriptor (Buffer Descriptor):
+ *------------------------------------------------------------------------------
+ *| 31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	 	  0|
+ *------------------------------------------------------------------------------
+ *| L	E	D	R	R	R	R	R	|<---- Reserved          ---->  |<- Length-> |
+ *------------------------------------------------------------------------------
+ *| <---------------------------- Data Ptr ----------------------------------->|
+ *------------------------------------------------------------------------------
+ *
+ * L bit (LAST): If set, means that this buffer of data is the last buffer of the frame
+ * E bit (END): If set, we reached the end of the buffers passed to the function
+ * D bit (DONE): Only valid on the read callback. When set, means that the buffer has been 
+ * filled by the SDMA.
+ * Length: Length of data pointed by this node in bytes
+ * Data Ptr: Pointer to the data pointed to by this node.
+ */
+typedef struct ipc_dataNodeDescriptor {
+	unsigned short length;
+	unsigned short comand;
+	void *data_ptr;
+} HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T;
+
+/*!
+ * This function is called when kernel is loading the module.
+ * It initializes all low-level resources needed by the POSIX
+ * layer in order to make SDMA/MU transfers.
+ *
+ * @param init_params	Pointer to a struct containing global
+ * 			initialization parameters.
+ *
+ * @return		returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *			otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_init(const HW_CTRL_IPC_INIT_T * init_params);
+
+/*!
+ * Opens an IPC link. This functions can be called directly by kernel
+ * modules. POSIX implementation of the IPC Driver also calls it.
+ *
+ * @param config	Pointer to a struct containing configuration para
+ * 			meters for the channel to open (type of channel,
+ *			callbacks, etc)
+ *
+ * @return		returns a virtual channel handler on success, a NULL pointer otherwise.
+ */
+HW_CTRL_IPC_CHANNEL_T *hw_ctrl_ipc_open(const HW_CTRL_IPC_OPEN_T * config);
+
+/*!
+ * Close an IPC link. This functions can be called directly by kernel
+ * modules. POSIX implementation of the IPC Driver also calls it.
+ *
+ * @param channel	handler to the virtual channel to close.
+ *
+ * @return		returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *			otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_close(HW_CTRL_IPC_CHANNEL_T * channel);
+
+/*!
+ * Reads data from an IPC link. This functions can be called directly by kernel
+ * modules. POSIX implementation of the IPC Driver also calls it.
+ *
+ * @param channel	virtual channel handler where read has been requested.
+ * @param buf		buffer to store data read from the channel.
+ * @param buffer_size	size of the buffer
+ *
+ * @return		returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *			otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_read(HW_CTRL_IPC_CHANNEL_T * channel,
+				      unsigned char *buf,
+				      unsigned short buffer_size);
+
+/*!
+ * Writes data to an IPC link. This functions can be called directly by kernel
+ * modules. POSIX implementation of the IPC Driver also calls it.
+ *
+ * @param channel	virtual handler to the channel where read has been requested.
+ * @param buf		buffer containing data t be written on the channel.
+ * @param buffer_size	size of the buffer
+ *
+ * @return		returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *			otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_write(HW_CTRL_IPC_CHANNEL_T * channel,
+				       unsigned char *buf,
+				       unsigned short nb_bytes);
+
+/*!
+ * Writes data to an IPC link. This function can be called directly by kernel
+ * modules. It accepts a linked list or contiguous data.
+ *
+ * @param channel       handler to the virtual channel where read has
+ *                      been requested.
+ * @param mem_ptr       of type HW_CTRL_IPC_WRITE_PARAMS_T.
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_write_ex(HW_CTRL_IPC_CHANNEL_T * channel,
+					  HW_CTRL_IPC_WRITE_PARAMS_T * mem_ptr);
+
+/*!
+ * Used to set various channel parameters
+ *
+ * @param channel handler to the virtual channel where read has
+ *                been requested.
+ * @param action  IPC driver control action to perform.
+ * @param param   parameters required to complete the requested action
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_ioctl(HW_CTRL_IPC_CHANNEL_T * channel,
+				       HW_CTRL_IPC_IOCTL_ACTION_T action,
+				       void *param);
+/*!
+ * This function is a variant on the write() function, and is used to send a
+ * group of frames made of various pieces each to the IPC driver.
+ * It is mandatory to allow high throughput on IPC while minimizing the time
+ * spent in the drivers / interrupts.
+ *
+ * @param channel       handler to the virtual channel where read has
+ *                      been requested.
+ * @param ctrl_ptr      Pointer on the control structure.
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_write_ex2(HW_CTRL_IPC_CHANNEL_T * channel,
+					   HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *
+					   ctrl_ptr);
+
+/*!
+ * This function is used to give a set of buffers to the IPC and enable data
+ * transfers.
+ *
+ * @param channel       handler to the virtual channel where read has
+ *                      been requested.
+ * @param ctrl_ptr      Pointer on the control structure.
+ *
+ * @return              returns HW_CTRL_IPC_STATUS_OK on success, an error code
+ *                      otherwise.
+ */
+HW_CTRL_IPC_STATUS_T hw_ctrl_ipc_read_ex2(HW_CTRL_IPC_CHANNEL_T * channel,
+					  HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *
+					  ctrl_ptr);
+
+void hw_ctrl_ipc_register(void * param);
+
+#endif				//__IPC_API_H__
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 7fa3718..7cac232 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -16,6 +16,9 @@
 #include <linux/log2.h>
 #include <linux/typecheck.h>
 #include <linux/ratelimit.h>
+#ifdef CONFIG_DEBUG_MEMLEAK
+#include <linux/memleak.h>
+#endif
 #include <linux/dynamic_printk.h>
 #include <asm/byteorder.h>
 #include <asm/bug.h>
@@ -490,9 +493,20 @@ static inline char *pack_hex_byte(char *buf, u8 byte)
  * @member:	the name of the member within the struct.
  *
  */
+#ifdef CONFIG_DEBUG_MEMLEAK
+#define __container_of(ptr, type, member) ({			\
+	const typeof(((type *)0)->member) *__mptr = (ptr);	\
+	(type *)((char *)__mptr - offsetof(type, member)); })
+
+#define container_of(ptr, type, member) ({                    \
+		DECLARE_MEMLEAK_OFFSET(container_of, type, member);     \
+		__container_of(ptr, type, member);                      \
+})
+#else
 #define container_of(ptr, type, member) ({			\
 	const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
 	(type *)( (char *)__mptr - offsetof(type,member) );})
+#endif
 
 struct sysinfo;
 extern int do_sysinfo(struct sysinfo *info);
diff --git a/include/linux/led-lm3530.h b/include/linux/led-lm3530.h
index 5f30b26..f8069e3 100755
--- a/include/linux/led-lm3530.h
+++ b/include/linux/led-lm3530.h
@@ -58,6 +58,11 @@
 #define LM3530_MANUAL_VALUE		0x64
 #define LM3530_SENSOR_ENABLE	0x08
 
+#define LM3530_MANUAL_RAMP_RATE_VALUE	0x1B
+
+#define LM3530_ALS_ZONE_MAX     0x4
+#define LM3530_ALS_ZONE_MIN     0x0
+
 #ifdef __KERNEL__
 struct lm3530_platform_data {
 	u8  power_up_gen_config;
diff --git a/include/linux/leds-bd7885.h b/include/linux/leds-bd7885.h
new file mode 100644
index 0000000..c463552
--- /dev/null
+++ b/include/linux/leds-bd7885.h
@@ -0,0 +1,122 @@
+/*
+ * include/leds-bd7885.h
+ *
+ * Configuration for BD7885 Flash driver
+ */
+
+#ifndef __LEDS_BD7885_H
+#define __LEDS_BD7885_H
+
+#include <linux/ioctl.h>
+
+/*This definition for Xenon flash driver.*/
+
+#define E_OK 0
+
+/* BD7885 indicator */
+#define BD7885_DRIVER_NAME 	     "bd7885"
+#define BD7885_DEVICE_NAME       "bd7885"
+
+#define BD7885_SLAVE_ADDR   (0x51)
+
+#define F_RDY_N_GPIO             36
+#define MAX_RETRY_CNT          (10)
+#define BD7885_REG_ADDR_LEN    (1)    /* 1 BYTE */
+#define BD7885_REG_DATA_LEN    (1)    /* 1 BYTE */
+#define BD7885_REG_ADDR_DATA_LEN    (2)    /* 2 BYTE */
+
+#define BD7885_MAX_RW_SIZE      (1)    /* 1 BYTE */
+
+#define BD7885_REG_ADDR_POS 0   /*Address position is first of array.*/
+#define BD7885_REG_DATA_POS 1   /*Data position is second of array.*/
+/* BD7885 control register map */
+
+/* BD7885 POWER STATUS */
+#define BD7885_INIT_STATUS	0
+#define BD7885_CHARGE_ENABLE_STATUS	1
+#define BD7885_CHARGE_DISABLE_STATUS 	2
+
+#define BD7885_REG_TERM 0xFF
+#define BD7885_VAL_TERM 0xFF
+
+#define BD7885_HW_ID_REG		0x00
+#define BD7885_HW_ID_VAL		0x01
+
+#define BD7885_DRVCNT_REG         0x01
+#define BD7885_PCNT_EN_MASK 0x1
+#define BD7885_CHG_EN_MASK 0x2
+
+#define BD7885_RECHG_REG           0x02
+#define BD7885_RECHG_EN_MASK 0x10
+
+#define BD7885_IPEAKADJ_REG      0x03
+
+#define BD7885_FULLADJ_REG        0x04
+#define BD7885_FULL_ADJ_LVL_MASK 0x0F
+
+#define BD7885_QUENCHCNT_REG   0x05
+
+#define BD7885_CAPDIS_EN_MASK  0x2
+#define BD7885_QUENCH_EN_MASK 0x1
+
+#define BD7885_QUENCH_ENABLE    0x1
+#define BD7885_QUENCH_DISABLE   0x0
+
+#define BD7885_DELAYADJ_REG      0x06
+
+#define BD7885_QUENCHADJ_REG   0x07
+#define BD7885_VSTOPADJ_SHIFT 0x3
+
+#define BD7885_STATUS_REG          0x08
+#define BD7885_STATUS_FULL_CHG_MASK 0x1
+#define BD7885_STATUS_QMON_MASK 0x2
+
+#define    BD7885_STROBE_OFF         0
+#define    BD7885_STROBE_QUENCH_MODE 1
+#define    BD7885_STROBE_MANUAL_MODE 2
+
+
+typedef enum {
+    BD7885_CHARGE_DISABLE = 0,
+    BD7885_CHARGE_ENABLE,
+} bd7885_charge_mode;
+
+typedef struct {
+	unsigned char reg;
+	unsigned char	   data;
+} bd7885_cfg;
+
+/* ****************************************************************************
+ *   Command ID
+ * ************************************************************************** */
+
+#define BD7885_IOCTL_BASE 42
+/** \def BD7885_IOCTL_*
+ *  \brief The following define the IOCTL command values via the ioctl macros
+ */
+/*Below direct register control is for exceptional case for HAL.*/
+#define BD7885_IOCTL_GET_REGISTER  _IOR(BD7885_IOCTL_BASE, 0, bd7885_cfg)
+		/*Register value read out from Xenon flash module.*/
+#define BD7885_IOCTL_SET_REGISTER  _IOW(BD7885_IOCTL_BASE, 1, bd7885_cfg)
+		/*Register value write down to Xenon flash module.*/
+#define BD7885_IOCTL_SET_CHARGING  _IOW(BD7885_IOCTL_BASE, 2, unsigned char)
+		/*Set charging status.*/
+
+#define BD7885_IOCTL_SET_CHARGE_LEVEL _IOW(BD7885_IOCTL_BASE, 3, unsigned char)
+		/*Set FULLADJ value for charging.*/
+#define BD7885_IOCTL_SET_MODE  _IOW(BD7885_IOCTL_BASE, 4, unsigned char)
+		/* 0=Off, 1= Quench mode, 2=Manual Mode */
+#define BD7885_IOCTL_SET_QUENCH_THRESHOLD \
+			_IOW(BD7885_IOCTL_BASE, 5, unsigned char)
+		/*Sets VSTOPADJ parameter.*/
+#define BD7885_IOCTL_GET_STATUS _IOR(BD7885_IOCTL_BASE, 6, unsigned char)
+		/*Charged status get.*/
+
+#define BD7885_IOCTL_READY_STROBE_MANUAL \
+			_IOW(BD7885_IOCTL_BASE, 7, unsigned char)
+		/* test ready strobe manually.*/
+#define BD7885_IOCTL_FIRE_STROBE_MANUAL \
+		_IOW(BD7885_IOCTL_BASE, 8, unsigned char)
+		/* test fire strobe manually.*/
+
+#endif /* __LEDS_BD7885_H */
diff --git a/include/linux/leds-bu9847.h b/include/linux/leds-bu9847.h
new file mode 100644
index 0000000..1aef720
--- /dev/null
+++ b/include/linux/leds-bu9847.h
@@ -0,0 +1,67 @@
+/*
+ * include/leds-bu9847.h
+ *
+ * Configuration for BU9847 Flash driver
+ */
+
+#ifndef __LEDS_BU9847_H
+#define __LEDS_BU9847_H
+
+#include <linux/ioctl.h>
+
+/*This definition for Xenon flash driver.*/
+
+#define E_OK 0
+
+/* BU9847 indicator */
+#define BU9847_DRIVER_NAME 	     "bu9847"
+#define BU9847_DEVICE_NAME            "bu9847"
+
+/*#define BU9847_SLAVE_ADDR   (0x50)*/ /*For P1 unit.*/
+#define BU9847_SLAVE_ADDR   (0x54) /*For P2 unit.*/
+
+#define MAX_RETRY_CNT          (10)
+#define BU9847_REG_ADDR_LEN    (1)    /* 1 BYTE */
+#define BU9847_REG_DATA_LEN    (1)    /* 1 BYTE */
+#define BU9847_REG_ADDR_DATA_LEN    (2)    /* 2 BYTE */
+
+#define BU9847_MAX_RW_SIZE      (1)    /* 1 BYTE */
+
+#define BU9847_REG_ADDR_POS 0   /*Address position is first of array.*/
+#define BU9847_REG_DATA_POS 1   /*Data position is second of array.*/
+/* BU9847 control register map */
+
+#define BU9847_REG_TERM 0xFF
+#define BU9847_VAL_TERM 0xFF
+
+#define BU9847_HW_ID_REG	    0x00
+#define BU9847_PRID1_REG         0x01
+#define BU9847_PRID2_REG         0x02
+#define BU9847_PRID3_REG         0x03
+
+#define BU9847_QCHC1_REG         0x04
+#define BU9847_QCHC2_REG         0x05
+#define BU9847_QCHC3_REG         0x06
+#define BU9847_QCHC4_REG         0x07
+#define BU9847_QCHC5_REG         0x08
+#define BU9847_QCHC6_REG         0x09
+#define BU9847_QCHC7_REG         0x0A
+#define BU9847_QCHC8_REG         0x0B
+#define BU9847_QCHC9_REG         0x0C
+#define BU9847_QCHC10_REG         0x0D
+#define BU9847_QCHC11_REG         0x0E
+#define BU9847_QCHC12_REG         0x0F
+
+#define BU9847_VCHGC_REG           0x10
+#define BU9847_PRLDT_REG           0x11
+
+/* ****************************************************************************
+ *   Command ID
+ * ************************************************************************** */
+
+#define BU9847_IOCTL_BASE 42
+
+/*Below direct register control is for exceptional case for HAL.*/
+#define BU9847_IOCTL_INIT                  _IO(BU9847_IOCTL_BASE, 20) /*Basic init for BU9847 device.*/
+
+#endif /* __LEDS_BU9847_H */
diff --git a/include/linux/leds-ld-cpcap.h b/include/linux/leds-ld-cpcap.h
index f2a9c2e..20d4073 100755
--- a/include/linux/leds-ld-cpcap.h
+++ b/include/linux/leds-ld-cpcap.h
@@ -22,27 +22,34 @@
 #define LD_MSG_IND_DEV "notification-led"
 #define LD_DISP_BUTTON_DEV "button-backlight"
 #define LD_KPAD_DEV "keyboard-backlight"
+#define LD_AF_LED_DEV "af-led"
 #define LD_SUPPLY "sw5"
 
-#define LD_MSG_IND_ON			0x1
-#define LD_MSG_IND_CURRENT		0x2
+#define LD_MSG_IND_ON               0x1
+#define LD_MSG_IND_CURRENT          0x2
+#define LD_MSG_IND_LO_CURRENT       0x0
 
-#define LD_MSG_IND_CPCAP_MASK		0x3FF
+#define LD_MSG_IND_CPCAP_MASK       0x3FF
 
-#define LD_MSG_IND_LOW			0x20
-#define LD_MSG_IND_LOW_MED		0x20
-#define LD_MSG_IND_MEDIUM		0x30
-#define LD_MSG_IND_MED_HIGH		0x40
-#define LD_MSG_IND_HIGH			0x50
+#define LD_MSG_IND_LOW              0x10
+#define LD_MSG_IND_LOW_MED          0x20
+#define LD_MSG_IND_MEDIUM           0x30
+#define LD_MSG_IND_MED_HIGH         0x40
+#define LD_MSG_IND_HIGH             0x50
 
-#define LD_LED_RED		0x01
-#define LD_LED_GREEN	0x02
-#define LD_LED_BLUE		0x04
-  
+#define LD_LED_RED                  0x01
+#define LD_LED_GREEN                0x02
+#define LD_LED_BLUE                 0x04
 
-#define LD_DISP_BUTTON_ON		0x1
-#define LD_DISP_BUTTON_CURRENT		0xa
-#define LD_DISP_BUTTON_DUTY_CYCLE	0x2a0
+#define LD_DISP_BUTTON_ON           0x1
+#define LD_DISP_BUTTON_CURRENT      0xA
+#define LD_DISP_BUTTON_DUTY_CYCLE	0x2A0
 #define LD_DISP_BUTTON_CPCAP_MASK	0x3FF
 
+#define LD_BLED_CPCAP_DUTY_CYCLE    0xB8
+#define LD_BLED_CPCAP_MASK          0x3FF
+#define LD_BLED_CPCAP_CURRENT       0x0
+
+#define LD_ALT_ADBL_CURRENT         0x4
+
 #endif  /* __LED_LD_CPCAP_H__ */
diff --git a/include/linux/lttlite-events.h b/include/linux/lttlite-events.h
new file mode 100644
index 0000000..efae06d
--- /dev/null
+++ b/include/linux/lttlite-events.h
@@ -0,0 +1,175 @@
+/*
+ * linux/include/linux/lttlite-events.h
+ *
+ * Copyright (C) 1999-2004 Karim Yaghmour (karim@opersys.com)
+ * Copyright (C) 2004, 2005 - MontaVista Software, Inc. (source@mvista.com)
+ *
+ * This contains the event definitions for the Linux Trace Toolkit.
+ *
+ * This file is released  under the terms of the GNU GPL version 2.
+ * This program  is licensed "as is" without any warranty of any kind,
+ * whether express or implied.
+ *
+ */
+
+#ifndef _LINUX_TRACE_H
+#define _LINUX_TRACE_H
+#ifdef __KERNEL__
+
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/ioctl.h>
+
+#define LTT_LITE_VERSION "LTT-LITE 1.0.1"
+#define LTT_EV_FILE_SYSTEM_IOCTL __NR_ioctl
+#define LTT_EV_SOFT_IRQ_SOFT_IRQ LTT_LITE_EV_SOFT_IRQ
+#define LTT_EV_SOFT_IRQ_TASKLET_ACTION LTT_LITE_EV_TASKLET
+#define LTT_EV_SOFT_IRQ_TASKLET_HI_ACTION LTT_LITE_EV_TASKLET_HI
+#define LTT_LITE_MAX_LOG_STRING_SIZE 50
+#define LTT_LITE_TASK_COMM_LEN 32
+#define LTT_LITE_LOG_STRING(var) ltt_lite_log_string(var, sizeof(var) - 1)
+/* Performance tracking commands*/
+#define LL_CMD 'l'
+#define LLEVENT     _IOW(LL_CMD, 0x01, unsigned int)
+#define LLINFO      _IOW(LL_CMD, 0x02, char *)
+#define ltt_ev(ID, DATA)
+#define ltt_ev_process(ID, DATA1, DATA2)
+#define ltt_ev_trap_entry(DATA1, DATA2)	ltt_lite_ev_trap_entry(DATA1, DATA2)
+#define ltt_ev_trap_exit() ltt_lite_ev_trap_exit()
+#define ltt_ev_irq_entry(ID, KERNEL) ltt_lite_int_entry((unsigned short)ID, \
+				KERNEL)
+#define ltt_ev_irq_exit() ltt_lite_int_exit((unsigned short)irq)
+#define ltt_ev_schedchange(DATA) ltt_lite_ev_schedchange(DATA)
+#define ltt_ev_soft_irq(ID, DATA) ltt_lite_log_softirq(ID, \
+				LTT_LITE_EVENT_ENTER, DATA)
+#define ltt_init_sched_event(DATA, OUT, IN) ltt_lite_init_sched_event(DATA, \
+				OUT, IN)
+#define ltt_ev_process_exit(DATA1, DATA2) ltt_lite_ev_process_exit()
+#define ltt_lite_ev_process(DATA1, DATA2) ltt_lite_ev_log_process(DATA1, DATA2)
+
+#define CONFIG_LTT_LITE_ANDROID_LOG
+
+extern struct resource ltt_lite_res;
+
+enum {
+	TRAP_T_RETURN = -1,
+	TRAP_T_PAGE_FAULT = 14,
+	TRAP_T_BAD_DATA_ABOUT = 18,
+};
+
+enum {
+	LTT_LITE_RUN_TIMER,
+	LTT_LITE_RUN_HRT_EXP,
+	LTT_LITE_RUN_HRT_PED,
+};
+
+/* process event enum */
+enum {
+	LTT_LITE_EV_PROCESS_TABLE,
+	LTT_LITE_EV_PROCESS_FORK,
+	LTT_LITE_EV_PROCESS_EXEC,
+	LTT_LITE_EV_PROCESS_EXIT,
+	LTT_LITE_EV_PROCESS_COMM_CHANGE,
+};
+
+/*
+ * LTTLITE event enum, start from 1 is to keep consistent with deinition of
+ * APLV.
+ */
+enum {
+	LTT_LITE_EV_SYSCALL_ENTRY = 1,
+	LTT_LITE_EV_SCHEDULE,
+	LTT_LITE_EV_MEM_PROFILE,
+	LTT_LITE_EV_PROCESS,
+	LTT_LITE_EV_TRAP,
+	LTT_LITE_EV_INT,
+	LTT_LITE_EV_SOFT_IRQ,
+	LTT_LITE_EV_TASKLET,
+	LTT_LITE_EV_TASKLET_HI,
+	LTT_LITE_EV_STRING,
+	LTT_LITE_EV_SIG,
+	LTT_LITE_EV_SIG_HANDLE,
+	LTT_LITE_EV_TIMER,
+	LTT_LITE_EV_TIMER_RUN,
+	/* keep LTT_LITE_EV_REPORT as the last event type */
+	LTT_LITE_EV_REPORT,
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	LTT_LITE_EV_ANDROID_LOG,      /* /dev/log/main  */
+	LTT_LITE_EV_ANDROID_EVENTLOG, /* /dev/log/event */
+	LTT_LITE_EV_ANDROID_RADIO,    /* /dev/log/radio */
+	LTT_LITE_EV_PRINTK,
+#endif
+	/* the item below is used as array length */
+	LTT_LITE_EV_LAST,
+};
+
+/* log event in/out enum */
+enum {
+	/* sign used to indicate return of a log event */
+	LTT_LITE_EVENT_RETURN,
+	/* sign used to indicate enter of a log event */
+	LTT_LITE_EVENT_ENTER,
+};
+
+/*
+ * log_ps_buffer size *MUST NOT* exceed
+ * LTTLITE_RSVBUF_SZ definded in task.h
+ */
+struct log_ps_buffer{
+	/* number of syscalls this task made */
+	unsigned long syscalls;
+	/* number of file group syscalls this task made*/
+	unsigned long file_syscalls;
+	/* Number of context switches of this task */
+	unsigned long ctxt;
+};
+
+struct ltt_lite_schedchange {
+	unsigned short opid;   /* switch-out pid */
+	unsigned short out_state; /* process state */
+	unsigned short oprio; /* priority of process*/
+	unsigned short reserve;
+	/* following elements are data about switch in process */
+	unsigned short ipid;   /* switch-in pid */
+	unsigned short iprio; /* priority of process */
+};
+
+static inline void ltt_lite_init_sched_event(
+				struct ltt_lite_schedchange *sched_event,
+				struct task_struct *task_out,
+				struct task_struct *task_in)
+{
+	sched_event->opid = (u32)task_out->pid;
+	sched_event->ipid  = (u32)task_in->pid;
+	sched_event->oprio = task_out->prio;
+	sched_event->iprio = task_in->prio;
+	sched_event->out_state = task_out->state;
+}
+
+void ltt_lite_int_entry(unsigned short, char);
+void ltt_lite_int_exit(unsigned short);
+void ltt_lite_log_softirq(unsigned short, unsigned int, unsigned int);
+void ltt_lite_ev_sig(unsigned short, unsigned short, unsigned short);
+void ltt_lite_ev_handle_sig(unsigned short, unsigned short, unsigned long);
+void ltt_lite_log_timer(struct timer_list *, unsigned short);
+void ltt_lite_run_timer(unsigned short, unsigned long, unsigned long);
+void ltt_lite_early_init(void);
+void ltt_lite_ev_process_exit(void);
+void ltt_lite_ev_log_process(int type, struct task_struct *p);
+void ltt_lite_log_syscall(char sign, int scno);
+void ltt_lite_ev_trap_entry(unsigned short trapid, unsigned long address);
+void ltt_lite_ev_trap_exit(void);
+void ltt_lite_ev_schedchange(struct ltt_lite_schedchange *);
+void ltt_lite_printf(char *fmt, ...);
+void ltt_lite_syscall_param(int scno, char *string, int size);
+int ltt_lite_get_ms_time(struct timeval *ktv);
+int ltt_lite_log_string(char *string, int size);
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+int  ltt_lite_log_android(const struct iovec *iov,
+						unsigned long nr_segs,
+						char logchar);
+void ltt_lite_log_printk(char *string, int size);
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* _LINUX_TRACE_H */
diff --git a/include/linux/memleak.h b/include/linux/memleak.h
new file mode 100644
index 0000000..661d16d
--- /dev/null
+++ b/include/linux/memleak.h
@@ -0,0 +1,118 @@
+/*
+ * include/linux/memleak.h
+ *
+ * Copyright (C) 2006 ARM Limited
+ * Written by Catalin Marinas <catalin.marinas@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __MEMLEAK_H
+#define __MEMLEAK_H
+
+#include <linux/stddef.h>
+
+struct memleak_offset {
+	unsigned long type_id;
+	unsigned long member_type_id;
+	unsigned long offset;
+};
+
+/* type id approximation */
+#define ml_guess_typeid(size)	((unsigned long)(size))
+#define ml_typeid(type)		ml_guess_typeid(sizeof(type))
+#define ml_sizeof(typeid)	((size_t)(typeid))
+
+#ifdef CONFIG_DEBUG_MEMLEAK
+
+/* if offsetof(type, member) is not a constant known at compile time,
+ * just use 0 instead since we cannot add it to the
+ * .init.memleak_offsets section
+ */
+#define memleak_offsetof(type, member)				\
+	(__builtin_constant_p(offsetof(type, member)) ?		\
+	 offsetof(type, member) : 0)
+
+#define DECLARE_MEMLEAK_OFFSET(name, type, member)		\
+	static const struct memleak_offset			\
+	__attribute__ ((__section__(".init.memleak_offsets")))	\
+	__used __memleak_offset__##name = {		\
+		ml_typeid(type),				\
+		ml_typeid(typeof(((type *)0)->member)),		\
+		memleak_offsetof(type, member)			\
+	}
+
+extern int kmemleak_module;
+extern struct memleak_offset __memleak_offsets_start[];
+extern struct memleak_offset __memleak_offsets_end[];
+
+extern void memleak_init(void);
+extern void memleak_alloc(const void *ptr, size_t size, int ref_count);
+extern void memleak_free(const void *ptr);
+extern void memleak_padding(const void *ptr, unsigned long offset, size_t size);
+extern void memleak_not_leak(const void *ptr);
+extern void memleak_ignore(const void *ptr);
+extern void memleak_scan_area(const void *ptr, unsigned long offset,
+				size_t length);
+extern void memleak_insert_aliases(struct memleak_offset *ml_off_start,
+				   struct memleak_offset *ml_off_end);
+
+static inline void memleak_erase(void **ptr)
+{
+	*ptr = NULL;
+}
+
+#define memleak_container(type, member)	{			\
+	DECLARE_MEMLEAK_OFFSET(container_of, type, member);	\
+}
+
+extern void memleak_typeid_raw(const void *ptr, unsigned long type_id);
+#define memleak_typeid(ptr, type) \
+	memleak_typeid_raw(ptr, ml_typeid(type))
+
+#else
+
+#define DECLARE_MEMLEAK_OFFSET(name, type, member)
+
+static inline void memleak_init(void)
+{ }
+static inline void memleak_alloc(const void *ptr, size_t size, int ref_count)
+{ }
+static inline void memleak_free(const void *ptr)
+{ }
+static inline void memleak_padding(const void *ptr, unsigned long offset,
+					size_t size)
+{ }
+static inline void memleak_not_leak(const void *ptr)
+{ }
+static inline void memleak_ignore(const void *ptr)
+{ }
+static inline void memleak_scan_area(const void *ptr, unsigned long offset,
+					 size_t length)
+{ }
+static inline void memleak_insert_aliases(struct memleak_offset *ml_off_start,
+					  struct memleak_offset *ml_off_end)
+{ }
+static inline void memleak_erase(void **ptr)
+{ }
+
+#define memleak_container(type, member)
+
+static inline void memleak_typeid_raw(const void *ptr, unsigned long type_id)
+{ }
+#define memleak_typeid(ptr, type)
+
+#endif	/* CONFIG_DEBUG_MEMLEAK */
+
+#endif	/* __MEMLEAK_H */
diff --git a/include/linux/mipi_dli.h b/include/linux/mipi_dli.h
new file mode 100644
index 0000000..f20eca7
--- /dev/null
+++ b/include/linux/mipi_dli.h
@@ -0,0 +1,18 @@
+#ifndef __MIPI_DLI_H
+#define __MIPI_DLI_H
+
+#include <linux/ioctl.h>
+
+#define MIPI_DLI_DRIVER_NAME 	     "mipi_dli_tester"
+#define MIPI_DLI_DEVICE_NAME 	     "mipi_dli_tester"
+
+#define MIPI_DLI_IOCTL_BASE 88
+
+/* MIPI DLI Frame count.*/
+#define MIPI_DLI_IOCTL_FRAME_COUNT  _IOWR(MIPI_DLI_IOCTL_BASE, 0, unsigned long)
+/* MIPI DLI ECC count.*/
+#define MIPI_DLI_IOCTL_ECC_COUNT  _IOWR(MIPI_DLI_IOCTL_BASE, 1, unsigned long)
+/* MIPI DLI CRC count.*/
+#define MIPI_DLI_IOCTL_CRC_COUNT  _IOWR(MIPI_DLI_IOCTL_BASE, 2, unsigned long)
+
+#endif /*__MIPI_DLI_H*/
diff --git a/include/linux/module.h b/include/linux/module.h
index 145a755..244c8c6 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -345,6 +345,11 @@ struct module
 	local_t ref;
 #endif
 #endif
+
+#ifdef CONFIG_GCOV_PROFILE
+	const char *ctors_start;        /* Pointer to start of .ctors-section */
+	const char *ctors_end;          /* Pointer to end of .ctors-section */
+#endif
 };
 #ifndef MODULE_ARCH_INIT
 #define MODULE_ARCH_INIT {}
diff --git a/include/linux/panel-suppliers.h b/include/linux/panel-suppliers.h
new file mode 100755
index 0000000..2c8012c
--- /dev/null
+++ b/include/linux/panel-suppliers.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2010 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ */
+
+#ifndef _LINUX_PANEL_SUPPLIERS_H__
+#define _LINUX_PANEL_SUPPLIERS_H__
+
+#define SUPPLIER_ID_AUO		0x0186
+#define SUPPLIER_ID_TMD		0x0126
+#define SUPPLIER_ID_INVALID	0xFFFF
+
+#endif /* _LINUX_PANEL_SUPPLIERS_H__ */
diff --git a/include/linux/qtouch_obp_ts.h b/include/linux/qtouch_obp_ts.h
index 1091b89..5a3e7e7 100644
--- a/include/linux/qtouch_obp_ts.h
+++ b/include/linux/qtouch_obp_ts.h
@@ -43,12 +43,23 @@ enum {
 	QTM_OBJ_TOUCH_KEYARRAY		= 15,
 	QTM_OBJ_PROCG_SIG_FILTER	= 16,
 	QTM_OBJ_PROCI_LINEAR_TBL	= 17,
-	QTM_OBJ_PROCI_GESTURES_PROC	= 18,
+	QTM_OBJ_SPT_COM_CONFIG		= 18,
+	QTM_OBJ_SPT_GPIO_PWM		= 19,
 	QTM_OBJ_PROCI_GRIPFACESUPPRESSION = 20,
-	QTM_OBJ_NOISESUPPRESSION_1 = 36,
+	QTM_OBJ_RESERVED3		= 21,
+	QTM_OBJ_PROCG_NOISE_SUPPRESSION	= 22,
+	QTM_OBJ_TOUCH_PROXIMITY		= 23,
+	QTM_OBJ_PROCI_ONE_TOUCH_GESTURE_PROC = 24,
+	QTM_OBJ_SPT_SELF_TEST		= 25,
+	QTM_OBJ_DEBUG_CTE_RANGE		= 26,
+	QTM_OBJ_PROCI_TWO_TOUCH_GESTURE_PROC = 27,
+	QTM_OBJ_SPT_CTE_CONFIG		= 28,
+	QTM_OBJ_NOISESUPPRESSION_1  = 36,
+	QTM_OBJ_DEBUG_DIAGNOSTIC         = 37,
+	QTM_OBJ_CPT_USERDATA             = 38,
 
 	/* Max number of objects currently defined */
-	QTM_OBP_MAX_OBJECT_NUM = QTM_OBJ_NOISESUPPRESSION_1 + 1,
+	QTM_OBP_MAX_OBJECT_NUM = QTM_OBJ_CPT_USERDATA + 1,
 };
 
 /* OBP structures as defined by the wire protocol. */
@@ -155,11 +166,13 @@ struct qtm_gen_power_cfg {
 /* GEN_ACQUIRECONFIG_T8 */
 struct qtm_gen_acquire_cfg {
 	uint8_t			charge_time;       /* in 250ns */
-	uint8_t			atouch_drift;      /* in 200ms */
+	uint8_t			reserve0;          /* Reserved */
 	uint8_t			touch_drift;       /* in 200ms */
 	uint8_t			drift_susp;        /* in 200ms */
 	uint8_t			touch_autocal;     /* in 200ms */
 	uint8_t			sync;
+	uint8_t			anti_cal_susp;
+	uint8_t			anti_cal_sthr;
 } __attribute__ ((packed));
 
 /* TOUCH_MULTITOUCHSCREEN_T9 */
@@ -173,22 +186,25 @@ struct qtm_touch_multi_cfg {
 	uint8_t			burst_len;
 	uint8_t			tch_det_thr;
 	uint8_t			tch_det_int;
-	uint8_t			rsvd1;
-	uint8_t			rsvd2;
+	uint8_t			orient;
+	uint8_t			mrg_to;
 	uint8_t			mov_hyst_init;
 	uint8_t			mov_hyst_next;
 	uint8_t			mov_filter;
 	uint8_t			num_touch;
 	uint8_t			merge_hyst;
 	uint8_t			merge_thresh;
-	uint8_t         amp_hyst;
+	uint8_t			amp_hyst;
 	uint16_t		x_res;
 	uint16_t		y_res;
 	uint8_t			x_low_clip;
 	uint8_t			x_high_clip;
 	uint8_t			y_low_clip;
 	uint8_t			y_high_clip;
-
+	uint8_t			x_edge_ori;
+	uint8_t			x_edge_cdist;
+	uint8_t			y_edge_ori;;
+	uint8_t			y_edge_cdist;
 } __attribute__ ((packed));
 
 /* TOUCH_KEYARRAY_T15 */
@@ -222,6 +238,32 @@ struct qtm_proci_linear_tbl_cfg {
 	uint8_t			y_segment[16];
 } __attribute__ ((packed));
 
+/* SPT_COM_CONFIG_T18 */
+struct qtm_spt_com_cfg {
+	uint8_t			ctrl;
+	uint8_t			cmd;
+} __attribute__ ((packed));
+
+/* SPT_GPIOPWM_T19*/
+struct qtm_spt_gpio_pwm_cfg {
+	uint8_t			ctrl;
+	uint8_t			report_mask;
+	uint8_t			pin_direction;
+	uint8_t			internal_pullup;
+	uint8_t			output_value;
+	uint8_t			wake_on_change;
+	uint8_t			pwm_enable;
+	uint8_t			pwm_period;
+	uint8_t			duty_cycle_0;
+	uint8_t			duty_cycle_1;
+	uint8_t			duty_cycle_2;
+	uint8_t			duty_cycle_3;
+	uint8_t			trigger_0;
+	uint8_t			trigger_1;
+	uint8_t			trigger_2;
+	uint8_t			trigger_3;
+} __attribute__ ((packed));
+
 /* PROCI_GRIPFACESUPPRESSION_T20 */
 struct qtm_proci_grip_suppression_cfg {
 	uint8_t			ctrl;
@@ -237,6 +279,72 @@ struct qtm_proci_grip_suppression_cfg {
 	uint8_t			shpthr2;
 } __attribute__ ((packed));
 
+/* PROCG_NOISESUPPRESSION_T22 */
+struct qtm_procg_noise_suppression_cfg {
+	uint8_t			ctrl;
+	uint16_t		reserve0;
+	uint16_t		gcaf_upper_limit;
+	uint16_t		gcaf_lower_limit;
+	uint8_t			gcaf_num_active;
+	uint8_t			noise_threshold;
+	uint8_t			reserve1;
+	uint8_t			freq_hop_scale;
+	uint8_t			burst_freq_0;
+	uint8_t			burst_freq_1;
+	uint8_t			burst_freq_2;
+	uint8_t			burst_freq_3;
+	uint8_t			burst_freq_4;
+	uint8_t			gcaf_num_idle;
+} __attribute__ ((packed));
+
+/* PROCI_ONETOUCHGESTUREPROCESSOR_T24 */
+struct qtm_proci_one_touch_gesture_proc_cfg {
+	uint8_t			ctrl;
+	uint8_t			reserve0;
+	uint16_t		gesture_enable;
+	uint8_t			pres_proc;
+	uint8_t			tap_time_out;
+	uint8_t			flick_time_out;
+	uint8_t			drag_time_out;
+	uint8_t			short_press_time_out;
+	uint8_t			long_press_time_out;
+	uint8_t			repeat_press_time_out;
+	uint16_t		flick_threshold;
+	uint16_t		drag_threshold;
+	uint16_t		tap_threshold;
+	uint16_t		throw_threshold;
+} __attribute__ ((packed));
+
+/* SPT_SELFTEST_T25 */
+struct qtm_spt_self_test_cfg {
+	uint8_t			ctrl;
+	uint8_t			command;
+	uint16_t		high_signal_limit_0;
+	uint16_t		low_signal_limit_0;
+	uint16_t		high_signal_limit_1;
+	uint16_t		low_signal_limit_1;
+} __attribute__ ((packed));
+
+/* PROCI_TWOTOUCHGESTUREPROCESSOR_T27 */
+struct qtm_proci_two_touch_gesture_proc_cfg {
+	uint8_t			ctrl;
+	uint8_t			reserved0;
+	uint8_t			reserved1;
+	uint8_t			gesture_enable;
+	uint8_t			rotate_threshold;
+	uint16_t		zoom_threshold;
+} __attribute__ ((packed));
+
+/* SPT_CTECONFIG_T28 */
+struct qtm_spt_cte_config_cfg {
+	uint8_t			ctrl;
+	uint8_t			command;
+	uint8_t			mode;
+	uint8_t			idle_gcaf_depth;
+	uint8_t			active_gcaf_depth;
+	uint8_t			voltage;
+} __attribute__ ((packed));
+
 /* QTM_OBJ_NOISESUPPRESSION_1 */
 struct qtm_proci_noise1_suppression_cfg {
 	uint8_t			ctrl;
@@ -245,14 +353,28 @@ struct qtm_proci_noise1_suppression_cfg {
 	uint8_t			duty_cycle;
 } __attribute__ ((packed));
 
+/* QTM_OBJ_CPT_USERDATA_T38 */
+struct qtm_spt_userdata {
+	uint8_t			data_0;
+	uint8_t			data_1;
+	uint8_t			data_2;
+	uint8_t			data_3;
+	uint8_t			data_4;
+	uint8_t			data_5;
+	uint8_t			data_6;
+	uint8_t			data_7;
+} __attribute__ ((packed));
+
 /*******************************/
 /******** platform data ********/
 /*******************************/
 
 struct vkey {
-	int	code;
-	int	min;
-	int	max;
+	int     code;
+	int     center_x;
+	int     center_y;
+	int     width;
+	int     height;
 };
 
 struct virt_keys {
@@ -293,8 +415,8 @@ struct qtouch_ts_platform_data {
 	uint32_t		abs_min_w;
 	uint32_t		abs_max_w;
 
-	uint32_t		x_delta;
-	uint32_t		y_delta;
+        uint32_t                x_delta;
+        uint32_t                y_delta;
 
 	uint16_t		nv_checksum;
 
@@ -317,8 +439,17 @@ struct qtouch_ts_platform_data {
 	struct qtm_touch_keyarray_cfg   key_array_cfg;
 	struct qtm_procg_sig_filter_cfg		sig_filter_cfg;
 	struct qtm_proci_linear_tbl_cfg		linear_tbl_cfg;
-	struct qtm_proci_grip_suppression_cfg	grip_suppression_cfg;
-	struct qtm_proci_noise1_suppression_cfg noise1_suppression_cfg;
+	struct qtm_proci_grip_suppression_cfg	    grip_suppression_cfg;
+	struct qtm_spt_com_cfg			        com_cfg;
+	struct qtm_spt_gpio_pwm_cfg			        gpio_pwm_cfg;
+	struct qtm_procg_noise_suppression_cfg	    noise_suppression_cfg;
+	struct qtm_proci_one_touch_gesture_proc_cfg	\
+					one_touch_gesture_proc_cfg;
+	struct qtm_spt_self_test_cfg			    self_test_cfg;
+	struct qtm_proci_two_touch_gesture_proc_cfg	two_touch_gesture_proc_cfg;
+	struct qtm_spt_cte_config_cfg			    cte_config_cfg;
+	struct qtm_proci_noise1_suppression_cfg     noise1_suppression_cfg;
+	struct qtm_spt_userdata     userdata;
 };
 
 #endif /* _LINUX_QTOUCH_OBP_TS_H */
diff --git a/include/linux/quickwakeup.h b/include/linux/quickwakeup.h
new file mode 100644
index 0000000..60df3b8
--- /dev/null
+++ b/include/linux/quickwakeup.h
@@ -0,0 +1,33 @@
+/* include/linux/quickwakeup.h
+ *
+ * Copyright (C) 2009 Motorola.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+struct quickwakeup_ops {
+	struct list_head list;
+	int (*qw_callback) (void);
+	int (*qw_check)(void);
+	int checked;
+};
+
+#ifdef CONFIG_QUICK_WAKEUP
+
+int quickwakeup_register(struct quickwakeup_ops *ops);
+int quickwakeup_check(void);
+int quickwakeup_execute(void);
+void quickwakeup_unregister(struct quickwakeup_ops *ops);
+
+#else
+static int quickwakeup_register(struct quickwakeup_ops *ops) { return 0; };
+void quickwakeup_unregister(struct quickwakeup_ops *ops) {};
+#endif
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index d4d2a78..9950476 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -2,6 +2,7 @@
  *  linux/include/linux/serial_8250.h
  *
  *  Copyright (C) 2004 Russell King
+ *  Copyright (C) 2009 Motorola, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,6 +15,11 @@
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
 
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+#define SERIAL8250_AUTO_RTS 0x01
+#define SERIAL8250_AUTO_CTS 0x02
+#endif
+
 /*
  * This is the platform device platform_data structure
  */
@@ -31,6 +37,9 @@ struct plat_serial8250_port {
 	unsigned int	type;		/* If UPF_FIXED_TYPE */
 	unsigned int	(*serial_in)(struct uart_port *, int);
 	void		(*serial_out)(struct uart_port *, int, int);
+#ifdef CONFIG_SERIAL_OMAP3430_HW_FLOW_CONTROL
+	unsigned char   rtscts;     /* bit0: rts, bit1: cts */
+#endif
 };
 
 /*
diff --git a/include/linux/slab.h b/include/linux/slab.h
index 24c5602..b48a4e9 100644
--- a/include/linux/slab.h
+++ b/include/linux/slab.h
@@ -126,7 +126,13 @@ int kmem_ptr_validate(struct kmem_cache *cachep, const void *ptr);
  */
 void * __must_check __krealloc(const void *, size_t, gfp_t);
 void * __must_check krealloc(const void *, size_t, gfp_t);
+/* CONFIG_MEMLEAK_BLD is only for built-in code */
+#if !defined(CONFIG_MEMLEAK_BLD) || defined(MODULE)
 void kfree(const void *);
+#else
+void memleak_kfree(const void *);
+#define kfree memleak_kfree
+#endif
 void kzfree(const void *);
 size_t ksize(const void *);
 
diff --git a/include/linux/slab_def.h b/include/linux/slab_def.h
index 6ca6a7b..09b20c7 100644
--- a/include/linux/slab_def.h
+++ b/include/linux/slab_def.h
@@ -26,10 +26,16 @@ struct cache_sizes {
 extern struct cache_sizes malloc_sizes[];
 
 void *kmem_cache_alloc(struct kmem_cache *, gfp_t);
+#ifndef CONFIG_MEMLEAK_BLD
 void *__kmalloc(size_t size, gfp_t flags);
+#else
+void *__memleak_kmalloc(size_t size, gfp_t flags);
+#define __kmalloc(size, flags) __memleak_kmalloc(size, flags)
+#endif
 
 static inline void *kmalloc(size_t size, gfp_t flags)
 {
+#ifndef CONFIG_DEBUG_MEMLEAK
 	if (__builtin_constant_p(size)) {
 		int i = 0;
 
@@ -52,6 +58,7 @@ found:
 #endif
 		return kmem_cache_alloc(malloc_sizes[i].cs_cachep, flags);
 	}
+#endif
 	return __kmalloc(size, flags);
 }
 
@@ -61,6 +68,7 @@ extern void *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node);
 
 static inline void *kmalloc_node(size_t size, gfp_t flags, int node)
 {
+#ifndef CONFIG_DEBUG_MEMLEAK
 	if (__builtin_constant_p(size)) {
 		int i = 0;
 
@@ -84,6 +92,7 @@ found:
 		return kmem_cache_alloc_node(malloc_sizes[i].cs_cachep,
 						flags, node);
 	}
+#endif
 	return __kmalloc_node(size, flags, node);
 }
 
diff --git a/include/linux/soundcard.h b/include/linux/soundcard.h
index 1904afe..b682b84 100644
--- a/include/linux/soundcard.h
+++ b/include/linux/soundcard.h
@@ -954,6 +954,9 @@ typedef unsigned char mixer_record[128];
 #define SOUND_MIXER_PRIVATE4		_SIOWR('M', 114, int)
 #define SOUND_MIXER_PRIVATE5		_SIOWR('M', 115, int)
 
+#define SOUND_MIXER_FMON            _SIOR('M', 120, int)
+#define SOUND_MIXER_FMOFF           _SIOR('M', 121, int)
+#define SOUND_MIXER_FMPATH          _SIOR('M', 122, int)
 /*
  * SOUND_MIXER_GETLEVELS and SOUND_MIXER_SETLEVELS calls can be used
  * for querying current mixer settings from the driver and for loading
diff --git a/include/linux/spi/cpcap.h b/include/linux/spi/cpcap.h
index 5f24abb..44e19c6 100644
--- a/include/linux/spi/cpcap.h
+++ b/include/linux/spi/cpcap.h
@@ -271,6 +271,9 @@ enum cpcap_reg {
 
 	CPCAP_REG_MAX		/* The largest valid register value. */
 	= CPCAP_REG_END,
+
+	CPCAP_REG_SIZE = CPCAP_REG_MAX + 1,
+	CPCAP_REG_UNUSED = CPCAP_REG_MAX + 2,
 };
 
 enum {
@@ -503,6 +506,7 @@ struct cpcap_platform_data {
 	struct cpcap_spi_init_data *init;
 	int init_len;
 	unsigned short *regulator_mode_values;
+	unsigned short *regulator_off_mode_values;
 	struct regulator_init_data *regulator_init;
 	struct cpcap_adc_ato *adc_ato;
 
@@ -602,6 +606,8 @@ struct cpcap_regacc {
 #define CPCAP_IOCTL_UC_MACRO_START \
 	_IOWR(0, CPCAP_IOCTL_NUM_UC_MACRO_START, enum cpcap_macro)
 
+/*#define CPCAP_AUDIO_REG_DEBUG*/
+
 #ifdef __KERNEL__
 struct cpcap_device {
 	struct spi_device	*spi;
@@ -682,5 +688,15 @@ int cpcap_uc_stop(struct cpcap_device *cpcap, enum cpcap_macro macro);
 
 unsigned char cpcap_uc_status(struct cpcap_device *cpcap,
 			      enum cpcap_macro macro);
+
+#if defined(CONFIG_LEDS_FLASH_RESET)
+int cpcap_direct_misc_write(unsigned short reg, unsigned short value,\
+							unsigned short mask);
+#endif
+
+#ifdef CPCAP_AUDIO_REG_DEBUG
+void cpcap_regacc_audio_reg_dump(void);
+#endif
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SPI_CPCAP_H */
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 68bb1c5..5026eed 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -803,4 +803,8 @@ spi_unregister_device(struct spi_device *spi)
 		device_unregister(&spi->dev);
 }
 
+#ifdef CONFIG_MOT_FEAT_SPI_SMS1130
+struct spi_device *spi_get_spi_device(char *modalias);
+#endif
+
 #endif /* __LINUX_SPI_H */
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index f9f900c..f1b8734 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -692,6 +692,10 @@ asmlinkage long sys_ppoll(struct pollfd __user *, unsigned int,
 asmlinkage long sys_pipe2(int __user *, int);
 asmlinkage long sys_pipe(int __user *);
 
+#ifdef CONFIG_LTT_LITE
+asmlinkage long sys_lttlite(unsigned int cmd, unsigned long arg);
+#endif
+
 int kernel_execve(const char *filename, char *const argv[], char *const envp[]);
 
 #endif
diff --git a/include/linux/usb/composite.h b/include/linux/usb/composite.h
index 935c380..2399007 100644
--- a/include/linux/usb/composite.h
+++ b/include/linux/usb/composite.h
@@ -100,6 +100,7 @@ struct usb_function {
 	struct usb_descriptor_header	**hs_descriptors;
 
 	struct usb_configuration	*config;
+	int				hidden;
 
 	/* REVISIT:  bind() functions can be marked __init, which
 	 * makes trouble for section mismatch analysis.  See if
diff --git a/include/linux/usb/omap.h b/include/linux/usb/omap.h
index df5d2bc..dd2d685 100644
--- a/include/linux/usb/omap.h
+++ b/include/linux/usb/omap.h
@@ -48,6 +48,7 @@ struct omap_usb_platform_data {
 	u32	flags;
 	struct omap_usb_port_data	*port_data;
 	int	num_ports;
+	int (*usbhost_standby_status)(void);
 };
 
 
diff --git a/include/linux/usb_ipc.h b/include/linux/usb_ipc.h
new file mode 100644
index 0000000..33133c3
--- /dev/null
+++ b/include/linux/usb_ipc.h
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 2007 - 2008 Motorola, Inc, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ * 
+ * Changelog:
+ * Date               Author           Comment
+ * -----------------------------------------------------------------------------
+ * 12/07/2007      Motorola        USB-IPC initial
+ * 03/22/2007      Motorola        USB-IPC header support
+ * 10/09/2008      Motorola        USB-IPC suspend/resume support
+ * 
+ */
+ 
+/*!
+ * @file usb_ipc.h
+ * @brief Header file for USB-IPC
+ *
+ * This is the generic portion of the USB-IPC driver.
+ *
+ * @ingroup IPCFunction
+ */
+
+
+#ifndef _USB_IPC_H_
+#define _USB_IPC_H_
+
+#include <linux/ipc_api.h>
+
+#ifndef __KERNEL__
+
+/* device node for BP log:  major=180, minor=250 */
+#define USB_IPC_LOG_DRV_NAME        "/dev/logger"
+
+#else  /*  */
+
+/* device name in kernel */
+#define USB_IPC_LOG_DRV_NAME       "logger"
+#define USB_IPC_LOG_MINOR_NUM      250
+
+/* just for test */
+#define USB_IPC_DATA_DRV_NAME      "usb_data"
+#define USB_IPC_DATA_MINOR_NUM     251
+
+/* USB device descriptor */
+#define MOTO_USBIPC_VID            0x22b8
+#define MOTO_USBIPC_PID            0x40e6
+#define USB_IPC_DATA_IF_NUM        0
+#define USB_IPC_LOG_IF_NUM         1
+
+
+/* USB IPC events */
+#define IPC_DATA_WR 0x1
+#define IPC_DATA_RD 0x2
+#define IPC_DATA_WR_CB 0x4
+#define IPC_DATA_RD_CB 0x8
+#define IPC_LOG_RD_CB 0x10
+
+#ifdef CONFIG_PM
+#define IPC_PM_SUSPEND 0x20
+#define IPC_PM_RESUME 0x40
+
+#define USB_IPC_SUSPEND_DELAY      500 // 500ms delay required by IPC
+#endif // CONFIG_PM
+
+#define IPC_DBG_ARRAY_SIZE 128
+
+/* define IPC channels which will map with each USB class driver */
+typedef enum {
+	IPC_DATA_CH_NUM = 0,
+	IPC_LOG_CH_NUM,
+	MAX_USB_IPC_CHANNELS
+} USB_IPC_CHANNEL_INDEX;
+
+/* define the read/write type */
+typedef enum {
+        /* read type */
+        HW_CTRL_IPC_READ_TYPE,
+        HW_CTRL_IPC_READ_EX2_TYPE,
+
+        /* write type */
+        HW_CTRL_IPC_WRITE_TYPE,
+        HW_CTRL_IPC_WRITE_EX_CONT_TYPE,
+        HW_CTRL_IPC_WRITE_EX_LIST_TYPE,
+        HW_CTRL_IPC_WRITE_EX2_TYPE
+} IPC_CHANNEL_ACCESS_TYPE;
+
+/* structure is used to manage data transfer for USB class driver */
+typedef struct {
+        // URB
+        struct usb_device *udev;   /* USB device handle */
+        struct urb read_urb;
+        struct urb write_urb;
+
+        /* endpoint wMaxPacketSize */
+        int read_wMaxPacketSize;
+        int write_wMaxPacketSize;
+
+        /* the following two functions are called by IPC API to send/read data:
+         * "buff" is the buffer pointer
+         * "size" is buffer size to read/write
+         * If return is 0, the function call is correct, otherwise, error 
+         */
+        int (*usb_write)(unsigned char *buff, int size);
+        int (*usb_read)(unsigned char *buff, int size);
+
+        /* When URB is completed, the following callback is used to notify the IPC API.
+         * "ch" is the IPC API channel
+         * "flag" is used to indicate whether data transmit is correct. If 0, ok, otherwise, error.
+         * "size" is the actual size for read/write
+         */
+        void (*ipc_read_cb)(USB_IPC_CHANNEL_INDEX ch, int flag, int size);
+        void (*ipc_write_cb)(USB_IPC_CHANNEL_INDEX ch, int flag, int size);
+#ifdef CONFIG_PM
+        /* flag to indicate whether URB is used */
+        int read_urb_used;
+        int write_urb_used;
+        int sleeping;
+        int working;
+	int allow_suspend;
+        spinlock_t pm_lock;
+        struct work_struct wakeup_work;
+        struct delayed_work suspend_work;
+        struct workqueue_struct *kwakeup_usb_wq;
+        struct workqueue_struct *ksuspend_usb_wq;
+#endif
+        int ipc_events;
+	char *truncated_buf;
+	int truncated_size;
+} USB_IPC_IFS_STRUCT;
+
+extern USB_IPC_IFS_STRUCT usb_ipc_data_param;
+extern spinlock_t ipc_event_lock;
+extern wait_queue_head_t kipcd_wait;
+
+/* macros for LinkDriver read/write semphore */
+#define SEM_LOCK_INIT(x)     init_MUTEX_LOCKED(x)
+#define SEM_LOCK(x)          down(x)
+#define SEM_UNLOCK(x)        up(x)
+
+/* if defined, the temporary buffer is used to merge scatter buffers into one frame buffer */
+/* only useful, if one frame is saved into more than one scatter buffers */
+//#define IPC_USE_TEMP_BUFFER
+#define USE_IPC_FRAME_HEADER
+/* use DMA to merge scatter buffer into one frame buffer. ONLY valid while USE_IPC_FRAME_HEADER is defined  */
+#if defined(USE_IPC_FRAME_HEADER)
+#define USE_OMAP_SDMA
+#endif
+
+/* Structure used to manage data read/write of IPC APIs */
+typedef struct  {
+
+    /* parameters for IPC channels */
+    HW_CTRL_IPC_CHANNEL_T ch;
+    HW_CTRL_IPC_OPEN_T    cfg;
+    int                   open_flag;
+    int                   read_flag;
+    int                   write_flag;
+    int                   max_node_num;  /* max node number for xxx_write/read_ex2 */
+
+    /* read APIs parameters */
+    IPC_CHANNEL_ACCESS_TYPE  read_type;  /* indicate read function types: xxx_read or xxx_read_ex2 */
+    struct   {                           /* all parameters used for xxx_read/read_ex2() function call */
+        struct {
+                unsigned char *buf;
+                unsigned short nb_bytes;
+        } gen_ptr;
+
+        /* the following parameters are used as the node descriptor read operation */
+        HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *node_ptr;
+        int  node_index;
+        int  node_num;
+#if defined(IPC_USE_TEMP_BUFFER) || defined(USE_IPC_FRAME_HEADER)
+        unsigned char *temp_buff;   // temporary buffer if the node buffer is smaller than EP maxpacksize or frame size
+#if defined(USE_OMAP_SDMA)
+        dma_addr_t         temp_buff_phy_addr;
+#endif
+        int temp_buff_flag;         // flag to indicat whether temporary buffer is used
+#endif
+        int        total_num;               // totally read byte number for callback arguments
+        struct semaphore read_mutex;   /* only useful, if LinkDriver read callback is NULL */
+    } read_ptr;
+
+    /* write API parameters */
+    IPC_CHANNEL_ACCESS_TYPE  write_type; /* indicate write function types: xxx_write, xxx_write_ex, or xxx_write_ex2 */
+    struct   {
+        struct {
+                unsigned char *buf;
+                unsigned short nb_bytes;
+        } gen_ptr;
+
+        HW_CTRL_IPC_CONTIGUOUS_T           *cont_ptr;
+        HW_CTRL_IPC_LINKED_LIST_T          *list_ptr;
+
+        /* the following parameters are used as the node descriptor read operation */
+        HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T *node_ptr;
+        int  node_index;
+        int  node_num;
+        int  end_flag;              // indicate whether the last transmit is a zero package of all frames
+        int  total_num;             // totally write byte number for callback arguments
+        struct semaphore  write_mutex;  /* in case, LinkDriver write callback is NULL */
+#if defined(IPC_USE_TEMP_BUFFER) || defined(USE_IPC_FRAME_HEADER)
+        unsigned char *temp_buff;   // temporary buffer if the node buffer is smaller than EP maxpacksize or frame size
+#if defined(USE_OMAP_SDMA)
+        dma_addr_t         temp_buff_phy_addr;
+#endif
+        int temp_buff_flag;         // flag to indicat whether temporary buffer is used
+#endif
+    } write_ptr;
+
+#ifdef USE_IPC_FRAME_HEADER
+    unsigned long max_temp_buff_size;
+#endif
+    /* USB Class driver interfaces for the relevant IPC channel */
+    USB_IPC_IFS_STRUCT *usb_ifs;
+} USB_IPC_API_PARAMS;
+
+typedef struct {
+	void *        next;
+	int           data_num;
+	int	      read_num;
+	unsigned char *ptr;
+} IPC_LOG_DATA_BUFFER;
+
+typedef struct {
+        struct usb_device    *udev;         /* USB device handle */
+	int                  read_bufsize;  /* each receive buffer size, NOT less than MaxPacketSize */
+	IPC_LOG_DATA_BUFFER  *read_buf;     /* pointer to IPC_LOG_DATA_BUFFER for read function call*/
+	IPC_LOG_DATA_BUFFER  *write_buf;    /* pointer to IPC_LOG_DATA_BUFFER for submit URB */
+	IPC_LOG_DATA_BUFFER  *end_buf;      /* pointer to last IPC_LOG_DATA_BUFFER */
+	int                  buf_num;       /* totally IPC_LOG_DATA_BUFFER */
+
+//	struct semaphore     mutex;         /* used to block read */
+
+	/* URB */
+	struct   urb         read_urb;   /* URB for data read */
+        int                  isopen;     /* whether open function is called */
+	int                  probe_flag; /* whether probed */
+        int                  urb_flag;
+} USB_LOG_IFS_STRUCT;
+
+#ifdef USE_OMAP_SDMA
+#define IPC_DMA_NODE2BUF_ID      1
+#define IPC_DMA_BUF2NODE_ID      2
+
+struct IPC_DMA_MEMCPY {
+	int dma_ch;
+	int node_index;
+	int frame_index;
+	int total_size;
+	USB_IPC_API_PARAMS *ipc_ch;
+	unsigned long      buf_phy;
+	IPC_DATA_HEADER    *header;
+	HW_CTRL_IPC_DATA_NODE_DESCRIPTOR_T  *node_ptr;
+};
+
+extern struct IPC_DMA_MEMCPY ipc_memcpy_node2buf;
+extern struct IPC_DMA_MEMCPY ipc_memcpy_buf2node;
+extern void ipc_dma_node2buf_callback(int lch, u16 ch_status, void *data);
+extern void ipc_dma_buf2node_callback(int lch, u16 ch_status, void *data);
+#endif
+
+extern int ipc_dbg_index;
+extern char ipc_dbg_array[IPC_DBG_ARRAY_SIZE];
+extern unsigned int dma_vsrc;
+extern unsigned int dma_psrc;
+extern unsigned int dma_vdest;
+extern unsigned int dma_pdest;
+extern unsigned int dma_size;
+extern unsigned int dma_ch;
+
+extern void ipc_api_usb_probe(USB_IPC_CHANNEL_INDEX ch_index, USB_IPC_IFS_STRUCT *usb_ifs);
+extern void ipc_api_usb_disconnect(USB_IPC_CHANNEL_INDEX ch_index);
+extern void ipc_api_init(void);
+extern void ipc_api_exit(void);
+
+/* IPC Data interface */
+extern int usb_ipc_data_probe(struct usb_interface *intf, const struct usb_device_id *id);
+extern void usb_ipc_data_disconnect(struct usb_interface *intf);
+extern int usb_ipc_data_init(void);
+extern void usb_ipc_data_exit(void);
+
+/* IPC Log interface */
+extern int usb_ipc_log_probe(struct usb_interface *intf, const struct usb_device_id *id);
+extern void usb_ipc_log_disconnect(struct usb_interface *intf);
+extern int usb_ipc_log_init(void);
+extern void usb_ipc_log_exit(void);
+
+#endif  //__KERNEL__
+
+#endif // _USB_IPC_H_
+
+
diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h
index 9c0890c..af4dc6b 100644
--- a/include/linux/vmalloc.h
+++ b/include/linux/vmalloc.h
@@ -50,7 +50,13 @@ static inline void vmalloc_init(void)
 }
 #endif
 
+/* CONFIG_MEMLEAK_BLD is only for built-in code */
+#if !defined(CONFIG_MEMLEAK_BLD) || defined(MODULE)
 extern void *vmalloc(unsigned long size);
+#else
+extern void *memleak_vmalloc(unsigned long size);
+#define vmalloc(size) memleak_vmalloc(size)
+#endif
 extern void *vmalloc_user(unsigned long size);
 extern void *vmalloc_node(unsigned long size, int node);
 extern void *vmalloc_exec(unsigned long size);
@@ -59,7 +65,13 @@ extern void *vmalloc_32_user(unsigned long size);
 extern void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot);
 extern void *__vmalloc_area(struct vm_struct *area, gfp_t gfp_mask,
 				pgprot_t prot);
+/* CONFIG_MEMLEAK_BLD is only for built-in code */
+#if !defined(CONFIG_MEMLEAK_BLD) || defined(MODULE)
 extern void vfree(const void *addr);
+#else
+extern void memleak_vfree(void *addr);
+#define vfree(addr) memleak_vfree(addr)
+#endif
 
 extern void *vmap(struct page **pages, unsigned int count,
 			unsigned long flags, pgprot_t prot);
diff --git a/include/linux/wakeup_timer.h b/include/linux/wakeup_timer.h
new file mode 100644
index 0000000..14cd211
--- /dev/null
+++ b/include/linux/wakeup_timer.h
@@ -0,0 +1,56 @@
+/*
+ *  wakeup_timer.h
+ *
+ *  Copyright (C) 2009 Motorola, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Adds ability to program periodic interrupts from user space that
+ *  can wake the phone out of low power modes.
+ *
+ */
+ /*
+ * DATE             AUTHOR         COMMENT
+ * -----            ------         --------
+ * Apr 30, 2009     Motorola       Initial version for omap Android
+ *
+ */
+
+#ifndef WAKEUP_TIMER_H_
+#define WAKEUP_TIMER_H_
+
+#include <linux/time.h>
+
+/*
+ * We only allow one thread to have one wakeup timer
+ * For periodic timer, it can just use IOC_WAKEUP_TIMER_SETPERIOD
+ * to set the perioid and after that,
+ * the thread can only use poll on this driver to wait for timer fire.
+ * For oneshot timer, the app should use IOC_WAKEUP_TIMER_ONESHOT to
+ * reset the time out every time after the timer fires
+ * It should call IOC_WAKEUP_TIMER_DELETE in time to remove the timer
+ * if it only wants for one time wakeup
+ */
+/* Set a periodic wakeup timers request */
+#define IOC_WAKEUP_TIMER_SETPERIOD		_IOW('w', 0x1, int)
+/* Set a oneshot wakeup timer request */
+#define IOC_WAKEUP_TIMER_ONESHOT		_IOW('w', 0x2, int)
+/* Selete the wakeup timer request */
+#define IOC_WAKEUP_TIMER_DELETE			_IO('w', 0x3)
+
+/* Operations for /dev/clock_32k device */
+#define IOC_32KHZ_READ                          _IOW('w', 0x1, int)
+
+#endif /* WAKEUP_TIMER_H_ */
diff --git a/include/linux/wakeup_timer_kernel.h b/include/linux/wakeup_timer_kernel.h
new file mode 100644
index 0000000..e884ee8
--- /dev/null
+++ b/include/linux/wakeup_timer_kernel.h
@@ -0,0 +1,90 @@
+/*
+ *  wakeup_timer.h
+ *
+ *  Copyright (C) 2009 Motorola, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Adds ability to program periodic interrupts from user space that
+ *  can wake the phone out of low power modes.
+ *
+ */
+ /*
+ * DATE             AUTHOR         COMMENT
+ * -----            ------         --------
+ * Apr 30, 2009     Motorola       Initial version for omap Android
+ *
+ */
+
+#ifndef WAKEUP_TIMER_KERNEL_H_
+#define WAKEUP_TIMER_KERNEL_H_
+
+#include <linux/time.h>
+
+#ifdef CONFIG_HAS_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+/*
+ * Wakeup timer type definition:
+ * Periodic wakeup timers will ensure the accuracy in period,
+ * but the first wakeup time point maybe adjusted
+ * oneshot wakeup timers will ensure the accuracy on the desired time point
+ */
+enum timer_type {
+	/* Periodic wakeup timers which will be restarted after it fires */
+	TYPE_PERIODIC = 0,
+	/* Oneshot wakeup timers which only start for once */
+	TYPE_ONESHOT,
+	/* scim status timer, very special case */
+	TYPE_STATUS
+};
+
+struct timer_cascade_root {
+	/* Timers cascade link list */
+	struct list_head node;
+	struct hrtimer alarm_timer;
+	unsigned long period_time;
+	unsigned long timer_base_time;
+
+	/* wait queue head for this timer cascade */
+	wait_queue_head_t cascade_wq;
+
+	/* Periodic or oneshot for timers in this cascade */
+	int cascade_type;
+
+	/* current timer status */
+	int state;
+
+	/* calling process */
+	struct task_struct *process;
+
+	/* callback for kernel status timer */
+	int (*callback) (void);
+
+#ifdef CONFIG_HAS_WAKELOCK
+	/* Wake lock to prevent suspend so allow app to finish their work */
+	struct wake_lock wkuptimer_wake_lock;
+#endif
+};
+
+extern struct timer_cascade_root *wakeup_create_status_timer(
+		int (*callback) (void));
+extern void wakeup_start_status_timer(struct timer_cascade_root *timer,
+		unsigned long period_time);
+extern int wakeup_stop_status_timer(struct timer_cascade_root *timer);
+extern int wakeup_del_status_timer(struct timer_cascade_root *timer);
+extern int wakeup_check_status_timer(struct timer_cascade_root *timer);
+
+#endif /* WAKEUP_TIMER_H_ */
diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index 011bcfe..14b5980 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -31,6 +31,7 @@ struct watchdog_info {
 #define	WDIOC_SETPRETIMEOUT	_IOWR(WATCHDOG_IOCTL_BASE, 8, int)
 #define	WDIOC_GETPRETIMEOUT	_IOR(WATCHDOG_IOCTL_BASE, 9, int)
 #define	WDIOC_GETTIMELEFT	_IOR(WATCHDOG_IOCTL_BASE, 10, int)
+#define	WDIOC_STARTTIMER	_IOWR(WATCHDOG_IOCTL_BASE, 11, int)
 
 #define	WDIOF_UNKNOWN		-1	/* Unknown flag error */
 #define	WDIOS_UNKNOWN		-1	/* Unknown status error */
diff --git a/init/main.c b/init/main.c
index 83697e1..d359d58 100644
--- a/init/main.c
+++ b/init/main.c
@@ -2,11 +2,17 @@
  *  linux/init/main.c
  *
  *  Copyright (C) 1991, 1992  Linus Torvalds
+ *  Copyright (C) 2009 Motorola, Inc.
  *
  *  GK 2/5/95  -  Changed to support mounting root fs via NFS
  *  Added initrd & change_root: Werner Almesberger & Hans Lermen, Feb '96
  *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96
  *  Simplified starting of init:  Michael A. Griffith <grif@acm.org> 
+ *
+ *  Revision History:
+ *  Date         Author        Comment
+ *  ---------    ----------    ---------
+ *  Jun 30,2008   Motorola      Update cmdline param for emu_uart_debug option
  */
 
 #include <linux/types.h>
@@ -63,6 +69,8 @@
 #include <linux/idr.h>
 #include <linux/ftrace.h>
 #include <linux/async.h>
+#include <linux/lttlite-events.h>
+
 #include <trace/boot.h>
 
 #include <asm/io.h>
@@ -74,6 +82,9 @@
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/smp.h>
 #endif
+#ifdef CONFIG_EMU_UART_DEBUG
+#include <mach/board-mapphone-emu_uart.h>
+#endif
 
 static int kernel_init(void *);
 
@@ -342,6 +353,15 @@ static int __init rdinit_setup(char *str)
 }
 __setup("rdinit=", rdinit_setup);
 
+#ifdef CONFIG_EMU_UART_DEBUG
+static int __init emu_uart_debug(char *str)
+{
+    activate_emu_uart();
+    return 0;
+}
+early_param("emu_uart_debug", emu_uart_debug);
+#endif
+
 #ifndef CONFIG_SMP
 
 #ifdef CONFIG_X86_LOCAL_APIC
@@ -452,6 +472,11 @@ static noinline void __init_refok rest_init(void)
 {
 	int pid;
 
+#ifdef CONFIG_LTT_LITE
+	/* initialize before the init process is started */
+	ltt_lite_early_init();
+#endif
+
 	kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
 	numa_default_policy();
 	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
@@ -644,6 +669,10 @@ asmlinkage void __init start_kernel(void)
 	kmem_cache_init();
 	debug_objects_mem_init();
 	idr_init_cache();
+#ifdef CONFIG_DEBUG_MEMLEAK
+	radix_tree_init();
+	memleak_init();
+#endif
 	setup_per_cpu_pageset();
 	numa_policy_init();
 	if (late_time_init)
@@ -665,7 +694,9 @@ asmlinkage void __init start_kernel(void)
 	key_init();
 	security_init();
 	vfs_caches_init(num_physpages);
+#ifndef CONFIG_DEBUG_MEMLEAK
 	radix_tree_init();
+#endif
 	signals_init();
 	/* rootfs populating might need page-writeback */
 	page_writeback_init();
diff --git a/kernel/Kconfig.lttlite b/kernel/Kconfig.lttlite
new file mode 100644
index 0000000..b2c6029
--- /dev/null
+++ b/kernel/Kconfig.lttlite
@@ -0,0 +1,11 @@
+menu "LTT-Lite (Linux Tracing Tool)"
+config LTT_LITE
+		bool "Lite version of the Linux Trace Toolkit support"
+		depends on !LTT
+		default n
+		help
+				provide a scaled-down version of LTT: logs only some
+				of the events;
+				logs them to a file rather than to relayfs;
+				does not require a user-space daemon.
+endmenu
diff --git a/kernel/Makefile b/kernel/Makefile
index e4791b3..c51f2b2 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -77,6 +77,7 @@ obj-$(CONFIG_DETECT_SOFTLOCKUP) += softlockup.o
 obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
 obj-$(CONFIG_SECCOMP) += seccomp.o
 obj-$(CONFIG_RCU_TORTURE_TEST) += rcutorture.o
+obj-$(CONFIG_GCOV_PROFILE) += gcov/
 obj-$(CONFIG_CLASSIC_RCU) += rcuclassic.o
 obj-$(CONFIG_TREE_RCU) += rcutree.o
 obj-$(CONFIG_PREEMPT_RCU) += rcupreempt.o
@@ -93,6 +94,7 @@ obj-$(CONFIG_HAVE_GENERIC_DMA_COHERENT) += dma-coherent.o
 obj-$(CONFIG_FUNCTION_TRACER) += trace/
 obj-$(CONFIG_TRACING) += trace/
 obj-$(CONFIG_SMP) += sched_cpupri.o
+obj-$(CONFIG_LTT_LITE) += ltt-lite.o
 
 ifneq ($(CONFIG_SCHED_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff --git a/kernel/exit.c b/kernel/exit.c
index efd30cc..73d7c3c 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -47,6 +47,8 @@
 #include <linux/task_io_accounting_ops.h>
 #include <linux/tracehook.h>
 #include <linux/init_task.h>
+#include <linux/lttlite-events.h>
+
 #include <trace/sched.h>
 
 #include <asm/uaccess.h>
@@ -472,6 +474,11 @@ void daemonize(const char *name, ...)
 	atomic_inc(&current->files->count);
 
 	reparent_to_kthreadd();
+
+#ifdef CONFIG_LTT_LITE
+	ltt_lite_ev_process(LTT_LITE_EV_PROCESS_COMM_CHANGE,
+		current);
+#endif
 }
 
 EXPORT_SYMBOL(daemonize);
@@ -1070,6 +1077,9 @@ NORET_TYPE void do_exit(long code)
 	taskstats_exit(tsk, group_dead);
 
 	exit_mm(tsk);
+#ifdef CONFIG_LTT_LITE
+	ltt_ev_process_exit(0, 0);
+#endif
 
 	if (group_dead)
 		acct_process();
diff --git a/kernel/fork.c b/kernel/fork.c
index 4854c2c..04db350 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -60,6 +60,8 @@
 #include <linux/tty.h>
 #include <linux/proc_fs.h>
 #include <linux/blkdev.h>
+#include <linux/lttlite-events.h>
+
 #include <trace/sched.h>
 
 #include <asm/pgtable.h>
@@ -1269,6 +1271,10 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 		nr_threads++;
 	}
 
+#ifdef CONFIG_LTT_LITE
+	ltt_lite_ev_process(LTT_LITE_EV_PROCESS_FORK, p);
+#endif
+
 	total_forks++;
 	spin_unlock(&current->sighand->siglock);
 	write_unlock_irq(&tasklist_lock);
diff --git a/kernel/gcov/Kconfig b/kernel/gcov/Kconfig
new file mode 100644
index 0000000..d0048d5
--- /dev/null
+++ b/kernel/gcov/Kconfig
@@ -0,0 +1,55 @@
+#
+# GCOV coverage profiling
+#
+
+menu "GCOV coverage profiling"
+
+config GCOV_PROFILE
+	bool "Include GCOV coverage profiling"
+	---help---
+        Provide infrastructure for GCOV kernel coverage support.
+
+        Enable GCOV_ALL to get coverage data for the entire kernel
+        source.
+
+        To get coverage data for only specific files or directories,
+        add the following line to the respective Makefile:
+
+                EXTRA_CFLAGS += $(GCOV_FLAGS)
+
+        Note that GCOV_PROC has to be enabled to access GCOV kernel
+        coverage data.
+
+config GCOV_ALL
+	bool "Profile entire Kernel"
+	depends on GCOV_PROFILE
+	---help---
+	If you say Y here, it will compile the entire kernel with coverage
+	option enabled.
+
+config GCOV_PROC
+	tristate "Provide GCOV proc file system entry"
+	depends on GCOV_PROFILE && PROC_FS
+	---help---
+        Install a proc file system entry at /proc/gcov which provides
+        access to the current coverage state of the kernel code.
+
+        This option is also available as a module called gcov-proc.o.
+        It can be loaded using:
+
+          modprobe gcov-proc
+
+config GCOV_HAMMER
+	bool "Support for modified GCC version 3.3.x (hammer patch)"
+	depends on GCOV_PROFILE
+	---help---
+	Some Linux distributions ship a modified version of GCC 3.3.x that
+	produces GCOV data incompatible with the format of the standard
+	GCC 3.3.x. If you are using such a distribution, you need to enable
+	this option for the GCOV kernel support to work correctly.
+
+	Distributions known to include this modification:
+		SUSE SLES9
+		Mandrake Linux 10.x
+
+endmenu
diff --git a/kernel/gcov/Makefile b/kernel/gcov/Makefile
new file mode 100644
index 0000000..010ee83
--- /dev/null
+++ b/kernel/gcov/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for GCOV profiling kernel module
+#
+
+# 2006-03-07, anderson.lizardo@gmail.com:
+# Disable coverage for the gcov-kernel module itself. In the ARM platform, it
+# generates a soft-lockup while trying to read the data from /proc/gcov.
+KBUILD_CFLAGS := $(KBUILD_CFLAGS_NOGCOV)
+
+obj-$(CONFIG_GCOV_PROFILE) += gcov-core.o
+obj-$(CONFIG_GCOV_PROC)	   += gcov-proc.o
+
+CFLAGS_gcov-core.o := -DGCOV_SRC_PATH='"$(srctree)"' -DGCOV_OBJ_PATH='"$(objtree)"'
diff --git a/kernel/gcov/gcov-core.c b/kernel/gcov/gcov-core.c
new file mode 100644
index 0000000..e1bee8d
--- /dev/null
+++ b/kernel/gcov/gcov-core.c
@@ -0,0 +1,295 @@
+/*
+ * kernel/gcov/gcov-core.c
+ *
+ * Core functionality for GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2006
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Rajan Ravindran <rajancr@us.ibm.com>
+ *         Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/gcov.h>
+#include <linux/unistd.h>
+#include <linux/syscalls.h>
+#include <linux/semaphore.h>
+
+/* Newer kernel versions no longer support EXPORT_SYMBOL_NOVERS */
+#ifndef EXPORT_SYMBOL_NOVERS
+#define EXPORT_SYMBOL_NOVERS(x)	EXPORT_SYMBOL(x)
+#endif
+
+#define GCOV_CORE_HEADER	"gcov-core: "
+
+/* This structure is used to keep track of all struct bbs associated with a
+ * module. */
+struct gcov_context
+{
+	struct list_head list;
+	struct module *module;
+	unsigned long count;
+	struct bb **bb;
+};
+
+struct ctor_list
+{
+	unsigned long num;
+	ctor_t ctor[];
+};
+
+/* Start of global constructor list. Declared in vmlinux-ld script.  */
+extern struct ctor_list __CTOR_LIST__;
+
+/* Linked list for registered struct bbs. */
+struct bb *bb_head;
+
+/* Callback informed of struct bb addition and removal. */
+void (*gcov_callback)(enum gcov_cmd, struct bb *bbptr) = NULL;
+
+/* Path to kernel files. */
+const char *gcov_sourcepath = GCOV_SRC_PATH;
+const char *gcov_objectpath = GCOV_OBJ_PATH;
+
+/* List of contexts for registered bb entries. */
+static LIST_HEAD(context_list);
+
+/* Context into which blocks are inserted during initialization. */
+static struct gcov_context *current_context;
+
+/* Protect global variables from concurrent access. */
+struct semaphore gcov_core_lock;
+
+#if GCC_VERSION_LOWER(3, 4) && !CONFIG_GCOV_HAMMER
+static const char *gcov_format = "pre-gcc_3.4";
+
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__bb_init_func(struct bb *bb)
+{
+	if (bb->zero_word)
+		return;
+	/* Set up linked list */
+	bb->zero_word = 1;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+
+/* Unused functions needed to prevent linker errors. */
+void __bb_fork_func(void) {}
+
+EXPORT_SYMBOL_NOVERS(__bb_init_func);
+EXPORT_SYMBOL_NOVERS(__bb_fork_func);
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+static const char *gcov_format = "gcc_3.3_(hammer)";
+unsigned long gcov_version;
+
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__gcov_init(struct bb *bb)
+{
+	if (!bb->version)
+		return;
+	/* Check for compatible gcc version */
+	if (gcov_version == 0)
+		gcov_version = bb->version;
+	else if (bb->version != gcov_version) {
+		printk(KERN_WARNING GCOV_CORE_HEADER "gcc version mismatch in "
+		       "file '%s'!\n", bb->filename);
+		return;
+	}
+	/* Set up linked list */
+	bb->version = 0;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+void __gcov_flush(void) {}
+
+EXPORT_SYMBOL_NOVERS(gcov_version);
+EXPORT_SYMBOL_NOVERS(__gcov_init);
+EXPORT_SYMBOL_NOVERS(__gcov_flush);
+#else
+static const char *gcov_format = "gcc_3.4";
+gcov_unsigned_t gcov_version = 0;
+
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__gcov_init(struct bb *bb)
+{
+	if (!bb->version)
+		return;
+	/* Check for compatible gcc version */
+	if (gcov_version == 0)
+		gcov_version = bb->version;
+	else if (bb->version != gcov_version) {
+		printk(KERN_WARNING GCOV_CORE_HEADER "gcc version mismatch in "
+		       "file '%s'!\n", bb->filename);
+		return;
+	}
+	/* Set up linked list */
+	bb->version = 0;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+
+/* Unused functions needed to prevent linker errors. */
+void __gcov_flush(void) {}
+void __gcov_merge_add(gcov_type *counters, unsigned int n_counters) {}
+void __gcov_merge_single(gcov_type *counters, unsigned int n_counters) {}
+void __gcov_merge_delta(gcov_type *counters, unsigned int n_counters) {}
+int __gcov_execve(const char *path, char *const argv[], char *const envp[])
+{
+	return kernel_execve(path, argv, envp);
+}
+
+EXPORT_SYMBOL_NOVERS(gcov_version);
+EXPORT_SYMBOL_NOVERS(__gcov_init);
+EXPORT_SYMBOL_NOVERS(__gcov_flush);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_add);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_single);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_delta);
+EXPORT_SYMBOL_NOVERS(__gcov_execve);
+#endif /* GCC_VERSION */
+
+
+/* Call NUM constructors in CTOR. If defined, MODULE specifies that resulting
+ * bb data be associated with module. */
+void
+do_global_ctors(ctor_t ctor[], unsigned long num, struct module *module)
+{
+	unsigned long i;
+
+	down(&gcov_core_lock);
+	if (module) {
+		/* Create a context to associate struct bbs with this MODULE */
+		current_context = (struct gcov_context *) kmalloc(
+					sizeof(struct gcov_context) +
+					num * sizeof(struct bb *),
+					GFP_KERNEL);
+		if (!current_context) {
+			printk(KERN_WARNING GCOV_CORE_HEADER "not enough memory"
+			       " for coverage data!\n");
+			up(&gcov_core_lock);
+			return;
+		}
+		current_context->module = module;
+		current_context->count = 0;
+		current_context->bb = (struct bb **) (current_context + 1);
+		list_add(&current_context->list, &context_list);
+	}
+	/* Call constructors */
+	for (i = 0; i < num && ctor[i]; i++)
+		ctor[i]();
+	current_context = NULL;
+	up(&gcov_core_lock);
+}
+
+
+/* Remove data associated with MODULE. */
+void
+remove_bb_link(struct module *module)
+{
+	struct gcov_context* context;
+	struct gcov_context* tmp;
+	struct bb *bb;
+	struct bb *prev;
+	unsigned long i;
+
+	down(&gcov_core_lock);
+	/* Get associated context */
+	context = NULL;
+	list_for_each_entry(tmp, &context_list, list) {
+		if (tmp->module == module) {
+			context = tmp;
+			break;
+		}
+	}
+	if (!context) {
+		up(&gcov_core_lock);
+		return;
+	}
+	/* Remove all bb entries belonging to this module */
+	prev = NULL;
+	for (bb = bb_head; bb ; bb = bb->next) {
+		for (i = 0; i < context->count; i++) {
+			if (context->bb[i] == bb) {
+				/* Detach bb from list. */
+				if (prev)
+					prev->next = bb->next;
+				else
+					bb_head = bb->next;
+				/* Notify callback */
+				if (gcov_callback)
+					(*gcov_callback)(gcov_remove, bb);
+				break;
+			}
+		}
+		if (i == context->count)
+			prev = bb;
+	}
+	list_del(&context->list);
+	kfree(context);
+	up(&gcov_core_lock);
+}
+
+
+static int __init
+gcov_core_init(void)
+{
+	printk(KERN_INFO GCOV_CORE_HEADER "initializing core module: "
+	       "format=%s\n", gcov_format);
+	sema_init(&gcov_core_lock, 1);
+	do_global_ctors(__CTOR_LIST__.ctor, __CTOR_LIST__.num, NULL);
+	printk(KERN_INFO GCOV_CORE_HEADER "init done\n");
+	return 0;
+}
+
+module_init(gcov_core_init);
+
+
+EXPORT_SYMBOL_NOVERS(bb_head);
+EXPORT_SYMBOL_NOVERS(gcov_sourcepath);
+EXPORT_SYMBOL_NOVERS(gcov_objectpath);
+EXPORT_SYMBOL_NOVERS(gcov_callback);
+EXPORT_SYMBOL_NOVERS(gcov_core_lock);
+EXPORT_SYMBOL_NOVERS(do_global_ctors);
diff --git a/kernel/gcov/gcov-proc.c b/kernel/gcov/gcov-proc.c
new file mode 100644
index 0000000..864b73e
--- /dev/null
+++ b/kernel/gcov/gcov-proc.c
@@ -0,0 +1,2147 @@
+/*
+ * kernel/gcov/gcov-proc.c
+ *
+ * Provides proc filesystem entry for GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2003
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Rajan Ravindran <rajancr@us.ibm.com>
+ *         Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
+ *         Paul Larson
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/gcov.h>
+
+
+MODULE_LICENSE("GPL");
+
+#define GCOV_PROC_HEADER	"gcov-proc: "
+#define GCOV_PROC_ROOT		"gcov"
+#define GCOV_PROC_MODULE	"module"
+#define GCOV_PROC_VMLINUX	"vmlinux"
+#define PAD8(x)			(((x) + 7) & ~7)
+#define PAD4(x)			(((x) + 3) & ~3)
+
+typedef enum {
+	status_normal,	/* Normal status */
+	status_ghost	/* Module associated with this node has been unloaded
+			 * but data was saved. */
+} node_status;
+
+/* Data structure used to manage proc filesystem entries. */
+struct gcov_ftree_node
+{
+	char *fname;			 /* Hierarchy-relative name */
+	struct gcov_ftree_node *sibling; /* First sibling of this node */
+	struct gcov_ftree_node *files;	 /* First child of this node */
+	struct gcov_ftree_node *parent;	 /* Parent of this node */
+	struct proc_dir_entry *proc[4];	 /* Entries for .da, .bb, .bbg, .c */
+	struct bb *bb;			 /* Associated struct bb */
+	loff_t offset;			 /* Offset in vmlinux file */
+	size_t da_size;			 /* Size of associated .da file */
+	size_t header_size;		 /* Size of associated file header */
+	struct gcov_ftree_node *next;	 /* Next leaf node */
+	node_status status;		 /* Status of this node */
+};
+
+
+/* If set to non-zero, keep gcov data for modules after unload. */
+static int gcov_persist = 0;
+
+/* If set to non-zero, create links to additional files in proc filesystem
+ * entries. */
+static int gcov_link = 1;
+
+/* Protect global variables from concurrent access. */
+static struct semaphore gcov_lock;
+
+/* Length of kernel source path string. */
+static int sourcepath_len;
+
+/* Length of kernel object path string. */
+static int objectpath_len;
+
+/* Filesystem entry for /proc/gcov/vmlinux */
+static struct proc_dir_entry *proc_vmlinux = NULL;
+
+/* First leaf node. */
+static struct gcov_ftree_node *leaf_nodes = NULL;
+
+/* Cached node used to speed up sequential reads in /proc/vmlinux. */
+static struct gcov_ftree_node *cached_node = NULL;
+
+/* Root node for internal data tree. */
+static struct gcov_ftree_node tree_root;
+
+#if GCC_VERSION_LOWER(3,4) && !CONFIG_GCOV_HAMMER
+/* Filename extension for data files. */
+static const char *da_ending = "da";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "bb", "bbg", "c" };
+#elif GCC_VERSION_EQUAL(3,3) && CONFIG_GCOV_HAMMER
+/* Filename extension for data files. */
+static const char *da_ending = "da";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "bbg", "c" };
+#else /* GCC_VERSION */
+/* Filename extension for data files. */
+static const char *da_ending = "gcda";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "gcno", "c" };
+#endif /* GCC_VERSION_LOWER */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)) &&	\
+    (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,4)) ||	\
+    (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23))
+/* Retrieve proc_dir_entry associated with INODE. */
+static inline struct proc_dir_entry *
+PDE(const struct inode *inode)
+{
+	return ((struct proc_dir_entry *) inode->u.generic_ip);
+}
+#endif
+
+
+#ifdef MODULE
+/* Parameter handling. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+/* module_param is a 2.6 thing (though there are compat macros since 2.4.25) */
+MODULE_PARM(gcov_persist, "i");
+MODULE_PARM(gcov_link, "i");
+#else
+module_param(gcov_persist, int, 0400);
+module_param(gcov_link, int, 0400);
+#endif /* LINUX_VERSION_CODE */
+
+MODULE_PARM_DESC(gcov_persist, "If set to non-zero, keep gcov data for modules "
+			       "after unload");
+MODULE_PARM_DESC(gcov_link, "If set to non-zero, create links to additional "
+			    "files in proc filesystem entries");
+
+#else /* MODULE */
+
+/* Called when 'gcov_persist' is specified on the kernel command line. */
+static int __init
+gcov_persist_setup(char *str)
+{
+	gcov_persist = (int) simple_strtol(str, NULL, 10);
+	return 1;
+}
+
+__setup("gcov_persist=", gcov_persist_setup);
+
+
+/* Called when 'gcov_link' is specified on the kernel command line. */
+static int __init
+gcov_link_setup(char *str)
+{
+	gcov_link = (int) simple_strtol(str, NULL, 10);
+	return 1;
+}
+
+__setup("gcov_link=", gcov_link_setup);
+#endif /* MODULE */
+
+
+/* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.
+ * Return a non-zero value if VALUE requires more than BYTES*8-1 bits
+ * to store (adapted from gcc/gcov-io.h). */
+static int
+store_gcov_type(gcov_type value, char *dest, size_t bytes)
+{
+	int upper_bit = (value < 0 ? 128 : 0);
+	size_t i;
+
+	if (value < 0) {
+		gcov_type oldvalue = value;
+		value = -value;
+		if (oldvalue != -value)
+			return 1;
+	}
+
+	for (i = 0 ; i < (sizeof(value) < bytes ? sizeof(value) : bytes) ;
+	     i++) {
+		dest[i] = value & (i == (bytes - 1) ? 127 : 255);
+		value = value / 256;
+	}
+
+	if (value && value != -1)
+		return 1;
+
+	for(; i < bytes ; i++)
+		dest[i] = 0;
+	dest[bytes - 1] |= upper_bit;
+	return 0;
+}
+
+
+/* Return size of header which precedes .da file entry associated with BB
+ * in the vmlinux file. */
+static inline size_t
+sizeof_vmlinux_header(struct bb *bb)
+{
+	return 8 + PAD8(strlen(bb->filename) + 1);
+}
+
+
+/* Store data of header which precedes .da file entry associated with NODE
+ * in the vmlinux file to userspace memory at BUF. OFFSET specifies the offset
+ * inside the header file. COUNT is the maximum number of bytes to store.
+ * Return the number of bytes stored, zero for EOF or a negative number in
+ * case of error. */
+static ssize_t
+store_vmlinux_header(struct gcov_ftree_node *node, char *buf, size_t count,
+		     loff_t offset)
+{
+	char data[8];
+	char *from;
+	size_t namelen;
+	ssize_t stored;
+	size_t len;
+
+	namelen = strlen(node->bb->filename);
+	stored = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			/* Filename length */
+			if (store_gcov_type(PAD8(namelen + 1), data, 8))
+				return -EINVAL;
+			from = data + offset;
+			len = 8 - offset;
+		} else if (offset < 8 + namelen) {
+			/* Filename */
+			from = (char *) node->bb->filename + offset - 8;
+			len = namelen - (offset - 8);
+		} else if (offset < node->header_size) {
+			/* Nil byte padding */
+			memset(data, 0, 8);
+			from = data;
+			len = PAD8(namelen + 1) - (offset - 8);
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+
+	return stored;
+}
+
+
+#if GCC_VERSION_LOWER(3, 3)
+/*
+ *  pre-gcc 3.3 functions
+ */
+static const char* gcov_proc_format = "pre-gcc 3.3";
+
+
+/* Return size of .da file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	return (bb->ncounts + 1) * 8;
+}
+
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	char data[8];
+	char *from;
+	ssize_t stored;
+	size_t len;
+
+	stored = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			/* Number of counts */
+			if (store_gcov_type(node->bb->ncounts, data, 8))
+				return -EINVAL;
+			from = data + offset;
+			len = 8 - offset;
+		} else if (offset < node->da_size) {
+			/* Count data */
+			if (store_gcov_type(node->bb->counts[(offset - 8) / 8],
+					    data, 8))
+				return -EINVAL;
+			from = data + offset % 8;
+			len = 8 - offset % 8;
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+	return stored;
+}
+
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+
+/*
+ *   gcc 3.3 specific functions (hammer patch)
+ */
+static const char* gcov_proc_format = "gcc 3.3 (hammer)";
+
+
+/* Return length of string encoded in GCOV format. */
+static size_t
+sizeof_str(const char *str)
+{
+	size_t len;
+
+	len = strlen(str);
+	if (len == 0)
+		return 4;
+
+	return 4 + len + 4 - (len & 3);
+}
+
+
+/* Return length of counter section encoded in GCOV format. */
+static size_t
+sizeof_counter_data(const struct counter_section *section)
+{
+	return /* tag */ 4 + /* length */ 4 +
+	       /* counters */ section->n_counters * 8;
+}
+
+
+/* Return length of function section encoded in GCOV format. */
+static size_t
+sizeof_func_data(const struct function_info *fn)
+{
+	size_t sec_len;
+	unsigned int i;
+
+	sec_len = 0;
+	for (i=0; i < fn->n_counter_sections; i++)
+		sec_len += sizeof_counter_data(&fn->counter_sections[i]);
+
+	return /* tag */ 4 + /* length */ 4 + sizeof_str(fn->name) +
+	       /* checksum */ 4 + sec_len;
+}
+
+
+/* Return length of node data encoded in GCOV format. */
+static size_t
+sizeof_da_file(struct bb *bb)
+{
+	size_t fn_len;
+	unsigned int i;
+
+	fn_len = 0;
+	for (i=0; i < bb->n_functions; i++)
+		fn_len += sizeof_func_data(&bb->functions[i]);
+	return /* magic */ 4 + /* version */ 4 + fn_len;
+}
+
+
+/* Store a 32 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static void
+store_unsigned(unsigned int v, unsigned char *buf)
+{
+	int i;
+
+	for (i=0; i < 4; i++) {
+		buf[3 - i] = v & 0xff;
+		v >>= 8;
+	}
+}
+
+
+/* Store a 64 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static void
+store_counter(gcov_type v, unsigned char *buf)
+{
+	int i;
+
+	for (i=0; i < 8; i++) {
+		buf[7 - i] = v & 0xff;
+		v >>= 8;
+	}
+}
+
+
+/* Find counter section data with given TAG. Return number if found, -EINVAL
+ * otherwise. */
+static long
+find_count_section(struct bb *bb, unsigned int tag)
+{
+	unsigned int i;
+
+	for (i=0; i < bb->n_counter_sections; i++)
+		if (bb->counter_sections[i].tag == tag)
+			return i;
+
+	return -EINVAL;
+}
+
+
+/* Store a string in GCOV format in userspace memory. The string is passed in
+ * STR. The destination address is BUF. Store at most COUNT bytes beginning at
+ * OFFSET. Return the number of bytes stored or a negative value on error. */
+static ssize_t
+store_string_data(const char *str, char *buf, size_t count, loff_t offset)
+{
+	const char *from;
+	char data[8];
+	size_t len;
+	ssize_t result;
+	size_t str_len;
+
+	str_len = strlen(str);
+	result = 0;
+	while (count > 0) {
+		if (offset < 4) {
+			/* Tag ID */
+			store_unsigned(str_len, data);
+			len = 4 - offset;
+			from = data + offset;
+		} else if (offset < 4 + str_len) {
+			/* String */
+			len = str_len - (offset - 4);
+			from = str + (offset - 4);
+		} else if (offset < sizeof_str(str)) {
+			/* Nil byte padding */
+			store_unsigned(0, data);
+			len = 4 - (str_len & 3) - (offset - 4 - str_len);
+			from = data;
+		} else
+			/* EOF */
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store a counter section in userspace memory. The counter section is
+ * identified by BB, FUNC and SEC. The destination address is BUF. Store at
+ * most COUNT bytes beginning at OFFSET. Return the number of bytes stored or a
+ * negative value on error. */
+static ssize_t
+store_counter_data(struct bb *bb, unsigned int func, unsigned int sec,
+		   gcov_type ***counters, char *buf, size_t count,
+		   loff_t offset)
+{
+	const struct function_info *func_ptr;
+	char data[8];
+	char *from;
+	size_t len;
+	ssize_t result;
+	unsigned int i;
+
+	func_ptr = &bb->functions[func];
+	result = 0;
+	while (count > 0) {
+		if (offset < 4) {
+			/* Tag ID */
+			store_unsigned(func_ptr->counter_sections[sec].tag,
+				       data);
+			len = 4 - offset;
+			from = data + offset;
+		} else if (offset < 8) {
+			/* Tag length in bytes */
+			store_unsigned(
+				func_ptr->counter_sections[sec].n_counters * 8,
+				data);
+			len = 4 - (offset - 4);
+			from = data + (offset - 4);
+		} else {
+			/* Actual counter data */
+			i = (offset - 8) / 8;
+			/* Check for EOF */
+			if (i >= func_ptr->counter_sections[sec].n_counters)
+				break;
+			store_counter(*(counters[func][sec] + i), data);
+			len = 8 - (offset - 8) % 8;
+			from = data + (offset - 8) % 8;
+		}
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store a function section and associated counter sections in userspace memory.
+ * The function section is identified by BB and FUNC. The destination address is
+ * BUF. Store at most COUNT bytes beginning at OFFSET. Return the number of
+ * bytes stored or a negative value on error. */
+static ssize_t
+store_func_data(struct bb *bb, unsigned int func, gcov_type ***counters,
+		char *buf, size_t count, loff_t offset)
+{
+	const struct function_info *func_ptr;
+	char data[4];
+	char *from;
+	size_t len;
+	ssize_t result;
+	ssize_t rc;
+	size_t name_len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+
+	func_ptr = &bb->functions[func];
+	name_len = sizeof_str(func_ptr->name);
+	result = 0;
+	from = NULL;
+	len = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			if (offset < 4) {
+				/* Tag ID */
+				store_unsigned(GCOV_TAG_FUNCTION, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* Tag length */
+				store_unsigned(name_len + 4, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else if (offset < 8 + name_len) {
+			/* Function name */
+			rc = store_string_data(func_ptr->name, buf, count,
+					       offset - 8);
+			if (rc < 0)
+				return rc;
+			len = rc;
+		} else if (offset < 8 + name_len + 4) {
+			/* Function checksum */
+			store_unsigned(func_ptr->checksum, data);
+			len = 4 - (offset - (8 + name_len));
+			from = data + (offset - (8 + name_len));
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 8 + name_len + 4;
+			len = 0;
+			for (i=0; i < func_ptr->n_counter_sections; i++) {
+				size = sizeof_counter_data(
+					&func_ptr->counter_sections[i]);
+				if (offset < off + size) {
+					rc = store_counter_data(bb, func, i,
+								counters,
+								buf, count,
+								offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (len == 0)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Allocate and initialize counter pointer array for BB. Return zero on
+ * success, non-zero otherwise. The array will have the following content:
+ *
+ *   counters[function_index][counter_section_index] = pointer to first count */
+static int
+create_counters_array(struct bb *bb, gcov_type ****counters)
+{
+	unsigned int f;
+	long bb_c;
+	unsigned int fn_c;
+	unsigned int max_c;
+	gcov_type ***fn_counters;
+	gcov_type **bb_counters;
+	const struct function_info *fn;
+	const struct counter_section *sec;
+
+	/* Calculate maximum number of counter_sections */
+	max_c = 0;
+	for (f=0; f < bb->n_functions; f++)
+		if (bb->functions[f].n_counter_sections > max_c)
+			max_c = bb->functions[f].n_counter_sections;
+	fn_counters = kmalloc(bb->n_functions * sizeof(gcov_type **) +
+			      bb->n_functions * max_c * sizeof(gcov_type *),
+			      GFP_KERNEL);
+	if (!fn_counters)
+		return -ENOMEM;
+	for (f=0; f < bb->n_functions; f++)
+		fn_counters[f] =
+			((gcov_type **) &fn_counters[bb->n_functions]) +
+			f * max_c;
+	bb_counters = kmalloc(bb->n_counter_sections * sizeof(gcov_type *),
+			      GFP_KERNEL);
+	if (!bb_counters) {
+		kfree(fn_counters);
+		return -ENOMEM;
+	}
+	/* Initialize arrays */
+	for (bb_c=0; bb_c < bb->n_counter_sections; bb_c++)
+		bb_counters[bb_c] = bb->counter_sections[bb_c].counters;
+	for (f=0; f < bb->n_functions; f++) {
+		fn = &bb->functions[f];
+		for (fn_c=0; fn_c < fn->n_counter_sections; fn_c++) {
+			sec = &fn->counter_sections[fn_c];
+			bb_c = find_count_section(bb, sec->tag);
+			if (bb_c < 0) {
+				/* Tag not found */
+				kfree(fn_counters);
+				kfree(bb_counters);
+				return -EINVAL;
+			}
+			fn_counters[f][fn_c] = bb_counters[bb_c];
+			bb_counters[bb_c] += sec->n_counters;
+		}
+	}
+	kfree(bb_counters);
+	*counters = fn_counters;
+	return 0;
+}
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb *bb;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+	gcov_type ***counters;
+
+	bb = node->bb;
+	rc = create_counters_array(bb, &counters);
+	if (rc)
+		return rc;
+	result = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			if (offset < 4) {
+				/* File magic */
+				store_unsigned(GCOV_DATA_MAGIC, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else {
+				/* File format/GCC version */
+				store_unsigned(gcov_version, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len)) {
+				kfree(counters);
+				return -EFAULT;
+			}
+		} else {
+			off = 8;
+			len = 0;
+			for (i=0; i < bb->n_functions; i++) {
+				size = sizeof_func_data(&bb->functions[i]);
+				if (offset < off + size) {
+					rc = store_func_data(bb, i, counters,
+							     buf, count,
+							     offset - off);
+					if (rc < 0) {
+						kfree(counters);
+						return rc;
+					}
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (len == 0)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	kfree(counters);
+	return result;
+}
+
+#elif GCC_VERSION_LOWER(3, 4)
+
+/*
+ *   gcc 3.3 specific functions (unmodified)
+ */
+static const char* gcov_proc_format = "gcc 3.3";
+
+
+/* Return size of .da file section associated with function data FUNC. */
+static inline size_t
+sizeof_func_info(struct bb_function_info *func)
+{
+	return (size_t)
+	       (/* delim */ 4 + /* strlen */ 4 + PAD4(strlen(func->name) + 1) +
+	        /* delim */ 4 + /* checksum */ 4 + /* arc_count */ 4 +
+	        /* count values */ func->arc_count * 8);
+}
+
+
+/* Return size of .da file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	struct bb_function_info *func;
+	size_t size;
+
+	size = ( /* magic */ 4 + /* num_func */ 4 + /* num_extra */ 4);
+	for (func = bb->function_infos; func->arc_count != -1; func++)
+		size += sizeof_func_info(func);
+	return size;
+}
+
+
+/* Return the number of functions associated with BB. */
+static inline gcov_type
+count_functions(struct bb *bb)
+{
+	gcov_type result;
+
+	for (result = 0; bb->function_infos[result].arc_count != -1;
+	     result++);
+	return result;
+}
+
+
+/* Return non-zero if OFFSET is within the range START <= OFFSET < START + SIZE,
+ * zero otherwise. Update REL_OFF to contain the relative offset inside the
+ * range, SIZE_VAR to contain the range size and START to point to the next
+ * range after this one. */
+static inline int in_range(loff_t offset, size_t size, loff_t *rel_off,
+			   loff_t *start, size_t *size_var)
+{
+	int result;
+
+	result = (offset >= *start) && (offset < *start + size);
+	*rel_off = offset - *start;
+	*start += size;
+	*size_var = size;
+	return result;
+}
+
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb_function_info *func;
+	gcov_type *count_ptr;
+	char data[8];
+	char *from;
+	ssize_t stored;
+	size_t len;
+	size_t size;
+	size_t func_off;
+	size_t next_off;
+	loff_t rel_off;
+	loff_t start;
+
+	func_off = 0;
+	func = NULL;
+	count_ptr = NULL;
+	stored = 0;
+	while (count > 0) {
+		start = 0;
+		if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Magic */
+			if (store_gcov_type(-123, data, 4))
+				return -EINVAL;
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Number of functions */
+			if (store_gcov_type(count_functions(node->bb),
+					    data, 4))
+				return -EINVAL;
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Size of extra data */
+			store_gcov_type(0, data, 4);
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (offset < node->da_size) {
+			/* Function data */
+			rel_off = offset - 12;
+			/* Try to minimize search effort */
+			if (!(func && (func_off <= rel_off))) {
+				func = node->bb->function_infos;
+				func_off = 0;
+				count_ptr = node->bb->counts;
+			}
+			/* Find function which is hit by offset */
+			for (; func->arc_count != -1; func++) {
+				next_off = func_off + sizeof_func_info(func);
+				if (next_off > rel_off)
+					break;
+				func_off = next_off;
+				count_ptr += func->arc_count;
+			}
+			start = 0;
+			if (in_range(offset - func_off - 12, 4, &rel_off,
+				     &start, &size)) {
+				/* String delimiter */
+				store_gcov_type(-1, data, 4);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* String length */
+				if (store_gcov_type(strlen(func->name),
+						    data, 4))
+					return -EINVAL;
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   strlen(func->name), &rel_off, &start,
+				   &size)) {
+				/* Function name */
+				from = (char *) func->name + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   PAD4(strlen(func->name) + 1) -
+				   strlen(func->name), &rel_off, &start,
+				   &size)) {
+				/* Nil byte padding */
+				memset(data, 0, size);
+				from = data;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* String delimiter */
+				store_gcov_type(-1, data, size);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* Checksum */
+				store_gcov_type(func->checksum, data, 4);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* Number of arcs */
+				if (store_gcov_type(func->arc_count, data, 4))
+					return -EINVAL;
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   func->arc_count * 8, &rel_off, &start,
+				   &size)) {
+				/* Counts */
+				if (store_gcov_type(count_ptr[rel_off / 8],
+						    data, 8))
+					return -EINVAL;
+				from = data + rel_off % 8;
+				len = 8 - rel_off % 8;
+			} else {
+				break;
+			}
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+	return stored;
+}
+
+#else /* GCC_VERSION */
+
+/*
+ *  gcc 3.4 functions
+ */
+static const char* gcov_proc_format = "gcc 3.4";
+
+/* Determine whether counter TYPE is active in BB. */
+static inline int
+counter_active(struct bb *bb, unsigned int type)
+{
+	return (1 << type) & bb->ctr_mask;
+}
+
+
+/* Return the number of active counter types for BB. */
+static inline unsigned int
+num_counter_active(struct bb *bb)
+{
+	unsigned int i;
+	unsigned int result;
+
+	result = 0;
+	for (i=0; i < GCOV_COUNTERS; i++)
+		if (counter_active(bb, i))
+			result++;
+	return result;
+}
+
+
+/* Get number of bytes used for one entry in the gcov_fn_info array pointed to
+ * by BB->functions. */
+static inline unsigned int
+get_fn_stride(struct bb *bb)
+{
+	unsigned int stride;
+
+	stride = sizeof(struct gcov_fn_info) + num_counter_active(bb) *
+		 sizeof(unsigned int);
+	if (__alignof__(struct gcov_fn_info) > sizeof(unsigned int)) {
+		stride += __alignof__(struct gcov_fn_info) - 1;
+		stride &= ~(__alignof__(struct gcov_fn_info) - 1);
+	}
+	return stride;
+}
+
+
+/* Get the address of gcov_fn_info for function FUNC of BB. */
+static inline struct gcov_fn_info *
+get_fn_info(struct bb *bb, unsigned int func)
+{
+	return (struct gcov_fn_info *)
+		((char *) bb->functions + func * get_fn_stride(bb));
+}
+
+
+/* Return size of .gcda counter section. */
+static inline size_t
+sizeof_counter_data(struct bb *bb, struct gcov_fn_info *func, unsigned int type)
+{
+	if (counter_active(bb, type)) {
+		return /* tag */ 4 + /* length */ 4 +
+		       /* counters */ func->n_ctrs[type] * 8;
+	} else
+		return 0;
+}
+
+
+/* Return size of .gcda data section associated with FUNC.  */
+static inline size_t
+sizeof_func_data(struct bb *bb, struct gcov_fn_info *func)
+{
+	size_t result;
+	unsigned int type;
+
+	result = /* tag */ 4 + /* length */ 4 + /* ident */ 4+
+		 /* checksum */ 4;
+	for (type=0; type < GCOV_COUNTERS; type++)
+		result += sizeof_counter_data(bb, func, type);
+	return result;
+}
+
+
+/* Get size of .gcda file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	size_t result;
+	unsigned int i;
+
+	result = /* magic */ 4 + /* version */ 4 + /* stamp */ 4;
+	for (i=0; i < bb->n_functions; i++)
+		result += sizeof_func_data(bb, get_fn_info(bb, i));
+	return result;
+}
+
+
+/* Store a 32 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static inline void
+store_int32(uint32_t i, char *buf)
+{
+	uint32_t *p;
+
+	p = (int *) buf;
+	*p = i;
+}
+
+
+/* Store a 64 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static inline void
+store_int64(uint64_t i, char *buf)
+{
+	store_int32((uint32_t) (i & 0xffff), buf);
+	store_int32((uint32_t) (i >> 32), buf + 4);
+}
+
+
+/* Store a gcov counter in GCOV format to memory at address BUF. The counter is
+ * identified by BB, FUNC, TYPE and COUNTER. */
+static inline void
+store_counter(struct bb *bb, unsigned int func, unsigned int type,
+	      unsigned int counter, char *buf)
+{
+	unsigned int counter_off;
+	unsigned int type_off;
+	unsigned int i;
+
+	/* Get offset into counts array */
+	type_off = 0;
+	for (i=0; i < type; i++)
+		if (counter_active(bb, i))
+			type_off++;
+	/* Get offset into values array. */
+	counter_off = counter;
+	for (i=0; i < func; i++)
+		counter_off += get_fn_info(bb, i)->n_ctrs[type];
+	/* Create in temporary storage */
+	store_int64(bb->counts[type_off].values[counter_off], buf);
+}
+
+
+/* Store a counter section in userspace memory. The counter section is
+ * identified by BB, FUNC and TYPE. The destination address is BUF. Store at
+ * most COUNT bytes beginning at OFFSET. Return the number of bytes stored or a
+ * negative value on error. */
+static inline ssize_t
+store_counter_data(struct bb *bb, unsigned int func, unsigned int type,
+		  char *buf, size_t count, loff_t offset)
+{
+	struct gcov_fn_info *func_ptr;
+	char data[8];
+	char *from;
+	size_t len;
+	ssize_t result;
+	unsigned int i;
+
+	func_ptr = get_fn_info(bb, func);
+	result = 0;
+	while (count > 0) {
+		if (offset < 4) {
+			/* Tag ID */
+			store_int32((uint32_t) GCOV_TAG_FOR_COUNTER(type),
+				    data);
+			len = 4 - offset;
+			from = data + offset;
+		} else if (offset < 8) {
+			/* Tag length in groups of 4 bytes */
+			store_int32((uint32_t)
+				    func_ptr->n_ctrs[type] * 2, data);
+			len = 4 - (offset - 4);
+			from = data + (offset - 4);
+		} else {
+			/* Actual counter data */
+			i = (offset - 8) / 8;
+			/* Check for EOF */
+			if (i >= func_ptr->n_ctrs[type])
+				break;
+			store_counter(bb, func, type, i, data);
+			len = 8 - (offset - 8) % 8;
+			from = data + (offset - 8) % 8;
+		}
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store a function section and associated counter sections in userspace memory.
+ * The function section is identified by BB and FUNC. The destination address is
+ * BUF. Store at most COUNT bytes beginning at OFFSET. Return the number of
+ * bytes stored or a negative value on error. */
+static inline ssize_t
+store_func_data(struct bb *bb, unsigned int func, char *buf,
+		size_t count, loff_t offset)
+{
+	struct gcov_fn_info *func_ptr;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+
+	func_ptr = get_fn_info(bb, func);
+	result = 0;
+	while (count > 0) {
+		if (offset < 16) {
+			if (offset < 4) {
+				/* Tag ID */
+				store_int32((uint32_t) GCOV_TAG_FUNCTION, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* Tag length */
+				store_int32(2, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			} else if (offset < 12) {
+				/* Function ident */
+				store_int32((uint32_t) func_ptr->ident, data);
+				len = 4 - (offset - 8);
+				from = data + (offset - 8);
+			} else {
+				/* Function checksum */
+				store_int32((uint32_t) func_ptr->checksum,
+					    data);
+				len = 4 - (offset - 12);
+				from = data + (offset - 12);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 16;
+			len = 0;
+			for (i=0; i < GCOV_COUNTERS; i++) {
+				size = sizeof_counter_data(bb, func_ptr, i);
+				if (offset < off + size) {
+					rc = store_counter_data(bb, func, i,
+								buf, count,
+								offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (i == GCOV_COUNTERS)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store data of .gcda file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb *bb;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+
+	bb = node->bb;
+	result = 0;
+	while (count > 0) {
+		if (offset < 12) {
+			if (offset < 4) {
+				/* File magic */
+				store_int32((uint32_t) GCOV_DATA_MAGIC, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* File format/GCC version */
+				store_int32(gcov_version, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			} else {
+				/* Time stamp */
+				store_int32((uint32_t) bb->stamp, data);
+				len = 4 - (offset - 8);
+				from = data + (offset - 8);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 12;
+			len = 0;
+			for (i=0; i < bb->n_functions; i++) {
+				size = sizeof_func_data(bb, get_fn_info(bb, i));
+				if (offset < off + size) {
+					rc = store_func_data(bb, i, buf, count,
+							     offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (i == bb->n_functions)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+#endif /* GCC_VERSION */
+
+
+/* Update data related to vmlinux file. */
+static void
+update_vmlinux_data(void)
+{
+	struct gcov_ftree_node *node;
+	loff_t offset;
+
+	offset = 0;
+	for (node = leaf_nodes; node; node = node->next) {
+		node->offset = offset;
+		node->da_size = sizeof_da_file(node->bb);
+		node->header_size = sizeof_vmlinux_header(node->bb);
+		offset += node->header_size + node->da_size;
+	}
+	proc_vmlinux->size = offset;
+	cached_node = NULL;
+}
+
+
+/* Read .da or vmlinux file. */
+static ssize_t
+read_gcov(struct file *file, char *buf, size_t count, loff_t *pos)
+{
+	struct gcov_ftree_node *node;
+	struct proc_dir_entry *dir_entry;
+	ssize_t rc;
+
+	down(&gcov_lock);
+	dir_entry = PDE(file->f_dentry->d_inode);
+	rc = 0;
+	if (dir_entry == proc_vmlinux) {
+		/* Are we in a sequential read? */
+		if (cached_node && (*pos >= cached_node->offset))
+			node = cached_node;
+		else
+			node = leaf_nodes;
+		/* Find node corresponding to offset */
+		while (node && node->next && (*pos >= node->next->offset))
+			node = node->next;
+		cached_node = node;
+		if (node) {
+			if (*pos - node->offset < node->header_size)
+				rc = store_vmlinux_header(node, buf, count,
+							  *pos - node->offset);
+			else
+				rc = store_da_file(node, buf, count,
+						   *pos - node->offset -
+							node->header_size);
+		}
+	} else {
+		node = (struct gcov_ftree_node *) dir_entry->data;
+		if (node)
+			rc = store_da_file(node, buf, count, *pos);
+	}
+	if (rc > 0)
+		*pos += rc;
+	up(&gcov_lock);
+	return rc;
+}
+
+
+static inline void
+reset_bb(struct bb* bb)
+{
+#if GCC_VERSION_EQUAL(3,3) && defined(CONFIG_GCOV_HAMMER)
+	unsigned int i;
+
+	for (i=0; i < bb->n_counter_sections; i++)
+		memset(bb->counter_sections[i].counters, 0,
+		       bb->counter_sections[i].n_counters * sizeof(gcov_type));
+#elif GCC_VERSION_LOWER(3, 4)
+	memset(bb->counts, 0, bb->ncounts * sizeof(gcov_type));
+#else /* GCC_VERSION */
+	const struct gcov_ctr_info *ctr;
+	unsigned int i;
+
+	ctr = bb->counts;
+	for (i=0; i < GCOV_COUNTERS; i++)
+		if (counter_active(bb, i)) {
+			memset(ctr->values, 0, ctr->num * sizeof(gcov_type));
+			ctr++;
+		}
+#endif /* GCC_VERSION */
+}
+
+
+static void cleanup_node_and_path(struct gcov_ftree_node *node);
+
+/* Reset counters on write request. */
+static ssize_t
+write_gcov(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	struct gcov_ftree_node *node;
+	struct gcov_ftree_node *next;
+	struct proc_dir_entry *dir_entry;
+
+	down(&gcov_lock);
+	dir_entry = PDE(file->f_dentry->d_inode);
+	if (dir_entry == proc_vmlinux) {
+		/* Reset all nodes */
+		node = leaf_nodes;
+		while (node) {
+			next = node->next;
+			/* Delete ghosted nodes */
+			if (node->status == status_ghost)
+				cleanup_node_and_path(node);
+			else
+				reset_bb(node->bb);
+			node = next;
+		}
+		/* Nodes may have been deleted - update data */
+		if (gcov_persist)
+			update_vmlinux_data();
+	} else {
+		node = (struct gcov_ftree_node *) dir_entry->data;
+		reset_bb(node->bb);
+	}
+	up(&gcov_lock);
+	return count;
+}
+
+
+/* Return a newly allocated copy of STRING. */
+static inline char *
+strdup(const char *string)
+{
+	char *result;
+
+	result = (char *) kmalloc(strlen(string) + 1, GFP_KERNEL);
+	if (result)
+		strcpy(result, string);
+	return result;
+}
+
+
+/* Allocate a new node and fill in NAME and BB. */
+static struct gcov_ftree_node *
+alloc_node(const char *name, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+
+	node = (struct gcov_ftree_node *)
+		kmalloc(sizeof(struct gcov_ftree_node), GFP_KERNEL);
+	if (!node)
+		return NULL;
+	memset(node, 0, sizeof(struct gcov_ftree_node));
+	node->fname = strdup(name);
+	if (!node->fname) {
+		kfree(node);
+		return NULL;
+	}
+	node->bb = bb;
+	node->status = status_normal;
+	return node;
+}
+
+
+/* Free memory allocated for BB. */
+static void
+free_bb(struct bb *bb)
+{
+#if GCC_VERSION_LOWER(3,4)
+	kfree(bb);
+#else /* GCC_VERSION */
+	kfree(bb->functions);
+	kfree(bb);
+#endif /* GCC_VERSION */
+}
+
+
+/* Free memory allocated for NODE. */
+static void
+free_node(struct gcov_ftree_node *node)
+{
+	if (node == &tree_root)
+		return;
+	if (node->fname)
+		kfree(node->fname);
+	if (node->status == status_ghost)
+		free_bb(node->bb);
+	kfree(node);
+}
+
+
+/* Remove proc filesystem entries associated with NODE. */
+static void
+delete_from_proc(struct gcov_ftree_node *node)
+{
+	struct proc_dir_entry *parent;
+	int i;
+
+	if (node->parent)
+		parent = node->parent->proc[0];
+	else
+		parent = NULL;
+	for (i = 0; i < sizeof(node->proc) / sizeof(node->proc[0]); i++)
+		if (node->proc[i])
+			remove_proc_entry(node->proc[i]->name, parent);
+}
+
+
+/* Release all resources associated with NODE. If NODE is a directory node,
+ * also clean up all children. */
+static void
+cleanup_node(struct gcov_ftree_node *node)
+{
+	struct gcov_ftree_node *curr;
+	struct gcov_ftree_node *next;
+	struct gcov_ftree_node *prev;
+
+	next = node;
+	do {
+		/* Depth first traversal of all children */
+		curr = next;
+		while (curr->files)
+			curr = curr->files;
+		if (curr->sibling)
+			next = curr->sibling;
+		else
+			next = curr->parent;
+		/* Remove from tree */
+		if (curr->parent) {
+			if (curr->parent->files == curr)
+				curr->parent->files = curr->sibling;
+			else {
+				for (prev = curr->parent->files;
+				     prev->sibling != curr;
+				     prev = prev->sibling);
+				prev->sibling = curr->sibling;
+			}
+		}
+		/* Remove from leaf node list if necessary */
+		if (curr->bb) {
+			if (leaf_nodes == curr)
+				leaf_nodes = curr->next;
+			else {
+				for (prev = leaf_nodes;
+				     prev && (prev->next != curr);
+				     prev = prev->next);
+				if (prev)
+					prev->next = curr->next;
+			}
+		}
+		/* Delete node */
+		delete_from_proc(curr);
+		free_node(curr);
+	} while (node != curr);
+}
+
+
+/* Clean up NODE and containing path in case it would be left empty. */
+static void
+cleanup_node_and_path(struct gcov_ftree_node *node)
+{
+	while (node->parent &&
+	       node->parent != &tree_root &&
+	       !node->parent->files->sibling)
+		node = node->parent;
+	cleanup_node(node);
+}
+
+
+/* Create a new directory node named NAME under PARENT. Upon success return
+ * zero and update RESULT to point to the newly created node. Return non-zero
+ * otherwise. */
+static int
+create_dir_node(struct gcov_ftree_node *parent, char *name,
+		struct gcov_ftree_node **result)
+{
+	struct gcov_ftree_node *node;
+
+	/* Initialize new node */
+	node = alloc_node(name, NULL);
+	if (!node)
+		return -ENOMEM;
+	/* Create proc filesystem entry */
+	node->proc[0] = proc_mkdir(name, parent->proc[0]);
+	if (!node->proc[0]) {
+		free_node(node);
+		return -EIO;
+	}
+	/* Insert node into tree */
+	node->parent = parent;
+	node->sibling = parent->files;
+	parent->files = node;
+	*result = node;
+	return 0;
+}
+
+
+static struct file_operations proc_gcov_operations = {
+	read: read_gcov,
+	write: write_gcov,
+	owner: THIS_MODULE
+};
+
+/* Create a new file node named NAME under PARENT. Associate node with BB.
+ * Return zero upon success, non-zero otherwise. */
+static int
+create_file_node(struct gcov_ftree_node *parent, char *name, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+	char *link_target;
+	char *link_name;
+	int i;
+
+	/* Initialize new node */
+	node = alloc_node(name, bb);
+	if (!node)
+		return -ENOMEM;
+	/* Create proc filesystem entry */
+	node->proc[0] = create_proc_entry(name, S_IWUSR | S_IRUGO,
+					  parent->proc[0]);
+	if (!node->proc[0]) {
+		free_node(node);
+		return -EIO;
+	}
+	node->proc[0]->data = node;
+	node->proc[0]->proc_fops = &proc_gcov_operations;
+	node->proc[0]->size = sizeof_da_file(bb);
+	/* Create symbolic links */
+	if (gcov_link) {
+		/* Note: temp string length is calculated as upper limit */
+		link_target = (char *) kmalloc(strlen(bb->filename) +
+					       strlen(da_ending) +
+					       strlen(gcov_sourcepath),
+					       GFP_KERNEL);
+		if (!link_target) {
+			delete_from_proc(node);
+			free_node(node);
+			return -ENOMEM;
+		}
+		for (i = 0; i < sizeof(endings) / sizeof(endings[0]); i++) {
+			if ((strcmp(endings[i], "c") == 0) &&
+			    (strcmp(gcov_sourcepath, gcov_objectpath) != 0) &&
+			    (strncmp(bb->filename, gcov_objectpath,
+				     objectpath_len) == 0)) {
+				strcpy(link_target, gcov_sourcepath);
+				strcat(link_target,
+				       bb->filename + objectpath_len);
+			} else {
+				strcpy(link_target, bb->filename);
+			}
+			link_target[strlen(link_target) -
+				    strlen(da_ending)] = 0;
+			strcat(link_target, endings[i]);
+			link_name = strrchr(link_target, '/') + 1;
+			node->proc[i + 1] = proc_symlink(link_name,
+							 parent->proc[0],
+							 link_target);
+			if (!node->proc[i + 1]) {
+				kfree(link_target);
+				delete_from_proc(node);
+				free_node(node);
+				return -EIO;
+			}
+		}
+		kfree(link_target);
+	}
+	/* Insert node into tree */
+	node->parent = parent;
+	node->sibling = parent->files;
+	parent->files = node;
+	node->next = leaf_nodes;
+	leaf_nodes = node;
+	return 0;
+}
+
+
+/* Return proc filesystem entry name for FILENAME. */
+static char *
+get_proc_filename(const char *filename)
+{
+	char *result;
+
+	/* Is this file located in the kernel source directory? */
+	if (strncmp(filename, gcov_objectpath, objectpath_len) == 0) {
+		/* Use relative path */
+		result = strdup(filename + objectpath_len + 1);
+	} else {
+		/* Use full path in module subdirectory */
+		result = (char *) kmalloc(strlen(GCOV_PROC_MODULE) +
+					  strlen(filename) + 1, GFP_KERNEL);
+		if (result) {
+			strcpy(result, GCOV_PROC_MODULE);
+			strcat(result, filename);
+		}
+	}
+	return result;
+}
+
+
+/* Create tree node and proc filesystem entry for BB. Create subdirectories as
+ * necessary. Return zero upon success, non-zero otherwise. */
+static int
+create_node(struct bb *bb)
+{
+	struct gcov_ftree_node *parent;
+	struct gcov_ftree_node *node;
+	char *filename;
+	char *curr;
+	char *next;
+	int rc;
+
+	filename = get_proc_filename(bb->filename);
+	if (!filename)
+		return -ENOMEM;
+	/* Recreate directory path in proc filesystem */
+	parent = &tree_root;
+	for (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {
+		/* Skip empty path components */
+		if (curr == next)
+			continue;
+		*next = 0;
+		/* Check whether directory already exists */
+		for (node = parent->files;
+		     node && (strcmp(node->fname, curr) != 0);
+		     node = node->sibling);
+		if (!node) {
+			/* Create directory node */
+			rc = create_dir_node(parent, curr, &node);
+			if (rc) {
+				if (parent != &tree_root)
+					cleanup_node_and_path(parent);
+				kfree(filename);
+				return rc;
+			}
+		}
+		parent = node;
+	}
+	rc = create_file_node(parent, curr, bb);
+	kfree(filename);
+	return rc;
+}
+
+
+/* Return a copy of BB which contains only data relevant to this module. */
+static struct bb *
+clone_bb(struct bb *bb)
+{
+	struct bb *result;
+	size_t len;
+
+#if GCC_VERSION_LOWER(3, 3)
+
+	/* Allocate memory */
+	len = sizeof(struct bb) + bb->ncounts * sizeof(gcov_type) +
+	      strlen(bb->filename) + 1;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Copy count data */
+	result->counts = (gcov_type *) (result + 1);
+	result->ncounts = bb->ncounts;
+	memcpy(result->counts, bb->counts, result->ncounts * sizeof(gcov_type));
+	/* Copy filename */
+	result->filename = (const char *) &result->counts[result->ncounts];
+	strcpy((char *) result->filename, bb->filename);
+
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+
+	unsigned int i;
+	unsigned char *curr;
+	struct function_info *func;
+	struct counter_section_data *sec;
+
+	/* Allocate memory */
+	len = sizeof(struct bb) +
+	      bb->n_functions * sizeof(struct function_info) +
+	      bb->n_counter_sections * sizeof(struct counter_section_data) +
+	      strlen(bb->filename) + 1;
+	for (i=0; i < bb->n_functions; i++) {
+		len += strlen(bb->functions[i].name) + 1;
+		len += bb->functions[i].n_counter_sections *
+		       sizeof(struct counter_section);
+	}
+	for (i=0 ; i < bb->n_counter_sections; i++)
+		len += bb->counter_sections[i].n_counters * sizeof(gcov_type);
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	curr = (unsigned char *) result + sizeof(struct bb);
+	/* Copy relevant function data */
+	result->n_functions = bb->n_functions;
+	result->functions = (struct function_info *) curr;
+	curr += sizeof(struct function_info) * bb->n_functions;
+	for (i=0; i < bb->n_functions; i++) {
+		func = (struct function_info *) &result->functions[i];
+		func->checksum = bb->functions[i].checksum;
+		func->n_counter_sections = bb->functions[i].n_counter_sections;
+		func->counter_sections = (struct counter_section *) curr;
+		curr += sizeof(struct counter_section) *
+			func->n_counter_sections;
+		memcpy((struct counter_section *) func->counter_sections,
+		       bb->functions[i].counter_sections,
+		       sizeof(struct counter_section) *
+		       func->n_counter_sections);
+	}
+	/* Copy relevant counter section data */
+	result->n_counter_sections = bb->n_counter_sections;
+	result->counter_sections = (struct counter_section_data *) curr;
+	curr += sizeof(struct counter_section_data) *
+		result->n_counter_sections;
+	for (i=0; i < bb->n_counter_sections; i++) {
+		sec = (struct counter_section_data *)
+			&result->counter_sections[i];
+		sec->tag = bb->counter_sections[i].tag;
+		sec->n_counters = bb->counter_sections[i].n_counters;
+		sec->counters = (gcov_type *) curr;
+		curr += sizeof(gcov_type) * sec->n_counters;
+		memcpy(sec->counters, bb->counter_sections[i].counters,
+		       sizeof(gcov_type) * sec->n_counters);
+	}
+	/* Copy filename */
+	result->filename = (char *) curr;
+	curr += strlen(bb->filename) + 1;
+	strcpy((char *) result->filename, bb->filename);
+	/* Copy function names */
+	for (i=0; i < bb->n_functions; i++) {
+		func = (struct function_info *) &result->functions[i];
+		func->name = (char *) curr;
+		curr += strlen(bb->functions[i].name) + 1;
+		strcpy((char *) func->name, bb->functions[i].name);
+	}
+
+#elif GCC_VERSION_LOWER(3, 4)
+
+	unsigned int i;
+	char *name;
+
+	/* Allocate memory */
+	len = sizeof(struct bb) + bb->ncounts * sizeof(gcov_type) +
+	      strlen(bb->filename) + 1 + sizeof(struct bb_function_info);
+	for (i = 0; bb->function_infos[i].arc_count != -1; i++)
+		len += sizeof(struct bb_function_info) +
+		       strlen(bb->function_infos[i].name) + 1;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Copy count data */
+	result->counts = (gcov_type *) (result + 1);
+	result->ncounts = bb->ncounts;
+	memcpy(result->counts, bb->counts, result->ncounts * sizeof(gcov_type));
+	/* Prepare copy of function infos */
+	result->function_infos = (struct bb_function_info *)
+					&result->counts[result->ncounts];
+	/* Copy filename */
+	result->filename = (const char *) &result->function_infos[i + 1];
+	strcpy((char *) result->filename, bb->filename);
+	/* Copy function infos */
+	name = (char *) result->filename + strlen(result->filename) + 1;
+	for (i = 0; bb->function_infos[i].arc_count != -1; i++) {
+		result->function_infos[i].checksum =
+			bb->function_infos[i].checksum;
+		result->function_infos[i].arc_count =
+			bb->function_infos[i].arc_count;
+		strcpy(name, bb->function_infos[i].name);
+		result->function_infos[i].name = name;
+		name += strlen(name) + 1;
+	}
+	result->function_infos[i].arc_count = -1;
+	result->sizeof_bb = bb->sizeof_bb;
+
+#else /* GCOV_VERSION */
+
+	unsigned int active;
+	unsigned int i;
+	char *name;
+	struct gcov_fn_info *func;
+
+	/* Allocate memory for struct bb */
+	active = num_counter_active(bb);
+	len = sizeof(struct bb) +
+	      sizeof(struct gcov_ctr_info) * active +
+	      strlen(bb->filename) + 1;
+	for (i=0; i < active; i++)
+		len += sizeof(gcov_type) * bb->counts[i].num;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Allocate memory for array of struct gcov_fn_info */
+	len = bb->n_functions * get_fn_stride(bb);
+	func = (struct gcov_fn_info *) kmalloc(len, GFP_KERNEL);
+	if (!func) {
+		kfree(result);
+		return NULL;
+	}
+	/* Copy function data */
+	memcpy(func, bb->functions, len);
+	result->functions = func;
+	/* Copy counts */
+	for (i=0; i < active; i++) {
+		result->counts[i].num = bb->counts[i].num;
+		result->counts[i].merge = bb->counts[i].merge;
+		if (i == 0) {
+			result->counts[i].values =
+				(gcov_type *) &result->counts[active];
+		} else {
+			result->counts[i].values =
+				result->counts[i - 1].values +
+				result->counts[i - 1].num;
+		}
+		memcpy(result->counts[i].values, bb->counts[i].values,
+		       sizeof(gcov_type) * result->counts[i].num);
+	}
+	/* Copy rest */
+	result->stamp = bb->stamp;
+	name = (char *) (result->counts[active - 1].values +
+			 result->counts[active - 1].num);
+	strcpy(name, bb->filename);
+	result->filename = name;
+	result->n_functions = bb->n_functions;
+	result->ctr_mask = bb->ctr_mask;
+
+#endif /* GCC_VERSION */
+
+	return result;
+}
+
+
+/* Return non-zero if BB1 and BB2 are compatible, zero otherwise. */
+static int
+is_compatible(struct bb *bb1, struct bb *bb2)
+{
+#if GCC_VERSION_LOWER(3, 3)
+	return (bb1->ncounts == bb2->ncounts);
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+	unsigned int i;
+
+	if (bb1->n_functions != bb2->n_functions ||
+	    bb1->n_counter_sections != bb2->n_counter_sections)
+		return 0;
+	for (i=0; i < bb1->n_counter_sections; i++)
+		if (bb1->counter_sections[i].tag !=
+			bb2->counter_sections[i].tag ||
+		    bb1->counter_sections[i].n_counters !=
+			bb2->counter_sections[i].n_counters)
+			return 0;
+	for (i=0; i < bb1->n_functions; i++) {
+		if (bb1->functions[i].checksum != bb2->functions[i].checksum ||
+		    bb1->functions[i].n_counter_sections !=
+			bb2->functions[i].n_counter_sections)
+			return 0;
+	}
+	return 1;
+#elif GCC_VERSION_LOWER(3, 4)
+	int i;
+
+	if ((bb1->ncounts != bb2->ncounts) ||
+	    (bb1->sizeof_bb != bb2->sizeof_bb))
+		return 0;
+	for (i = 0; (bb1->function_infos[i].arc_count != -1) &&
+		    (bb2->function_infos[i].arc_count != -1); i++)
+		if (bb1->function_infos[i].checksum !=
+		    bb2->function_infos[i].checksum)
+			return 0;
+	return (bb1->function_infos[i].arc_count == -1) &&
+	       (bb2->function_infos[i].arc_count == -1);
+#else /* GCC_VERSION */
+	return (bb1->stamp == bb2->stamp);
+#endif /* GCC_VERSION */
+}
+
+
+/* Add count data from SOURCE to DEST. */
+static void
+merge_bb(struct bb *dest, struct bb *source)
+{
+#if GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+	unsigned int i;
+	unsigned int j;
+
+	for (i=0; i < dest->n_counter_sections; i++)
+		for (j=0; j < dest->counter_sections[i].n_counters; j++)
+			dest->counter_sections[i].counters[j] +=
+				source->counter_sections[i].counters[j];
+#elif GCC_VERSION_LOWER(3, 4)
+	long i;
+
+	for (i = 0; i < dest->ncounts; i++)
+		dest->counts[i] += source->counts[i];
+#else /* GCC_VERSION */
+	unsigned int i;
+	unsigned int j;
+
+	for (i=0; i < num_counter_active(dest); i++)
+		for (j=0; j < dest->counts[i].num; j++)
+			dest->counts[i].values[j] +=
+				source->counts[i].values[j];
+#endif /* GCC_VERSION_LOWER */
+}
+
+
+/* If there is a ghosted node for BB, merge old and current data, set status
+ * to normal and return zero. Return non-zero otherwise. */
+static int
+revive_node(struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+
+	/* Check for a ghosted node */
+	for (node = leaf_nodes; node &&
+	     (strcmp(node->bb->filename, bb->filename) != 0);
+	     node=node->next);
+	if (!node)
+		return -ENOENT;
+	/* Check for compatible data */
+	if (!is_compatible(bb, node->bb)) {
+		printk(KERN_WARNING GCOV_PROC_HEADER "discarding saved data "
+		       "for %s due to incompatibilities\n", bb->filename);
+		cleanup_node_and_path(node);
+		update_vmlinux_data();
+		return -EINVAL;
+	}
+	/* Revive */
+	merge_bb(bb, node->bb);
+	kfree(node->bb);
+	node->bb = bb;
+	node->status = status_normal;
+	return 0;
+}
+
+
+/* Make a copy of the struct bb associated with node and set node status to
+ * ghost. Return zero on success, non-zero otherwise. */
+static int
+ghost_node(struct gcov_ftree_node *node)
+{
+	struct bb *bb;
+
+	/* Ghost node instead of removing it */
+	bb = clone_bb(node->bb);
+	if (!bb) {
+		printk(KERN_ERR GCOV_PROC_HEADER "not enough memory to save "
+		       "data for %s", node->bb->filename);
+		return -ENOMEM;
+	}
+	node->bb = bb;
+	node->status = status_ghost;
+	return 0;
+}
+
+
+/* Callback used to keep track of changes in the bb list. */
+static void
+gcov_proc_callback(enum gcov_cmd cmd, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+	int rc;
+
+	down(&gcov_lock);
+	switch (cmd) {
+	case gcov_add:
+		if (gcov_persist && (revive_node(bb) == 0))
+			break;
+		/* Insert node */
+		rc = create_node(bb);
+		if (rc) {
+			printk(KERN_ERR GCOV_PROC_HEADER "add failed: could "
+			       "not create node for %s (err=%d)\n",
+			       bb->filename, rc);
+		}
+		update_vmlinux_data();
+		break;
+	case gcov_remove:
+		/* Find node to remove */
+		for (node = leaf_nodes; node && (node->bb != bb);
+		     node=node->next);
+		if (!node)
+			break;
+		if (gcov_persist && (ghost_node(node) == 0))
+			break;
+		/* Remove node and empty path */
+		cleanup_node_and_path(node);
+		update_vmlinux_data();
+		break;
+	}
+	up(&gcov_lock);
+}
+
+
+/* Initialize module. */
+static int __init
+gcov_init_module(void)
+{
+	struct bb *bb;
+	int rc;
+
+	printk(KERN_INFO GCOV_PROC_HEADER "initializing proc module: "
+	       "persist=%d link=%d format=%s\n",
+	       gcov_persist, gcov_link, gcov_proc_format);
+	sema_init(&gcov_lock, 0);
+	sourcepath_len = strlen(gcov_sourcepath);
+	objectpath_len = strlen(gcov_objectpath);
+	/* Initialize root node and /proc/gcov entry */
+	tree_root.fname = GCOV_PROC_ROOT;
+	tree_root.proc[0] = proc_mkdir(tree_root.fname, NULL);
+	if (!tree_root.proc[0]) {
+		printk(KERN_ERR GCOV_PROC_HEADER "init failed: could not "
+		       "create root proc filesystem entry\n");
+		return -EIO;
+	}
+	/* Create /proc/gcov/vmlinux entry */
+	proc_vmlinux = create_proc_entry(GCOV_PROC_VMLINUX, S_IWUSR | S_IRUGO,
+					 tree_root.proc[0]);
+	if (!proc_vmlinux) {
+		printk(KERN_ERR GCOV_PROC_HEADER "init failed: could not "
+		       "create proc filesystem entry %s\n", GCOV_PROC_VMLINUX);
+		cleanup_node(&tree_root);
+		return -EIO;
+	}
+	proc_vmlinux->proc_fops = &proc_gcov_operations;
+	/* Initialize /proc/gcov tree */
+	down(&gcov_core_lock);
+	for (bb = bb_head; bb ; bb = bb->next) {
+		rc = create_node(bb);
+		if (rc) {
+			printk(KERN_ERR GCOV_PROC_HEADER "init failed: could "
+			       "not create node for %s (err=%d)\n",
+			       bb->filename, rc);
+			remove_proc_entry(proc_vmlinux->name,
+					  tree_root.proc[0]);
+			cleanup_node(&tree_root);
+			up(&gcov_core_lock);
+			return rc;
+		}
+	}
+	gcov_callback = gcov_proc_callback;
+	update_vmlinux_data();
+	up(&gcov_core_lock);
+	up(&gcov_lock);
+	printk(KERN_INFO GCOV_PROC_HEADER "init done\n");
+	return 0;
+}
+
+
+/* Clean up module data. */
+static void __exit
+gcov_cleanup_module(void)
+{
+	down(&gcov_lock);
+	gcov_callback = NULL;
+	remove_proc_entry(proc_vmlinux->name, tree_root.proc[0]);
+	cleanup_node(&tree_root);
+	printk(KERN_INFO GCOV_PROC_HEADER "proc module is now unloaded\n");
+}
+
+
+module_init(gcov_init_module);
+module_exit(gcov_cleanup_module);
diff --git a/kernel/kthread.c b/kernel/kthread.c
index 4fbc456..e06eb8a 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -13,6 +13,7 @@
 #include <linux/file.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#include <linux/lttlite-events.h>
 #include <trace/sched.h>
 
 #define KTHREAD_NICE_LEVEL (-5)
@@ -159,6 +160,10 @@ struct task_struct *kthread_create(int (*threadfn)(void *data),
 		vsnprintf(create.result->comm, sizeof(create.result->comm),
 			  namefmt, args);
 		va_end(args);
+#ifdef CONFIG_LTT_LITE
+		ltt_lite_ev_process(LTT_LITE_EV_PROCESS_COMM_CHANGE,
+			create.result);
+#endif
 	}
 	return create.result;
 }
diff --git a/kernel/ltt-lite.c b/kernel/ltt-lite.c
new file mode 100644
index 0000000..d088f80
--- /dev/null
+++ b/kernel/ltt-lite.c
@@ -0,0 +1,2737 @@
+/*
+ * ltt-lite - the core functions of ltt lite
+ *
+ * Copyright (C) Motorola 2006-2009
+ */
+
+/*
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+
+/*!
+ * @defgroup USER_SPACE_LTTLITE_PROC_DOCS /proc/lttlite
+ *
+ * Provides an interface to control Linux Trace Toolkit Lite (LTT-LITE)
+ * and to retrieve trace information created by it.
+ * When enabled, LTT-LITE creates a trace of significant system events
+ * (process switching by the Linux scheduler, system call entry and exit).
+ * This trace is stored (in binary form) in a regular file.
+ * This trace file can be processed to create a human-readable trace.
+ * LTT-LITE also keeps track of all processes in the system. It does this even
+ * when LTT-LITE is disabled.
+ *
+ * @section LttLiteInitProc User-space Device Names
+ * This driver supports the following devices in <code>/proc</code>:<br>
+ *
+ * @htmlonly
+ * <table cellpadding="2" cellspacing="1" width="100%">
+ * <tr halign="left" bgcolor="#D0D0D0"><td><b>Device Name</b></td>
+ * <td><b>Function</b></td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>/proc/lttlite/init</code></td>
+ * <td>When written, enables LTT-LITE in a specified mode or disables LTT-LITE.
+ * <br> When read, returns LTT-LITE working mode</td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>/proc/lttlite/config</code>
+ * </td><td>When written, sets certain features of LTT-LITE.
+ * <br> When read, returns the current config of LTT-LITE.</td></tr>
+ * </table>
+ * @endhtmlonly
+ *
+ * @example
+ * -bash-2.05b# echo 15 > /proc/lttlite/init
+ * @endexample
+ * The command above starts scheduling logging, system call logging
+ * memory profiling, and trap logging.
+ * The types of events are defined in bit manner:
+ * TRAP_LOGGING=8, MEMORY_PROFILING=4, SYSCALL_LOGGING=2, SCHEDULING_LOGGING=1.
+ * INT_LOGGING=16, SOFTIRQ_LOGGING=32
+ * A number between 0~15 corresponds to the various combination of
+ * the four types of events.
+ *
+ * @example
+ * -bash-2.05b# cat /proc/lttlite/init
+ * @endexample
+ * The command above read current log mode
+ *
+ * @example
+ * -bash-2.05b# echo "memint 1" > /proc/lttlite/config
+ * @endexample
+ * The command above sets the interval second of memory profiling.
+ * A number between 1~9 is valid. Its default value is 1.
+ *
+ * @example
+ * -bash-2.05b# echo "logfil /home/dlog" >/proc/lttlite/config
+ * @endexample
+ * The command above sets the name of the file in which LTT-LITE stores the
+ * trace it generates.
+ * The LTT-LITE trace file defaults to <code>/home/ltt_lite_profilelog</code>.
+ *
+ * @example
+ * -bash-2.05b# echo "sysftg 0" > /proc/lttlite/config
+ * @endexample
+ * The command above changes system call group id. A number between
+ * 0~5 is valid.
+ * <table cellpadding="2" cellspacing="1" width="100%">
+ * <tr halign="left" bgcolor="#D0D0D0"><td><b>Group ID</b></td>
+ * <td><b>Description</b></td><td><b>Syscalls included</b></td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>0</code></td>
+ * <td>default, log all system calls</td><td>all</td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>1</code></td>
+ * <td>file, contains system calls related to file operations</td>
+ * <td>read, write, open, close, creat, link,
+ * unlink, execve, chdir, mknod, chmod,
+ * lchown16, stat, lseek, mount, oldumount,
+ * fstat, utime, access, rename, mkdir,
+ * rmdir, dup, pipe, acct, umount,
+ * ioctl, fcntl, chroot, dup2, old_select,
+ * symlink, lstat, readlink, uselib, swapon,
+ * old_readdir, old_mmap, truncate, ftruncate,
+ * fchmod, fchown16, statfs, fstatfs,
+ * socketcall, newstat, newlstat, newfstat,
+ * fsync, fchdir, llseek, getdents, select,
+ * flock, readv, writev, fdatasync, poll,
+ * pread64, pwrite64, chown16, getcwd,
+ * sendfile, truncate64, ftruncate64, stat64,
+ * lstat64, fstat64, lchown, fchown,
+ * chown, getdents64, pivot_root, fcntl64,
+ * readahead, setxattr, lsetxattr, fsetxattr,
+ * getxattr, lgetxattr, listxattr, llistxattr,
+ * removexattr, lremovexattr, fremovexattr, sendfile64
+ * epoll_ctl, epoll_wait, statfs64, fstatfs64,
+ * utimes</td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>2</code></td>
+ * <td>process, contains system calls related to process operations</td>
+ * <td>exit, fork, waitpid, execve, wait4, clone,
+ * vfork, exit_group, waitid</td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>3</code></td>
+ * <td>network, contains system calls related to network operations</td>
+ * <td>sethostname, socketcall, setdomainname</td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>4</code></td>
+ * <td>signal, contains system calls related to signal operations</td>
+ * <td>pause, kill, signal, sigaction, sgetmask,
+ * ssetmask, sigsuspend, sigpending, sigreturn,
+ * sigprocmask, rt_sigreturn, rt_sigaction,
+ * rt_sigprocmask, rt_sigpending, rt_sigtimedwait,
+ * rt_sigqueueinfo, rt_sigsuspend, sigaltstack,
+ * tkill, tgkill</td></tr>
+ * <tr halign="left" bgcolor="#F0F0F0"><td><code>5</code></td>
+ * <td>ipc, contains system calls related to ipc operations</td>
+ * <td>mq_open, mq_unlink, mq_timedsend, mq_timedreceive,
+ * mq_notify, mq_getsetattr</td></tr></table>
+ *
+ * @example
+ * 1. -bash-2.05b# echo pidflt 152 > /proc/lttlite/config
+ * 2. -bash-2.05b# echo pidflt -100 > /proc/lttlite/config
+ * 3. -bash-2.05b# echo pidflt 152-162 > /proc/lttlite/config
+ * 4. -bash-2.05b# echo pidflt 1000- > /proc/lttlite/config
+ * 5. -bash-2.05b# echo pidflt 152 160-170 650-700 > /proc/lttlite/config
+ * 6. -bash-2.05b# echo pidflt > /proc/lttlite/config
+ * @endexample
+ * The command above make ltt-lite log events only related
+ * to process whose pid is selected.
+ * <br>The 1st command only log process with pid 152.
+ * <br>The 2nd command log processes with pid <= 100.
+ * <br>The 3rd command log processes with 152 <= pid <= 162.
+ * <br>The 4th command log processes with pid >= 1000.
+ * <br>The 5th command log processes with pid 152, or
+ * 160 <= pid <= 170, or 650 <= pid <= 700.
+ * <br>The 6th command clear process filters.
+ * <br>User must make sure the numbers are in an incremental
+ * order, both between and inside rules, or the rule will
+ * be rejected by ltt-lite.
+ * <br>This feature currently applies to syscall logging, scheduling logging,
+ * trap logging.
+ * <br>It is better to use "cat config" to check if the
+ * rules are set successfully.
+ * <br>At most three rules are accepted. More rules are ignored.
+ * <br>Interrupt filters are same as pid filter
+ * @example
+ * -bash-2.05b# echo priram 1 >/proc/lttlite/config
+ * @endexample
+ * The command above let ltt-lite use private ram as buffer.
+ * @example
+ * -bash-2.05b# echo priram 0 >/proc/lttlite/config
+ * @endexample
+ * @example
+ * -bash-2.05b# echo ramfil 1 >/proc/lttlite/config
+ * @endexample
+ * @example
+ * -bash-2.05b# echo ramfil 0 >/proc/lttlite/config
+ * @endexample
+ * The command above forbid ltt-lite use private ram as buffer.
+ *
+ * @example
+ * -bash-2.05b# echo + >/proc/lttlite/init
+ * @endexample
+ * The command above append private ram content to a existed log file.
+ * config->logfil is the file to be appended. This feature is used in private
+ * ram mode to get a seamless log.
+ *
+ * @example
+ * -bash-2.05b# echo filesz 5 >/proc/lttlite/config
+ * @endexample
+ * The command above make the log file maximal size to 5 MB. This is useful
+ * for logging long time. The minimal size of the file is 2MB. If this value
+ * equal zero, means there is no maximal size limit.
+ *
+ * @example
+ * -bash-2.05b# cat /proc/lttlite/config
+ * filesz:0M
+ * priram: 0
+ * ramfil: 0
+ * memint: 1
+ * sysftg: 0
+ * logfil: /home/ltt_lite_profilelog
+ * pidflt: 102, 120-130, 140-150
+ * intflt:
+ * @endexample
+ * The command above lists configuration of LTT-LITE
+ *
+ * @example
+ * Add "lttlite" to kernel boot command line; add
+ * "echo 11 /proc/lttlite/init" to rcS.d/Start.sh, right below
+ * "mountall.sh start".
+ * @endexample
+ * ltt-lite provides an early start feature.
+ * You can get a continuous log starts from the time
+ * when the init process is created. Writing early mode buffer
+ * to file (on flash) takes a long time. This may cause the
+ * later writing operation wait long and lose record when
+ * buffer if full. So it is better to point your log file
+ * to /tmp to avoid losing records.
+ */
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/uaccess.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/kthread.h>
+#include <linux/cpu.h>
+#include <linux/init.h>
+#include <linux/signal.h>
+#include <linux/completion.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/ctype.h>
+#include <linux/lttlite-events.h>
+#include <linux/io.h>
+#include <asm/mach/time.h>
+#include <asm/setup.h>
+#include <linux/page-flags.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/syscalls.h>
+#include <linux/ioport.h>
+#include <mach/system.h>
+
+/* debug printk macro */
+#ifdef LTT_LITE_DEBUG
+#define DPRINT(args...) printk(args)
+#else
+#define DPRINT(args...)
+#endif
+
+#define UNUSED_PARAM(v) (void)(v)
+/* command length when writing to config proc entry */
+#define LTT_LITE_CMD_LEN 255
+
+#define TIME_DELTA(a , b) ((unsigned long)((long)(a) - (long)(b)))
+
+#define LTT_LITE_TRAP_RETURN -1
+/* MIN_FILE_SIZE equal 2MB */
+#define MIN_FILE_SIZE 2
+#define SEEK_SET 0
+/*
+ * the file name for LTT LITE to store log data
+ */
+static char log_file[LTT_LITE_CMD_LEN] = "/data/ltt_lite_profilelog";
+
+/* functions to set LTT version info */
+static int set_ltt_version(void);
+static int ltt_version_tag;
+
+/* tag if buf has been overlapped in private ram mode */
+static int is_buf_overlap;
+
+/* page array for reserved pages, for free purpose */
+static struct page **early_page_array, **page_array;
+/* memory profiling interval, default to 1 second */
+static int mem_profile_interval = 1;
+static struct timer_list mem_profile_timer;
+static void log_mem_status(unsigned long ignore);
+
+/* the function that logs the top buf */
+static void wq_log_top_half(struct work_struct *ignore);
+/* the function that logs the bottom buf */
+static void wq_log_bottom_half(struct work_struct *ignore);
+/* the function that executes the initialization of workqueue */
+static void wq_init(struct work_struct *ignore);
+/* the function that executes close file and disable profile */
+static void wq_close_file(struct work_struct *ignore);
+/* declare the workqueues of the above four functions */
+static DECLARE_WORK(wq_log_top_half_work, wq_log_top_half);
+static DECLARE_WORK(wq_log_bottom_half_work, wq_log_bottom_half);
+static DECLARE_WORK(wq_init_work, wq_init);
+static DECLARE_WORK(wq_close_file_work, wq_close_file);
+
+/* get a time stamp */
+static inline void get_time_stamp(struct timeval *ktv);
+
+/* alloc/free memory function */
+static void free_reserved_pages(void *mem, struct page **pagearray,
+				int pagecount);
+static void *alloc_reserved_pages(struct page ***pagearray, int pagecount);
+
+/* proc/lttlite for LTT LITE proc file directory */
+static struct proc_dir_entry *proc_lttlite_entry;
+
+/* record header used by all log data structures */
+struct record_header_t{
+	unsigned short type;
+	unsigned short ssize;	/* header size + log struct size */
+	unsigned long timestamp_sec;
+	unsigned long timestamp_usec;
+} record_header_t;
+
+/* system call log data structure */
+struct ltt_lite_syscalllog {
+	struct record_header_t header;
+	unsigned short pid;	/* pid of issue the syscall */
+	short syscall_id;	/* syscall id */
+};
+/* kernel schedule log data structure */
+struct ltt_lite_schedlog {
+	struct record_header_t header;
+	/* following elements are data about switch out process */
+	unsigned short opid;	/* switch-out pid */
+	unsigned short out_state;	/* process state */
+	unsigned short oprio;	/* priority of process */
+	unsigned short reserve;
+	/* following elements are data about switch in process */
+	unsigned short ipid;	/* switch-in pid */
+	unsigned short iprio;	/* priority of process */
+};
+
+struct process_mem_log {
+	struct record_header_t header;
+	unsigned short pid;	/* switch-in pid */
+	unsigned short reserve;
+	unsigned long start_time_sec;	/* process start time */
+	unsigned long start_time_usec;
+	unsigned long vmsize;	/* total virtual memory size */
+	unsigned long vmlck;	/* pages locked by kernel */
+	unsigned long vmrss;	/* physical pages */
+	unsigned long vmdata;	/* data section size */
+	unsigned long vmstk;	/* stack section size */
+	unsigned long vmexe;	/* text section size */
+	unsigned long vmlib;	/* lib size */
+	unsigned long vmrsv;	/* pages reserved by kernel */
+	unsigned long vmshr;	/* pages could be shared */
+	unsigned long min_flt;	/* page fault count do not block process */
+	unsigned long maj_flt;	/* page fault count block process */
+	unsigned long utime;
+	unsigned long stime;
+};
+
+struct process_table_log {
+	struct record_header_t header;
+	unsigned short pid;
+	unsigned short ppid;	/* parent pid */
+	unsigned short tgid;	/* fork/clone record */
+	unsigned long sub_type;
+	char comm[LTT_LITE_TASK_COMM_LEN];
+};
+struct ltt_lite_trap_log {
+	struct record_header_t header;
+	unsigned short pid;
+	unsigned short subtype;
+};
+/* signal log structures */
+struct sig_send_log {
+	struct record_header_t header;
+	unsigned short s_pid;
+	unsigned short r_pid;
+	unsigned short sig;
+	unsigned short reserve;
+};
+struct sig_handle_log {
+	struct record_header_t header;
+	unsigned short sig;
+	unsigned short pid;
+	unsigned long handler;
+};
+/* timer log data structure */
+struct timer_log {
+	struct record_header_t header;
+	unsigned short pid;
+	unsigned short sub_type;
+	unsigned long exp;
+	unsigned long ace;
+	unsigned long fn;
+};
+struct timer_run_log {
+	struct record_header_t header;
+	unsigned short timer_type;
+	unsigned short reserve;
+	unsigned long fn;
+	unsigned long data;
+};
+/* interrupt log data structure */
+struct ltt_lite_intlog {
+	struct record_header_t header;
+	unsigned short intid;
+	unsigned short subtype;
+};
+
+struct ltt_lite_soft_irq {
+	struct record_header_t header;
+	unsigned long sub_type;
+	unsigned long data;
+};
+/*
+ * ltt-lite may lose records due to buffer is exhausted
+ * when it takes too much time to write file.
+ * At least we should know whether or how many records are lost.
+ * There is report for early mode and normal mode separately.
+ * For early report, we write it to file right after written
+ * the early buffer;
+ * For normal report, we write it to the end of the log file,
+ * just before closing the file.
+ */
+#define REPORT_ITEM_LEN (sizeof(unsigned long) * (LTT_LITE_EV_LAST - 2))
+struct ltt_lite_report_event {
+	struct record_header_t header;
+	unsigned long reports[LTT_LITE_EV_LAST - 2];
+};
+
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+#define LTT_LITE_SMALL_BUFFER_SIZE 1024
+
+static char ltt_lite_small_buffer[LTT_LITE_SMALL_BUFFER_SIZE];
+
+/* this interface is for custom events used for the
+ * Taskview-LTTLite android extensions.
+ * */
+struct ltt_lite_android_event {
+	struct record_header_t header;
+	unsigned short  pid;
+	unsigned short  reserved;
+	unsigned long   data;
+};
+#endif
+
+static void commit_log(void *addr, int size, unsigned short type);
+
+/* get /proc/<pid>/cmdline valude */
+static int get_proc_pid_cmdline(struct task_struct *task, char *buffer);
+
+/* save the early logged buffer to file */
+static int write_early_buf(void *);
+
+/* workqueue used by LTT LITE */
+static struct workqueue_struct *ltt_lite_wq;
+static long log_file_fd = -1;	/* logfile fd */
+
+/* reserved pages for early logging */
+static unsigned long ltt_lite_early_page_num = 1024;
+/* reserve 128 pages for general logging */
+#define LTT_LITE_PAGE_ORDER 7
+static unsigned long early_unlogged_count[LTT_LITE_EV_LAST];
+
+/*
+ * buffer control struct
+ * this stuct will be placed at the start of the buffer
+ */
+struct buf_info_t{
+	unsigned long size;
+	unsigned long buf_pos;
+	unsigned long log_file_pos;
+	char is_top;
+	char buf_top_full;
+	char buf_bottom_full;
+	char reserved_2;
+	unsigned long unlogged_count[LTT_LITE_EV_LAST];
+};
+static struct buf_info_t *buf_info;
+#define LTT_LITE_PRI_RAM_SIZE SZ_64K
+static unsigned long ltt_lite_buf_size;
+static unsigned long ltt_lite_privateram_size;
+static unsigned long ltt_lite_half_buf_size;
+static unsigned long ltt_lite_file_size;
+static unsigned long buf_empty_size;
+static void ltt_lite_append_log(void);
+
+static char *ltt_lite_buf;
+static char *ltt_lite_privateram_virtaddr;
+static char *ltt_lite_early_buf;
+static unsigned long early_buf_pos;
+/* indicate if ltt lite is enabled */
+static bool ltt_lite_is_enabled;
+
+static bool use_private_ram;
+static long *pevent_count;
+static char *pevent_table;
+#define PEVENT_COUNT_MAX 1000
+static bool use_private_ram_file;
+
+/* bit definition of ltt_lite_mode */
+enum ltt_lite_mode_t {
+	LTT_LITE_MODE_DEFAULT = 0,
+	LTT_LITE_MODE_SCHD = 1,
+	LTT_LITE_MODE_SYSC = 1 << 1,
+	LTT_LITE_MODE_MEM = 1 << 2,
+	LTT_LITE_MODE_TRAP = 1 << 3,
+	LTT_LITE_MODE_INT = 1 << 4,
+	LTT_LITE_MODE_SOFTIRQ = 1 << 5,
+	LTT_LITE_MODE_SIG = 1 << 6,
+	LTT_LITE_MODE_TMR = 1 << 7,
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	LTT_LITE_MODE_PRINTK  = 1 << 8,
+	LTT_LITE_MODE_ANDROID_RADIO = 1 << 9,
+	LTT_LITE_MODE_ANDROID = 1 << 10,
+#endif
+};
+
+/*indicate ltt lite working mode */
+static enum ltt_lite_mode_t ltt_lite_mode;
+
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+/* indicate Android message stream logigng mode
+ * 0 = Log Android message via existing method and into the LTT-Lite log file
+ * 1 = Log Android message into the LTT-Lite log file only
+ */
+static int android_logging_mode = 1;
+#endif
+
+#define MASK_ARRAY_LEN 18
+
+enum syscall_group_t {
+	SYSCALL_GROUP_ALL,
+	SYSCALL_GROUP_FILE,
+	SYSCALL_GROUP_PROCESS,
+	SYSCALL_GROUP_NETWORK,
+	SYSCALL_GROUP_SIGNAL,
+	SYSCALL_GROUP_IPC
+};
+
+/* save the syscall mask group id */
+static enum syscall_group_t syscall_mask_group_id;
+
+/* save the code of current syscall groups */
+/* we user MASK_ARRAY_LEN numbers to record bit mask map for system calls
+   in each group. 16bits (from bit0 to bit15) are used in each number. */
+static unsigned short ltt_lite_syscall_mask[SYSCALL_GROUP_IPC +
+						1][MASK_ARRAY_LEN]
+	= {
+/* syscall group code for all syscalls */
+/* when syscall_mask_group_id is SYSCALL_GROUP_ALL, we won't check
+   this array, so keep it empty for SYSCALL_GROUP_ALL group is ok */
+	{},
+/* syscall group code for file group */
+	{57208, 20589, 1986, 41176, 0, 63228, 7256, 64, 61472,
+	 22, 256, 2288, 32894, 9744, 47998, 6144, 11264, 0},
+/* syscall group code for process group */
+	{134, 0, 0, 0, 0, 0, 0, 260, 0,
+	 0, 0, 16384, 0, 0, 0, 256, 0, 256},
+/* syscall group code for network group */
+	{0, 0, 0, 0, 1024, 0, 64, 512, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0},
+/* syscall group code for signal group */
+	{0, 8192, 32, 1, 824, 0, 0, 16512, 0,
+	 0, 40960, 1039, 0, 0, 16384, 0, 4096, 0},
+/* syscall group code for ipc group */
+	{0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 252}
+};
+
+#define BITS_IN_SHORT (sizeof(unsigned short) * 8)
+/* max length of pid string */
+#define PID_NUM_LEN 5
+/* a fake syscall id to indicate return from syscall */
+#define LTT_LITE_SYSCALL_RETURN_ID -1
+/* define maximum pid filter rule number */
+#define LTT_LITE_PID_FILTER_MAX 3
+/* max length of output string when reading config entry */
+#define OUT_STR_LEN (300 + LTT_LITE_PID_FILTER_MAX * 12)
+/* config command string length */
+#define CFG_SELECTOR_LEN 6
+
+static bool early_enabled_mode;
+static bool early_tracing_is_allowed;
+/* variable used to record pid filter rule number (0~3) */
+static unsigned short ltt_lite_pid_filter_num;
+/* array stores the pid filter rules */
+static unsigned short ltt_lite_pid_filter[LTT_LITE_PID_FILTER_MAX][2];
+
+/* array stores the interrupt filter rules */
+static unsigned short ltt_lite_int_filter_num;
+static unsigned short ltt_lite_int_filter[LTT_LITE_PID_FILTER_MAX][2];
+
+enum ltt_lite_config_cmd {
+	NONCMD,			/* not valid command */
+	CMD_LOG_FILE_NAME,	/* set log file name command */
+	CMD_MEM_PROF_INTERVAL,	/* set memory profiling interval (seconds) */
+	CMD_SYSCALL_FILTER_GROUP,	/* set system call filter group id */
+	CMD_PID_FILTER,		/* set process id filter */
+	CMD_PRIVATE_RAM,	/* use private ram as buffer */
+	CMD_RAM_FILE,		/* set private ram and writing file mode */
+	CMD_FILE_SIZE,		/* set file size */
+	CMD_INT_FILTER,		/* set intterrupt number filter */
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	CMD_ANDROID_LOGMODE, /* set logging mode for Android streams */
+#endif
+};
+
+/*
+ * get kernel parameter for ltt-lite
+ * if lttlite is given, ltt-lite will enter early started mode.
+ * In this mode, ltt-lite start logging before process 1 is created,
+ * and log records until the early buffer is full.
+ * This buffer is written to file the first time ltt-lite is started
+ * by echo a non-zero number to /proc/lttlite/init.
+ * The early buffer can't stand too long, to avoid losing records,
+ * we should start this echo as early as possible(e.g., in rcS.d/Start.sh,
+ * after mountall.sh is called), and redirect log file to
+ * /tmp/ to save time.
+ */
+static void __init ltt_lite_cmdline_setup(char **arg)
+{
+	int res, i;
+	unsigned long pagenum;
+	char string[5];
+
+	for (i = 0; i < 5 && isxdigit((*arg)[i]); i++)
+		string[i] = (*arg)[i];
+	string[i] = '\0';
+
+	res = strict_strtoul(string, 10, &pagenum);
+
+	if (res)
+		DPRINT(KERN_INFO   "Ltt-lite pagenum may be incorret\n");
+
+
+	/* at most reserve 20M for bootup log */
+	ltt_lite_early_page_num = min_t(unsigned long, pagenum, 5120);
+	early_tracing_is_allowed = true;
+	printk(KERN_ERR
+		   "Ltt-lite early mode enabled: bootlog = %lu pages\n",
+		   ltt_lite_early_page_num);
+}
+
+__early_param("bootlog=", ltt_lite_cmdline_setup);
+
+struct resource ltt_lite_res = {
+	.start = 0x0,
+	.end = 0x0,
+};
+
+static int is_privateram_reserved(void)
+{
+
+	if (ltt_lite_res.start)
+		return 1;
+	else
+		return 0;
+}
+
+static char *get_privateram_address(void)
+{
+	if (ltt_lite_res.start && !ltt_lite_privateram_virtaddr) {
+		ltt_lite_privateram_virtaddr =
+			(char *) ioremap(ltt_lite_res.start,
+					 ltt_lite_privateram_size);
+	}
+	return ltt_lite_privateram_virtaddr;
+}
+
+static void release_privateram_address(void *addr)
+{
+	iounmap(addr);
+	ltt_lite_privateram_virtaddr = NULL;
+}
+
+/*
+ * setup private ram size and position for LTT-LITE
+ */
+static void __init ltt_lite_parser_mem(char **arg)
+{
+	unsigned long size, base;
+	size = memparse(*arg, arg);
+	if (**arg == '@') {
+		base = memparse(*arg + 1, arg);
+		ltt_lite_res.start = base + PHYS_OFFSET;
+		ltt_lite_res.end = ltt_lite_res.start + size - 1;
+		ltt_lite_privateram_size = size;
+	}
+	printk(KERN_DEBUG "ltt_lite_parser_mem:base 0x%lx, %lu\n",
+		   (unsigned long) ltt_lite_res.start, size);
+}
+
+__early_param("lttpriram=", ltt_lite_parser_mem);
+
+/*
+ * pages used by ltt-lite should not be reclaimed for performance.
+ * so wrap page malloc and page free with the following two functions.
+ * every page got in alloc_reserved_pages is reserved and organized
+ * into an array.
+ *
+ * allocate pages that can not be reclaimed
+ * return NULL if failed, otherwise the address
+ */
+static void *alloc_reserved_pages(struct page ***pagearray, int pagecount)
+{
+	int n_pages;
+	struct page **page_array;
+	int page_array_size;
+	int i;
+	void *mem;
+	n_pages = pagecount;
+	page_array_size = n_pages * sizeof(struct page *);
+	page_array = kmalloc(page_array_size, GFP_KERNEL);
+	if (page_array == NULL)
+		return NULL;
+
+	memset(page_array, 0, page_array_size);
+	for (i = 0; i < n_pages; i++) {
+		page_array[i] = alloc_page(GFP_KERNEL);
+		if (unlikely(!page_array[i])) {
+			free_reserved_pages(NULL, page_array, i);
+			return NULL;
+		}
+		SetPageReserved(page_array[i]);
+	}
+	mem = vmap(page_array, n_pages, GFP_KERNEL, PAGE_KERNEL);
+	if (!mem) {
+		free_reserved_pages(NULL, page_array, n_pages);
+		return NULL;
+	}
+	memset(mem, 0, pagecount << PAGE_SHIFT);
+	*pagearray = page_array;
+	return mem;
+}
+
+/*
+ * Free reserved pages
+ */
+static void free_reserved_pages(void *mem, struct page **pagearray,
+				int pagecount)
+{
+	int j;
+	if (mem)
+		vunmap(mem);
+
+	for (j = 0; j < pagecount; j++) {
+		ClearPageReserved(pagearray[j]);
+		__free_page(pagearray[j]);
+	}
+	kfree(pagearray);
+}
+
+/*
+ * store process name information of all threads
+ */
+static int process_name_table_init(void)
+{
+
+	struct process_table_log process_log;
+	struct task_struct *t, *p = &init_task;
+	int res = 0, size = 0;
+	char *buffer = "cmdline";
+
+	memset(&process_log.header, 0, sizeof(struct record_header_t));
+	process_log.header.type = LTT_LITE_EV_PROCESS;
+	process_log.header.ssize = sizeof(process_log);
+	process_log.sub_type = LTT_LITE_EV_PROCESS_TABLE;
+	read_lock(&tasklist_lock);
+	/*
+	 * init_task is the idle process, do not need log.
+	 * skip it.
+	 */
+	while ((p = next_task(p)) != &init_task) {
+		t = p;
+		do {
+			process_log.pid = t->pid;
+			process_log.ppid = t->parent->pid;
+			buffer = "";
+			process_log.tgid = t->tgid;
+
+			/* update thread name  */
+			res = get_proc_pid_cmdline(t, buffer);
+			if (!res)
+				buffer = t->comm;
+
+			memset(process_log.comm, 0, sizeof(process_log.comm));
+			size = strlen(buffer);
+			if (size >= LTT_LITE_TASK_COMM_LEN)
+				size = LTT_LITE_TASK_COMM_LEN - 1;
+			memcpy(process_log.comm, buffer, size);
+
+			commit_log(&process_log, sizeof(process_log),
+				   LTT_LITE_EV_PROCESS);
+			if (t->mm)
+				t = next_thread(t);
+			else
+				break;
+		} while (t != p);
+	}
+	read_unlock(&tasklist_lock);
+	return 0;
+}
+
+/* workqueue open file and mark ltt lite enabled here */
+static void wq_init(struct work_struct *ignore)
+{
+	int retval;
+	char *buf;
+	struct task_struct *ltt_kthread;
+	struct sched_param param = {.sched_priority = 1 };
+	UNUSED_PARAM(ignore);
+
+	/*
+	 * ltt_lite_is_enabled should not be set when enter this
+	 * function.
+	 */
+	BUG_ON(ltt_lite_is_enabled);
+
+	/*
+	 * set the work queue to rt_priority
+	 * low priority ittliter may not be scheduled in a long period,
+	 * thus ltt-lite may lose records.
+	 */
+	set_user_nice(current, -20);
+	retval = sched_setscheduler(current, SCHED_FIFO, &param);
+	if (retval)
+		printk(KERN_ERR "LTT-LITE: setscheduler(): %d.\n", retval);
+
+	set_fs(get_ds());
+	log_file_fd = sys_open((const char __user *)log_file,
+					O_RDWR | O_CREAT | O_TRUNC,
+					0600);
+	if (log_file_fd  < 0) {
+		printk(KERN_ERR "cannot open %s, %lu\n", log_file,
+			   log_file_fd);
+		return;
+	}
+
+	if (!ltt_lite_buf) {
+		printk(KERN_DEBUG "Ltt-lite wq-int ltt-lite-buff true\n");
+		if (!use_private_ram_file) {
+			buf = alloc_reserved_pages(&page_array,
+						   1 <<
+						   LTT_LITE_PAGE_ORDER);
+			if (!buf) {
+				printk(KERN_ERR
+					"cannot get pages for ltt_lite_buf\n");
+			} else {
+				ltt_lite_buf_size =
+					PAGE_SIZE *
+					(1 << LTT_LITE_PAGE_ORDER) -
+					sizeof(struct buf_info_t);
+			}
+		} else {
+			if (!is_privateram_reserved()) {
+				printk(KERN_ERR
+					   "no ltt-lite private ram!\n");
+				log_file_fd = -1;
+				return;
+			}
+			buf = get_privateram_address();
+			ltt_lite_buf_size =
+				ltt_lite_privateram_size
+				- sizeof(struct buf_info_t);
+		}
+		if (!buf) {
+			if (sys_close(log_file_fd))
+				printk(KERN_ERR "%s: close error\n",
+					   __func__);
+			ltt_lite_buf_size = 0;
+			return;
+		}
+		buf_info = (struct buf_info_t *) buf;
+		ltt_lite_buf = buf + sizeof(struct buf_info_t);
+		ltt_lite_half_buf_size = ltt_lite_buf_size / 2;
+		memset(buf_info, 0, sizeof(struct buf_info_t));
+		buf_info->size = ltt_lite_buf_size;
+		buf_info->is_top = 1;
+		buf_info->buf_pos = 0;
+		buf_info->buf_top_full = 0;
+		buf_info->buf_bottom_full = 0;
+		buf_info->log_file_pos = ltt_lite_file_size ? 0 : -1;
+	}
+
+	ltt_lite_is_enabled = true;
+
+	if (early_enabled_mode) {
+		printk(KERN_DEBUG "LTT-LITE: wq-init early mode enabled\n");
+		early_enabled_mode = false;
+
+		ltt_kthread = kthread_run(write_early_buf, NULL, current->comm);
+		if (!ltt_kthread)
+			printk(KERN_ERR
+				"LTT-LITE: create kernel thread failed\n");
+	}
+
+	set_ltt_version();
+	process_name_table_init();
+}
+
+/*
+ * write private ram to a new file, this function is used for priram mode
+ */
+static void ltt_lite_write_privateram(void)
+{
+	char *buf;
+	int result;
+	int buf_offset;
+	int buf_write_size;
+	long total_buf_head_size;
+
+	set_fs(get_ds());
+	if ((log_file_fd != -1) || ltt_lite_is_enabled) {
+		printk(KERN_ERR "please disable ltt-lite first\n");
+		return;
+	}
+	log_file_fd = sys_open((const char __user *) log_file,
+				   O_RDWR | O_CREAT | O_TRUNC, 0600);
+	if (log_file_fd < 0) {
+		printk(KERN_ERR "cannot open %s, %ld\n", log_file,
+			   log_file_fd);
+		log_file_fd = -1;
+		return;
+	}
+	if (!is_privateram_reserved()) {
+		printk(KERN_ERR "no ltt-lite private ram!\n");
+		if (sys_close(log_file_fd))
+			printk(KERN_ERR "%s: close error\n", __func__);
+		log_file_fd = -1;
+		return;
+	}
+	buf = get_privateram_address();
+	if (buf == NULL) {
+		DPRINT(KERN_ALERT
+			   "Error in mapping LTTLITE partition offset\n");
+		if (sys_close(log_file_fd))
+			printk(KERN_ERR "%s: close error\n", __func__);
+		return;
+	}
+	buf_info = (struct buf_info_t *) buf;
+	total_buf_head_size = sizeof(struct buf_info_t) +
+					PEVENT_COUNT_MAX *
+					sizeof(struct process_table_log);
+	ltt_lite_buf_size = ltt_lite_privateram_size -
+						total_buf_head_size;
+	if (buf_info->size != ltt_lite_buf_size) {
+		DPRINT(KERN_ALERT "Buf info not correct! %ld\n",
+			   buf_info->size);
+	}
+
+	/* dump ram from three parts */
+	if (is_buf_overlap) {
+		/* part 1 buf table and process table */
+		buf_offset = 0;
+		buf_write_size = total_buf_head_size;
+		result = sys_write(log_file_fd,
+						buf + buf_offset,
+						buf_write_size);
+		if (result < 0)
+			printk(KERN_ERR "%s: write part 1 error\n", __func__);
+		/* part 2 log before overlalp */
+		buf_offset = buf_info->buf_pos +
+					total_buf_head_size;
+		buf_write_size = ltt_lite_buf_size -
+						buf_info->buf_pos;
+		result = sys_write(log_file_fd,
+						buf + buf_offset,
+						buf_write_size);
+		if (result < 0)
+			printk(KERN_ERR "%s: write part 2 error\n", __func__);
+		/* part 3 log after overlap */
+		buf_offset = total_buf_head_size;
+		buf_write_size = buf_info->buf_pos;
+		result = sys_write(log_file_fd,
+						buf + buf_offset,
+						buf_write_size);
+		if (result < 0)
+			printk(KERN_ERR "%s: write part 3 error\n", __func__);
+	} else {
+		result = sys_write(log_file_fd, buf, ltt_lite_privateram_size);
+		if (result < 0)
+			printk(KERN_ERR "%s: write error\n", __func__);
+	}
+
+	if (sys_close(log_file_fd))
+		printk(KERN_ERR "%s: close error\n", __func__);
+	log_file_fd = -1;
+	release_privateram_address(buf);
+	ltt_lite_buf = NULL;
+}
+
+/*
+ * used to append last part of log (in private ram) to an existed log file
+ */
+static void ltt_lite_append_log()
+{
+	char *buf;
+	int result;
+	struct ltt_lite_report_event lreport;
+
+	set_fs(get_ds());
+	if ((log_file_fd != -1) || ltt_lite_is_enabled) {
+		printk(KERN_ERR "please disable ltt-lite first\n");
+		return;
+	}
+	log_file_fd = sys_open((const char __user *) log_file,
+				   O_WRONLY | O_APPEND, 0600);
+	if (log_file_fd < 0) {
+		printk(KERN_ERR "cannot open %s, %lu\n", log_file,
+			   log_file_fd);
+		log_file_fd = -1;
+		return;
+	}
+	if (!is_privateram_reserved()) {
+		printk(KERN_ERR "no ltt-lite private ram!\n");
+		if (sys_close(log_file_fd))
+			printk(KERN_ERR "%s: close error\n", __func__);
+		log_file_fd = -1;
+		return;
+	}
+	buf = get_privateram_address();
+
+	buf_info = (struct buf_info_t *) buf;
+	ltt_lite_buf = buf + sizeof(struct buf_info_t);
+	ltt_lite_buf_size =
+			ltt_lite_privateram_size - sizeof(struct buf_info_t);
+	ltt_lite_half_buf_size = ltt_lite_buf_size / 2;
+	/* Verify the private ram content is right */
+	if ((buf_info->size != ltt_lite_buf_size) ||
+		(buf_info->is_top
+		 && (buf_info->buf_pos > ltt_lite_half_buf_size))
+		|| (!buf_info->is_top
+		&& (buf_info->buf_pos <= ltt_lite_half_buf_size))) {
+		DPRINT(KERN_ALERT
+			   "Buf info not correct, will not append!%lu, %lu\n",
+			   buf_info->size, buf_info->buf_pos);
+		if (sys_close(log_file_fd))
+			printk(KERN_ERR "%s: close error\n", __func__);
+		log_file_fd = -1;
+		return;
+	}
+	if (buf_info->log_file_pos != -1) {
+		result =
+			sys_lseek(log_file_fd, buf_info->log_file_pos,
+				  SEEK_SET);
+		if (result < 0) {
+			printk(KERN_ERR "%s: seek error - %d\n",
+				   __func__, result);
+			goto err_out;
+		}
+	}
+	if (buf_info->is_top) {
+		if (buf_info->buf_bottom_full) {
+			result =
+				sys_write(log_file_fd,
+					  ltt_lite_buf +
+					  ltt_lite_half_buf_size,
+					  ltt_lite_half_buf_size);
+			if (result < 0) {
+				printk(KERN_ERR "%s: write error - %d\n",
+					   __func__, result);
+				goto err_out;
+			}
+		}
+		result =
+			sys_write(log_file_fd, ltt_lite_buf,
+				  buf_info->buf_pos);
+	} else {
+		if (buf_info->buf_top_full) {
+			result = sys_write(log_file_fd, ltt_lite_buf,
+					   ltt_lite_half_buf_size);
+			if (result < 0) {
+				printk(KERN_ERR "%s: write error - %d\n",
+					   __func__, result);
+				goto err_out;
+			}
+		}
+		result = sys_write(log_file_fd, ltt_lite_buf +
+				   ltt_lite_half_buf_size,
+				   buf_info->buf_pos -
+				   ltt_lite_half_buf_size);
+	}
+	if (result < 0) {
+		printk(KERN_ERR "%s: write error - %d\n", __func__,
+			   result);
+		goto err_out;
+	}
+	memset(&lreport.header, 0, sizeof(struct record_header_t));
+	lreport.header.type = LTT_LITE_EV_REPORT;
+	lreport.header.ssize = sizeof(struct ltt_lite_report_event);
+	memcpy(&lreport.reports,
+		   &buf_info->unlogged_count[LTT_LITE_EV_SYSCALL_ENTRY],
+		   REPORT_ITEM_LEN);
+	result =
+		sys_write(log_file_fd, (char *) &lreport, sizeof(lreport));
+	if (result < 0) {
+		printk(KERN_ERR "%s: write report error - %d\n",
+			   __func__, result);
+		goto err_out;
+	}
+	memset(buf_info, 0, sizeof(struct buf_info_t));
+err_out:
+	result = sys_close(log_file_fd);
+	if (result < 0)
+		printk(KERN_ERR "%s: close error\n", __func__);
+	log_file_fd = -1;
+	release_privateram_address(buf);
+	ltt_lite_buf = NULL;
+}
+
+/*
+ * start ltt-lite early
+ */
+void ltt_lite_early_init(void)
+{
+	if (!early_tracing_is_allowed)
+		return;
+	ltt_lite_early_buf =
+		(char *) alloc_reserved_pages(&early_page_array,
+					  ltt_lite_early_page_num);
+	if (!ltt_lite_early_buf) {
+		printk(KERN_ERR "cannot get pages for early ltt-lite\n");
+		return;
+	}
+	ltt_lite_mode = LTT_LITE_MODE_SCHD | LTT_LITE_MODE_SYSC
+		| LTT_LITE_MODE_TRAP;
+	early_enabled_mode = true;
+}
+
+/* workqueue writes the left log data before closes the file */
+static void wq_close_file(struct work_struct *ignore)
+{
+	int result, size;
+	char *start;
+	struct ltt_lite_report_event lreport;
+	UNUSED_PARAM(ignore);
+
+	printk(KERN_DEBUG "LTT-LITE %s: wq_close_file enter\n", __func__);
+
+	BUG_ON(log_file_fd < 0);
+	/* write the log data has not be committed to log */
+	if (buf_info->is_top) {
+		start = ltt_lite_buf;
+		size = buf_info->buf_pos;
+	} else {
+		start = ltt_lite_buf + ltt_lite_half_buf_size;
+		size = buf_info->buf_pos - ltt_lite_half_buf_size;
+	}
+
+	result = sys_write(log_file_fd, start, size);
+	if (result < 0)
+		printk(KERN_ERR "%s: write error\n", __func__);
+	/*
+	 * write a report to the end of the log file
+	 * only logs lost in normal ltt-lite mode
+	 */
+	memset(&lreport.header, 0, sizeof(struct record_header_t));
+	lreport.header.type = LTT_LITE_EV_REPORT;
+	lreport.header.ssize = sizeof(struct ltt_lite_report_event);
+	memcpy(&lreport.reports,
+		   &buf_info->unlogged_count[LTT_LITE_EV_SYSCALL_ENTRY],
+		   REPORT_ITEM_LEN);
+
+	result =
+		sys_write(log_file_fd, (char *) &lreport, sizeof(lreport));
+	if (result < 0)
+		printk(KERN_ERR "%s: write error\n", __func__);
+	memset(buf_info, 0, sizeof(struct buf_info_t));
+
+	result = sys_close(log_file_fd);
+	if (result < 0)
+		printk(KERN_ERR "%s: close error\n", __func__);
+	else
+		log_file_fd = -1;
+	/*
+	 * ltt_lite_buf will not be freed twice for this work not been queued
+	 * when ltt_lite_is_enabled is not set.
+	 */
+	if (!ltt_lite_buf)
+		return;
+	if (!use_private_ram_file) {
+		free_reserved_pages(buf_info, page_array,
+					1 << LTT_LITE_PAGE_ORDER);
+	} else {
+		release_privateram_address(ltt_lite_buf);
+	}
+
+	ltt_lite_buf = NULL;
+}
+
+/*
+ * proc file init read function:
+ */
+static ssize_t
+ltt_lite_proc_read_init(struct file *file, char __user *buffer,
+			size_t buflen, loff_t *fpos)
+{
+	char buf[10];
+	int len;
+
+	UNUSED_PARAM(file);
+	UNUSED_PARAM(buflen);
+	if (*fpos)
+		return 0;
+	len = snprintf(buf, sizeof(buf), "%d\n", ltt_lite_mode);
+	if (copy_to_user(buffer, buf, len))
+		return -EFAULT;
+
+	*fpos += len;
+	return len;
+}
+
+static int init_private_ram(void)
+{
+	char *buf;
+	if (!is_privateram_reserved()) {
+		printk(KERN_ERR "no ltt-lite private ram!\n");
+		return 0;
+	}
+
+	ltt_lite_buf_size = ltt_lite_privateram_size - sizeof(struct buf_info_t)
+		- PEVENT_COUNT_MAX * sizeof(struct process_table_log);
+	if (ltt_lite_buf_size < 0) {
+		printk(KERN_ERR "ltt-lite private ram not enough!\n");
+		return 0;
+	}
+	buf = get_privateram_address();
+
+	buf_info = (struct buf_info_t *) buf;
+	pevent_count = buf_info->unlogged_count;
+	pevent_table = (char *) (buf + sizeof(struct buf_info_t));
+	ltt_lite_buf = (char *) (buf + sizeof(struct buf_info_t) +
+					PEVENT_COUNT_MAX *
+					sizeof(struct process_table_log));
+
+	memset(buf, 0, ltt_lite_privateram_size);
+	buf_info->size = ltt_lite_buf_size;
+	buf_info->is_top = 1;
+	buf_info->buf_pos = 0;
+	buf_info->buf_top_full = 0;
+	buf_info->buf_bottom_full = 0;
+
+	set_ltt_version();
+
+	process_name_table_init();
+
+	return 1;
+}
+
+/*
+ * proc_init_char_command - deal with char command to
+ * /proc/lttlite/init interface
+ */
+static inline int proc_init_char_command(char *str)
+{
+	if (*str == 'r' || *str == 'R') {
+		/* maybe enable reset feature in future */
+		/* arch_reset('h'); */
+	} else if (*str == '+') {
+		if (use_private_ram_file)
+			ltt_lite_append_log();
+		else if (use_private_ram)
+			ltt_lite_write_privateram();
+
+		return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * ltt_lite_proc_write_init - procfs write callback for init attr
+ * write 1-7: start to enable logging
+ * write 0: disable logging
+ */
+static int ltt_lite_proc_write_init(struct file *filp,
+					const char *buffer, size_t count,
+					loff_t *data)
+{
+	int buf, mode;
+	int res, i;
+	char string[5];
+	UNUSED_PARAM(filp);
+	UNUSED_PARAM(data);
+
+	if (copy_from_user(string, buffer, 5))
+		return -EFAULT;
+
+	if (proc_init_char_command(string))
+		return count;
+
+	i = 0;
+	while (isdigit(string[i]) && i < 5)
+		i++;
+
+	string[i] = '\0';
+
+	res = strict_strtol(string, 0, (long *)&buf);
+	if (res)
+		return -EFAULT;
+
+	mode =
+		LTT_LITE_MODE_SCHD | LTT_LITE_MODE_SYSC | LTT_LITE_MODE_MEM |
+		LTT_LITE_MODE_TRAP | LTT_LITE_MODE_INT | LTT_LITE_MODE_SOFTIRQ
+		| LTT_LITE_MODE_SIG | LTT_LITE_MODE_TMR
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+		| LTT_LITE_MODE_PRINTK
+		| LTT_LITE_MODE_ANDROID
+		| LTT_LITE_MODE_ANDROID_RADIO
+#endif
+		;
+
+	if (buf < 0 || buf > mode)
+		return count;
+
+	/* stop profiling */
+	if (!buf && ltt_lite_is_enabled) {
+		if (use_private_ram)
+			release_privateram_address(get_privateram_address
+						   ());
+		ltt_lite_is_enabled = false;
+		if (ltt_lite_mode & LTT_LITE_MODE_MEM)
+			del_timer_sync(&mem_profile_timer);
+
+		if (log_file_fd >= 0 && ltt_lite_wq)
+			queue_work(ltt_lite_wq, &wq_close_file_work);
+
+	}
+	/* start profiling */
+	else if (buf && !ltt_lite_is_enabled) {
+		if (use_private_ram) {
+			if (init_private_ram())
+				ltt_lite_is_enabled = 1;
+			else
+				return count;
+		} else {
+			if (!ltt_lite_wq) {
+				/* enable ltt lite at first time */
+				ltt_lite_wq =
+					create_singlethread_workqueue
+					("lttliter");
+				BUG_ON(!ltt_lite_wq);
+				queue_work(ltt_lite_wq, &wq_init_work);
+			} else if (log_file_fd < 0) {
+				queue_work(ltt_lite_wq, &wq_init_work);
+			}
+		}
+		if (buf & LTT_LITE_MODE_MEM) {
+			init_timer(&mem_profile_timer);
+			mem_profile_timer.function = log_mem_status;
+			mod_timer(&mem_profile_timer,
+				  jiffies + mem_profile_interval * HZ);
+		}
+		/* recaculate file size limit */
+		if (ltt_lite_file_size) {
+			if (ltt_lite_file_size < MIN_FILE_SIZE)
+				ltt_lite_file_size = MIN_FILE_SIZE;
+
+			if (use_private_ram_file || use_private_ram) {
+				if ((ltt_lite_file_size * SZ_1M) <
+					(ltt_lite_privateram_size / 2)) {
+					ltt_lite_file_size =
+						ltt_lite_privateram_size / 2 /
+						SZ_1M + 1;
+				}
+			}
+		}
+	}
+	/* change profiling mode. Should deal with memory profiling timer */
+	else if (buf && ltt_lite_is_enabled) {
+		/* start memory profiling */
+		if (!(ltt_lite_mode & LTT_LITE_MODE_MEM) &&
+			(buf & LTT_LITE_MODE_MEM)) {
+			init_timer(&mem_profile_timer);
+			mem_profile_timer.function = log_mem_status;
+			mod_timer(&mem_profile_timer, jiffies +
+				  mem_profile_interval * HZ);
+		}
+		/* stop memory profiling */
+		else if ((ltt_lite_mode & LTT_LITE_MODE_MEM) &&
+			 !(buf & LTT_LITE_MODE_MEM)) {
+			del_timer_sync(&mem_profile_timer);
+		}
+	}
+	ltt_lite_mode = buf;
+
+	return count;
+}
+
+static const struct file_operations proc_ltt_lite_init_operations = {
+	.read = ltt_lite_proc_read_init,
+	.write = ltt_lite_proc_write_init,
+};
+
+/*
+ * open interface for proc file config
+ */
+static int ltt_lite_proc_config_open(struct inode *inode,
+					 struct file *file)
+{
+	if ((file->f_mode & FMODE_WRITE) && !(inode->i_mode & S_IWUSR))
+		return -EPERM;
+
+	return 0;
+}
+
+/*
+ * read interface for proc file config, show config info
+ */
+static ssize_t ltt_lite_proc_config_read(struct file *file,
+					 char __user *buf, size_t count,
+					 loff_t *ppos)
+{
+	char *config_buf;
+	int i, len;
+	int ret;
+
+	UNUSED_PARAM(file);
+	if (*ppos)
+		return 0;
+
+	config_buf = kmalloc(OUT_STR_LEN, GFP_KERNEL);
+	if (!config_buf) {
+		printk(KERN_ERR "%s: kmalloc failed\n", __func__);
+		return 0;
+	}
+
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	len = snprintf(config_buf, OUT_STR_LEN,
+			   "filesz:%luM\npriram: %d\nramfil: %d\nmemint: \
+			   %d\nsysftg: %d\nlogfil: %s\nlogmod: %d\npidflt: ",
+				ltt_lite_file_size, use_private_ram,
+				use_private_ram_file, mem_profile_interval,
+				syscall_mask_group_id, log_file,
+				android_logging_mode);
+#else
+	len = snprintf(config_buf, OUT_STR_LEN,
+			   "filesz:%luM\npriram: %d\nramfil: %d\nmemint: \
+			   %d\nsysftg: %d\nlogfil: %s\npidflt: ",
+				ltt_lite_file_size, use_private_ram,
+				use_private_ram_file, mem_profile_interval,
+				syscall_mask_group_id, log_file);
+#endif
+
+	for (i = 0; i < ltt_lite_pid_filter_num; i++) {
+		if (ltt_lite_pid_filter[i][0] == ltt_lite_pid_filter[i][1])
+			len +=
+				snprintf(config_buf + len, OUT_STR_LEN - len,
+					 "%d ", ltt_lite_pid_filter[i][0]);
+		else
+			len +=
+				snprintf(config_buf + len, OUT_STR_LEN - len,
+					 "%d-%d ", ltt_lite_pid_filter[i][0],
+					 ltt_lite_pid_filter[i][1]);
+	}
+	len += snprintf(config_buf + len, OUT_STR_LEN - len, "\nintflt:");
+	for (i = 0; i < ltt_lite_int_filter_num; i++) {
+		if (ltt_lite_int_filter[i][0] == ltt_lite_int_filter[i][1])
+			len +=
+				snprintf(config_buf + len, OUT_STR_LEN - len,
+					 "%d ", ltt_lite_int_filter[i][0]);
+		else
+			len +=
+				snprintf(config_buf + len, OUT_STR_LEN - len,
+					 "%d-%d ", ltt_lite_int_filter[i][0],
+					 ltt_lite_int_filter[i][1]);
+	}
+	len += snprintf(config_buf + len, OUT_STR_LEN - len, "\n");
+	len = len < (int) count ? len : (int) count;
+
+	ret = copy_to_user(buf, config_buf, len);
+	kfree(config_buf);
+	if (ret < 0)
+		return -EFAULT;
+	*ppos += len;
+
+	return len;
+}
+
+/*
+ * split string to substrings according to char pattern
+ * deal with multiple characters of pattern
+ * more parameters than max_param are ignored
+ * the input string is modified
+ * return value range from 0~max_param
+ * when return 0, means there is no parameter
+ */
+static int split(char *string, char **index_array, char pattern,
+		 int max_param)
+{
+	char *ptr;
+	int count;
+
+	/* thumb through the characters */
+	for (ptr = string, count = 0; count < max_param; count++, ptr++) {
+		/* find the start of substring */
+		while (*ptr == pattern)
+			ptr++;
+		if (*ptr == '\0')
+			break;
+		*(index_array + count) = ptr;
+		/* find the end of substring */
+		while (*ptr != pattern && *ptr != '\0')
+			ptr++;
+		if (*ptr != '\0')
+			*ptr = '\0';
+		else {
+			count++;
+			break;
+		}
+	}
+
+	return count;
+}
+
+/*
+ * get pid number from string
+ * check if the pid number is valid
+ */
+static int string2pid(char *string)
+{
+	int pidnum;
+	int res;
+
+	if (strlen(string) > PID_NUM_LEN)
+		return -1;
+	res = strict_strtol(string, 0, (long *)&pidnum);
+	if (res)
+		return -1;
+
+	if (pidnum < 0 || pidnum > PID_MAX_DEFAULT)
+		return -1;
+
+	return pidnum;
+}
+
+/*
+ * deal with pid filter command
+ */
+static void do_cmd_filter(char *params, unsigned short *array,
+			  unsigned short *filter_num)
+{
+	char *char_sub_pos;
+	int param_num = 0;
+	int input_pid1 = -1;
+	int input_pid2 = -1;
+	char *substr_index[LTT_LITE_PID_FILTER_MAX];
+	char *subpid_index[2];
+	int i = 0;
+	unsigned short temp_pid_filter[LTT_LITE_PID_FILTER_MAX][2];
+
+	param_num =
+		split(params, substr_index, ' ', LTT_LITE_PID_FILTER_MAX);
+	if (!param_num) {
+		/* clear filters if no parameter */
+		*filter_num = 0;
+		return;
+	}
+
+	for (i = 0; i < param_num; i++) {
+		char_sub_pos = strchr(substr_index[i], (int) '-');
+		/* more than one separator '-', invalid input */
+		if (char_sub_pos != strrchr(substr_index[i], (int) '-'))
+			break;
+		/* pid filter rule "pidnum" */
+		if (!char_sub_pos) {
+			input_pid1 = string2pid(substr_index[i]);
+			input_pid2 = input_pid1;
+		}
+		/* pid filter rule "-pidnum" */
+		else if (char_sub_pos == substr_index[i]) {
+			substr_index[i]++;
+			input_pid1 = 0;
+			input_pid2 = string2pid(substr_index[i]);
+		}
+		/* pid filter rule "pidnum-" */
+		else if (char_sub_pos - substr_index[i] ==
+			 strlen(substr_index[i]) - 1) {
+			*char_sub_pos = '\0';
+			input_pid1 = string2pid(substr_index[i]);
+			input_pid2 = PID_MAX_DEFAULT;
+		}
+		/* pid filter rule "pidnum1-pidnum2" */
+		else {
+			split(substr_index[i], subpid_index, '-', 2);
+			input_pid1 = string2pid(subpid_index[0]);
+			input_pid2 = string2pid(subpid_index[1]);
+		}
+		/* string2pid do pid valid checking,
+		   when invalid string, return a -1 on the pid */
+		if (input_pid1 != -1 && input_pid2 != -1 &&
+			input_pid1 <= input_pid2) {
+			temp_pid_filter[i][0] = input_pid1;
+			temp_pid_filter[i][1] = input_pid2;
+		} else
+			break;
+	}
+	/* do filter rules check */
+	if (i == param_num) {
+		for (i = 0; i < param_num - 1; i++) {
+			if (temp_pid_filter[i][1] >=
+				temp_pid_filter[i + 1][0])
+				break;
+		}
+		if (i == param_num - 1) {
+			memcpy(array, temp_pid_filter,
+				   param_num * sizeof(unsigned short) * 2);
+			*filter_num = param_num;
+			return;
+		}
+	}
+	DPRINT(KERN_NOTICE "Ltt-lite pid filter not set.\n");
+}
+
+/*
+ * deal with command options according to command type
+ */
+static void do_cmd(char *cmd_line, int cmd_type)
+{
+	char *char_sub_pos;
+	int res;
+	int param_num = 0;
+	int file_size = 0;
+
+	switch (cmd_type) {
+	case CMD_MEM_PROF_INTERVAL:
+		param_num = split(cmd_line, &char_sub_pos, ' ', 1);
+		if (param_num && strlen(char_sub_pos) == 1 &&
+			*char_sub_pos >= '1' && *char_sub_pos <= '9') {
+			mem_profile_interval = *char_sub_pos - '0';
+		}
+		break;
+	case CMD_LOG_FILE_NAME:
+		param_num = split(cmd_line, &char_sub_pos, ' ', 1);
+		/* do not change log file name during logging */
+		if (param_num && !ltt_lite_is_enabled &&
+			strlen(char_sub_pos) < LTT_LITE_CMD_LEN) {
+			memcpy(log_file, char_sub_pos,
+				   strlen(char_sub_pos) + 1);
+		}
+		break;
+	case CMD_SYSCALL_FILTER_GROUP:
+		param_num = split(cmd_line, &char_sub_pos, ' ', 1);
+		if (param_num && strlen(char_sub_pos) == 1 &&
+			*char_sub_pos >= '0' && *char_sub_pos <= '5') {
+			syscall_mask_group_id = *char_sub_pos - '0';
+		}
+		break;
+	case CMD_PID_FILTER:
+		do_cmd_filter(cmd_line,
+				  (unsigned short *) ltt_lite_pid_filter,
+				  &ltt_lite_pid_filter_num);
+		break;
+	case CMD_INT_FILTER:
+		do_cmd_filter(cmd_line,
+				  (unsigned short *) ltt_lite_int_filter,
+				  &ltt_lite_int_filter_num);
+		break;
+		/*
+		 * PRIRAM and RAMFIL can not be set in meanwhile
+		 */
+	case CMD_PRIVATE_RAM:
+		if (use_private_ram_file) {
+			printk(KERN_ERR "please disable RAMFIL first\n");
+			break;
+		}
+		param_num = split(cmd_line, &char_sub_pos, ' ', 1);
+		/* do not change buffer during logging */
+		if (param_num && strlen(char_sub_pos) == 1 &&
+			*char_sub_pos >= '0' && *char_sub_pos <= '1') {
+			if (*char_sub_pos == '0' && use_private_ram == 1)
+				ltt_lite_buf = NULL;
+
+			use_private_ram = *char_sub_pos - '0';
+		}
+		break;
+	case CMD_RAM_FILE:
+		if (use_private_ram) {
+			printk(KERN_ERR "please disable PRIRAM first\n");
+			break;
+		}
+		param_num = split(cmd_line, &char_sub_pos, ' ', 1);
+		/* do not change buffer during logging */
+		if (param_num && strlen(char_sub_pos) == 1 &&
+			*char_sub_pos >= '0' && *char_sub_pos <= '1') {
+			use_private_ram_file = *char_sub_pos - '0';
+		}
+		break;
+	case CMD_FILE_SIZE:
+		param_num = split(cmd_line, &char_sub_pos, ' ', 1);
+		/* do not change buffer during logging */
+		if (param_num) {
+			res = strict_strtoul(char_sub_pos,
+							0,
+							(long *) &file_size);
+			if (res) {
+				ltt_lite_file_size = 0;
+				break;
+			}
+
+			if (file_size == 0) {
+				ltt_lite_file_size = 0;
+				break;
+			}
+			if (file_size < MIN_FILE_SIZE)
+				file_size = MIN_FILE_SIZE;
+
+			if (use_private_ram_file || use_private_ram) {
+				if ((file_size * SZ_1M) <
+					(ltt_lite_privateram_size / 2)) {
+					file_size =
+						ltt_lite_privateram_size / 2 /
+						SZ_1M + 1;
+				}
+			}
+			ltt_lite_file_size = file_size;
+		}
+		break;
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	case CMD_ANDROID_LOGMODE:
+		param_num = split(cmd_line, &char_sub_pos, ' ', 1);
+		android_logging_mode = *char_sub_pos - '0';
+		break;
+#endif
+	}
+}
+
+/*
+ * write interface for proc file config
+ */
+static ssize_t ltt_lite_proc_config_write(struct file *file,
+					  const char __user *buf,
+					  size_t count, loff_t *ppos)
+{
+	char cmd_line[LTT_LITE_CMD_LEN];
+	int i = 0;
+	enum ltt_lite_config_cmd cmd_type = NONCMD;
+
+	UNUSED_PARAM(file);
+	UNUSED_PARAM(ppos);
+
+	if (ltt_lite_is_enabled) {
+		printk(KERN_ERR "Please disable LTT-LITE first\n");
+		return count;
+	}
+
+	if (count >= LTT_LITE_CMD_LEN)
+		return 0;
+	if (copy_from_user(cmd_line, buf, count))
+		return -EFAULT;
+
+	if (strncmp(cmd_line, "memint", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_MEM_PROF_INTERVAL;
+	else if (strncmp(cmd_line, "logfil", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_LOG_FILE_NAME;
+	else if (strncmp(cmd_line, "sysftg", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_SYSCALL_FILTER_GROUP;
+	else if (strncmp(cmd_line, "pidflt", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_PID_FILTER;
+	else if (strncmp(cmd_line, "priram", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_PRIVATE_RAM;
+	else if (strncmp(cmd_line, "ramfil", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_RAM_FILE;
+	else if (strncmp(cmd_line, "filesz", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_FILE_SIZE;
+	else if (strncmp(cmd_line, "intflt", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_INT_FILTER;
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	else if (strncmp(cmd_line, "logmod", CFG_SELECTOR_LEN) == 0)
+		cmd_type = CMD_ANDROID_LOGMODE;
+#endif
+
+	if (cmd_type != NONCMD) {
+		for (i = 0; i < count; i++) {
+			if (cmd_line[i] == '\n') {
+				cmd_line[i] = '\0';
+				break;
+			}
+		}
+		cmd_line[count] = '\0';
+		do_cmd(cmd_line + CFG_SELECTOR_LEN, cmd_type);
+	}
+
+	return count;
+}
+
+static const struct file_operations proc_ltt_lite_config_operations = {
+	.open = ltt_lite_proc_config_open,
+	.read = ltt_lite_proc_config_read,
+	.write = ltt_lite_proc_config_write,
+};
+
+/* log all user applications' mem status */
+static void log_mem_status(unsigned long ignore)
+{
+	struct task_struct *t, *p = &init_task;
+	struct process_mem_log mem_log;
+	struct mm_struct *mm;
+	UNUSED_PARAM(ignore);
+
+	if (!ltt_lite_is_enabled)
+		return;
+
+	read_lock(&tasklist_lock);
+	while ((p = next_task(p)) != &init_task) {
+		/*
+		 * skip all kernel thread
+		 */
+		if (!p->mm)
+			continue;
+		memset((void *) &mem_log, 0,
+			   sizeof(struct process_mem_log));
+		mem_log.pid = p->pid;
+		mem_log.start_time_sec = p->start_time.tv_sec;
+		mem_log.start_time_usec = p->start_time.tv_nsec;
+		mm = get_task_mm(p);
+		mem_log.vmsize = mm->total_vm - mm->reserved_vm;
+		mem_log.vmlck = mm->locked_vm;
+		mem_log.vmrss = get_mm_rss(mm);
+		mem_log.vmshr =
+			mem_log.vmrss - get_mm_counter(mm, anon_rss);
+		mem_log.vmdata =
+			mm->total_vm - mm->shared_vm - mm->stack_vm;
+		mem_log.vmstk = mm->stack_vm;
+		mem_log.vmexe = (PAGE_ALIGN(mm->end_code) -
+				 (mm->
+				  start_code & PAGE_MASK)) >> PAGE_SHIFT;
+		mem_log.vmlib = mm->exec_vm - mem_log.vmexe;
+		mem_log.vmrsv = mm->reserved_vm;
+		mmput(mm);
+		t = p;
+		do {
+			mem_log.min_flt += t->min_flt;
+			mem_log.maj_flt += t->maj_flt;
+			mem_log.utime += t->utime;
+			mem_log.stime += t->stime;
+			t = next_thread(t);
+		} while (t != p);
+
+		commit_log(&mem_log, sizeof(mem_log),
+			   LTT_LITE_EV_MEM_PROFILE);
+
+	}
+	read_unlock(&tasklist_lock);
+	mod_timer(&mem_profile_timer, jiffies + mem_profile_interval * HZ);
+}
+
+/*
+ * ltt_lite initialization function that initialize proc file for control
+ * which is dependent on that kernel has already initialized file system
+ * layer. So claim it as late_initcall
+ */
+int __init ltt_lite_init(void)
+{
+	struct proc_dir_entry *init_entry;
+	struct proc_dir_entry *config_entry;
+
+	proc_lttlite_entry = proc_mkdir("lttlite", NULL);
+	if (proc_lttlite_entry == NULL) {
+		printk(KERN_ERR "create proc lttlite directory error\n");
+		return -ENOMEM;
+	}
+	init_entry = create_proc_entry("init", 0666, proc_lttlite_entry);
+	if (init_entry == NULL) {
+		remove_proc_entry("lttlite", NULL);
+		printk(KERN_ERR "lttlite proc init create error\n");
+		return -ENOMEM;
+	}
+	config_entry = create_proc_entry("config", 0666,
+					 proc_lttlite_entry);
+	if (config_entry == NULL) {
+		remove_proc_entry("init", proc_lttlite_entry);
+		remove_proc_entry("lttlite", NULL);
+		printk(KERN_ERR "lttlite proc config create error\n");
+		return -ENOMEM;
+	}
+
+	init_entry->proc_fops = &proc_ltt_lite_init_operations;
+	config_entry->proc_fops = &proc_ltt_lite_config_operations;
+
+	return 0;
+}
+
+late_initcall(ltt_lite_init);
+
+/*
+ * save the early logged buffer to file
+ */
+static int write_early_buf(void *ignore)
+{
+	int result;
+	long early_log_file_fd;
+	char early_log_file[LTT_LITE_CMD_LEN];
+	struct ltt_lite_report_event lreport;
+	UNUSED_PARAM(ignore);
+	set_fs(get_ds());
+	strncpy(early_log_file, log_file, LTT_LITE_CMD_LEN);
+	strncat(early_log_file, ".early",
+		LTT_LITE_CMD_LEN - strlen(log_file));
+	early_log_file_fd = sys_open((const char __user *) early_log_file,
+					 O_RDWR | O_CREAT | O_TRUNC, 0600);
+	if (early_log_file_fd < 0) {
+		printk(KERN_ERR "cannot open %s, %ld\n", early_log_file,
+			   early_log_file_fd);
+		early_log_file_fd = -1;
+		return 0;
+	}
+
+	result = sys_write(early_log_file_fd, ltt_lite_early_buf,
+			   early_buf_pos);
+	/* write a report to the end of the early log */
+	memset(&lreport.header, 0, sizeof(struct record_header_t));
+	lreport.header.type = LTT_LITE_EV_REPORT;
+	lreport.header.ssize = sizeof(struct ltt_lite_report_event);
+	memcpy(&lreport.reports,
+		   &early_unlogged_count[LTT_LITE_EV_SYSCALL_ENTRY],
+		   REPORT_ITEM_LEN);
+	result +=
+		sys_write(early_log_file_fd, (char *) &lreport,
+			  sizeof(lreport));
+	if (result < 0)
+		printk(KERN_ERR "%s: write error\n", __func__);
+	sys_close(early_log_file_fd);
+
+	free_reserved_pages(ltt_lite_early_buf, early_page_array,
+				ltt_lite_early_page_num);
+	ltt_lite_early_buf = NULL;
+
+	return 0;
+}
+
+/*
+ * save the top half buffer to file
+ */
+static void wq_log_top_half(struct work_struct *ignore)
+{
+	int result;
+	UNUSED_PARAM(ignore);
+	if (ltt_lite_file_size) {
+		printk(KERN_DEBUG "bottom: buf_info->log_file_pos %lu\n",
+			   buf_info->log_file_pos);
+		if ((buf_info->log_file_pos + ltt_lite_half_buf_size) >=
+			ltt_lite_file_size * SZ_1M) {
+			buf_info->log_file_pos = 0;
+			result =
+				sys_lseek(log_file_fd, buf_info->log_file_pos,
+					  SEEK_SET);
+			if (result < 0) {
+				printk(KERN_ERR "%s: seek error - %d\n",
+					   __func__, result);
+			}
+		}
+	}
+	result = sys_write(log_file_fd, ltt_lite_buf,
+			   ltt_lite_half_buf_size);
+	if (result < 0)
+		printk(KERN_ERR "%s: write error\n", __func__);
+	if (ltt_lite_file_size)
+		buf_info->log_file_pos += ltt_lite_half_buf_size;
+
+	buf_info->buf_top_full = 0;
+}
+
+/*
+ * save the bottom half buffer to file
+ */
+static void wq_log_bottom_half(struct work_struct *ignore)
+{
+	int result;
+	UNUSED_PARAM(ignore);
+
+	if (ltt_lite_file_size) {
+		printk(KERN_DEBUG "bottom: buf_info->log_file_pos %lu\n",
+			   buf_info->log_file_pos);
+		if ((buf_info->log_file_pos + ltt_lite_half_buf_size -
+			 buf_empty_size)
+			>= ltt_lite_file_size * SZ_1M) {
+			buf_info->log_file_pos = 0;
+			result =
+				sys_lseek(log_file_fd, buf_info->log_file_pos,
+					  SEEK_SET);
+			if (result < 0) {
+				printk(KERN_ERR "%s: seek error - %d\n",
+					   __func__, result);
+			}
+		}
+	}
+	result = sys_write(log_file_fd,
+			   ltt_lite_buf + ltt_lite_half_buf_size,
+			   ltt_lite_half_buf_size - buf_empty_size);
+	if (result < 0)
+		printk(KERN_ERR "%s: write error\n", __func__);
+	if (ltt_lite_file_size) {
+		buf_info->log_file_pos +=
+			(ltt_lite_half_buf_size - buf_empty_size);
+	}
+	buf_info->buf_bottom_full = 0;
+}
+
+/*
+ * count the missed events
+ */
+static inline void count_lost_event(unsigned short type)
+{
+	if (unlikely(early_enabled_mode))
+		early_unlogged_count[type]++;
+	else
+		buf_info->unlogged_count[type]++;
+}
+
+/*
+ * common entry for commit log data
+ *
+ * This is an algorithm which handles a buffer composite of
+ * double buffer and circle buffer.
+ * When log data size exceeds half size of the buffer, kernel
+ * queues a work to lttlite workqueue and wakes up work thread
+ * to write that half of the buffer.
+ * To speed up logging, buf_empty_size bytes of bottom half buffer
+ * are wasted without truncating one log, as schedule and syscall
+ * events are frequent.
+ * To make work thread as simple as writing file, this algorithm
+ * declares two works for work queue, one writes top half while the
+ * other writes bottom half. When complete writing file, the work
+ * thread of workqueue release CPU immediately.
+ */
+static void commit_log(void *addr, int size, unsigned short type)
+{
+	struct record_header_t *header = addr;
+	char in_irq_handler = 0;
+	header->type = type;
+	header->ssize = size;
+
+	if (irqs_disabled())
+		in_irq_handler = 1;
+	if (!in_irq_handler)
+		local_irq_disable();
+	DPRINT(KERN_ERR "bj:%d,%d\n", type, in_irq_handler);
+	if (early_enabled_mode) {
+		if ((early_buf_pos + size) >
+			((PAGE_SIZE * ltt_lite_early_page_num) - 1)) {
+			count_lost_event(type);
+			goto complete;
+		}
+		get_time_stamp((struct timeval *) &header->timestamp_sec);
+		memcpy(ltt_lite_early_buf + early_buf_pos, addr, size);
+		early_buf_pos += size;
+		goto complete;
+	} else if (use_private_ram) {
+		/*
+		 * purpose of assign "size" to 64 is to avoid log overlap
+		 * issue when buffer overlap happening. get all log evnents
+		 * to be align with biggest log record size
+		 */
+		if ((buf_info->buf_pos + 64) > (ltt_lite_buf_size - 1)) {
+			buf_info->buf_pos = 0;
+			is_buf_overlap = 1;
+		}
+
+		get_time_stamp((struct timeval *) &header->timestamp_sec);
+
+		if (*pevent_count <= PEVENT_COUNT_MAX &&
+			header->type == LTT_LITE_EV_PROCESS) {
+			memcpy(pevent_table + *pevent_count *
+				   sizeof(struct process_table_log), addr,
+				   size);
+			(*pevent_count)++;
+		} else {
+			memcpy(ltt_lite_buf + buf_info->buf_pos, addr,
+				   size);
+			buf_info->buf_pos += 64;
+		}
+		goto complete;
+	}
+
+	/*
+	 * if log data is exceed the buffer size, write the log
+	 * from the head of buffer, and queue the bottom half work
+	 * to the work queue and wake up the thread to write bottom
+	 * half buffer.
+	 */
+	if ((buf_info->buf_pos + size) > (ltt_lite_buf_size - 1)) {
+		buf_empty_size = ltt_lite_buf_size - buf_info->buf_pos;
+		if (buf_info->buf_top_full) {
+			count_lost_event(type);
+			goto complete;
+		}
+		buf_info->buf_pos = 0;
+		buf_info->is_top = 1;
+		buf_info->buf_bottom_full = 1;
+		if (ltt_lite_wq)
+			queue_work(ltt_lite_wq, &wq_log_bottom_half_work);
+	}
+
+	if (((buf_info->buf_pos + size) > ltt_lite_half_buf_size) &&
+		buf_info->buf_bottom_full && buf_info->is_top) {
+		count_lost_event(type);
+		goto complete;
+	}
+	get_time_stamp((struct timeval *) &header->timestamp_sec);
+	memcpy(ltt_lite_buf + buf_info->buf_pos, addr, size);
+	buf_info->buf_pos += size;
+
+	/*
+	 * when log data size exceed half of buffer first time,
+	 * queue top half work to work queue and wake up the thread
+	 * to write top half buffer.
+	 */
+	if ((buf_info->buf_pos > ltt_lite_half_buf_size)
+		&& buf_info->is_top) {
+		buf_info->is_top = 0;
+		buf_info->buf_top_full = 1;
+		if (!ltt_lite_wq)
+			goto complete;
+		queue_work(ltt_lite_wq, &wq_log_top_half_work);
+	}
+	DPRINT(KERN_ERR "ej:%d\n", type);
+
+
+
+complete:
+	if (!in_irq_handler)
+		local_irq_enable();
+	return;
+}
+
+/*
+ * log the process exit event, and link the process info
+ * to the exit process list
+ */
+void ltt_lite_ev_process_exit(void)
+{
+	struct process_table_log process_log;
+	int res = 0, size = 0;
+	char *buffer = "cmdline";
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode))
+		return;
+
+	process_log.sub_type = LTT_LITE_EV_PROCESS_EXIT;
+	process_log.pid = current->pid;
+	process_log.ppid = current->parent->pid;
+	process_log.tgid = current->tgid;
+
+	res = get_proc_pid_cmdline(current, buffer);
+	if (!res)
+		buffer = current->comm;
+
+	size = strlen(buffer);
+	if (size >= LTT_LITE_TASK_COMM_LEN)
+		size = LTT_LITE_TASK_COMM_LEN - 1;
+	memset(process_log.comm, 0, sizeof(process_log.comm));
+	memcpy(process_log.comm, buffer, size);
+
+	commit_log(&process_log, sizeof(process_log), LTT_LITE_EV_PROCESS);
+}
+
+/*
+ * get a time stamp
+ */
+static inline void get_time_stamp(struct timeval *ktv)
+{
+	ktime_get_ts((struct timespec *) ktv);
+}
+
+/*
+ * use jiffies + system_timer->offset() to get the time stamp
+ * can be used when can obtain xtime_lock
+ * comment out because kernel has provided ktime_get_ts to get
+ * time
+ */
+int ltt_lite_get_ms_time(struct timeval *ktv)
+{
+	ktime_get_ts((struct timespec *) ktv);
+
+	return 0;
+}
+EXPORT_SYMBOL(ltt_lite_get_ms_time);
+
+/*
+ * check whether a pid is in pid filters
+ * return 1 on true, 0 on false
+ */
+static inline int check_in_filter(unsigned short target,
+				  unsigned short
+				  array[LTT_LITE_PID_FILTER_MAX][2],
+				  unsigned short num)
+{
+	int i;
+
+	if (num == 0)
+		return 1;
+	for (i = 0; i < num; i++) {
+		if (target >= array[i][0] && target <= array[i][1])
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * log the schedule change event
+ */
+void ltt_lite_ev_schedchange(struct ltt_lite_schedchange *schedchange)
+{
+	struct ltt_lite_schedlog sched_event;
+
+	/*
+	 * go on if ltt lite is enabled
+	 * and ltt lite is in log scheduling mode
+	 */
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_SCHD))
+		return;
+
+	if (!check_in_filter
+		(schedchange->ipid, ltt_lite_pid_filter,
+		 ltt_lite_pid_filter_num)
+		&& !check_in_filter(schedchange->opid, ltt_lite_pid_filter,
+				ltt_lite_pid_filter_num))
+		return;
+
+	memcpy(&sched_event.opid, schedchange,
+					sizeof(struct ltt_lite_schedchange));
+	commit_log(&sched_event, sizeof(sched_event),
+		   LTT_LITE_EV_SCHEDULE);
+}
+
+static inline int if_log_syscall(unsigned short syscall_pid,
+				 short syscallid)
+{
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_SYSC))
+		return 0;
+
+	if (syscall_mask_group_id != SYSCALL_GROUP_ALL && syscallid >= 0) {
+		/* use scno / 16 to get the index in the mask array,
+		   use scno % 16 to get the bit in the mask variable */
+		if ((ltt_lite_syscall_mask[syscall_mask_group_id]
+			 [(int) (syscallid / BITS_IN_SHORT)]
+			 & (1 << syscallid % BITS_IN_SHORT)) == 0)
+			return 0;
+	}
+
+	if (!check_in_filter
+		(syscall_pid, ltt_lite_pid_filter, ltt_lite_pid_filter_num))
+		return 0;
+
+	return 1;
+}
+
+/*
+ * syscall log entry
+ */
+void ltt_lite_log_syscall(char sign, int scno)
+{
+	unsigned short syscall_pid = current->pid;
+	struct ltt_lite_syscalllog syscall_event;
+	short syscallid = scno;
+
+	/*
+	 * go on if ltt lite is enabled and
+	 * ltt lite is in log system call mode
+	 */
+	if (!(if_log_syscall(syscall_pid, syscallid)))
+		return;
+
+	syscall_event.syscall_id = (sign == LTT_LITE_EVENT_ENTER) ?
+		syscallid : LTT_LITE_SYSCALL_RETURN_ID;
+	syscall_event.pid = syscall_pid;
+
+	commit_log(&syscall_event, sizeof(syscall_event),
+		   LTT_LITE_EV_SYSCALL_ENTRY);
+}
+
+/*
+ * log process event log
+ */
+void ltt_lite_ev_log_process(int type, struct task_struct *p)
+{
+	struct process_table_log process_log;
+	int res = 0, size = 0;
+	char *buffer = "cmdline";
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode))
+		return;
+
+	process_log.sub_type = type;
+	process_log.pid = p->pid;
+	process_log.ppid = p->parent->pid;
+	process_log.tgid = p->tgid;
+
+	res = get_proc_pid_cmdline(p, buffer);
+	if (!res)
+		buffer = p->comm;
+
+	size = strlen(buffer);
+	if (size >= LTT_LITE_TASK_COMM_LEN)
+		size = LTT_LITE_TASK_COMM_LEN - 1;
+	memset(process_log.comm, 0, sizeof(process_log.comm));
+	memcpy(process_log.comm, buffer, size);
+
+	commit_log(&process_log, sizeof(process_log), LTT_LITE_EV_PROCESS);
+}
+
+/*
+ * when trap is triggered, this log occurs.
+ */
+void ltt_lite_ev_trap_entry(unsigned short trapid, unsigned long address)
+{
+	struct ltt_lite_trap_log trap_log;
+	unsigned short pid;
+	UNUSED_PARAM(address);
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_TRAP))
+		return;
+	pid = current->pid;
+	if (!check_in_filter
+		(pid, ltt_lite_pid_filter, ltt_lite_pid_filter_num))
+		return;
+
+	trap_log.subtype = trapid;
+	trap_log.pid = pid;
+	commit_log(&trap_log, sizeof(trap_log), LTT_LITE_EV_TRAP);
+}
+
+/*
+ * when trap exit, this log is triggered.
+ */
+void ltt_lite_ev_trap_exit(void)
+{
+	struct ltt_lite_trap_log trap_log;
+	unsigned short pid;
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_TRAP))
+		return;
+
+	pid = current->pid;
+	if (!check_in_filter
+		(pid, ltt_lite_pid_filter, ltt_lite_pid_filter_num))
+		return;
+
+	trap_log.pid = pid;
+	trap_log.subtype = LTT_LITE_TRAP_RETURN;
+	commit_log(&trap_log, sizeof(trap_log), LTT_LITE_EV_TRAP);
+}
+
+/*
+ * log interrupt entry
+ */
+void ltt_lite_int_entry(unsigned short intid, char kmod)
+{
+	struct ltt_lite_intlog int_log;
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode)
+		|| !(ltt_lite_mode & LTT_LITE_MODE_INT))
+		return;
+	if (!check_in_filter
+		(intid, ltt_lite_int_filter, ltt_lite_int_filter_num))
+		return;
+
+	int_log.intid = intid;
+	int_log.subtype = kmod ? (LTT_LITE_EVENT_ENTER |
+				  (1 << 15)) : LTT_LITE_EVENT_ENTER;
+	commit_log(&int_log, sizeof(int_log), LTT_LITE_EV_INT);
+}
+
+/*
+ * log interrup exit
+ */
+void ltt_lite_int_exit(unsigned short intid)
+{
+	struct ltt_lite_intlog int_log;
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_INT))
+		return;
+
+	if (!check_in_filter
+		(intid, ltt_lite_int_filter, ltt_lite_int_filter_num))
+		return;
+
+	int_log.intid = intid;
+	int_log.subtype = LTT_LITE_EVENT_RETURN;
+	commit_log(&int_log, sizeof(int_log), LTT_LITE_EV_INT);
+}
+
+void ltt_lite_log_softirq(unsigned short type, unsigned int sub_type,
+			  unsigned int data)
+{
+	struct ltt_lite_soft_irq soft_irq_log;
+	if (!(ltt_lite_is_enabled | early_enabled_mode)
+		|| !(ltt_lite_mode & LTT_LITE_MODE_SOFTIRQ))
+		return;
+
+	soft_irq_log.sub_type = sub_type, soft_irq_log.data = data;
+
+	commit_log(&soft_irq_log, sizeof(soft_irq_log), type);
+}
+
+/*
+ * this interface is for some user to log special log.
+ * This log is logged when ltt-lite is enabled.
+ */
+int ltt_lite_log_string(char *string, int size)
+{
+	char userinfo[sizeof(struct record_header_t) +
+			  LTT_LITE_MAX_LOG_STRING_SIZE];
+
+	/* we don't need ioctl parameters on bootup log */
+	if (!(ltt_lite_is_enabled | early_enabled_mode))
+		return 0;
+	memset(userinfo, 0, sizeof(userinfo));
+	if (size < LTT_LITE_MAX_LOG_STRING_SIZE) {
+		memcpy(userinfo + sizeof(struct record_header_t), string, size);
+		commit_log(userinfo, sizeof(struct record_header_t) + size,
+			   LTT_LITE_EV_STRING);
+	} else {
+		memcpy(userinfo + sizeof(struct record_header_t), string,
+			   LTT_LITE_MAX_LOG_STRING_SIZE);
+		commit_log(userinfo, sizeof(userinfo), LTT_LITE_EV_STRING);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ltt_lite_log_string);
+
+/*
+ * printf-style interface to user logging
+ *
+ * @param fmt	printf-style format string
+ */
+void ltt_lite_printf(char *fmt, ...)
+{
+	va_list fmtargs;
+	char buffer[LTT_LITE_MAX_LOG_STRING_SIZE];
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode))
+		return;
+
+	va_start(fmtargs, fmt);
+	vsnprintf(buffer, sizeof(buffer) - 1, fmt, fmtargs);
+	va_end(fmtargs);
+
+	ltt_lite_log_string(buffer, LTT_LITE_MAX_LOG_STRING_SIZE);
+}
+EXPORT_SYMBOL(ltt_lite_printf);
+
+void ltt_lite_syscall_param(int scno, char *string, int size)
+{
+	unsigned short syscall_pid = current->pid;
+	short syscallid = scno;
+
+	/*
+	 * go on if ltt lite is enabled (non-early mode)and
+	 * ltt lite is in log system call mode
+	 * for early log mode, we only let __NR_lttlite go through
+	 */
+	if (!if_log_syscall(syscall_pid, syscallid)
+		|| (early_enabled_mode && (scno != __NR_lttlite)))
+		return;
+
+	ltt_lite_log_string(string, size);
+}
+
+void ltt_lite_ev_sig(unsigned short s_pid, unsigned short r_pid,
+			 unsigned short sig)
+{
+	struct sig_send_log slog;
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_SIG))
+		return;
+
+	slog.s_pid = s_pid;
+	slog.r_pid = r_pid;
+	slog.sig = sig;
+	commit_log(&slog, sizeof(slog), LTT_LITE_EV_SIG);
+}
+
+void ltt_lite_ev_handle_sig(unsigned short pid, unsigned short sig,
+				unsigned long handler)
+{
+	struct sig_handle_log slog;
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_SIG))
+		return;
+
+	slog.sig = sig;
+	slog.pid = pid;
+	slog.handler = handler;
+	commit_log(&slog, sizeof(slog), LTT_LITE_EV_SIG_HANDLE);
+}
+
+void ltt_lite_log_timer(struct timer_list *timer, unsigned short type)
+{
+	struct timer_log tlog;
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_TMR))
+		return;
+
+	tlog.pid = current->pid;
+	tlog.sub_type = type;
+	tlog.exp = timer->expires;
+	/* tlog.ace = timer->arch_cycle_expires; */
+	tlog.ace = 0;
+	tlog.fn = (unsigned long) (timer->function);
+	commit_log(&tlog, sizeof(tlog), LTT_LITE_EV_TIMER);
+}
+
+void ltt_lite_run_timer(unsigned short timer_type, unsigned long fn,
+			unsigned long data)
+{
+	struct timer_run_log tlog;
+
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+		!(ltt_lite_mode & LTT_LITE_MODE_TMR))
+		return;
+
+	tlog.timer_type = timer_type;
+	tlog.fn = fn;
+	tlog.data = data;
+	commit_log(&tlog, sizeof(tlog), LTT_LITE_EV_TIMER_RUN);
+}
+
+asmlinkage long sys_lttlite(unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case LLEVENT:{
+			char ltt_string[LTT_LITE_MAX_LOG_STRING_SIZE];
+
+			snprintf(ltt_string, LTT_LITE_MAX_LOG_STRING_SIZE,
+				 "User event:pid=%d,eventid=%d\n",
+				 current->pid, (unsigned int) arg);
+			ltt_lite_syscall_param(__NR_lttlite, ltt_string,
+						   strlen(ltt_string));
+
+			break;
+		}
+	case LLINFO:{
+			char ltt_string[LTT_LITE_MAX_LOG_STRING_SIZE];
+			int len;
+
+			len =
+				strncpy_from_user(ltt_string, (char *) arg,
+						  LTT_LITE_MAX_LOG_STRING_SIZE
+						  - 1);
+				if (len < 0)
+					return -EFAULT;
+
+			ltt_string[LTT_LITE_MAX_LOG_STRING_SIZE - 1] =
+				'\0';
+
+			ltt_lite_log_string(ltt_string, len);
+
+			break;
+		}
+	default:
+		return -EPERM;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(sys_lttlite);
+
+/*
+ * get value of /proc/<pid>/cmdline
+ */
+static int get_proc_pid_cmdline(struct task_struct *task, char *buffer)
+{
+	unsigned int len;
+	struct mm_struct *mm = get_task_mm(task);
+	int res = 0;
+
+	if (!mm)
+		goto out;
+	if (!mm->arg_end)
+		goto out_mm;
+
+	len = mm->arg_end - mm->arg_start;
+
+	if (len > PAGE_SIZE)
+		len = PAGE_SIZE;
+
+	res = access_process_vm(task, mm->arg_start, buffer, len, 0);
+
+	if (res > 0 && buffer[res - 1] != '\0' && len < PAGE_SIZE) {
+		len = strnlen(buffer, res);
+		if (len < res)
+			res = len;
+		else {
+			len = mm->env_end - mm->env_start;
+			if (len > PAGE_SIZE - res)
+				len = PAGE_SIZE - res;
+				res += access_process_vm(task,
+							mm->env_start,
+							buffer+res, len, 0);
+			res = strnlen(buffer, res);
+		}
+	}
+
+out_mm:
+	mmput(mm);
+out:
+	return res;
+}
+
+/*
+ * set Ltt-Lite version
+ */
+static int set_ltt_version(void)
+{
+	char ltt_string[LTT_LITE_MAX_LOG_STRING_SIZE];
+	int len;
+
+	if (ltt_version_tag)
+		ltt_version_tag++;
+	else {
+		/* record LTT-Lite version in the 1st record */
+		snprintf(ltt_string,
+			LTT_LITE_MAX_LOG_STRING_SIZE,
+			"%s\n",
+			LTT_LITE_VERSION);
+		len = strlen(ltt_string);
+
+		ltt_lite_log_string(ltt_string, len);
+		ltt_version_tag++ ;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+/*
+ * This interface is for logging custom LTT-lite events from
+ * Android userspace (/dev/log/xxx), for graphical interpretation
+ * by the Taskview postprocessing tool.
+ */
+int ltt_lite_log_android(const struct iovec *iov,
+						unsigned long nr_segs,
+						char logchar)
+{
+	struct ltt_lite_android_event *record;
+	char *recptr;
+	int   reclen;
+	int   type;
+	int   vecs;
+
+	if (!ltt_lite_is_enabled)
+		return 0;
+
+	/* Select record type based on unique log name character */
+	switch (logchar) {
+			/* /dev/log/main   = android.util.Log      */
+	case 'm':
+		type = LTT_LITE_EV_ANDROID_LOG;
+		break;
+
+	/* /dev/log/events = android.util.EventLog */
+	case 'e':
+		type = LTT_LITE_EV_ANDROID_EVENTLOG;
+		break;
+
+	/* /dev/log/radio                          */
+	case 'r':
+		type = LTT_LITE_EV_ANDROID_RADIO;
+		break;
+
+	/* Undefined log type - just exit          */
+	default:
+		return 0;
+	}
+
+	/* Log only if the mode mask allows */
+	if (type == LTT_LITE_EV_ANDROID_RADIO) {
+		if (!(ltt_lite_mode & LTT_LITE_MODE_ANDROID_RADIO))
+			return 0;
+	} else {
+		if (!(ltt_lite_mode & LTT_LITE_MODE_ANDROID))
+			return 0;
+	}
+
+	/* Setup local buffer parameters for copy from userspace vectors */
+	record = (struct ltt_lite_android_event *) ltt_lite_small_buffer;
+	recptr = (char *) &(record->data);
+	/* offsetof(ltt_lite_android_event, data)? */
+	reclen = sizeof(record_header_t) + 4;
+	record->pid = current->pid;   /* Record the PID for the event */
+
+	/* Get the vector data from userspace */
+	for (vecs = 0; vecs < nr_segs; vecs++)	{
+		/* Discard the event if it exceeds the static buffer size */
+		if ((reclen + iov->iov_len) > LTT_LITE_SMALL_BUFFER_SIZE)
+			return 0;
+
+		/* Discard the event if all data was not copied */
+		if (copy_from_user(recptr, iov->iov_base, iov->iov_len))
+			return 0;
+
+		/* Advance the pointer in the record buffer  */
+		recptr += iov->iov_len;
+		/* Increment the size of the record buffer payload portion */
+		reclen += iov->iov_len;
+		/* Point to the next vector (userspace data) */
+		iov++;
+	}
+
+	/* Write populated record buffer into main LTT-lite log buffer */
+	commit_log(record, reclen, type);
+	return android_logging_mode;
+}
+
+/*
+ * This interface is for logging the printk message stream,
+ * for graphical interpretation by the Taskview postprocessing tool.
+ */
+void ltt_lite_log_printk(char *string, int size)
+{
+	if (!(ltt_lite_is_enabled | early_enabled_mode) ||
+			!(ltt_lite_mode & LTT_LITE_MODE_PRINTK))
+		return;
+
+	if ((sizeof(record_header_t) + size) <
+					LTT_LITE_SMALL_BUFFER_SIZE) {
+		memcpy(ltt_lite_small_buffer + sizeof(record_header_t),
+						string, size);
+		commit_log(ltt_lite_small_buffer, sizeof(record_header_t) +
+						size,
+						LTT_LITE_EV_PRINTK);
+	} else {
+		memcpy(ltt_lite_small_buffer + sizeof(record_header_t),
+					string, LTT_LITE_SMALL_BUFFER_SIZE);
+		/* Truncate/terminate string */
+		ltt_lite_small_buffer[LTT_LITE_SMALL_BUFFER_SIZE - 1] = 0;
+		commit_log(ltt_lite_small_buffer,
+						LTT_LITE_SMALL_BUFFER_SIZE,
+						LTT_LITE_EV_PRINTK);
+	}
+}
+#endif
diff --git a/kernel/module.c b/kernel/module.c
index 1196f5d..73c79fd 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -46,12 +46,17 @@
 #include <linux/rculist.h>
 #include <asm/uaccess.h>
 #include <asm/cacheflush.h>
+#include <linux/gcov.h>
 #include <linux/license.h>
 #include <asm/sections.h>
 #include <linux/tracepoint.h>
 #include <linux/ftrace.h>
 #include <linux/async.h>
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+int kmemleak_module;
+#endif
+
 #if 0
 #define DEBUGP printk
 #else
@@ -337,6 +342,19 @@ static unsigned long find_symbol(const char *name,
 {
 	struct find_symbol_arg fsa;
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+	if (kmemleak_module) {
+		if (strcmp(name, "__kmalloc") == 0)
+			name = "__memleak_kmalloc";
+		else if (strcmp(name, "kfree") == 0)
+			name = "memleak_kfree";
+		else if (strcmp(name, "vfree") == 0)
+			name = "memleak_vfree";
+		else if (strcmp(name, "vmalloc") == 0)
+			name = "memleak_vmalloc";
+	}
+#endif
+
 	fsa.name = name;
 	fsa.gplok = gplok;
 	fsa.warn = warn;
@@ -1454,6 +1472,11 @@ static void free_module(struct module *mod)
 	/* Arch-specific cleanup. */
 	module_arch_cleanup(mod);
 
+#ifdef CONFIG_GCOV_PROFILE
+	if (mod->ctors_start && mod->ctors_end)
+		remove_bb_link(mod);
+#endif
+
 	/* Module unload stuff */
 	module_unload_free(mod);
 
@@ -1856,6 +1879,40 @@ static void *module_alloc_update_bounds(unsigned long size)
 	return ret;
 }
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+static void memleak_load_module(struct module *mod, Elf_Ehdr *hdr,
+				Elf_Shdr *sechdrs, char *secstrings)
+{
+	unsigned int mloffindex, i;
+
+	/* insert any new pointer aliases */
+	mloffindex = find_sec(hdr, sechdrs, secstrings,
+				".init.memleak_offsets");
+	if (mloffindex)
+		memleak_insert_aliases((void *)sechdrs[mloffindex].sh_addr,
+				       (void *)sechdrs[mloffindex].sh_addr
+				       + sechdrs[mloffindex].sh_size);
+
+	/* only scan the sections containing data */
+	memleak_scan_area(mod->module_core,
+			  (unsigned long)mod - (unsigned long)mod->module_core,
+			  sizeof(struct module));
+
+	for (i = 1; i < hdr->e_shnum; i++) {
+		if (!(sechdrs[i].sh_flags & SHF_ALLOC))
+			continue;
+		if (strncmp(secstrings + sechdrs[i].sh_name, ".data", 5) != 0
+		    && strncmp(secstrings + sechdrs[i].sh_name, ".bss", 4) != 0)
+			continue;
+
+		memleak_scan_area(mod->module_core,
+				  sechdrs[i].sh_addr -
+				  (unsigned long)mod->module_core,
+				  sechdrs[i].sh_size);
+	}
+}
+#endif
+
 /* Allocate and load the module: note that size of section 0 is always
    zero, and we rely on this for optional sections. */
 static noinline struct module *load_module(void __user *umod,
@@ -1948,6 +2005,9 @@ static noinline struct module *load_module(void __user *umod,
 	}
 	/* This is temporary: point mod into copy of data. */
 	mod = (void *)sechdrs[modindex].sh_addr;
+#ifdef CONFIG_DEBUG_MEMLEAK
+	memleak_load_module(mod, hdr, sechdrs, secstrings);
+#endif
 
 	if (symindex == 0) {
 		printk(KERN_WARNING "%s: module has no symbols (stripped?)\n",
@@ -2082,6 +2142,13 @@ static noinline struct module *load_module(void __user *umod,
 		goto free_init;
 	}
 #endif
+
+#ifdef CONFIG_GCOV_PROFILE
+	modindex = find_sec(hdr, sechdrs, secstrings, ".init_array");
+	mod->ctors_start = (char *)sechdrs[modindex].sh_addr;
+	mod->ctors_end   = (char *)(mod->ctors_start +
+				sechdrs[modindex].sh_size);
+#endif
 	/* Now we've moved module, initialize linked lists, etc. */
 	module_unload_init(mod);
 
@@ -2340,6 +2407,14 @@ SYSCALL_DEFINE3(init_module, void __user *, umod,
 	blocking_notifier_call_chain(&module_notify_list,
 			MODULE_STATE_COMING, mod);
 
+#ifdef CONFIG_GCOV_PROFILE
+	if (mod->ctors_start && mod->ctors_end) {
+		do_global_ctors((ctor_t *) mod->ctors_start,
+			(mod->ctors_end - mod->ctors_start) / sizeof(ctor_t),
+			 mod);
+	}
+#endif
+
 	/* Start the module */
 	if (mod->init != NULL)
 		ret = do_one_initcall(mod->init);
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index 015e6ae..d1d81a9 100644
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -271,3 +271,11 @@ config APM_EMULATION
 	  random kernel OOPSes or reboots that don't seem to be related to
 	  anything, try disabling/enabling this option (or disabling/enabling
 	  APM in your BIOS).
+
+config QUICK_WAKEUP
+	bool "Quick wakeup"
+	depends on SUSPEND
+	default n
+	---help---
+	  Allow kernel driver to do periodic jobs without resuming the full system
+	  This option can increase battery life on android powered smartphone.
diff --git a/kernel/power/Makefile b/kernel/power/Makefile
index 0656094..f9bfc5b 100644
--- a/kernel/power/Makefile
+++ b/kernel/power/Makefile
@@ -1,5 +1,5 @@
 
-ifeq ($(CONFIG_PM_DEBUG),y)
+ifeq ($(CONFIG_PM_VERBOSE),y)
 EXTRA_CFLAGS	+=	-DDEBUG
 endif
 
@@ -12,5 +12,5 @@ obj-$(CONFIG_EARLYSUSPEND)	+= earlysuspend.o
 obj-$(CONFIG_CONSOLE_EARLYSUSPEND)	+= consoleearlysuspend.o
 obj-$(CONFIG_FB_EARLYSUSPEND)	+= fbearlysuspend.o
 obj-$(CONFIG_HIBERNATION)	+= swsusp.o disk.o snapshot.o swap.o user.o
-
+obj-$(CONFIG_QUICK_WAKEUP)	+= quickwakeup.o
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
diff --git a/kernel/power/main.c b/kernel/power/main.c
index bbc9c1c..17e941f 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -22,9 +22,16 @@
 #include <linux/freezer.h>
 #include <linux/vmstat.h>
 #include <linux/syscalls.h>
+#include <linux/quickwakeup.h>
+#include <linux/wakelock.h>
 
 #include "power.h"
 
+#ifdef CONFIG_OMAP_WATCHDOG
+int omap_wdt_suspend(pm_message_t state);
+int omap_wdt_resume(void);
+#endif
+
 DEFINE_MUTEX(pm_mutex);
 
 unsigned int pm_flags;
@@ -279,25 +286,21 @@ void __attribute__ ((weak)) arch_suspend_enable_irqs(void)
 	local_irq_enable();
 }
 
-/**
- *	suspend_enter - enter the desired system sleep state.
- *	@state:		state to enter
- *
- *	This function should be called after devices have been suspended.
- */
-static int suspend_enter(suspend_state_t state)
+static int _suspend_enter(suspend_state_t state)
 {
 	int error = 0;
 
-	device_pm_lock();
 	arch_suspend_disable_irqs();
 	BUG_ON(!irqs_disabled());
-
 	if ((error = device_power_down(PMSG_SUSPEND))) {
 		printk(KERN_ERR "PM: Some devices failed to power down\n");
 		goto Done;
 	}
 
+#ifdef CONFIG_OMAP_WATCHDOG
+	omap_wdt_suspend(PMSG_SUSPEND);
+#endif
+
 	error = sysdev_suspend(PMSG_SUSPEND);
 	if (!error) {
 		if (!suspend_test(TEST_CORE))
@@ -305,10 +308,40 @@ static int suspend_enter(suspend_state_t state)
 		sysdev_resume();
 	}
 
+#ifdef CONFIG_OMAP_WATCHDOG
+	omap_wdt_resume();
+#endif
+
 	device_power_up(PMSG_RESUME);
  Done:
+
+#ifdef CONFIG_QUICK_WAKEUP
+	quickwakeup_check();
+#endif
 	arch_suspend_enable_irqs();
 	BUG_ON(irqs_disabled());
+	return error;
+}
+
+/**
+ *	suspend_enter - enter the desired system sleep state.
+ *	@state:		state to enter
+ *
+ *	This function should be called after devices have been suspended.
+ */
+static int suspend_enter(suspend_state_t state)
+{
+	int error = 0;
+	device_pm_lock();
+	error = _suspend_enter(state);
+
+#ifdef CONFIG_QUICK_WAKEUP
+	while (!error && !quickwakeup_execute()) {
+		if (has_wake_lock(WAKE_LOCK_SUSPEND))
+			break;
+		error = _suspend_enter(state);
+	}
+#endif
 	device_pm_unlock();
 	return error;
 }
@@ -430,9 +463,9 @@ static int enter_state(suspend_state_t state)
 	if (!mutex_trylock(&pm_mutex))
 		return -EBUSY;
 
-	printk(KERN_INFO "PM: Syncing filesystems ... ");
+	pr_debug("PM: Syncing filesystems ... ");
 	sys_sync();
-	printk("done.\n");
+	pr_debug("done.\n");
 
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state]);
 	error = suspend_prepare();
diff --git a/kernel/power/process.c b/kernel/power/process.c
index 723cfbe..4dc95cd 100644
--- a/kernel/power/process.c
+++ b/kernel/power/process.c
@@ -5,8 +5,9 @@
  * Originally from swsusp.
  */
 
-
-#undef DEBUG
+#ifdef CONFIG_PM_VERBOSE
+#define DEBUG
+#endif
 
 #include <linux/interrupt.h>
 #include <linux/suspend.h>
@@ -105,7 +106,7 @@ static int try_to_freeze_tasks(bool sig_only)
 		} while_each_thread(g, p);
 		read_unlock(&tasklist_lock);
 	} else {
-		printk("(elapsed %d.%02d seconds) ", elapsed_csecs / 100,
+		pr_debug("(elapsed %d.%02d seconds) ", elapsed_csecs / 100,
 			elapsed_csecs % 100);
 	}
 
@@ -119,20 +120,20 @@ int freeze_processes(void)
 {
 	int error;
 
-	printk("Freezing user space processes ... ");
+	pr_debug("Freezing user space processes ... ");
 	error = try_to_freeze_tasks(true);
 	if (error)
 		goto Exit;
-	printk("done.\n");
+	pr_debug("done.\n");
 
-	printk("Freezing remaining freezable tasks ... ");
+	pr_debug("Freezing remaining freezable tasks ... ");
 	error = try_to_freeze_tasks(false);
 	if (error)
 		goto Exit;
-	printk("done.");
+	pr_debug("done.");
  Exit:
 	BUG_ON(in_atomic());
-	printk("\n");
+	pr_debug("\n");
 	return error;
 }
 
@@ -158,10 +159,10 @@ static void thaw_tasks(bool nosig_only)
 
 void thaw_processes(void)
 {
-	printk("Restarting tasks ... ");
+	pr_debug("Restarting tasks ... ");
 	thaw_tasks(true);
 	thaw_tasks(false);
 	schedule();
-	printk("done.\n");
+	pr_debug("done.\n");
 }
 
diff --git a/kernel/power/quickwakeup.c b/kernel/power/quickwakeup.c
new file mode 100644
index 0000000..f473c2f
--- /dev/null
+++ b/kernel/power/quickwakeup.c
@@ -0,0 +1,62 @@
+/* kernel/power/quickwakeup.c
+ *
+ * Copyright (C) 2009 Motorola.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/quickwakeup.h>
+#include <linux/module.h>
+static LIST_HEAD(qw_head);
+
+int quickwakeup_register(struct quickwakeup_ops *ops)
+{
+	list_add(&ops->list, &qw_head);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(quickwakeup_register);
+
+void quickwakeup_unregister(struct quickwakeup_ops *ops)
+{
+	list_del(&ops->list);
+}
+EXPORT_SYMBOL_GPL(quickwakeup_unregister);
+int quickwakeup_check(void)
+{
+	int ret = 0;
+	struct quickwakeup_ops *index;
+
+	list_for_each_entry(index, &qw_head, list) {
+		index->checked = index->qw_check();
+		ret |= index->checked;
+	}
+	return ret;
+}
+
+int quickwakeup_execute(void)
+{
+	int ret = 0;
+	int count = 0;
+	struct quickwakeup_ops *index;
+
+	list_for_each_entry(index, &qw_head, list) {
+		if (index->checked) {
+			ret = index->qw_callback();
+			if (ret != 0)
+				return ret;
+			count++;
+		}
+	}
+	if (!count)
+		return -1;
+	return 0;
+}
diff --git a/kernel/printk.c b/kernel/printk.c
index f5aa8c1..ef0db9b 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -32,6 +32,9 @@
 #include <linux/security.h>
 #include <linux/bootmem.h>
 #include <linux/syscalls.h>
+#ifdef CONFIG_LTT_LITE
+#include <linux/lttlite-events.h>
+#endif
 
 #include <asm/uaccess.h>
 
@@ -721,6 +724,11 @@ asmlinkage int vprintk(const char *fmt, va_list args)
 #ifdef	CONFIG_DEBUG_LL
 	printascii(printk_buf);
 #endif
+#ifdef CONFIG_LTT_LITE
+#ifdef CONFIG_LTT_LITE_ANDROID_LOG
+	ltt_lite_log_printk(printk_buf, printed_len);
+#endif
+#endif
 
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
@@ -941,7 +949,7 @@ void suspend_console(void)
 {
 	if (!console_suspend_enabled)
 		return;
-	printk("Suspending console(s) (use no_console_suspend to debug)\n");
+	/*printk("Suspending console(s) (use no_console_suspend to debug)\n");*/
 	acquire_console_sem();
 	console_suspended = 1;
 	up(&console_sem);
diff --git a/kernel/sched.c b/kernel/sched.c
index f20bab0..5fafb08 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -72,6 +72,8 @@
 #include <linux/debugfs.h>
 #include <linux/ctype.h>
 #include <linux/ftrace.h>
+#include <linux/lttlite-events.h>
+
 #include <trace/sched.h>
 
 #include <asm/tlb.h>
@@ -4639,12 +4641,21 @@ need_resched_nonpreemptible:
 	next = pick_next_task(rq, prev);
 
 	if (likely(prev != next)) {
+#ifdef CONFIG_LTT_LITE
+		struct ltt_lite_schedchange sched_event;
+#endif
+
 		sched_info_switch(prev, next);
 
 		rq->nr_switches++;
 		rq->curr = next;
 		++*switch_count;
 
+#ifdef CONFIG_LTT_LITE
+		ltt_init_sched_event(&sched_event, prev, next);
+		ltt_ev_schedchange(&sched_event);
+#endif
+
 		context_switch(rq, prev, next); /* unlocks the rq */
 		/*
 		 * the context switch might have flipped the stack from under
diff --git a/kernel/sched_features.h b/kernel/sched_features.h
index da5d93b..f587502 100644
--- a/kernel/sched_features.h
+++ b/kernel/sched_features.h
@@ -1,5 +1,5 @@
 SCHED_FEAT(NEW_FAIR_SLEEPERS, 1)
-SCHED_FEAT(NORMALIZED_SLEEPER, 1)
+SCHED_FEAT(NORMALIZED_SLEEPER, 0)
 SCHED_FEAT(WAKEUP_PREEMPT, 1)
 SCHED_FEAT(START_DEBIT, 1)
 SCHED_FEAT(AFFINE_WAKEUPS, 1)
diff --git a/kernel/signal.c b/kernel/signal.c
index 1c88144..3e2243b 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -27,6 +27,8 @@
 #include <linux/freezer.h>
 #include <linux/pid_namespace.h>
 #include <linux/nsproxy.h>
+#include <linux/lttlite-events.h>
+
 #include <trace/sched.h>
 
 #include <asm/param.h>
@@ -819,6 +821,14 @@ static int send_signal(int sig, struct siginfo *info, struct task_struct *t,
 	struct sigpending *pending;
 	struct sigqueue *q;
 
+#ifdef CONFIG_LTT_LITE
+	ltt_lite_ev_sig(
+				((unsigned long)info > 2)
+				? ((unsigned short)current->pid)
+				: 0,
+				(unsigned short)t->pid, (unsigned short)sig);
+#endif
+
 	trace_sched_signal_send(sig, t);
 
 	assert_spin_locked(&t->sighand->siglock);
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 9041ea7..51d381c 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -23,6 +23,7 @@
 #include <linux/rcupdate.h>
 #include <linux/smp.h>
 #include <linux/tick.h>
+#include <linux/lttlite-events.h>
 
 #include <asm/irq.h>
 /*
@@ -193,9 +194,17 @@ restart:
 
 	do {
 		if (pending & 1) {
+#ifdef CONFIG_LTT_LITE
+			ltt_ev_soft_irq(LTT_EV_SOFT_IRQ_SOFT_IRQ,
+							(h - softirq_vec));
+#endif
 			int prev_count = preempt_count();
 
 			h->action(h);
+#ifdef CONFIG_LTT_LITE
+			ltt_lite_log_softirq(LTT_LITE_EV_SOFT_IRQ,
+				LTT_LITE_EVENT_RETURN, (h - softirq_vec));
+#endif
 
 			if (unlikely(prev_count != preempt_count())) {
 				printk(KERN_ERR "huh, entered softirq %td %p"
@@ -380,7 +389,16 @@ static void tasklet_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+#ifdef CONFIG_LTT_LITE
+				ltt_ev_soft_irq(LTT_EV_SOFT_IRQ_TASKLET_ACTION,
+					(unsigned long) (t->func));
+#endif
 				t->func(t->data);
+#ifdef CONFIG_LTT_LITE
+				ltt_lite_log_softirq(LTT_LITE_EV_TASKLET,
+					LTT_LITE_EVENT_RETURN,
+					(unsigned long) (t->func));
+#endif
 				tasklet_unlock(t);
 				continue;
 			}
@@ -415,7 +433,17 @@ static void tasklet_hi_action(struct softirq_action *a)
 			if (!atomic_read(&t->count)) {
 				if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 					BUG();
+#ifdef CONFIG_LTT_LITE
+				ltt_ev_soft_irq(
+					LTT_EV_SOFT_IRQ_TASKLET_HI_ACTION,
+					(unsigned long) (t->func));
+#endif
 				t->func(t->data);
+#ifdef CONFIG_LTT_LITE
+				ltt_lite_log_softirq(LTT_LITE_EV_TASKLET_HI,
+					LTT_LITE_EVENT_RETURN,
+					(unsigned long) (t->func));
+#endif
 				tasklet_unlock(t);
 				continue;
 			}
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 44df94d..dee246e 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -58,6 +58,10 @@
 #include <asm/io.h>
 #endif
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+#include <linux/memleak.h>
+#endif
+
 static int deprecated_sysctl_warning(struct __sysctl_args *args);
 
 #if defined(CONFIG_SYSCTL)
@@ -1452,6 +1456,16 @@ static struct ctl_table debug_table[] = {
 		.proc_handler	= proc_dointvec
 	},
 #endif
+#ifdef CONFIG_DEBUG_MEMLEAK
+	{
+		.ctl_name	= CTL_UNNUMBERED,
+		.procname	= "kmemleak_module",
+		.data		= &kmemleak_module,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+#endif
 	{ .ctl_name = 0 }
 };
 
diff --git a/kernel/timer.c b/kernel/timer.c
index 13dd64f..faae592 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -37,6 +37,7 @@
 #include <linux/delay.h>
 #include <linux/tick.h>
 #include <linux/kallsyms.h>
+#include <linux/lttlite-events.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -628,6 +629,9 @@ int __mod_timer(struct timer_list *timer, unsigned long expires)
 	}
 
 	timer->expires = expires;
+#ifdef CONFIG_LTT_LITE
+	ltt_lite_log_timer(timer, LTT_LITE_EVENT_ENTER);
+#endif
 	internal_add_timer(base, timer);
 	spin_unlock_irqrestore(&base->lock, flags);
 
@@ -651,6 +655,9 @@ void add_timer_on(struct timer_list *timer, int cpu)
 	timer_stats_timer_set_start_info(timer);
 	BUG_ON(timer_pending(timer) || !timer->function);
 	spin_lock_irqsave(&base->lock, flags);
+#ifdef CONFIG_LTT_LITE
+	ltt_lite_log_timer(timer, LTT_LITE_EVENT_ENTER);
+#endif
 	timer_set_base(timer, base);
 	debug_timer_activate(timer);
 	internal_add_timer(base, timer);
@@ -731,6 +738,10 @@ int del_timer(struct timer_list *timer)
 		spin_unlock_irqrestore(&base->lock, flags);
 	}
 
+#ifdef CONFIG_LTT_LITE
+	ltt_lite_log_timer(timer, LTT_LITE_EVENT_RETURN);
+#endif
+
 	return ret;
 }
 
@@ -864,6 +875,12 @@ static inline void __run_timers(struct tvec_base *base)
 			spin_unlock_irq(&base->lock);
 			{
 				int preempt_count = preempt_count();
+#ifdef CONFIG_LTT_LITE
+				ltt_lite_run_timer(
+					LTT_LITE_RUN_TIMER,
+					(unsigned long)fn,
+					data);
+#endif
 				fn(data);
 				if (preempt_count != preempt_count()) {
 					printk(KERN_ERR "huh, entered %p "
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 1bcf9cd..0a985d4 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -298,6 +298,143 @@ config SLUB_STATS
 	  out which slabs are relevant to a particular load.
 	  Try running: slabinfo -DA
 
+menuconfig DEBUG_MEMLEAK
+	bool "Kernel memory leak detector"
+	default n
+	depends on EXPERIMENTAL && DEBUG_SLAB
+	select DEBUG_FS
+	select STACKTRACE
+	select FRAME_POINTER
+	select KALLSYMS
+	help
+	  Say Y here if you want to enable the memory leak
+	  detector. The memory allocation/freeing is traced in a way
+	  similar to the Boehm's conservative garbage collector, the
+	  difference being that the orphan objects are not freed but
+	  only shown in /sys/kernel/debug/memleak. Enabling this
+	  feature will introduce an overhead to memory
+	  allocations. See Documentation/kmemleak.txt for more
+	  details.
+
+	  In order to access the memleak file, debugfs needs to be
+	  mounted (usually at /sys/kernel/debug).
+
+config DEBUG_MEMLEAK_DYNAMIC_NR
+	bool "Dynamic maximum number of reported leaks"
+	default n
+	depends on DEBUG_MEMLEAK
+	help
+	  This option sets the maximum number of leaks reported. If
+	  this number is too big and there are leaks to be reported,
+	  reading the /sys/kernel/debug/memleak file could lead to
+	  some soft-locks.
+
+config DEBUG_MEMLEAK_HASH_BITS
+	int "Pointer hash bits"
+	default 16
+	depends on DEBUG_MEMLEAK
+	help
+	  This option sets the number of bits used for the pointer
+	  hash table. Higher values give better memory scanning
+	  performance but also lead to bigger RAM usage. The size of
+	  the allocated hash table is (sizeof(void*) * 2^hash_bits).
+
+	  The minimum recommended value is 16. A maximum value of
+	  around 20 should be sufficient.
+
+config DEBUG_MEMLEAK_TRACE_LENGTH
+	int "Stack trace length"
+	default 4
+	depends on DEBUG_MEMLEAK && FRAME_POINTER
+	help
+	  This option sets the length of the stack trace for the
+	  allocated objects tracked by kmemleak.
+
+config DEBUG_MEMLEAK_PREINIT_OBJECTS
+	int "Pre-init actions buffer size"
+	default 512
+	depends on DEBUG_MEMLEAK
+	help
+	  This is the buffer for storing the memory allocation/freeing
+	  calls before kmemleak is fully initialized. Each element in
+	  the buffer takes 24 bytes on a 32 bit architecture. This
+	  buffer will be freed once the system initialization is
+	  completed.
+
+config DEBUG_MEMLEAK_SECONDARY_ALIASES
+	bool "Create secondary level pointer aliases"
+	default y
+	depends on DEBUG_MEMLEAK
+	help
+	  This option creates aliases for container_of(container_of(member))
+	  access to objects. Disabling this option reduces the chances of
+	  false negatives but it can slightly increase the number of false
+	  positives.
+
+config DEBUG_MEMLEAK_TASK_STACKS
+	bool "Scan task kernel stacks"
+	default y
+	depends on DEBUG_MEMLEAK
+	help
+	  This option enables the scanning of the task kernel
+	  stacks. This option can introduce false negatives because of
+	  the randomness of stacks content.
+
+	  If unsure, say Y.
+
+config DEBUG_MEMLEAK_ORPHAN_FREEING
+	bool "Notify when freeing orphan objects"
+	default n
+	depends on DEBUG_MEMLEAK
+	help
+	  This option enables the notification when objects
+	  considered leaks are freed. The stack dump and the object
+	  information displayed allow an easier identification of
+	  false positives. Use this mainly for debugging kmemleak.
+
+	  If unsure, say N.
+
+config DEBUG_MEMLEAK_REPORT_THLD
+	int "Unreferenced reporting threshold"
+	default 1
+	depends on DEBUG_MEMLEAK
+	help
+	  This option sets the number of times an object needs to be
+	  detected as unreferenced before being reported as a memory
+	  leak. A value of 0 means that the object will be reported
+	  the first time it is found as unreferenced. Other positive
+	  values mean that the object needs to be found as
+	  unreferenced a specified number of times prior to being
+	  reported.
+
+	  This is useful to avoid the reporting of transient false
+	  positives where the pointers might be held in CPU registers,
+	  especially on SMP systems, or on the stack when the stack
+	  scanning option is disabled.
+
+config DEBUG_KEEP_INIT
+	bool "Do not free the __init code/data"
+	default n
+	depends on DEBUG_MEMLEAK
+	help
+	  This option moves the __init code/data out of the
+	  .init.text/.init.data sections. It is useful for identifying
+	  memory leaks happening during the kernel or modules
+	  initialization.
+
+	  If unsure, say N.
+
+config DEBUG_MEMLEAK_TEST
+	tristate "Test the kernel memory leak detector"
+	default n
+	depends on DEBUG_MEMLEAK
+	help
+	  Say Y or M here to build the test harness for the kernel
+	  memory leak detector. At the moment, this option enables a
+	  module that explicitly leaks memory.
+
+	  If unsure, say N.
+
 config DEBUG_PREEMPT
 	bool "Debug preemptible kernel"
 	depends on DEBUG_KERNEL && PREEMPT && (TRACE_IRQFLAGS_SUPPORT || PPC64)
@@ -905,3 +1042,4 @@ config DYNAMIC_PRINTK_DEBUG
 source "samples/Kconfig"
 
 source "lib/Kconfig.kgdb"
+source "kernel/gcov/Kconfig"
diff --git a/mm/Makefile b/mm/Makefile
index 78f97ff..2897610 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -34,3 +34,6 @@ obj-$(CONFIG_MIGRATION) += migrate.o
 obj-$(CONFIG_SMP) += allocpercpu.o
 obj-$(CONFIG_QUICKLIST) += quicklist.o
 obj-$(CONFIG_CGROUP_MEM_RES_CTLR) += memcontrol.o page_cgroup.o
+obj-$(CONFIG_DEBUG_MEMLEAK) += memleak.o
+obj-$(CONFIG_DEBUG_MEMLEAK_TEST) += memleak-test.o
+
diff --git a/mm/memleak-test.c b/mm/memleak-test.c
new file mode 100644
index 0000000..51320d8
--- /dev/null
+++ b/mm/memleak-test.c
@@ -0,0 +1,94 @@
+/*
+ * mm/memleak-test.c
+ *
+ * Copyright (C) 2006 ARM Limited
+ * Written by Catalin Marinas <catalin.marinas@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/list.h>
+#include <linux/percpu.h>
+
+#include <linux/memleak.h>
+
+struct test_node {
+	long header[25];
+	struct list_head list;
+	long footer[25];
+};
+
+static LIST_HEAD(test_list);
+static DEFINE_PER_CPU(void *, test_pointer);
+
+/* Some very simple testing. This function needs to be extended for
+ * proper testing */
+static int __init memleak_test_init(void)
+{
+	struct test_node *elem;
+	int i;
+
+	printk(KERN_INFO "KMemLeak testing\n");
+
+	/* make some orphan objects */
+	kmalloc(32, GFP_KERNEL);
+	kmalloc(32, GFP_KERNEL);
+	kmalloc(1024, GFP_KERNEL);
+	kmalloc(1024, GFP_KERNEL);
+	kmalloc(2048, GFP_KERNEL);
+	kmalloc(2048, GFP_KERNEL);
+	kmalloc(4096, GFP_KERNEL);
+	kmalloc(4096, GFP_KERNEL);
+#ifndef CONFIG_MODULES
+	kmem_cache_alloc(files_cachep, GFP_KERNEL);
+	kmem_cache_alloc(files_cachep, GFP_KERNEL);
+#endif
+	vmalloc(64);
+	vmalloc(64);
+
+	/* add elements to a list. They should only appear as orphan
+	 * after the module is removed */
+	for (i = 0; i < 10; i++) {
+		elem = kmalloc(sizeof(*elem), GFP_KERNEL);
+		if (!elem)
+			return -ENOMEM;
+		memset(elem, 0, sizeof(*elem));
+		INIT_LIST_HEAD(&elem->list);
+
+		list_add_tail(&elem->list, &test_list);
+	}
+
+	for_each_possible_cpu(i)
+		per_cpu(test_pointer, i) = kmalloc(129, GFP_KERNEL);
+
+	return 0;
+}
+module_init(memleak_test_init);
+
+static void __exit memleak_test_exit(void)
+{
+	struct test_node *elem, *tmp;
+
+	/* remove the list elements without actually freeing the memory */
+	list_for_each_entry_safe(elem, tmp, &test_list, list)
+		list_del(&elem->list);
+}
+module_exit(memleak_test_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/mm/memleak.c b/mm/memleak.c
new file mode 100644
index 0000000..3862e32
--- /dev/null
+++ b/mm/memleak.c
@@ -0,0 +1,1521 @@
+/*
+ * mm/memleak.c
+ *
+ * Copyright (C) 2006 ARM Limited
+ * Written by Catalin Marinas <catalin.marinas@gmail.com>
+ * Copyright (C) 2008 Motorola,Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ *
+ * Notes on locking
+ *
+ * Kmemleak needs to allocate/free memory for its own data structures:
+ * the memleak_object, the pointer hash and aliases radix trees. The
+ * memleak_free hook can be called from mm/slab.c with the list_lock
+ * held (i.e. when releasing off-slab management structures) and it
+ * will ackquire the memleak_lock. To avoid deadlocks caused by
+ * locking dependency, the list_lock must not be acquired while
+ * memleak_lock is held. This is ensured by not allocating/freeing
+ * memory while any of the kmemleak locks are held.
+ *
+ * The kmemleak hooks cannot be called concurrently on the same
+ * memleak_object (this is due to the way they were inserted in the
+ * kernel).
+ *
+ * The following locks are present in kmemleak:
+ *
+ * - alias_tree_lock - rwlock for accessing the radix tree holding the
+ *   objects type information
+ *
+ * - memleak_lock - global kmemleak lock; protects object_list,
+ *   last_object, pointer_hash and memleak_object structures
+ *
+ * Locking dependencies:
+ *
+ * - alias_tree_lock --> l3->list_lock
+ * - l3->list_lock --> memleak_lock
+ *   Date        Author    Comment
+ *   ----------- --------- -------------------------------------------------
+ *   29/07/2008  Motorola  change kmemleak support dynamic number
+ */
+
+/* #define DEBUG */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/radix-tree.h>
+#include <linux/gfp.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kallsyms.h>
+#include <linux/mman.h>
+#include <linux/nodemask.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/cpumask.h>
+#include <linux/spinlock.h>
+#include <linux/rcupdate.h>
+#include <linux/hash.h>
+#include <linux/stacktrace.h>
+
+#include <linux/bitops.h>
+#include <asm/sections.h>
+#include <linux/percpu.h>
+#include <asm/processor.h>
+#include <linux/thread_info.h>
+#include <asm/atomic.h>
+
+#include <linux/memleak.h>
+
+#ifdef CONFIG_DEBUG_SPINLOCK
+#define BUG_ON_LOCKING(cond)	BUG_ON(cond)
+#else
+#define BUG_ON_LOCKING(cond)
+#endif
+
+#define MAX_TRACE		CONFIG_DEBUG_MEMLEAK_TRACE_LENGTH
+/* maximum scan length with interrupts disabled */
+#define SCAN_BLOCK_SIZE		4096
+#define PREINIT_OBJECTS		CONFIG_DEBUG_MEMLEAK_PREINIT_OBJECTS
+#define HASH_BITS		CONFIG_DEBUG_MEMLEAK_HASH_BITS
+#define BYTES_PER_WORD		sizeof(void *)
+
+struct memleak_alias {
+	struct hlist_node node;
+	unsigned long offset;
+};
+
+struct memleak_scan_area {
+	struct hlist_node node;
+	unsigned long offset;
+	size_t length;
+};
+
+struct memleak_object {
+	unsigned long flags;
+	struct list_head object_list;
+	struct list_head gray_list;
+	struct rcu_head rcu;
+	int use_count;
+	unsigned long pointer;
+	unsigned long offset;	/* padding */
+	size_t size;
+	unsigned long type_id;
+	int ref_count;		/* the minimum encounters of the value */
+	int count;		/* the ecounters of the value */
+	/* the unreferenced reporting threshold */
+	int report_thld;
+	struct hlist_head *alias_list;
+	/* areas to be scanned (or empty for all) */
+	struct hlist_head area_list;
+	unsigned long trace[MAX_TRACE];
+	unsigned int trace_len;
+};
+
+struct hash_node {
+	struct hlist_node node;
+	unsigned long val;
+	void *object;
+};
+
+enum memleak_action {
+	MEMLEAK_ALLOC,
+	MEMLEAK_FREE,
+	MEMLEAK_PADDING,
+	MEMLEAK_NOT_LEAK,
+	MEMLEAK_IGNORE,
+	MEMLEAK_SCAN_AREA,
+	MEMLEAK_TYPEID
+};
+
+struct memleak_preinit_object {
+	enum memleak_action type;
+	const void *pointer;
+	unsigned long offset;
+	size_t size;
+	unsigned long type_id;
+	int ref_count;
+};
+
+/* Tree storing the pointer aliases indexed by size */
+static RADIX_TREE(alias_tree, GFP_ATOMIC);
+static DEFINE_RWLOCK(alias_tree_lock);
+/* Hash storing all the possible objects, indexed by the pointer value */
+static struct hlist_head *pointer_hash;
+/* The list of all allocated objects */
+static LIST_HEAD(object_list);
+/* The list of the gray objects */
+static LIST_HEAD(gray_list);
+
+static struct kmem_cache *object_cache;
+/* The main lock for protecting the object lists and radix trees */
+static DEFINE_SPINLOCK(memleak_lock);
+static cpumask_t memleak_cpu_mask = CPU_MASK_NONE;
+static atomic_t memleak_initialized = ATOMIC_INIT(0);
+static int preinit_pos;
+static struct memleak_preinit_object preinit_objects[PREINIT_OBJECTS];
+/* last allocated object (optimization); protected by memleak_lock */
+static struct memleak_object *last_object;
+static int reported_leaks;
+
+/* object flags */
+#define OBJECT_ALLOCATED	0x1
+#define OBJECT_TYPE_GUESSED	0x2
+
+/* Hash functions */
+static void hash_init(void)
+{
+	unsigned int i;
+	unsigned int hash_size = sizeof(*pointer_hash) * (1 << HASH_BITS);
+	unsigned int hash_order = fls(hash_size) - 1;
+
+	/* hash_size not a power of 2 */
+	if (hash_size & ((1 << hash_order) - 1))
+		hash_order += 1;
+	if (hash_order < PAGE_SHIFT)
+		hash_order = PAGE_SHIFT;
+
+	pointer_hash = (struct hlist_head *)
+	    __get_free_pages(GFP_ATOMIC, hash_order - PAGE_SHIFT);
+	if (!pointer_hash)
+		panic("kmemleak: cannot allocate the pointer hash\n");
+
+	for (i = 0; i < (1 << HASH_BITS); i++)
+		INIT_HLIST_HEAD(&pointer_hash[i]);
+}
+
+static struct hash_node *__hash_lookup_node(unsigned long val)
+{
+	struct hlist_node *elem;
+	struct hash_node *hnode;
+	unsigned long index = hash_long(val, HASH_BITS);
+
+	hlist_for_each_entry(hnode, elem, &pointer_hash[index], node) {
+		if (hnode->val == val)
+			return hnode;
+	}
+	return NULL;
+}
+
+static int hash_insert(unsigned long val, void *object)
+{
+	unsigned long flags;
+	unsigned long index = hash_long(val, HASH_BITS);
+	struct hash_node *hnode = kmalloc(sizeof(*hnode), GFP_ATOMIC);
+
+	if (!hnode)
+		return -ENOMEM;
+	INIT_HLIST_NODE(&hnode->node);
+	hnode->val = val;
+	hnode->object = object;
+
+	spin_lock_irqsave(&memleak_lock, flags);
+	hlist_add_head(&hnode->node, &pointer_hash[index]);
+	spin_unlock_irqrestore(&memleak_lock, flags);
+
+	return 0;
+}
+
+static void *hash_delete(unsigned long val)
+{
+	unsigned long flags;
+	void *object = NULL;
+	struct hash_node *hnode;
+
+	spin_lock_irqsave(&memleak_lock, flags);
+	hnode = __hash_lookup_node(val);
+	if (hnode) {
+		object = hnode->object;
+		hlist_del(&hnode->node);
+	}
+	spin_unlock_irqrestore(&memleak_lock, flags);
+
+	kfree(hnode);
+	return object;
+}
+
+/* memleak_lock held by the calling function and interrupts disabled */
+static void *hash_lookup(unsigned long val)
+{
+	struct hash_node *hnode;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+	BUG_ON_LOCKING(!spin_is_locked(&memleak_lock));
+
+	hnode = __hash_lookup_node(val);
+	if (hnode)
+		return hnode->object;
+	return NULL;
+}
+
+/* helper macros to avoid recursive calls. After disabling the
+ * interrupts, the only calls to this function on the same CPU should
+ * be from kmemleak itself and we can either ignore them or
+ * panic. Calls from other CPU's should be protected by spinlocks */
+#define recursive_enter(cpu_id, flags)	({		\
+	local_irq_save(flags);				\
+	cpu_id = get_cpu();				\
+	cpu_test_and_set(cpu_id, memleak_cpu_mask);	\
+})
+
+#define recursive_clear(cpu_id)		do {		\
+	cpu_clear(cpu_id, memleak_cpu_mask);		\
+} while (0)
+
+#define recursive_exit(flags)		do {		\
+	put_cpu_no_resched();				\
+	local_irq_restore(flags);			\
+} while (0)
+
+/* Object colors, encoded with count and ref_count:
+ *  - white - orphan object, i.e. not enough references to it (ref_count >= 1)
+ *  - gray  - referred at least once and therefore non-orphan (ref_count == 0)
+ *  - black - ignore; it doesn't contain references (text section) (ref_count
+ *  == -1)
+ */
+static inline int color_white(const struct memleak_object *object)
+{
+	return object->count != -1 && object->count < object->ref_count;
+}
+
+static inline int color_gray(const struct memleak_object *object)
+{
+	return object->ref_count != -1 && object->count >= object->ref_count;
+}
+
+static inline int color_black(const struct memleak_object *object)
+{
+	return object->ref_count == -1;
+}
+
+#ifdef DEBUG
+static inline void dump_object_internals(struct memleak_object *object)
+{
+	struct memleak_alias *alias;
+	struct hlist_node *elem;
+
+	printk(KERN_NOTICE "  size = %d\n", object->size);
+	printk(KERN_NOTICE "  ref_count = %d\n", object->ref_count);
+	printk(KERN_NOTICE "  count = %d\n", object->count);
+	printk(KERN_NOTICE "  aliases:\n");
+	if (object->alias_list) {
+		hlist_for_each_entry(alias, elem, object->alias_list, node)
+		    printk(KERN_NOTICE "    0x%lx\n", alias->offset);
+	}
+}
+#else
+static inline void dump_object_internals(struct memleak_object *object)
+{
+}
+#endif
+
+static void dump_object_info(struct memleak_object *object)
+{
+	struct stack_trace trace;
+
+	trace.nr_entries = object->trace_len;
+	trace.entries = object->trace;
+
+	printk(KERN_NOTICE "kmemleak: object 0x%08lx:\n", object->pointer);
+	dump_object_internals(object);
+	printk(KERN_NOTICE "  trace:\n");
+	print_stack_trace(&trace, 4);
+}
+
+/* Insert an element into the aliases radix tree.
+ * Return 0 on success. */
+static int insert_alias(unsigned long type_id, unsigned long offset)
+{
+	int ret = 0;
+	struct hlist_head *alias_list;
+	struct hlist_node *elem;
+	struct memleak_alias *alias;
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (type_id == 0 || offset == 0 || offset >= ml_sizeof(type_id))
+		return -EINVAL;
+
+	if (recursive_enter(cpu_id, flags))
+		BUG();
+	write_lock(&alias_tree_lock);
+
+	offset &= ~(BYTES_PER_WORD - 1);
+
+	alias_list = radix_tree_lookup(&alias_tree, type_id);
+	if (!alias_list) {
+		/* no alias list for this type id. Allocate list_head
+		 * and insert into the radix tree */
+		alias_list = kmalloc(sizeof(*alias_list), GFP_ATOMIC);
+		if (!alias_list)
+			panic("kmemleak: cannot allocate alias_list\n");
+		INIT_HLIST_HEAD(alias_list);
+
+		ret = radix_tree_insert(&alias_tree, type_id, alias_list);
+		if (ret)
+			panic("kmemleak: cannot insert into the aliases radix \
+			       tree: %d\n", ret);
+	}
+
+	hlist_for_each_entry(alias, elem, alias_list, node) {
+		if (alias->offset == offset) {
+			ret = -EEXIST;
+			goto out;
+		}
+	}
+
+	alias = kmalloc(sizeof(*alias), GFP_ATOMIC);
+	if (!alias)
+		panic("kmemleak: cannot allocate initial memory\n");
+	INIT_HLIST_NODE(&alias->node);
+	alias->offset = offset;
+
+	hlist_add_head_rcu(&alias->node, alias_list);
+
+out:
+	write_unlock(&alias_tree_lock);
+	recursive_clear(cpu_id);
+	recursive_exit(flags);
+
+	return ret;
+}
+
+/* Insert pointer aliases from the given array */
+void memleak_insert_aliases(struct memleak_offset *ml_off_start,
+			    struct memleak_offset *ml_off_end)
+{
+	struct memleak_offset *ml_off;
+	int i = 0;
+#ifdef CONFIG_DEBUG_MEMLEAK_SECONDARY_ALIASES
+	unsigned long flags;
+#endif
+
+	pr_debug("%s(0x%p, 0x%p)\n", __func__, ml_off_start, ml_off_end);
+
+	/* primary aliases - container_of(member) */
+	for (ml_off = ml_off_start; ml_off < ml_off_end; ml_off++)
+		if (!insert_alias(ml_off->type_id, ml_off->offset))
+			i++;
+	pr_debug("kmemleak: found %d primary alias(es)\n", i);
+
+#ifdef CONFIG_DEBUG_MEMLEAK_SECONDARY_ALIASES
+	/* secondary aliases - container_of(container_of(member)) */
+	for (ml_off = ml_off_start; ml_off < ml_off_end; ml_off++) {
+		struct hlist_head *alias_list;
+		struct memleak_alias *alias;
+		struct hlist_node *elem;
+
+		/* with imprecise type identification, if the member
+		 * id is the same as the outer structure id, just
+		 * ignore as any potential aliases are already in the
+		 * tree */
+		if (ml_off->member_type_id == ml_off->type_id)
+			continue;
+
+		read_lock_irqsave(&alias_tree_lock, flags);
+		alias_list =
+		    radix_tree_lookup(&alias_tree, ml_off->member_type_id);
+		read_unlock_irqrestore(&alias_tree_lock, flags);
+		if (!alias_list)
+			continue;
+
+		rcu_read_lock();
+		hlist_for_each_entry_rcu(alias, elem, alias_list, node)
+		    if (!insert_alias
+			(ml_off->type_id, ml_off->offset + alias->offset))
+			i++;
+		rcu_read_unlock();
+	}
+	pr_debug("kmemleak: found %d alias(es)\n", i);
+#endif
+}
+EXPORT_SYMBOL_GPL(memleak_insert_aliases);
+
+
+/* called with interrupts disabled */
+static inline struct memleak_object *get_cached_object(unsigned long ptr)
+{
+	struct memleak_object *object;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	spin_lock(&memleak_lock);
+	if (!last_object || ptr != last_object->pointer)
+		last_object = hash_lookup(ptr);
+	object = last_object;
+	spin_unlock(&memleak_lock);
+
+	return object;
+}
+
+/* no need for atomic operations since memleak_lock is already held
+ * and interrupts disabled. Return 1 if successful or 0 otherwise */
+static inline int get_object(struct memleak_object *object)
+{
+	BUG_ON_LOCKING(!irqs_disabled());
+	BUG_ON_LOCKING(!spin_is_locked(&memleak_lock));
+
+	if (object->use_count != 0)
+		object->use_count++;
+	return object->use_count != 0;
+}
+
+static void free_object_rcu(struct rcu_head *rcu)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+	struct hlist_node *elem, *tmp;
+	struct memleak_scan_area *area;
+	struct memleak_object *object =
+	    container_of(rcu, struct memleak_object, rcu);
+
+	if (recursive_enter(cpu_id, flags))
+		BUG();
+
+	/* once use_count is 0, there is no code accessing the object */
+	hlist_for_each_entry_safe(area, elem, tmp, &object->area_list, node) {
+		hlist_del(elem);
+		kfree(area);
+	}
+	kmem_cache_free(object_cache, object);
+
+	recursive_clear(cpu_id);
+	recursive_exit(flags);
+}
+
+/* called without memleak_lock held */
+static void put_object(struct memleak_object *object)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&memleak_lock, flags);
+
+	if (--object->use_count > 0)
+		goto out;
+
+	/* should only get here after delete_object was called */
+	BUG_ON(object->flags & OBJECT_ALLOCATED);
+
+	/* the last reference to this object */
+	list_del_rcu(&object->object_list);
+	call_rcu(&object->rcu, free_object_rcu);
+
+out:
+	spin_unlock_irqrestore(&memleak_lock, flags);
+}
+
+/* called with interrupts disabled (no need to hold the memleak_lock
+ * as the the pointer aliases functions cannot be called concurrently
+ * on the same object) */
+static void delete_pointer_aliases(struct memleak_object *object)
+{
+	struct memleak_alias *alias;
+	struct hlist_node *elem;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	if (object->offset)
+		hash_delete(object->pointer + object->offset);
+
+	if (object->alias_list) {
+		rcu_read_lock();
+		hlist_for_each_entry_rcu(alias, elem, object->alias_list, node)
+		    hash_delete(object->pointer
+				+ object->offset + alias->offset);
+		rcu_read_unlock();
+		object->alias_list = NULL;
+	}
+}
+
+/* called with interrupts disabled (see above for why memleak_lock
+ * doesn't need to be held) */
+static void create_pointer_aliases(struct memleak_object *object)
+{
+	struct memleak_alias *alias;
+	struct hlist_node *elem;
+	int err;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	if (object->offset) {
+		err = hash_insert(object->pointer + object->offset, object);
+		if (err) {
+			dump_stack();
+			panic("kmemleak: cannot insert offset into the pointer"
+					 " hash table: %d\n", err);
+		}
+	}
+
+	read_lock(&alias_tree_lock);
+	object->alias_list = radix_tree_lookup(&alias_tree, object->type_id);
+	read_unlock(&alias_tree_lock);
+
+	if (object->alias_list) {
+		rcu_read_lock();
+		hlist_for_each_entry_rcu(alias, elem,
+				object->alias_list, node) {
+			err = hash_insert(object->pointer + object->offset
+					  + alias->offset, object);
+			if (err) {
+				dump_stack();
+				panic("kmemleak: cannot insert alias into the"
+					" pointer hash table: %d\n", err);
+			}
+		}
+		rcu_read_unlock();
+	}
+}
+
+/* Insert a pointer and its aliases into the pointer hash table */
+static inline void create_object(unsigned long ptr, size_t size, int ref_count)
+{
+	struct memleak_object *object;
+	int err;
+	struct stack_trace trace;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	object = kmem_cache_alloc(object_cache, GFP_ATOMIC);
+	if (!object)
+		panic("kmemleak: cannot allocate a memleak_object structure\n");
+
+	INIT_LIST_HEAD(&object->object_list);
+	INIT_LIST_HEAD(&object->gray_list);
+	INIT_HLIST_HEAD(&object->area_list);
+	object->flags = OBJECT_TYPE_GUESSED;
+	object->use_count = 1;
+	object->pointer = ptr;
+	object->offset = 0;
+	object->size = size;
+	object->type_id = ml_guess_typeid(size);/* type id approximation */
+	object->ref_count = ref_count;
+	object->count = -1;
+	object->report_thld = CONFIG_DEBUG_MEMLEAK_REPORT_THLD;
+	object->alias_list = NULL;
+
+	trace.max_entries = MAX_TRACE;
+	trace.nr_entries = 0;
+	trace.entries = object->trace;
+	trace.skip = 2;
+	/* trace.all_contexts = 0; */
+	save_stack_trace(&trace);
+
+	object->trace_len = trace.nr_entries;
+
+	spin_lock(&memleak_lock);
+	/* object->use_count already set to 1 */
+	list_add_tail_rcu(&object->object_list, &object_list);
+	spin_unlock(&memleak_lock);
+
+	err = hash_insert(ptr, object);
+	if (err) {
+		dump_stack();
+		if (err == -EEXIST) {
+			printk(KERN_NOTICE "Existing pointer:\n");
+			spin_lock(&memleak_lock);
+			object = hash_lookup(ptr);
+			dump_object_info(object);
+			spin_unlock(&memleak_lock);
+		}
+		panic("kmemleak: cannot insert 0x%lx into the pointer hash"
+			" table: %d\n", ptr, err);
+	}
+
+	create_pointer_aliases(object);
+
+	/* everything completed fine, just mark the object as allocated */
+	spin_lock(&memleak_lock);
+	object->flags |= OBJECT_ALLOCATED;
+	last_object = object;
+	spin_unlock(&memleak_lock);
+}
+
+/* Remove a pointer and its aliases from the pointer hash table */
+static inline void delete_object(unsigned long ptr)
+{
+	struct memleak_object *object;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	object = hash_delete(ptr);
+	if (!object) {
+		dump_stack();
+		printk(KERN_WARNING
+		       "kmemleak: freeing unknown object at 0x%08lx\n", ptr);
+		return;
+	}
+
+	spin_lock(&memleak_lock);
+
+	if (object->pointer != ptr) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: freeing object by alias 0x%08lx\n", ptr);
+	}
+	BUG_ON(!(object->flags & OBJECT_ALLOCATED));
+
+	object->flags &= ~OBJECT_ALLOCATED;
+
+	/* deleting the cached object */
+	if (last_object && ptr == last_object->pointer)
+		last_object = NULL;
+
+#ifdef CONFIG_DEBUG_MEMLEAK_ORPHAN_FREEING
+	if (color_white(object)) {
+		dump_stack();
+		dump_object_info(object);
+		printk(KERN_WARNING "kmemleak: freeing orphan object 0x%08lx\n",
+		       ptr);
+	}
+#endif
+
+	spin_unlock(&memleak_lock);
+
+	delete_pointer_aliases(object);
+	object->pointer = 0;
+	put_object(object);
+}
+
+/* Re-create the pointer aliases according to the new size/offset
+ * information */
+static inline void unpad_object(unsigned long ptr, unsigned long offset,
+				size_t size)
+{
+	struct memleak_object *object;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	object = get_cached_object(ptr);
+	if (!object) {
+		dump_stack();
+		panic("kmemleak: resizing unknown object at 0x%08lx\n", ptr);
+	}
+	if (object->pointer != ptr) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: resizing object by alias 0x%08lx\n", ptr);
+	}
+	if (offset + size > object->size) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: new boundaries exceed object 0x%08lx\n", ptr);
+	}
+
+	/* nothing changed */
+	if (offset == object->offset && size == object->size)
+		return;
+
+	/* re-create the pointer aliases */
+	delete_pointer_aliases(object);
+
+	spin_lock(&memleak_lock);
+	object->offset = offset;
+	object->size = size;
+	if (object->flags & OBJECT_TYPE_GUESSED)
+		object->type_id = ml_guess_typeid(size);
+	spin_unlock(&memleak_lock);
+
+	create_pointer_aliases(object);
+}
+
+/* Make a object permanently gray (false positive) */
+static inline void make_gray_object(unsigned long ptr)
+{
+	struct memleak_object *object;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	object = get_cached_object(ptr);
+	if (!object) {
+		dump_stack();
+		panic("kmemleak: graying unknown object at 0x%08lx\n", ptr);
+	}
+	if (object->pointer != ptr) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: graying object by alias 0x%08lx\n", ptr);
+	}
+
+	spin_lock(&memleak_lock);
+	object->ref_count = 0;
+	spin_unlock(&memleak_lock);
+}
+
+/* Mark the object as black */
+static inline void make_black_object(unsigned long ptr)
+{
+	struct memleak_object *object;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	object = get_cached_object(ptr);
+	if (!object) {
+		dump_stack();
+		panic("kmemleak: blacking unknown object at 0x%08lx\n", ptr);
+	}
+	if (object->pointer != ptr) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: blacking object by alias 0x%08lx\n", ptr);
+	}
+
+	spin_lock(&memleak_lock);
+	object->ref_count = -1;
+	spin_unlock(&memleak_lock);
+}
+
+/* Add a scanning area to the object */
+static inline void add_scan_area(unsigned long ptr, unsigned long offset,
+				 size_t length)
+{
+	struct memleak_object *object;
+	struct memleak_scan_area *area;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	area = kmalloc(sizeof(*area), GFP_ATOMIC);
+	if (!area)
+		panic("kmemleak: cannot allocate a scan area\n");
+
+	INIT_HLIST_NODE(&area->node);
+	area->offset = offset;
+	area->length = length;
+
+	object = get_cached_object(ptr);
+	if (!object) {
+		dump_stack();
+		panic("kmemleak: adding scan area to unknown object at "
+			"0x%08lx\n", ptr);
+	}
+	if (object->pointer != ptr) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: adding scan area to object by alias 0x%08lx\n",
+		      ptr);
+	}
+	if (offset + length > object->size) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: scan area larger than object 0x%08lx\n", ptr);
+	}
+
+	spin_lock(&memleak_lock);
+	hlist_add_head(&area->node, &object->area_list);
+	spin_unlock(&memleak_lock);
+}
+
+/* Re-create the pointer aliases according to the new type id */
+static inline void change_type_id(unsigned long ptr, unsigned long type_id)
+{
+	struct memleak_object *object;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+
+	object = get_cached_object(ptr);
+	if (!object) {
+		dump_stack();
+		panic("kmemleak: changing type of unknown object at 0x%08lx\n",
+		      ptr);
+	}
+	if (object->pointer != ptr) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: changing type of object by alias 0x%08lx\n",
+		      ptr);
+	}
+	if (ml_sizeof(type_id) > object->size) {
+		dump_stack();
+		dump_object_info(object);
+		panic("kmemleak: new type larger than object 0x%08lx\n", ptr);
+	}
+
+	spin_lock(&memleak_lock);
+	object->type_id = type_id;
+	object->flags &= ~OBJECT_TYPE_GUESSED;
+	spin_unlock(&memleak_lock);
+
+	if (type_id == object->type_id)
+		return;
+
+	delete_pointer_aliases(object);
+	create_pointer_aliases(object);
+}
+
+/* Allocation function hook */
+void memleak_alloc(const void *ptr, size_t size, int ref_count)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (!ptr)
+		return;
+
+	if (recursive_enter(cpu_id, flags))
+		goto out;
+
+	pr_debug("%s(0x%p, %d, %d)\n", __func__, ptr, size, ref_count);
+
+	if (!atomic_read(&memleak_initialized)) {
+		/* no need for SMP locking since this object is
+		 * executed before the other CPUs are started */
+		struct memleak_preinit_object *object;
+
+		BUG_ON(cpu_id != 0);
+
+		if (preinit_pos < PREINIT_OBJECTS) {
+			object = &preinit_objects[preinit_pos];
+
+			object->type = MEMLEAK_ALLOC;
+			object->pointer = ptr;
+			object->size = size;
+			object->ref_count = ref_count;
+		}
+		preinit_pos++;
+
+		goto clear;
+	}
+
+	create_object((unsigned long)ptr, size, ref_count);
+
+clear:
+	recursive_clear(cpu_id);
+out:
+	recursive_exit(flags);
+}
+EXPORT_SYMBOL_GPL(memleak_alloc);
+
+
+/* Freeing function hook */
+void memleak_free(const void *ptr)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (!ptr)
+		return;
+
+	if (recursive_enter(cpu_id, flags))
+		goto out;
+
+	pr_debug("%s(0x%p)\n", __func__, ptr);
+
+	if (!atomic_read(&memleak_initialized)) {
+		struct memleak_preinit_object *object;
+
+		BUG_ON(cpu_id != 0);
+
+		if (preinit_pos < PREINIT_OBJECTS) {
+			object = &preinit_objects[preinit_pos];
+
+			object->type = MEMLEAK_FREE;
+			object->pointer = ptr;
+		}
+		preinit_pos++;
+
+		goto clear;
+	}
+
+	delete_object((unsigned long)ptr);
+
+clear:
+	recursive_clear(cpu_id);
+out:
+	recursive_exit(flags);
+}
+EXPORT_SYMBOL_GPL(memleak_free);
+
+
+/* Change the size and location information of an allocated memory
+ * object (this is needed for allocations padding the object) */
+void memleak_padding(const void *ptr, unsigned long offset, size_t size)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (!ptr)
+		return;
+
+	if (recursive_enter(cpu_id, flags))
+		goto out;
+
+	pr_debug("%s(0x%p, %d)\n", __func__, ptr, size);
+
+	if (!atomic_read(&memleak_initialized)) {
+		struct memleak_preinit_object *object;
+
+		BUG_ON(cpu_id != 0);
+
+		if (preinit_pos < PREINIT_OBJECTS) {
+			object = &preinit_objects[preinit_pos];
+
+			object->type = MEMLEAK_PADDING;
+			object->pointer = ptr;
+			object->offset = offset;
+			object->size = size;
+		}
+		preinit_pos++;
+
+		goto clear;
+	}
+
+	unpad_object((unsigned long)ptr, offset, size);
+
+clear:
+	recursive_clear(cpu_id);
+out:
+	recursive_exit(flags);
+}
+EXPORT_SYMBOL(memleak_padding);
+
+
+/* Mark a object as a false positive */
+void memleak_not_leak(const void *ptr)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (!ptr)
+		return;
+
+	if (recursive_enter(cpu_id, flags))
+		goto out;
+
+	pr_debug("%s(0x%p)\n", __func__, ptr);
+
+	if (!atomic_read(&memleak_initialized)) {
+		struct memleak_preinit_object *object;
+
+		BUG_ON(cpu_id != 0);
+
+		if (preinit_pos < PREINIT_OBJECTS) {
+			object = &preinit_objects[preinit_pos];
+
+			object->type = MEMLEAK_NOT_LEAK;
+			object->pointer = ptr;
+		}
+		preinit_pos++;
+
+		goto clear;
+	}
+
+	make_gray_object((unsigned long)ptr);
+
+clear:
+	recursive_clear(cpu_id);
+out:
+	recursive_exit(flags);
+}
+EXPORT_SYMBOL(memleak_not_leak);
+
+
+/* Ignore this memory object */
+void memleak_ignore(const void *ptr)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (!ptr)
+		return;
+
+	if (recursive_enter(cpu_id, flags))
+		goto out;
+
+	pr_debug("%s(0x%p)\n", __func__, ptr);
+
+	if (!atomic_read(&memleak_initialized)) {
+		struct memleak_preinit_object *object;
+
+		BUG_ON(cpu_id != 0);
+
+		if (preinit_pos < PREINIT_OBJECTS) {
+			object = &preinit_objects[preinit_pos];
+
+			object->type = MEMLEAK_IGNORE;
+			object->pointer = ptr;
+		}
+		preinit_pos++;
+
+		goto clear;
+	}
+
+	make_black_object((unsigned long)ptr);
+
+clear:
+	recursive_clear(cpu_id);
+out:
+	recursive_exit(flags);
+}
+EXPORT_SYMBOL(memleak_ignore);
+
+
+/* Add a scanning area to a object */
+void memleak_scan_area(const void *ptr, unsigned long offset, size_t length)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (!ptr)
+		return;
+
+	if (recursive_enter(cpu_id, flags))
+		goto out;
+
+	pr_debug("%s(0x%p)\n", __func__, ptr);
+
+	if (!atomic_read(&memleak_initialized)) {
+		struct memleak_preinit_object *object;
+
+		BUG_ON(cpu_id != 0);
+
+		if (preinit_pos < PREINIT_OBJECTS) {
+			object = &preinit_objects[preinit_pos];
+
+			object->type = MEMLEAK_SCAN_AREA;
+			object->pointer = ptr;
+			object->offset = offset;
+			object->size = length;
+		}
+		preinit_pos++;
+
+		goto clear;
+	}
+
+	add_scan_area((unsigned long)ptr, offset, length);
+
+clear:
+	recursive_clear(cpu_id);
+out:
+	recursive_exit(flags);
+}
+EXPORT_SYMBOL(memleak_scan_area);
+
+
+/* Change the type id of an allocated memory object */
+void memleak_typeid_raw(const void *ptr, unsigned long type_id)
+{
+	unsigned long flags;
+	unsigned int cpu_id;
+
+	if (!ptr)
+		return;
+	if (!type_id)
+		return;
+
+	if (recursive_enter(cpu_id, flags))
+		goto out;
+
+	pr_debug("%s(0x%p, %ld)\n", __func__, ptr, type_id);
+
+	if (!atomic_read(&memleak_initialized)) {
+		struct memleak_preinit_object *object;
+
+		BUG_ON(cpu_id != 0);
+
+		if (preinit_pos < PREINIT_OBJECTS) {
+			object = &preinit_objects[preinit_pos];
+
+			object->type = MEMLEAK_TYPEID;
+			object->pointer = ptr;
+			object->type_id = type_id;
+		}
+		preinit_pos++;
+
+		goto clear;
+	}
+
+	change_type_id((unsigned long)ptr, type_id);
+
+clear:
+	recursive_clear(cpu_id);
+out:
+	recursive_exit(flags);
+}
+EXPORT_SYMBOL(memleak_typeid_raw);
+
+
+/* Scan a block of memory (exclusive range) for pointers and move
+ * those found to the gray list. This function is called with
+ * memleak_lock held and interrupts disabled */
+static void __scan_block(void *_start, void *_end)
+{
+	unsigned long *ptr;
+	unsigned long *start = (unsigned long *)ALIGN((unsigned long)_start,
+						      BYTES_PER_WORD);
+	unsigned long *end = _end;
+
+	BUG_ON_LOCKING(!irqs_disabled());
+	BUG_ON_LOCKING(!spin_is_locked(&memleak_lock));
+
+	for (ptr = start; ptr < end; ptr++) {
+		struct memleak_object *object =
+		    hash_lookup((*ptr) & ~(BYTES_PER_WORD - 1));
+		if (!object)
+			continue;
+		if (!color_white(object))
+			continue;
+
+		object->count++;
+		/* this can also happen during the gray_list traversal */
+		if (color_gray(object)) {
+			/* found in the hash, get_object() returns 1 */
+			get_object(object);
+			object->report_thld++;
+			list_add_tail(&object->gray_list, &gray_list);
+		}
+	}
+}
+
+static void scan_block(void *start, void *end)
+{
+	unsigned long flags;
+	void *s, *e;
+
+	s = start;
+	while (s < end) {
+		e = s + SCAN_BLOCK_SIZE;
+
+		spin_lock_irqsave(&memleak_lock, flags);
+		__scan_block(s, e < end ? e : end);
+		spin_unlock_irqrestore(&memleak_lock, flags);
+
+		s = e;
+	}
+}
+
+/* Scan a memory block represented by a memleak_object */
+static inline void scan_object(struct memleak_object *object)
+{
+	struct memleak_scan_area *area;
+	struct hlist_node *elem;
+	unsigned long flags;
+
+	spin_lock_irqsave(&memleak_lock, flags);
+
+	/* freed object */
+	if (!(object->flags & OBJECT_ALLOCATED))
+		goto out;
+
+	if (hlist_empty(&object->area_list))
+		__scan_block((void *)(object->pointer + object->offset),
+			     (void *)(object->pointer + object->offset
+				      + object->size));
+	else
+		hlist_for_each_entry(area, elem, &object->area_list, node)
+		    __scan_block((void *)(object->pointer + area->offset),
+				 (void *)(object->pointer + area->offset
+					  + area->length));
+
+out:
+	spin_unlock_irqrestore(&memleak_lock, flags);
+}
+
+/* Scan the memory and print the orphan objects */
+static void memleak_scan(void)
+{
+	unsigned long flags;
+	struct memleak_object *object, *tmp;
+#ifdef CONFIG_DEBUG_MEMLEAK_TASK_STACKS
+	struct task_struct *task;
+#endif
+	int i;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(object, &object_list, object_list) {
+		spin_lock_irqsave(&memleak_lock, flags);
+
+		/* there should be a maximum of 1 reference to any
+		 * object at this point */
+		BUG_ON(object->use_count > 1);
+
+		/* reset the reference count (whiten the object) */
+		object->count = 0;
+		if (color_gray(object) && get_object(object))
+			list_add_tail(&object->gray_list, &gray_list);
+		else
+			object->report_thld--;
+
+		spin_unlock_irqrestore(&memleak_lock, flags);
+	}
+	rcu_read_unlock();
+
+	/* data/bss scanning */
+	scan_block(_sdata, _edata);
+	scan_block(__bss_start, __bss_stop);
+
+#ifdef CONFIG_SMP
+	/* per-cpu scanning */
+	for_each_possible_cpu(i)
+	    scan_block(__per_cpu_start + per_cpu_offset(i),
+		       __per_cpu_end + per_cpu_offset(i));
+#endif
+
+	/* mem_map scanning */
+	for_each_online_node(i) {
+		struct page *page, *end;
+
+		page = NODE_MEM_MAP(i);
+		end = page + NODE_DATA(i)->node_spanned_pages;
+
+		scan_block(page, end);
+	}
+
+#ifdef CONFIG_DEBUG_MEMLEAK_TASK_STACKS
+	read_lock(&tasklist_lock);
+	for_each_process(task)
+	    scan_block(task_stack_page(task),
+		       task_stack_page(task) + THREAD_SIZE);
+	read_unlock(&tasklist_lock);
+#endif
+
+	/* scan the objects already referenced. More objects will be
+	 * referenced and, if there are no memory leaks, all the
+	 * objects will be scanned. The list traversal is safe for
+	 * both tail additions and removals from inside the loop. The
+	 * memleak objects cannot be freed from outside the loop
+	 * because their use_count was increased */
+	object = list_entry(gray_list.next, typeof(*object), gray_list);
+	while (&object->gray_list != &gray_list) {
+		/* may add new objects to the list */
+		scan_object(object);
+
+		tmp = list_entry(object->gray_list.next, typeof(*object),
+				 gray_list);
+
+		/* remove the object from the list and release it */
+		list_del(&object->gray_list);
+		put_object(object);
+
+		object = tmp;
+	}
+	BUG_ON(!list_empty(&gray_list));
+}
+
+static void *memleak_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	struct memleak_object *object;
+	loff_t n = *pos;
+	unsigned long flags;
+
+	if (!n) {
+		memleak_scan();
+		reported_leaks = 0;
+	}
+#ifdef CONFIG_DEBUG_MEMLEAK_DYNAMIC_NR
+	if (reported_leaks >= kmemleak_module)
+#else
+	if (reported_leaks >= CONFIG_DEBUG_MEMLEAK_REPORTS_NR)
+#endif
+		return NULL;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(object, &object_list, object_list) {
+		if (n-- > 0)
+			continue;
+
+		spin_lock_irqsave(&memleak_lock, flags);
+		if (get_object(object)) {
+			spin_unlock_irqrestore(&memleak_lock, flags);
+			goto out;
+		}
+		spin_unlock_irqrestore(&memleak_lock, flags);
+	}
+	object = NULL;
+out:
+	rcu_read_unlock();
+	return object;
+}
+
+static void *memleak_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	struct list_head *n;
+	struct memleak_object *next = NULL;
+	unsigned long flags;
+
+	++(*pos);
+#ifdef CONFIG_DEBUG_MEMLEAK_DYNAMIC_NR
+	if (reported_leaks >= kmemleak_module)
+#else
+	if (reported_leaks >= CONFIG_DEBUG_MEMLEAK_REPORTS_NR)
+#endif
+		goto out;
+
+	spin_lock_irqsave(&memleak_lock, flags);
+
+	n = ((struct memleak_object *)v)->object_list.next;
+	if (n != &object_list) {
+		next = list_entry(n, struct memleak_object, object_list);
+		/* still in the object_list, get_object() returns 1 */
+		get_object(next);
+	}
+
+	spin_unlock_irqrestore(&memleak_lock, flags);
+
+out:
+	put_object(v);
+	return next;
+}
+
+static void memleak_seq_stop(struct seq_file *seq, void *v)
+{
+	if (v)
+		put_object(v);
+}
+
+static int memleak_seq_show(struct seq_file *seq, void *v)
+{
+	const struct memleak_object *object = v;
+	unsigned long flags;
+	char namebuf[KSYM_NAME_LEN + 1] = "";
+	char *modname = NULL;
+	unsigned long symsize;
+	unsigned long offset = 0;
+	int i;
+
+	spin_lock_irqsave(&memleak_lock, flags);
+
+	if (!color_white(object))
+		goto out;
+	/* freed in the meantime (false positive) or just allocated */
+	if (!(object->flags & OBJECT_ALLOCATED))
+		goto out;
+	if (object->report_thld >= 0)
+		goto out;
+
+	reported_leaks++;
+	seq_printf(seq, "unreferenced object 0x%08lx (size %d):\n",
+		   object->pointer, object->size);
+
+	for (i = 0; i < object->trace_len; i++) {
+		unsigned long trace = object->trace[i];
+
+		kallsyms_lookup(trace, &symsize, &offset, &modname, namebuf);
+		if (modname)
+			seq_printf(seq, "  [<%08lx>] (%s) %s\n", trace,
+				   modname, namebuf);
+		else
+			seq_printf(seq, "  [<%08lx>] %s\n", trace, namebuf);
+		modname = NULL;
+	}
+
+out:
+	spin_unlock_irqrestore(&memleak_lock, flags);
+	return 0;
+}
+
+static struct seq_operations memleak_seq_ops = {
+	.start = memleak_seq_start,
+	.next = memleak_seq_next,
+	.stop = memleak_seq_stop,
+	.show = memleak_seq_show,
+};
+
+static int memleak_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &memleak_seq_ops);
+}
+
+static struct file_operations memleak_fops = {
+	.owner = THIS_MODULE,
+	.open = memleak_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+/* KMemLeak initialization. Set up the radix tree for the pointer aliases */
+void __init memleak_init(void)
+{
+	int i;
+	unsigned long flags;
+
+	hash_init();
+
+	object_cache = kmem_cache_create("memleak_object_cache",
+					 sizeof(struct memleak_object),
+					 0, SLAB_PANIC, NULL);
+	if (!object_cache)
+		panic("kmemleak: cannot create the object cache\n");
+
+	memleak_insert_aliases(__memleak_offsets_start, __memleak_offsets_end);
+
+	/* no need to hold the spinlock as SMP is not initialized
+	 * yet. Holding it here would lead to a deadlock */
+	local_irq_save(flags);
+
+	atomic_set(&memleak_initialized, 1);
+
+	if (preinit_pos >= PREINIT_OBJECTS)
+		panic("kmemleak: preinit objects buffer overflow: %d\n",
+		      preinit_pos);
+
+	/* execute the buffered memleak actions */
+	pr_debug("kmemleak: %d preinit actions\n", preinit_pos);
+	for (i = 0; i < preinit_pos; i++) {
+		struct memleak_preinit_object *object = &preinit_objects[i];
+
+		switch (object->type) {
+		case MEMLEAK_ALLOC:
+			memleak_alloc(object->pointer, object->size,
+				      object->ref_count);
+			break;
+		case MEMLEAK_FREE:
+			memleak_free(object->pointer);
+			break;
+		case MEMLEAK_PADDING:
+			memleak_padding(object->pointer, object->offset,
+					object->size);
+			break;
+		case MEMLEAK_NOT_LEAK:
+			memleak_not_leak(object->pointer);
+			break;
+		case MEMLEAK_IGNORE:
+			memleak_ignore(object->pointer);
+			break;
+		case MEMLEAK_SCAN_AREA:
+			memleak_scan_area(object->pointer,
+					  object->offset, object->size);
+			break;
+		case MEMLEAK_TYPEID:
+			memleak_typeid_raw(object->pointer, object->type_id);
+			break;
+		default:
+			BUG();
+		}
+	}
+
+	local_irq_restore(flags);
+
+	printk(KERN_INFO "Kernel memory leak detector initialized\n");
+}
+
+/* Late initialization function */
+int __init memleak_late_init(void)
+{
+	struct dentry *dentry;
+
+	dentry = debugfs_create_file("memleak", S_IRUGO, NULL, NULL,
+				     &memleak_fops);
+	if (!dentry)
+		return -ENOMEM;
+
+	pr_debug("kmemleak: late initialization completed\n");
+
+	return 0;
+}
+
+late_initcall(memleak_late_init);
diff --git a/mm/slab.c b/mm/slab.c
index 4d00855..fecedd3 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -3661,6 +3661,96 @@ static __always_inline void *__do_kmalloc(size_t size, gfp_t flags,
 
 
 #ifdef CONFIG_DEBUG_SLAB
+
+#ifdef CONFIG_DEBUG_MEMLEAK
+static __always_inline void *
+__memleak_cache_alloc(struct kmem_cache *cachep, gfp_t flags, void *caller)
+{
+	unsigned long save_flags;
+	void *objp;
+
+	if (should_failslab(obj_size(cachep), flags))
+		return NULL;
+
+	cache_alloc_debugcheck_before(cachep, flags);
+	local_irq_save(save_flags);
+	objp = __do_cache_alloc(cachep, flags);
+	local_irq_restore(save_flags);
+	objp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);
+	memleak_alloc(objp, obj_size(cachep), 1);
+	prefetchw(objp);
+
+	if (unlikely((flags & __GFP_ZERO) && objp))
+		memset(objp, 0, obj_size(cachep));
+
+	return objp;
+}
+
+static __always_inline void *__memleak_do_kmalloc(size_t size, gfp_t flags,
+		void *caller)
+{
+	struct kmem_cache *cachep;
+	void *ptr;
+
+	/* If you want to save a few bytes .text space: replace
+	 * __ with kmem_.
+	 * Then kmalloc uses the uninlined functions instead of the inline
+	 * functions.
+	 */
+	cachep = __find_general_cachep(size, flags);
+	if (unlikely(cachep == NULL))
+		return NULL;
+	ptr = __memleak_cache_alloc(cachep, flags, caller);
+	memleak_padding(ptr, 0, size);
+
+	return ptr;
+}
+
+static inline void __memleak_cache_free(struct kmem_cache *cachep, void *objp)
+{
+	struct array_cache *ac = cpu_cache_get(cachep);
+
+	check_irq_off();
+	memleak_free(objp);
+	objp = cache_free_debugcheck(cachep, objp, __builtin_return_address(0));
+
+	if (cache_free_alien(cachep, objp))
+		return;
+
+	if (likely(ac->avail < ac->limit)) {
+		STATS_INC_FREEHIT(cachep);
+		ac->entry[ac->avail++] = objp;
+		return;
+	} else {
+		STATS_INC_FREEMISS(cachep);
+		cache_flusharray(cachep, ac);
+		ac->entry[ac->avail++] = objp;
+	}
+}
+
+void memleak_kfree(void *objp)
+{
+	struct kmem_cache *c;
+	unsigned long flags;
+
+	if (unlikely(!objp))
+		return;
+	local_irq_save(flags);
+	kfree_debugcheck(objp);
+	c = virt_to_cache(objp);
+	debug_check_no_locks_freed(objp, obj_size(c));
+	__memleak_cache_free(c, objp);
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL(memleak_kfree);
+
+void *__memleak_kmalloc(size_t size, gfp_t flags)
+{
+	return __memleak_do_kmalloc(size, flags, __builtin_return_address(0));
+}
+EXPORT_SYMBOL(__memleak_kmalloc);
+#endif
+
 void *__kmalloc(size_t size, gfp_t flags)
 {
 	return __do_kmalloc(size, flags, __builtin_return_address(0));
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 520a759..8c85fc7 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -1255,6 +1255,17 @@ void vfree(const void *addr)
 }
 EXPORT_SYMBOL(vfree);
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+void memleak_vfree(void *addr)
+{
+	BUG_ON(in_interrupt());
+
+	memleak_free(addr);
+
+	__vunmap(addr, 1);
+}
+EXPORT_SYMBOL(memleak_vfree);
+#endif
 /**
  *	vunmap  -  release virtual mapping obtained by vmap()
  *	@addr:		memory base address
@@ -1394,6 +1405,32 @@ static void *__vmalloc_node(unsigned long size, gfp_t gfp_mask, pgprot_t prot,
 	return __vmalloc_area_node(area, gfp_mask, prot, node, caller);
 }
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+static void *__memleak_vmalloc_node(unsigned long size, gfp_t gfp_mask,
+					pgprot_t prot, int node, void *caller)
+{
+	struct vm_struct *area;
+	void *addr;
+	unsigned long real_size = size;
+
+	size = PAGE_ALIGN(size);
+	if (!size || (size >> PAGE_SHIFT) > num_physpages)
+		return NULL;
+
+	area = get_vm_area_node(size, VM_ALLOC, node, gfp_mask);
+	if (!area)
+		return NULL;
+
+	addr = __vmalloc_area_node(area, gfp_mask, prot, node, caller);
+
+	/* this needs ref_count = 2 since the vm_struct also contains
+	   a pointer to this address */
+	memleak_alloc(addr, real_size, 2);
+
+	return addr;
+}
+#endif
+
 void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)
 {
 	return __vmalloc_node(size, gfp_mask, prot, -1,
@@ -1401,6 +1438,15 @@ void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)
 }
 EXPORT_SYMBOL(__vmalloc);
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+void *__memleak_vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)
+{
+	return __memleak_vmalloc_node(size, gfp_mask, prot, -1,
+			__builtin_return_address(0));
+}
+EXPORT_SYMBOL(__memleak_vmalloc);
+#endif
+
 /**
  *	vmalloc  -  allocate virtually contiguous memory
  *	@size:		allocation size
@@ -1417,6 +1463,14 @@ void *vmalloc(unsigned long size)
 }
 EXPORT_SYMBOL(vmalloc);
 
+#ifdef CONFIG_DEBUG_MEMLEAK
+void *memleak_vmalloc(unsigned long size)
+{
+	return __memleak_vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
+}
+EXPORT_SYMBOL(memleak_vmalloc);
+#endif
+
 /**
  * vmalloc_user - allocate zeroed virtually contiguous memory for userspace
  * @size: allocation size
diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e082b89..7a1bc22 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -495,7 +495,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn)
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->mode != HCI_CM_SNIFF || !conn->power_save)
+	if (conn->mode != HCI_CM_SNIFF /*|| !conn->power_save */)
 		goto timer;
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index da2c3b8..07402b1 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -34,11 +34,29 @@
  *
  */
 
+/*
+ * Copyright (C) 2009 Motorola, Inc.
+ */
+
+/*
+ * Author     Date          Comment
+ * =======   ===========   ====================================================
+ * Motorola  11/12/2009    Limit mss to be no bigger than 1372 to solve
+ *                         compatibility issue
+ */
+
+
 #include <net/tcp.h>
 
 #include <linux/compiler.h>
 #include <linux/module.h>
 
+/*
+ * Limit mss to be not bigger than 1372
+ * to solve compatibility issue
+ */
+#define TCP_MAX_SEGMENT_SIZE_LIMIT 1372
+
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse __read_mostly = 1;
 
@@ -113,6 +131,15 @@ static __u16 tcp_advertise_mss(struct sock *sk)
 	struct dst_entry *dst = __sk_dst_get(sk);
 	int mss = tp->advmss;
 
+	/*
+	 * Limit mss to be not bigger than 1372
+	 * to solve compatibility issue
+	 */
+	if (mss > TCP_MAX_SEGMENT_SIZE_LIMIT) {
+		mss = TCP_MAX_SEGMENT_SIZE_LIMIT;
+		tp->advmss = mss;
+	}
+
 	if (dst && dst_metric(dst, RTAX_ADVMSS) < mss) {
 		mss = dst_metric(dst, RTAX_ADVMSS);
 		tp->advmss = mss;
@@ -1021,6 +1048,13 @@ unsigned int tcp_sync_mss(struct sock *sk, u32 pmtu)
 	icsk->icsk_pmtu_cookie = pmtu;
 	if (icsk->icsk_mtup.enabled)
 		mss_now = min(mss_now, tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low));
+	/*
+	 * Limit mss to be not bigger than 1372
+	 * to solve compatiblity issue
+	 */
+	if (mss_now > TCP_MAX_SEGMENT_SIZE_LIMIT)
+		mss_now = TCP_MAX_SEGMENT_SIZE_LIMIT;
+
 	tp->mss_cache = mss_now;
 
 	return mss_now;
diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index ff50a05..b5935bc 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -714,7 +714,11 @@ static void rpc_async_schedule(struct work_struct *work)
 
 struct rpc_buffer {
 	size_t	len;
+#ifdef CONFIG_DEBUG_MEMLEAK
+	char	data[0];
+#else
 	char	data[];
+#endif
 };
 
 /**
diff --git a/scripts/Kbuild.include b/scripts/Kbuild.include
index c29be8f..860e821 100644
--- a/scripts/Kbuild.include
+++ b/scripts/Kbuild.include
@@ -147,6 +147,8 @@ build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj
 # skip if -I has no parameter
 addtree = $(if $(patsubst -I%,%,$(1)), \
 $(if $(filter-out -I/%,$(1)),$(patsubst -I%,-I$(srctree)/%,$(1))) $(1))
+addtree2 = $(if $(patsubst -I%,%,$(1)), \
+$(if $(filter-out -I/%,$(1)),$(patsubst -I%,-I$(objtree)/%,$(1))) $(1))
 
 # Find all -I options and call addtree
 flags = $(foreach o,$($(1)),$(if $(filter -I%,$(o)),$(call addtree,$(o)),$(o)))
diff --git a/scripts/Makefile.build b/scripts/Makefile.build
index c7de8b3..411d076 100644
--- a/scripts/Makefile.build
+++ b/scripts/Makefile.build
@@ -173,8 +173,12 @@ $(obj)/%.symtypes : $(src)/%.c FORCE
 quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
 
 ifndef CONFIG_MODVERSIONS
-cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
-
+	ifdef CONFIG_GCOV_PROFILE
+	cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ \
+             	$(if $(filter-out /%,$<),$(shell cd `dirname $<` && pwd)/$(shell basename $<),$<)
+	else
+	cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
+	endif
 else
 # When module versioning is enabled the following steps are executed:
 # o compile a .tmp_<file>.o from <file>.c
@@ -187,8 +191,12 @@ else
 # o generate <file>.o from .tmp_<file>.o using the linker to
 #   replace the unresolved symbols __crc_exported_symbol with
 #   the actual value of the checksum generated by genksyms
-
-cmd_cc_o_c = $(CC) $(c_flags) -c -o $(@D)/.tmp_$(@F) $<
+	ifdef CONFIG_GCOV_PROFILE
+	cmd_cc_o_c = $(CC) $(c_flags) -c -o $(@D)/.tmp_$(@F) \
+         	 $(if $(filter-out /%,$<),$(shell cd `dirname $<` && pwd)/$(shell basename $<),$<)
+	else
+		cmd_cc_o_c = $(CC) $(c_flags) -c -o $(@D)/.tmp_$(@F) $<
+	endif
 cmd_modversions =							\
 	if $(OBJDUMP) -h $(@D)/.tmp_$(@F) | grep -q __ksymtab; then	\
 		$(call cmd_gensymtypes, $(KBUILD_SYMTYPES))		\
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index e0636577..3278fb2 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -114,7 +114,7 @@ _cpp_flags     = $(KBUILD_CPPFLAGS) $(cppflags-y) $(CPPFLAGS_$(@F))
 # If building the kernel in a separate objtree expand all occurrences
 # of -Idir to -I$(srctree)/dir except for absolute paths (starting with '/').
 
-ifeq ($(KBUILD_SRC),)
+ifeq ($(KBUILD_SRC)$(CONFIG_GCOV_PROFILE),)
 __c_flags	= $(_c_flags)
 __a_flags	= $(_a_flags)
 __cpp_flags     = $(_cpp_flags)
@@ -124,15 +124,27 @@ else
 # $(call addtree,-I$(obj)) locates .h files in srctree, from generated .c files
 #   and locates generated .h files
 # FIXME: Replace both with specific CFLAGS* statements in the makefiles
+ifdef CONFIG_GCOV_PROFILE
+__c_flags      = $(call addtree,-I$(obj)) $(call addtree2,-I$(obj)) $(call flags,_c_flags)
+else
 __c_flags	= $(call addtree,-I$(obj)) $(call flags,_c_flags)
+endif
 __a_flags	=                          $(call flags,_a_flags)
 __cpp_flags     =                          $(call flags,_cpp_flags)
 endif
 
+ifdef CONFIG_GCOV_PROFILE
+nogcov = $(if $(NOGCOV_$(basetarget).o),$(filter-out $(KBUILD_GCOV_FLAGS),$(1)),$(1))
+c_flags        = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(LINUXINCLUDE) \
+                       $(call nogcov,$(__c_flags)) $(modkern_cflags) \
+                       -D"KBUILD_STR(s)=\#s" $(basename_flags) $(modname_flags) \
+                       $(debug_flags)
+else
 c_flags        = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(LINUXINCLUDE)     \
 		 $(__c_flags) $(modkern_cflags)                           \
 		 -D"KBUILD_STR(s)=\#s" $(basename_flags) $(modname_flags) \
 		  $(debug_flags)
+endif
 
 a_flags        = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(LINUXINCLUDE)     \
 		 $(__a_flags) $(modkern_aflags)
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index 2d5ece7..a436587 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -16,13 +16,13 @@ use Getopt::Long qw(:config no_auto_abbrev);
 
 my $quiet = 0;
 my $tree = 1;
-my $chk_signoff = 1;
+my $chk_signoff = 0;
 my $chk_patch = 1;
 my $tst_only;
 my $emacs = 0;
 my $terse = 0;
 my $file = 0;
-my $check = 0;
+my $check = 1;
 my $summary = 1;
 my $mailback = 0;
 my $summary_file = 0;
@@ -1025,7 +1025,7 @@ sub WARN {
 }
 sub CHK {
 	if ($check && report("CHECK: $_[0]\n")) {
-		our $clean = 0;
+		# our $clean = 0;
 		our $cnt_chk++;
 	}
 }
diff --git a/scripts/chk_gcc_warn.pl b/scripts/chk_gcc_warn.pl
new file mode 100755
index 0000000..621df0c
--- /dev/null
+++ b/scripts/chk_gcc_warn.pl
@@ -0,0 +1,162 @@
+#!/usr/bin/perl -w
+#
+# Copyright (C) 2009 Motorola, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307, USA
+#
+
+use File::Basename;
+
+my $argc = @ARGV;
+
+if ($argc < 2) {
+	print "Usage: gcc_warn_filter <git_top_dir> <filter_file>\n";
+	exit(1);
+}
+
+my $top = $ARGV[0];
+my $filter_file = $ARGV[1];
+my $dbg = $ARGV[2];
+my $file_warn;
+my $file_failed;
+my $failed = 0;
+
+
+print "GCC warning chk...\n";
+
+while (<STDIN>) {
+	chop;
+
+	$file_warn = chk_pattern($_);
+	if ($file_warn eq "0") {
+		next;
+	}
+
+	if (!open(FILE, $filter_file)) {
+		print STDERR"Can not open the file: $filter_file";
+		exit(1);
+	}
+
+	# In case the filter list is empty
+	$file_failed = $file_warn;
+	$file_failed =~ s/\:[0-9]+//;
+
+	while (defined ($eachline =<FILE>)) {
+     		chomp $eachline;
+		$file_failed = chk_filter($file_warn, $eachline, $top);
+
+		# Already in  filter list
+		if ($file_failed eq "0") {
+			last;
+		}
+	}
+
+	if ($file_failed ne "0") {
+		print STDERR"$_ \n";
+
+		if ( -e $file_failed) {
+			DBG("touch $file_failed \n");
+			system "touch $file_failed";
+		} else {
+			print STDERR"$file_failed not exist\n";
+		}
+
+		$failed = 1;
+	}
+        close FILE;
+}
+
+if ($failed ne "0") {
+	print STDERR"Unexpected GCC warning found!\n";
+	exit(1);
+}
+
+exit(0);
+
+sub DBG {
+	my ($dbg_msg) = @_;
+	if (!$dbg || ($dbg ne "1")) {
+		return;
+	}
+
+	print $dbg_msg;
+}
+
+#
+# Check if the gcc messages meet below pattern
+# xxxx/xxx/xxx/yyy.c:111:warning:mmmm
+#
+sub chk_pattern {
+	my ($full_msg) = @_;
+
+	my @array = split/\:/, $full_msg;
+	my $file = $array[0];
+	my $line = $array[1];
+	my $warn = $array[2];
+	my $msg = $array[3];
+
+	if (!$file || !$line || !$warn) {
+		return 0;
+	}
+
+
+	# Only handle warning for .c and .h files
+	if (!($file =~ /\.c/) && !($file =~ /\.h/)) {
+		return 0;
+	}
+
+	# The 2nd/3rd field should be line# and "warning"
+	if (!($line =~ /[0-9]/) || !($warn =~ /warning/)) {
+		return 0;
+	}
+
+	if ($msg =~ /unused variable/) {
+		return 0;
+	}
+
+	if ($msg =~ /defined but not used/) {
+		return 0;
+	}
+
+	$file = $file . "\:" . $line;
+	return $file;
+}
+
+sub chk_filter {
+	my ($file, $filter, $topdir) = @_;
+
+	$_file = $file;
+	# Get relative file path
+	$_file =~ s/$topdir\///;
+
+	if (!($filter =~ /\:[0-9]/)) {
+		# none-line# based rule
+		$_file =~ s/\:[0-9]+//;
+	}
+
+	if (!($filter =~ /\.c/) && !($filter =~ /\.h/)) {
+		# folder based rule
+	 	$_file = dirname($_file);
+	}
+
+	if ($_file eq $filter) {
+		DBG("$_file filter out\n");
+		return 0;
+	}
+
+	$file =~ s/\:[0-9]+//;
+	return $file;
+}
+
diff --git a/scripts/gcc_warn_filter.README b/scripts/gcc_warn_filter.README
new file mode 100644
index 0000000..88e16bc
--- /dev/null
+++ b/scripts/gcc_warn_filter.README
@@ -0,0 +1,39 @@
+# 
+# "-Wall" is used for gcc by default when building kernel
+# Any warnings reported by gcc will lead to build failure
+#
+# Change "gcc_warn_filter.cfg" to filter out specific warnings
+# 
+# NOTE: 
+# The main purpose of filter is to handle warnings in 
+# a) Original OSS code
+# b) Code from 3rd paty
+# "zero build warning" is expected for code changed/added by Motorola
+#
+# !!!WARNING!!! 
+# To remove filter(s), CLEAN build MUST be done for verification
+#
+# For example:
+# 1) To ignore gcc warnings at line#720 in .../arch/arm/mm/mmu.c
+#    "arch/arm/mm/mmu.c:720" shall be added in gcc_warn_filter.cfg
+#
+#    NOTE: 
+#    a) Relative path shall be used rather than absolute path
+#    	I.e. NOT use "/my_repo/xxx/.../kernel/arch/arm/..." 
+#    b) There is NO space allowed before/after ":"
+#    c) There is NO space alloed after "720"
+#    d) More than one rule can be added for one file
+#    	arch/arm/mm/mmu.c:720
+#    	arch/arm/mm/mmu.c:900
+#
+# 2) To ignore ALL gcc warnings in .../arch/arm/mm/mmu.c
+#    "arch/arm/mm/mmu.c" shall be added to gcc_warn_filter.cfg
+#
+# 3) To ignore gcc warnings for ALL files under .../arch/arm/mm
+#    "arch/arm/mm" shall be added in gcc_warn_filter.cfg
+#     NOTE:
+#     a) There is NO "/" at the end of folder name
+#     b) Only the lowest level folder is supported
+#        I.e. Don't expect "arch/arm" can filter warnings from "...arch/arm"
+#
+
diff --git a/scripts/gcc_warn_filter.cfg b/scripts/gcc_warn_filter.cfg
new file mode 100644
index 0000000..94befb3
--- /dev/null
+++ b/scripts/gcc_warn_filter.cfg
@@ -0,0 +1,56 @@
+scripts
+scripts/kconfig
+scripts/mod
+scripts/basic
+scripts/genksyms
+usr
+arch/arm/mm/mmu.c:723
+kernel/workqueue.c:819
+kernel/workqueue.c:684
+kernel/srcu.c:49
+kernel/sched.c:9548
+kernel/softirq.c:201
+net/core/neighbour.c:1416
+drivers/i2c/i2c-core.c:283
+drivers/i2c/i2c-core.c:646
+drivers/i2c/i2c-core.c:713
+drivers/i2c/i2c-core.c:780
+drivers/i2c/i2c-core.c:876
+drivers/i2c/i2c-core.c:904
+net/ipv4/af_inet.c:1397
+net/ipv4/af_inet.c:1400
+mm/slab.c
+include/asm-generic/pgtable.h
+include/linux/cred.h:188
+fs/nfs/iostat.h:62
+drivers/net/loopback.c:130
+drivers/spi/omap2_mcspi.c:963
+drivers/misc/ts27010mux/ts27010_ringbuf.h:80
+arch/arm/mach-omap2/resource34xx.h:32
+arch/arm/mach-omap2/resource34xx.h:33
+drivers/media/video/v4l2-common.c:884
+drivers/media/video/oldomap34xxcam.c:1606
+drivers/staging/android/binder.c:1274
+net/netfilter/nf_conntrack_core.c:1202
+net/ipv4/netfilter/ipt_ULOG.c:213
+net/ipv4/netfilter/ipt_IDLETIMER.c:272
+net/ipv4/netfilter/ipt_IDLETIMER.c:273
+net/netfilter/xt_time.c:173
+net/netfilter/nf_conntrack_ecache.c:103
+net/ipv4/route.c:3379
+net/xfrm/xfrm_ipcomp.c:226
+net/xfrm/xfrm_ipcomp.c:299
+drivers/misc/omap_mdm_ctrl.c:268
+drivers/usb/host/ohci-omap.c:471
+arch/arm/mach-omap2/board-mapphone-panic.c:442
+drivers/gpu/pvr/omap3430/sysutils_linux.c:445
+fs/fat/dir.c:1245
+drivers/dsp/bridge/wmd/io_sm.c:828
+drivers/dsp/bridge/rmgr/proc.c:1076
+drivers/dsp/bridge/dynload/cload.c:874
+drivers/dsp/bridge/dynload/cload.c:210
+drivers/media/video/hplens.c:369
+kernel/ltt-lite.c:2685
+fs/partitions/check.c:307
+fs/partitions/check.c:312
+fs/partitions/check.c:320
diff --git a/scripts/pre-commit b/scripts/pre-commit
new file mode 100755
index 0000000..2aaa8dc
--- /dev/null
+++ b/scripts/pre-commit
@@ -0,0 +1,20 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by git-commit with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, make this file executable.
+
+# This is slightly modified from Andrew Morton's Perfect Patch.
+# Lines you introduce should not have trailing whitespace.
+# Also check for an indentation that has SP before a TAB.
+if git-rev-parse --verify HEAD 2>/dev/null
+then
+	git-diff-index -p -M --cached HEAD
+else
+	# NEEDSWORK: we should produce a diff with an empty tree here
+	# if we want to do the same verification for the initial import.
+	:
+fi | $GIT_DIR/hooks/checkpatch.pl -
diff --git a/sound/oss/Kconfig b/sound/oss/Kconfig
index c7f4841..2ca0606 100644
--- a/sound/oss/Kconfig
+++ b/sound/oss/Kconfig
@@ -572,4 +572,4 @@ config SOUND_CPCAP_OMAP
 	bool "Audio driver for OMAP3430 with CPCAP"
 	default n
 	help
-	Audio driver for products using OMAP3430 and CPCAP.
\ No newline at end of file
+	  Audio driver for products using OMAP3430 and CPCAP.
diff --git a/sound/oss/Makefile b/sound/oss/Makefile
index aa64959..0ac8376 100644
--- a/sound/oss/Makefile
+++ b/sound/oss/Makefile
@@ -29,7 +29,11 @@ obj-$(CONFIG_SOUND_MSNDPIN)	+= msnd.o msnd_pinnacle.o
 obj-$(CONFIG_SOUND_VWSND)	+= vwsnd.o
 obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o
 obj-$(CONFIG_SOUND_BCM_CS4297A)	+= swarm_cs4297a.o
-obj-$(CONFIG_SOUND_CPCAP_OMAP)	+= omap34xx_audio_driver.o cpcap_audio_driver.o
+ifeq ($(CONFIG_MACH_MAPPHONE),y)
+	obj-$(CONFIG_SOUND_CPCAP_OMAP)  += moto_audio/
+else
+	obj-$(CONFIG_SOUND_CPCAP_OMAP)	+= omap34xx_audio_driver.o cpcap_audio_driver.o
+endif
 obj-$(CONFIG_DMASOUND)		+= dmasound/
 
 # Declare multi-part drivers.
diff --git a/sound/oss/moto_audio/Makefile b/sound/oss/moto_audio/Makefile
new file mode 100644
index 0000000..535bd0c
--- /dev/null
+++ b/sound/oss/moto_audio/Makefile
@@ -0,0 +1 @@
+obj-y	+= omap34xx_audio_driver.o cpcap_audio_driver.o
diff --git a/sound/oss/moto_audio/cpcap_audio_driver.c b/sound/oss/moto_audio/cpcap_audio_driver.c
new file mode 100755
index 0000000..1d2d945
--- /dev/null
+++ b/sound/oss/moto_audio/cpcap_audio_driver.c
@@ -0,0 +1,1204 @@
+/*
+ * Copyright (C) 2007 - 2009 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include "cpcap_audio_driver.h"
+#include <linux/spi/cpcap.h>
+#include <mach/resource.h>
+#include <linux/regulator/consumer.h>
+
+
+#define SLEEP_ACTIVATE_POWER 2
+
+#define CLOCK_TREE_RESET_TIME 1
+
+#define SLEEP_OUTPUT_AMPS_ENABLE 1
+
+#ifdef CPCAP_AUDIO_DEBUG
+#define CPCAP_AUDIO_DEBUG_LOG(args...)  \
+				printk(KERN_INFO "CPCAP_AUDIO_DRIVER:" args)
+#else
+#define CPCAP_AUDIO_DEBUG_LOG(args...)
+#endif
+
+#define CPCAP_AUDIO_ERROR_LOG(args...)  \
+			printk(KERN_ERR "CPCAP_AUDIO_DRIVER: Error " args)
+
+#define ERROR_EXIT _err
+#define TRY(a)  if (unlikely(a)) goto ERROR_EXIT;
+
+static struct cpcap_audio_state previous_state_struct = {
+	NULL,
+	CPCAP_AUDIO_MODE_NORMAL,
+	CPCAP_AUDIO_CODEC_OFF,
+	CPCAP_AUDIO_CODEC_RATE_8000_HZ,
+	CPCAP_AUDIO_CODEC_MUTE,
+	CPCAP_AUDIO_STDAC_OFF,
+	CPCAP_AUDIO_STDAC_RATE_8000_HZ,
+	CPCAP_AUDIO_STDAC_MUTE,
+	CPCAP_AUDIO_ANALOG_SOURCE_OFF,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_BALANCE_NEUTRAL,
+	CPCAP_AUDIO_BALANCE_NEUTRAL,
+	CPCAP_AUDIO_BALANCE_NEUTRAL,
+	0,			/* output gain */
+	CPCAP_AUDIO_IN_NONE,
+	0,			/* input_gain */
+	CPCAP_AUDIO_RAT_NONE
+};
+
+/* Define regulator to turn on the audio portion of cpcap */
+struct regulator *audio_reg;
+
+static inline int is_mic_stereo(int microphone)
+{
+	if (microphone == CPCAP_AUDIO_IN_DUAL_INTERNAL
+		|| microphone == CPCAP_AUDIO_IN_DUAL_EXTERNAL)
+		return 1;
+	return 0;
+}
+
+static inline int is_codec_changed(struct cpcap_audio_state *state,
+					struct cpcap_audio_state *prev_state)
+{
+	/*TODO: microphone check is overzealous. optimize.*/
+	/*TODO: need to also check for speaker turning on/off */
+	if (state->codec_mode != prev_state->codec_mode ||
+		state->codec_rate != prev_state->codec_rate ||
+		state->rat_type != prev_state->rat_type ||
+		state->microphone != prev_state->microphone)
+		return 1;
+	return 0;
+}
+
+static inline int is_stdac_changed(struct cpcap_audio_state *state,
+					struct cpcap_audio_state *prev_state)
+{
+	if (state->stdac_mode != prev_state->stdac_mode ||
+		state->rat_type != prev_state->rat_type ||
+		state->stdac_rate != prev_state->stdac_rate)
+		return 1;
+	return 0;
+}
+
+static inline int is_output_bt_only(struct cpcap_audio_state *state)
+{
+	if (state->codec_primary_speaker == CPCAP_AUDIO_OUT_BT_MONO
+		&& state->codec_secondary_speaker == CPCAP_AUDIO_OUT_NONE)
+		return 1;
+
+	if (state->stdac_primary_speaker == CPCAP_AUDIO_OUT_BT_MONO
+	      && state->stdac_secondary_speaker == CPCAP_AUDIO_OUT_NONE)
+		return 1;
+
+	if (state->ext_primary_speaker == CPCAP_AUDIO_OUT_BT_MONO
+		&& state->ext_secondary_speaker == CPCAP_AUDIO_OUT_NONE)
+		return 1;
+
+	return 0;
+}
+
+static inline int is_output_headset(struct cpcap_audio_state *state)
+{
+	if (state->codec_primary_speaker == CPCAP_AUDIO_OUT_STEREO_HEADSET
+	|| state->codec_primary_speaker == CPCAP_AUDIO_OUT_MONO_HEADSET
+	|| state->codec_secondary_speaker == CPCAP_AUDIO_OUT_STEREO_HEADSET
+	|| state->codec_secondary_speaker == CPCAP_AUDIO_OUT_MONO_HEADSET)
+		return 1;
+
+	if (state->stdac_primary_speaker == CPCAP_AUDIO_OUT_STEREO_HEADSET
+	|| state->stdac_primary_speaker == CPCAP_AUDIO_OUT_MONO_HEADSET
+	|| state->stdac_secondary_speaker == CPCAP_AUDIO_OUT_STEREO_HEADSET
+	|| state->stdac_secondary_speaker == CPCAP_AUDIO_OUT_MONO_HEADSET)
+		return 1;
+
+	if (state->ext_primary_speaker == CPCAP_AUDIO_OUT_STEREO_HEADSET
+	|| state->ext_primary_speaker == CPCAP_AUDIO_OUT_MONO_HEADSET
+	|| state->ext_secondary_speaker == CPCAP_AUDIO_OUT_STEREO_HEADSET
+	|| state->ext_secondary_speaker == CPCAP_AUDIO_OUT_MONO_HEADSET)
+		return 1;
+
+	return 0;
+}
+
+static inline int is_speaker_turning_off(struct cpcap_audio_state *state,
+					struct cpcap_audio_state *prev_state)
+{
+	if ((prev_state->codec_primary_speaker != CPCAP_AUDIO_OUT_NONE &&
+		state->codec_primary_speaker == CPCAP_AUDIO_OUT_NONE) ||
+		(prev_state->codec_secondary_speaker != CPCAP_AUDIO_OUT_NONE &&
+		state->codec_secondary_speaker == CPCAP_AUDIO_OUT_NONE) ||
+		(prev_state->stdac_primary_speaker != CPCAP_AUDIO_OUT_NONE &&
+		state->stdac_primary_speaker == CPCAP_AUDIO_OUT_NONE) ||
+		(prev_state->stdac_secondary_speaker != CPCAP_AUDIO_OUT_NONE &&
+		state->stdac_secondary_speaker == CPCAP_AUDIO_OUT_NONE) ||
+		(prev_state->ext_primary_speaker != CPCAP_AUDIO_OUT_NONE &&
+		state->ext_primary_speaker == CPCAP_AUDIO_OUT_NONE) ||
+		(prev_state->ext_secondary_speaker != CPCAP_AUDIO_OUT_NONE &&
+		state->ext_secondary_speaker == CPCAP_AUDIO_OUT_NONE))
+		return 1;
+
+	return 0;
+}
+
+static inline int is_output_changed(struct cpcap_audio_state *state,
+					struct cpcap_audio_state *prev_state)
+{
+	if (state->codec_primary_speaker != prev_state->codec_primary_speaker
+	|| state->codec_primary_balance != prev_state->codec_primary_balance
+		|| state->codec_secondary_speaker !=
+					prev_state->codec_secondary_speaker)
+		return 1;
+
+	if (state->stdac_primary_speaker != prev_state->stdac_primary_speaker
+	|| state->stdac_primary_balance != prev_state->stdac_primary_balance
+	|| state->stdac_secondary_speaker !=
+		prev_state->stdac_secondary_speaker)
+		return 1;
+
+	if (state->ext_primary_speaker != prev_state->ext_primary_speaker
+	|| state->ext_primary_balance != prev_state->ext_primary_balance
+	|| state->ext_secondary_speaker != prev_state->ext_secondary_speaker)
+		return 1;
+
+	return 0;
+}
+
+static void
+audioic_state_dump
+(
+	struct cpcap_audio_state *state
+)
+{
+	CPCAP_AUDIO_DEBUG_LOG("***************************************\n");
+	CPCAP_AUDIO_DEBUG_LOG("state->mode = %d\n",  state->mode);
+	CPCAP_AUDIO_DEBUG_LOG("state->codec_mode = %d\n", state->codec_mode);
+	CPCAP_AUDIO_DEBUG_LOG("state->codec_rate = %d\n", state->codec_rate);
+	CPCAP_AUDIO_DEBUG_LOG("state->codec_mute = %d\n", state->codec_mute);
+	CPCAP_AUDIO_DEBUG_LOG("state->stdac_mode = %d\n", state->stdac_mode);
+	CPCAP_AUDIO_DEBUG_LOG("state->stdac_rate = %d\n", state->stdac_rate);
+	CPCAP_AUDIO_DEBUG_LOG("state->stdac_mute = %d\n", state->stdac_mute);
+	CPCAP_AUDIO_DEBUG_LOG("state->analog_source = %d\n",
+						state->analog_source);
+	CPCAP_AUDIO_DEBUG_LOG("state->codec_primary_speaker = %d\n",
+						state->codec_primary_speaker);
+	CPCAP_AUDIO_DEBUG_LOG("state->stdac_primary_speaker = %d\n",
+						state->stdac_primary_speaker);
+	CPCAP_AUDIO_DEBUG_LOG("state->ext_primary_speaker = %d\n",
+						state->ext_primary_speaker);
+	CPCAP_AUDIO_DEBUG_LOG("state->codec_secondary_speaker = %d\n",
+						state->codec_secondary_speaker);
+	CPCAP_AUDIO_DEBUG_LOG("state->stdac_secondary_speaker = %d\n",
+						state->stdac_secondary_speaker);
+	CPCAP_AUDIO_DEBUG_LOG("state->ext_secondary_speaker   = %d\n",
+						state->ext_secondary_speaker);
+	CPCAP_AUDIO_DEBUG_LOG("state->stdac_primary_balance   = %d\n",
+						state->stdac_primary_balance);
+	CPCAP_AUDIO_DEBUG_LOG("state->ext_primary_balance     = %d\n",
+						state->ext_primary_balance);
+	CPCAP_AUDIO_DEBUG_LOG("state->output_gain             = %d\n",
+						state->output_gain);
+	CPCAP_AUDIO_DEBUG_LOG("state->microphone              = %d\n",
+						state->microphone);
+	CPCAP_AUDIO_DEBUG_LOG("state->input_gain              = %d\n",
+						state->input_gain);
+	CPCAP_AUDIO_DEBUG_LOG("state->rat_type                = %d\n",
+						state->rat_type);
+	CPCAP_AUDIO_DEBUG_LOG("***************************************\n");
+}
+
+/* this is only true for audio registers, but those are the only ones we use */
+#define CPCAP_REG_FOR_POWERIC_REG(a) ((a) + (0x200 - CPCAP_REG_VAUDIOC))
+
+static void logged_cpcap_write(struct cpcap_device *cpcap, unsigned int reg,
+			unsigned short int value, unsigned short int mask)
+{
+
+    int ret_val = 0;
+	if (mask == 0)
+		return;
+
+#ifdef CPCAP_AUDIO_SPI_LOG
+	printk(KERN_INFO
+		"CPCAP_AUDIO_SPI_WRITE: reg %u, value 0x%x, mask 0x%x\n",
+	       CPCAP_REG_FOR_POWERIC_REG(reg), value, mask);
+#endif
+	ret_val = cpcap_regacc_write(cpcap, reg, value, mask);
+	if (ret_val != 0)
+		CPCAP_AUDIO_ERROR_LOG(
+			"Write to register %u failed: error %d \n",
+			reg, ret_val);
+
+#ifdef CPCAP_AUDIO_SPI_READBACK
+	ret_val = cpcap_regacc_read(cpcap, reg, &value);
+	if (ret_val == 0)
+		printk(KERN_INFO
+			"CPCAP_AUDIO_SPI_VERIFY reg %u: value 0x%x \n",
+			CPCAP_REG_FOR_POWERIC_REG(reg), value);
+	else
+		printk(KERN_ERR
+			"CPCAP_AUDIO_SPI_VERIFY reg %u FAILED\n",
+			CPCAP_REG_FOR_POWERIC_REG(reg));
+#endif
+}
+
+
+
+static unsigned short int cpcap_audio_get_codec_output_amp_switches(
+						int speaker, int balance)
+{
+	unsigned short int value = CPCAP_BIT_PGA_CDC_EN;
+
+	CPCAP_AUDIO_DEBUG_LOG("%s() called with speaker = %d\n", __func__,
+			  speaker);
+
+	switch (speaker) {
+	case CPCAP_AUDIO_OUT_HANDSET:
+		value |= CPCAP_BIT_A1_EAR_CDC_SW;
+		break;
+
+	case CPCAP_AUDIO_OUT_LOUDSPEAKER:
+		value |= CPCAP_BIT_A2_LDSP_L_CDC_SW;
+		break;
+
+	case CPCAP_AUDIO_OUT_MONO_HEADSET:
+	case CPCAP_AUDIO_OUT_STEREO_HEADSET:
+		if (balance != CPCAP_AUDIO_BALANCE_L_ONLY)
+			value |= CPCAP_BIT_ARIGHT_HS_CDC_SW;
+		if (balance != CPCAP_AUDIO_BALANCE_R_ONLY)
+			value |= CPCAP_BIT_ALEFT_HS_CDC_SW;
+		break;
+
+	case CPCAP_AUDIO_OUT_LINEOUT:
+		value |= CPCAP_BIT_A4_LINEOUT_R_CDC_SW |
+			CPCAP_BIT_A4_LINEOUT_L_CDC_SW;
+		break;
+
+	case CPCAP_AUDIO_OUT_BT_MONO:
+	default:
+		value = 0;
+		break;
+	}
+
+	CPCAP_AUDIO_DEBUG_LOG("Exiting %s() with return value = %d\n", __func__,
+			  value);
+	return value;
+}
+
+static unsigned short int cpcap_audio_get_stdac_output_amp_switches(
+						int speaker, int balance)
+{
+	unsigned short int value = CPCAP_BIT_PGA_DAC_EN;
+
+	CPCAP_AUDIO_DEBUG_LOG("%s() called with speaker = %d\n", __func__,
+			  speaker);
+
+	switch (speaker) {
+	case CPCAP_AUDIO_OUT_HANDSET:
+		value |= CPCAP_BIT_A1_EAR_DAC_SW | CPCAP_BIT_MONO_DAC0 |
+			CPCAP_BIT_MONO_DAC1;
+		break;
+
+	case CPCAP_AUDIO_OUT_MONO_HEADSET:
+	case CPCAP_AUDIO_OUT_STEREO_HEADSET:
+		if (balance != CPCAP_AUDIO_BALANCE_R_ONLY)
+			value |= CPCAP_BIT_ALEFT_HS_DAC_SW;
+		if (balance != CPCAP_AUDIO_BALANCE_L_ONLY)
+			value |= CPCAP_BIT_ARIGHT_HS_DAC_SW;
+		break;
+
+	case CPCAP_AUDIO_OUT_LOUDSPEAKER:
+		value |= CPCAP_BIT_A2_LDSP_L_DAC_SW | CPCAP_BIT_MONO_DAC0 |
+			CPCAP_BIT_MONO_DAC1;
+		break;
+
+	case CPCAP_AUDIO_OUT_LINEOUT:
+		value |= CPCAP_BIT_A4_LINEOUT_R_DAC_SW |
+			CPCAP_BIT_A4_LINEOUT_L_DAC_SW;
+		break;
+
+	case CPCAP_AUDIO_OUT_BT_MONO:
+	default:
+		value = 0;
+		break;
+	}
+
+	CPCAP_AUDIO_DEBUG_LOG("Exiting %s() with return value = %d\n", __func__,
+			  value);
+	return value;
+}
+
+static unsigned short int cpcap_audio_get_ext_output_amp_switches(
+						int speaker,
+						int balance)
+{
+	unsigned short int value = 0;
+	CPCAP_AUDIO_DEBUG_LOG("%s() called with speaker %d\n", __func__,
+								speaker);
+
+	switch (speaker) {
+	case CPCAP_AUDIO_OUT_HANDSET:
+		value |= CPCAP_BIT_A1_EAR_EXT_SW | CPCAP_BIT_PGA_EXT_R_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_MONO_HEADSET:
+	case CPCAP_AUDIO_OUT_STEREO_HEADSET:
+		if (balance != CPCAP_AUDIO_BALANCE_L_ONLY)
+			value |= CPCAP_BIT_ARIGHT_HS_EXT_SW |
+				CPCAP_BIT_PGA_EXT_R_EN;
+		if (balance != CPCAP_AUDIO_BALANCE_R_ONLY)
+			value |= CPCAP_BIT_ALEFT_HS_EXT_SW |
+				CPCAP_BIT_PGA_EXT_L_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_LOUDSPEAKER:
+		value |= CPCAP_BIT_A2_LDSP_L_EXT_SW | CPCAP_BIT_PGA_EXT_L_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_LINEOUT:
+		value |= CPCAP_BIT_A4_LINEOUT_R_EXT_SW |
+			CPCAP_BIT_A4_LINEOUT_L_EXT_SW |
+			CPCAP_BIT_PGA_EXT_L_EN | CPCAP_BIT_PGA_EXT_R_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_BT_MONO:
+	default:
+		value = 0;
+		break;
+	}
+
+	CPCAP_AUDIO_DEBUG_LOG("Exiting %s() with return value = %d\n", __func__,
+			  value);
+	return value;
+}
+
+static void cpcap_audio_set_output_amp_switches(struct cpcap_audio_state *state)
+{
+	static unsigned int 	codec_prev_settings = 0,
+				stdac_prev_settings = 0,
+				ext_prev_settings = 0;
+
+	struct cpcap_regacc reg_changes;
+	unsigned short int value1 = 0, value2 = 0;
+
+	/* First set codec output amp switches */
+	value1 =
+	    cpcap_audio_get_codec_output_amp_switches(state->
+				codec_primary_speaker,
+				state->codec_primary_balance);
+	value2 =
+	    cpcap_audio_get_codec_output_amp_switches(state->
+				codec_secondary_speaker,
+				state->codec_primary_balance);
+
+	reg_changes.mask = value1 | value2 | codec_prev_settings;
+	reg_changes.value = value1 | value2;
+	codec_prev_settings = reg_changes.value;
+
+	logged_cpcap_write(state->cpcap, CPCAP_REG_RXCOA,
+		reg_changes.value, reg_changes.mask);
+
+	/* Second Stdac switches */
+	value1 =
+	    cpcap_audio_get_stdac_output_amp_switches(state->
+				stdac_primary_speaker,
+				state->stdac_primary_balance);
+	value2 =
+	    cpcap_audio_get_stdac_output_amp_switches(state->
+				stdac_secondary_speaker,
+				state->stdac_primary_balance);
+
+	reg_changes.mask = value1 | value2 | stdac_prev_settings;
+	reg_changes.value = value1 | value2;
+
+	if ((state->stdac_primary_speaker == CPCAP_AUDIO_OUT_STEREO_HEADSET &&
+		state->stdac_secondary_speaker == CPCAP_AUDIO_OUT_LOUDSPEAKER)
+		|| (state->stdac_primary_speaker == CPCAP_AUDIO_OUT_LOUDSPEAKER
+		&& state->stdac_secondary_speaker ==
+						CPCAP_AUDIO_OUT_STEREO_HEADSET))
+		reg_changes.value &= ~(CPCAP_BIT_MONO_DAC0 |
+					CPCAP_BIT_MONO_DAC1);
+
+	stdac_prev_settings = reg_changes.value;
+
+	logged_cpcap_write(state->cpcap, CPCAP_REG_RXSDOA,
+			reg_changes.value, reg_changes.mask);
+
+	/* Last External source switches */
+	value1 =
+	    cpcap_audio_get_ext_output_amp_switches(state->
+				ext_primary_speaker,
+				state->ext_primary_balance);
+	value2 =
+	    cpcap_audio_get_ext_output_amp_switches(state->
+				ext_secondary_speaker,
+				state->ext_primary_balance);
+
+	reg_changes.mask = value1 | value2 | ext_prev_settings;
+	reg_changes.value = value1 | value2;
+	ext_prev_settings = reg_changes.value;
+
+	logged_cpcap_write(state->cpcap, CPCAP_REG_RXEPOA,
+			reg_changes.value, reg_changes.mask);
+}
+
+static bool cpcap_audio_set_bits_for_speaker(int speaker, int balance,
+						unsigned short int *message)
+{
+	CPCAP_AUDIO_DEBUG_LOG("%s() called with speaker = %d\n", __func__,
+			  speaker);
+
+	/* Get the data required to enable each possible path */
+	switch (speaker) {
+	case CPCAP_AUDIO_OUT_HANDSET:
+		(*message) |= CPCAP_BIT_A1_EAR_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_MONO_HEADSET:
+	case CPCAP_AUDIO_OUT_STEREO_HEADSET:
+		if (balance != CPCAP_AUDIO_BALANCE_R_ONLY)
+			(*message) |= CPCAP_BIT_HS_L_EN;
+		if (balance != CPCAP_AUDIO_BALANCE_L_ONLY)
+			(*message) |= CPCAP_BIT_HS_R_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_LOUDSPEAKER:
+		(*message) |= CPCAP_BIT_A2_LDSP_L_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_LINEOUT:
+		(*message) |= CPCAP_BIT_A4_LINEOUT_R_EN |
+				CPCAP_BIT_A4_LINEOUT_L_EN;
+		break;
+
+	case CPCAP_AUDIO_OUT_BT_MONO:
+	default:
+		(*message) |= 0;
+		break;
+	}
+
+	return false; /* There is no external loudspeaker on this product */
+}
+
+static void cpcap_audio_set_output_amp(struct cpcap_audio_state *state)
+{
+  static unsigned int prev_aud_out_data;
+  bool activate_ext_loudspeaker = false;
+  struct cpcap_regacc reg_changes = { 0 };
+
+  activate_ext_loudspeaker = cpcap_audio_set_bits_for_speaker(
+					state->codec_primary_speaker,
+					state->codec_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->codec_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->stdac_primary_speaker,
+					state->stdac_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->stdac_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->ext_primary_speaker,
+					state->ext_primary_balance,
+					&(reg_changes.value));
+
+  activate_ext_loudspeaker = activate_ext_loudspeaker ||
+					cpcap_audio_set_bits_for_speaker(
+					state->ext_secondary_speaker,
+					CPCAP_AUDIO_BALANCE_NEUTRAL,
+					&(reg_changes.value));
+
+  reg_changes.mask = reg_changes.value | prev_aud_out_data;
+
+  prev_aud_out_data = reg_changes.value;
+
+  /* Charge pump should be enabled first and wait a minimum of 750 uSec
+		to allow for settling of the negative supply.
+  */
+	if ((reg_changes.mask & (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+		if (reg_changes.value
+			& (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN)) {
+			cpcap_regacc_write(state->cpcap, CPCAP_REG_RXOA,
+			CPCAP_BIT_ST_HS_CP_EN, CPCAP_BIT_ST_HS_CP_EN);
+			mdelay(1);
+		}
+	}
+
+  logged_cpcap_write(state->cpcap, CPCAP_REG_RXOA,
+      reg_changes.value, reg_changes.mask);
+
+  /* When disabling HS output amp, HS_CP should be turned off after output
+		amp goes down. */
+	if ((reg_changes.mask & (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+		if (!(reg_changes.value
+			& (CPCAP_BIT_HS_L_EN | CPCAP_BIT_HS_R_EN))) {
+			mdelay(1);
+			cpcap_regacc_write(state->cpcap, CPCAP_REG_RXOA,
+				0, CPCAP_BIT_ST_HS_CP_EN);
+		}
+	}
+}
+
+static void cpcap_audio_configure_aud_mute(struct cpcap_audio_state *state,
+				struct cpcap_audio_state *prev_state)
+{
+	struct cpcap_regacc reg_changes = { 0 };
+
+	if (state->codec_mute != prev_state->codec_mute) {
+		reg_changes.mask = CPCAP_BIT_CDC_SW;
+
+		if (state->codec_mute == CPCAP_AUDIO_CODEC_UNMUTE)
+			reg_changes.value = reg_changes.mask;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_RXCOA,
+					reg_changes.value, reg_changes.mask);
+	}
+
+	if (state->stdac_mute != prev_state->stdac_mute) {
+		reg_changes.mask = CPCAP_BIT_ST_DAC_SW;
+
+		if (state->stdac_mute == CPCAP_AUDIO_STDAC_UNMUTE)
+			reg_changes.value = reg_changes.mask;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_RXSDOA,
+					reg_changes.value, reg_changes.mask);
+	}
+
+}
+
+static void cpcap_audio_configure_codec(struct cpcap_audio_state *state,
+				struct cpcap_audio_state *previous_state) {
+	const unsigned int CODEC_FREQ_MASK = CPCAP_BIT_CDC_CLK0
+		| CPCAP_BIT_CDC_CLK1 | CPCAP_BIT_CDC_CLK2;
+	const unsigned int CODEC_RESET_FREQ_MASK = CODEC_FREQ_MASK
+		| CPCAP_BIT_CDC_CLOCK_TREE_RESET;
+
+	static unsigned int prev_codec_data = 0x0, prev_cdai_data = 0x0;
+
+	if (is_codec_changed(state, previous_state)) {
+		unsigned int temp_codec_rate = state->codec_rate;
+		struct cpcap_regacc cdai_changes = { 0 };
+		struct cpcap_regacc codec_changes = { 0 };
+		int codec_freq_config = 0;
+
+		if (state->rat_type == CPCAP_AUDIO_RAT_CDMA)
+			codec_freq_config = (CPCAP_BIT_CDC_CLK0
+					| CPCAP_BIT_CDC_CLK1) ; /* 19.2Mhz */
+		else
+			codec_freq_config = CPCAP_BIT_CDC_CLK2 ; /* 26Mhz */
+
+		/* If a codec is already in use, reset codec to initial state */
+		/* TODO: optimize - make less paranoid according to TI recs */
+		if (previous_state->codec_mode != CPCAP_AUDIO_CODEC_OFF) {
+			codec_changes.mask = prev_codec_data
+				| CPCAP_BIT_DF_RESET
+				| CPCAP_BIT_CDC_CLOCK_TREE_RESET;
+
+			logged_cpcap_write(state->cpcap, CPCAP_REG_CC,
+				codec_changes.value, codec_changes.mask);
+
+			prev_codec_data = 0;
+			previous_state->codec_mode = CPCAP_AUDIO_CODEC_OFF;
+		}
+
+		temp_codec_rate &= 0x0000000F;
+		temp_codec_rate = temp_codec_rate << 9;
+
+		switch (state->codec_mode) {
+		case CPCAP_AUDIO_CODEC_LOOPBACK:
+		case CPCAP_AUDIO_CODEC_ON:
+			if (state->codec_primary_speaker !=
+						CPCAP_AUDIO_OUT_NONE)
+				codec_changes.value |= CPCAP_BIT_CDC_EN_RX;
+
+			/* Turning on the input HPF */
+			if (state->microphone != CPCAP_AUDIO_IN_NONE)
+				codec_changes.value |= CPCAP_BIT_AUDIHPF_0 |
+							CPCAP_BIT_AUDIHPF_1;
+
+			if (state->microphone != CPCAP_AUDIO_IN_AUX_INTERNAL &&
+				state->microphone != CPCAP_AUDIO_IN_NONE)
+				codec_changes.value |= CPCAP_BIT_MIC1_CDC_EN;
+
+			if (state->microphone == CPCAP_AUDIO_IN_AUX_INTERNAL ||
+				is_mic_stereo(state->microphone))
+				codec_changes.value |= CPCAP_BIT_MIC2_CDC_EN;
+
+		/* falling through intentionally */
+		case CPCAP_AUDIO_CODEC_CLOCK_ONLY:
+			codec_changes.value |=
+				(codec_freq_config | temp_codec_rate |
+				CPCAP_BIT_DF_RESET);
+			cdai_changes.value |= CPCAP_BIT_CDC_CLK_EN;
+			break;
+
+		case CPCAP_AUDIO_CODEC_OFF:
+			cdai_changes.value |= CPCAP_BIT_SMB_CDC;
+			break;
+
+		default:
+			break;
+		}
+
+		/* Multimedia uses CLK_IN0, incall uses CLK_IN1 */
+		if (state->rat_type != CPCAP_AUDIO_RAT_NONE)
+			cdai_changes.value |= CPCAP_BIT_CLK_IN_SEL;
+
+		/* UMTS sholes uses Network mode - 4 time slots
+		-Codec is Master of Fsync Bclk
+		-CODEC uses DAI0
+		-CODEC PLL to be used */
+		cdai_changes.value |= (CPCAP_BIT_CDC_DIG_AUD_FS0 |
+						CPCAP_BIT_CDC_PLL_SEL);
+
+		if ((state->rat_type == CPCAP_AUDIO_RAT_NONE) &&
+			(state->microphone == CPCAP_AUDIO_IN_AUX_INTERNAL))
+			cdai_changes.value |= CPCAP_BIT_MIC1_RX_TIMESLOT0;
+		else
+			cdai_changes.value |= CPCAP_BIT_MIC2_TIMESLOT0;
+
+		/* OK, now start paranoid codec sequence */
+		/* TODO: optimize - make less paranoid */
+		/* FIRST, make sure the frequency config is right... */
+		logged_cpcap_write(state->cpcap, CPCAP_REG_CC,
+			codec_freq_config, CODEC_FREQ_MASK);
+
+		/* Next, write the CDAI if it's changed */
+		if (prev_cdai_data != cdai_changes.value) {
+			cdai_changes.mask = cdai_changes.value
+				| prev_cdai_data;
+			prev_cdai_data = cdai_changes.value;
+
+			logged_cpcap_write(state->cpcap,
+				CPCAP_REG_CDI, cdai_changes.value,
+				cdai_changes.mask);
+
+			/* Clock tree change -- reset and wait */
+			codec_freq_config |= CPCAP_BIT_CDC_CLOCK_TREE_RESET;
+			logged_cpcap_write(state->cpcap,
+					CPCAP_REG_CC,
+					codec_freq_config,
+					CODEC_RESET_FREQ_MASK);
+
+			/* Wait for clock tree reset to complete */
+			mdelay(CLOCK_TREE_RESET_TIME);
+		}
+
+		/* Clear old settings */
+		codec_changes.mask = codec_changes.value | prev_codec_data;
+		prev_codec_data    = codec_changes.value;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_CC,
+			codec_changes.value, codec_changes.mask);
+	}
+}
+
+static void cpcap_audio_configure_stdac(struct cpcap_audio_state *state,
+				struct cpcap_audio_state *previous_state)
+{
+	const unsigned int SDAC_FREQ_MASK = CPCAP_BIT_ST_DAC_CLK0
+		| CPCAP_BIT_ST_DAC_CLK1 | CPCAP_BIT_ST_DAC_CLK2;
+	const unsigned int SDAC_RESET_FREQ_MASK = SDAC_FREQ_MASK
+		| CPCAP_BIT_ST_CLOCK_TREE_RESET;
+	static unsigned int prev_stdac_data, prev_sdai_data;
+
+	if (is_stdac_changed(state, previous_state)) {
+		unsigned int temp_stdac_rate = state->stdac_rate;
+		struct cpcap_regacc sdai_changes = { 0 };
+		struct cpcap_regacc stdac_changes = { 0 };
+		int stdac_freq_config = 0;
+
+		if (state->rat_type == CPCAP_AUDIO_RAT_CDMA)
+			stdac_freq_config = (CPCAP_BIT_ST_DAC_CLK0
+					| CPCAP_BIT_ST_DAC_CLK1) ; /*19.2Mhz*/
+		else
+			stdac_freq_config = CPCAP_BIT_ST_DAC_CLK2 ; /* 26Mhz */
+
+		/* We need to turn off stdac before changing its settings */
+		if (previous_state->stdac_mode != CPCAP_AUDIO_STDAC_OFF) {
+			stdac_changes.mask = prev_stdac_data |
+					CPCAP_BIT_DF_RESET_ST_DAC |
+					CPCAP_BIT_ST_CLOCK_TREE_RESET;
+
+			logged_cpcap_write(state->cpcap, CPCAP_REG_SDAC,
+				stdac_changes.value, stdac_changes.mask);
+
+			prev_stdac_data = 0;
+			previous_state->stdac_mode = CPCAP_AUDIO_STDAC_OFF;
+		}
+
+		temp_stdac_rate &= 0x0000000F;
+		temp_stdac_rate = temp_stdac_rate << 4;
+
+		switch (state->stdac_mode) {
+		case CPCAP_AUDIO_STDAC_ON:
+			stdac_changes.value |= CPCAP_BIT_ST_DAC_EN;
+			/* falling through intentionally */
+		case CPCAP_AUDIO_STDAC_CLOCK_ONLY:
+			stdac_changes.value |= temp_stdac_rate |
+						 CPCAP_BIT_DF_RESET_ST_DAC |
+						 stdac_freq_config;
+			sdai_changes.value |= CPCAP_BIT_ST_CLK_EN;
+			break;
+
+		case CPCAP_AUDIO_STDAC_OFF:
+		default:
+			break;
+		}
+
+		if (state->rat_type != CPCAP_AUDIO_RAT_NONE)
+			sdai_changes.value |= CPCAP_BIT_ST_DAC_CLK_IN_SEL;
+
+		/* -True I2S mode
+		-STDAC is Master of Fsync Bclk
+		-STDAC uses DAI1
+		*/
+#ifdef AUDIO_I2S_MODE
+		sdai_changes.value |= CPCAP_BIT_DIG_AUD_IN_ST_DAC |
+			CPCAP_BIT_ST_DIG_AUD_FS0 | CPCAP_BIT_ST_DIG_AUD_FS1;
+#else
+		sdai_changes.value |= CPCAP_BIT_ST_DIG_AUD_FS0 |
+			CPCAP_BIT_DIG_AUD_IN_ST_DAC | CPCAP_BIT_ST_L_TIMESLOT0;
+#endif
+		/* OK, now start paranoid stdac sequence */
+		/* TODO: optimize - make less paranoid */
+		/* FIRST, make sure the frequency config is right... */
+		logged_cpcap_write(state->cpcap, CPCAP_REG_SDAC,
+			stdac_freq_config, SDAC_FREQ_MASK);
+
+		/* Next, write the SDACDI if it's changed */
+		if (prev_sdai_data != sdai_changes.value) {
+			sdai_changes.mask = sdai_changes.value
+				| prev_sdai_data;
+			prev_sdai_data = sdai_changes.value;
+
+			logged_cpcap_write(state->cpcap,
+				CPCAP_REG_SDACDI, sdai_changes.value,
+				sdai_changes.mask);
+
+			/* Clock tree change -- reset and wait */
+			stdac_freq_config |= CPCAP_BIT_ST_CLOCK_TREE_RESET;
+			logged_cpcap_write(state->cpcap,
+					CPCAP_REG_SDAC,
+					stdac_freq_config,
+					SDAC_RESET_FREQ_MASK);
+
+			/* Wait for clock tree reset to complete */
+			mdelay(CLOCK_TREE_RESET_TIME);
+		}
+
+		/* Clear old settings */
+		stdac_changes.mask = stdac_changes.value | prev_stdac_data;
+		prev_stdac_data = stdac_changes.value;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_SDAC,
+			stdac_changes.value, stdac_changes.mask);
+	}
+}
+
+static void cpcap_audio_configure_analog_source(
+	struct cpcap_audio_state *state,
+	struct cpcap_audio_state *previous_state)
+{
+	if (state->analog_source != previous_state->analog_source) {
+		struct cpcap_regacc ext_changes = { 0 };
+		static unsigned int prev_ext_data;
+		switch (state->analog_source) {
+		case CPCAP_AUDIO_ANALOG_SOURCE_STEREO:
+			ext_changes.value |= CPCAP_BIT_MONO_EXT0 |
+			CPCAP_BIT_PGA_IN_R_SW | CPCAP_BIT_PGA_IN_L_SW;
+			break;
+		case CPCAP_AUDIO_ANALOG_SOURCE_L:
+			ext_changes.value |= CPCAP_BIT_MONO_EXT1 |
+						CPCAP_BIT_PGA_IN_L_SW;
+			break;
+		case CPCAP_AUDIO_ANALOG_SOURCE_R:
+			ext_changes.value |= CPCAP_BIT_MONO_EXT1 |
+						CPCAP_BIT_PGA_IN_R_SW;
+			break;
+		default:
+			break;
+		}
+
+		ext_changes.mask = ext_changes.value | prev_ext_data;
+
+		prev_ext_data = ext_changes.value;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_RXEPOA,
+				ext_changes.value, ext_changes.mask);
+	}
+}
+static void cpcap_audio_configure_input_gains(
+	struct cpcap_audio_state *state,
+	struct cpcap_audio_state *previous_state)
+{
+	if (state->input_gain != previous_state->input_gain) {
+		struct cpcap_regacc reg_changes = { 0 };
+		unsigned int temp_input_gain = state->input_gain & 0x0000001F;
+
+		reg_changes.value |= ((temp_input_gain << 5) | temp_input_gain);
+
+		reg_changes.mask = 0x3FF;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_TXMP,
+				reg_changes.value, reg_changes.mask);
+	}
+}
+
+/* In case of sholes tablet, FM radio use external pga.
+   FM radio have a different gain table. So we should set gain separately
+*/
+
+#define EXT_PGA_SPEAKER_OUT_GAIN         0x12
+#define EXT_PGA_HEADSET_OUT_GAIN         0x08
+
+
+static void cpcap_audio_configure_output_gains(
+	struct cpcap_audio_state *state,
+	struct cpcap_audio_state *previous_state)
+{
+/*	FM radio volume gain control routine is added by w21558
+*/
+#if 1
+	if (state->output_gain != previous_state->output_gain) {
+		struct cpcap_regacc reg_changes = { 0 };
+		unsigned int temp_output_gain = state->output_gain & 0x0000000F;
+		unsigned int ext_pag_output_gain = EXT_PGA_HEADSET_OUT_GAIN;
+		unsigned short prev_output_gain = 0;
+
+		if (state->output_gain == 0xFF) {
+			/* Only external PGA gain is changed */
+			int ret_val = 0;
+
+			ret_val = cpcap_regacc_read(state->cpcap,
+				CPCAP_REG_RXVC, &prev_output_gain);
+			prev_output_gain = (prev_output_gain & 0x00000F00) >> 8;
+
+			reg_changes.value |=
+			    ((prev_output_gain << 2) | (prev_output_gain << 8) |
+			     (ext_pag_output_gain << 12));
+		} else {
+
+			ext_pag_output_gain = (state->output_gain) ? \
+						EXT_PGA_HEADSET_OUT_GAIN : 0x00;
+
+		reg_changes.value |=
+		    ((temp_output_gain << 2) | (temp_output_gain << 8) |
+		     (ext_pag_output_gain << 12));
+		}
+
+		reg_changes.mask = 0xFF3C;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_RXVC,
+				reg_changes.value, reg_changes.mask);
+	}
+#else
+
+	if (state->output_gain != previous_state->output_gain) {
+		struct cpcap_regacc reg_changes = { 0 };
+		unsigned int temp_output_gain = state->output_gain & 0x0000000F;
+
+		reg_changes.value |=
+		    ((temp_output_gain << 2) | (temp_output_gain << 8) |
+		     (temp_output_gain << 12));
+
+		reg_changes.mask = 0xFF3C;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_RXVC,
+				reg_changes.value, reg_changes.mask);
+	}
+#endif
+}
+
+static void cpcap_audio_configure_output(
+	struct cpcap_audio_state *state,
+	struct cpcap_audio_state *previous_state,
+	bool speaker_off)
+{
+	if (is_output_changed(previous_state, state) ||
+	    is_codec_changed(previous_state, state) ||
+	    is_stdac_changed(previous_state, state)) {
+
+		/* In case of turning on speaker, output amp switches should be
+			configured ahead of amp */
+		if (!speaker_off)
+			cpcap_audio_set_output_amp_switches(state);
+
+		cpcap_audio_set_output_amp(state);
+
+		/* In case of turning off speaker, output amp should be turned
+			off ahead of amp switches */
+		if (speaker_off)
+			cpcap_audio_set_output_amp_switches(state);
+	}
+}
+
+#define CODEC_LOOPBACK_CHANGED() \
+	((state->codec_mode != previous_state->codec_mode) && \
+	 (state->codec_mode == CPCAP_AUDIO_CODEC_LOOPBACK || \
+	  previous_state->codec_mode == CPCAP_AUDIO_CODEC_LOOPBACK))
+
+static void cpcap_audio_configure_input(
+	struct cpcap_audio_state *state,
+	struct cpcap_audio_state *previous_state) {
+	static unsigned int prev_input_data = 0x0;
+	struct cpcap_regacc reg_changes = { 0 };
+
+	if (state->microphone != previous_state->microphone ||
+		CODEC_LOOPBACK_CHANGED()) {
+
+		if (state->codec_mode == CPCAP_AUDIO_CODEC_LOOPBACK)
+			reg_changes.value |= CPCAP_BIT_DLM;
+
+#ifndef CONFIG_MACH_SHOLEST 
+		if (previous_state->microphone
+		    == CPCAP_AUDIO_IN_HEADSET) {
+			logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
+				     0, CPCAP_BIT_GPIO4DRV);
+		}
+#endif
+		switch (state->microphone) {
+		case CPCAP_AUDIO_IN_HANDSET:
+			reg_changes.value |= CPCAP_BIT_MB_ON1R
+				| CPCAP_BIT_MIC1_MUX | CPCAP_BIT_MIC1_PGA_EN;
+			break;
+
+		case CPCAP_AUDIO_IN_HEADSET:
+			reg_changes.value |= CPCAP_BIT_HS_MIC_MUX
+				| CPCAP_BIT_MIC1_PGA_EN;
+#ifndef CONFIG_MACH_SHOLEST
+			logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
+					   CPCAP_BIT_GPIO4DRV,
+					   CPCAP_BIT_GPIO4DRV);
+#endif
+			break;
+
+		case CPCAP_AUDIO_IN_EXT_BUS:
+			reg_changes.value |=  CPCAP_BIT_EMU_MIC_MUX
+				| CPCAP_BIT_MIC1_PGA_EN;
+			break;
+
+		case CPCAP_AUDIO_IN_AUX_INTERNAL:
+			reg_changes.value |= CPCAP_BIT_MB_ON1L
+				| CPCAP_BIT_MIC2_MUX | CPCAP_BIT_MIC2_PGA_EN;
+			break;
+
+		case CPCAP_AUDIO_IN_DUAL_INTERNAL:
+			reg_changes.value |= CPCAP_BIT_MB_ON1R
+				| CPCAP_BIT_MIC1_MUX | CPCAP_BIT_MIC1_PGA_EN
+				| CPCAP_BIT_MB_ON1L | CPCAP_BIT_MIC2_MUX
+				| CPCAP_BIT_MIC2_PGA_EN;
+			break;
+
+		case CPCAP_AUDIO_IN_DUAL_EXTERNAL:
+			reg_changes.value |= CPCAP_BIT_RX_R_ENCODE
+				| CPCAP_BIT_RX_L_ENCODE;
+			break;
+
+		case CPCAP_AUDIO_IN_BT_MONO:
+		default:
+			reg_changes.value = 0;
+			break;
+		}
+
+		reg_changes.mask = reg_changes.value | prev_input_data;
+		prev_input_data = reg_changes.value;
+
+		logged_cpcap_write(state->cpcap, CPCAP_REG_TXI,
+			reg_changes.value, reg_changes.mask);
+	}
+}
+
+static void cpcap_audio_configure_power(int power)
+{
+	static int previous_power = -1;
+
+	CPCAP_AUDIO_DEBUG_LOG("%s() called with power= %d\n", __func__, power);
+
+	if (power != previous_power) {
+
+		if (IS_ERR(audio_reg)) {
+			CPCAP_AUDIO_ERROR_LOG("audio_reg not valid for"
+							"regulator setup\n");
+			return;
+		}
+
+		if (power) {
+			regulator_enable(audio_reg);
+			regulator_set_mode(audio_reg, REGULATOR_MODE_NORMAL);
+		} else {
+			printk(KERN_INFO "turning off regulator\n");
+			regulator_set_mode(audio_reg, REGULATOR_MODE_STANDBY);
+			regulator_disable(audio_reg);
+		}
+
+		previous_power = power;
+
+		if (power)
+			mdelay(SLEEP_ACTIVATE_POWER);
+	}
+}
+
+void cpcap_audio_set_audio_state(struct cpcap_audio_state *state)
+{
+	struct cpcap_audio_state *previous_state = &previous_state_struct;
+	bool is_speaker_off = false;
+
+	if (state->codec_mute == CPCAP_AUDIO_CODEC_BYPASS_LOOP)
+		state->codec_mode = CPCAP_AUDIO_CODEC_ON;
+
+	if (state->codec_mode == CPCAP_AUDIO_CODEC_OFF ||
+	    state->codec_mode == CPCAP_AUDIO_CODEC_CLOCK_ONLY)
+		state->codec_mute = CPCAP_AUDIO_CODEC_MUTE;
+	else
+		state->codec_mute = CPCAP_AUDIO_CODEC_UNMUTE;
+
+	if (state->stdac_mode != CPCAP_AUDIO_STDAC_ON)
+		state->stdac_mute = CPCAP_AUDIO_STDAC_MUTE;
+	else
+		state->stdac_mute = CPCAP_AUDIO_STDAC_UNMUTE;
+
+	if (state->stdac_mode == CPCAP_AUDIO_STDAC_CLOCK_ONLY)
+		state->stdac_mode = CPCAP_AUDIO_STDAC_ON;
+
+	if ((state->codec_mode != CPCAP_AUDIO_CODEC_OFF &&
+	     state->codec_mode != CPCAP_AUDIO_CODEC_CLOCK_ONLY) ||
+	    state->stdac_mode != CPCAP_AUDIO_STDAC_OFF ||
+	    (state->codec_primary_speaker != CPCAP_AUDIO_OUT_NONE &&
+	     state->codec_primary_speaker != CPCAP_AUDIO_OUT_BT_MONO) ||
+	    state->stdac_primary_speaker != CPCAP_AUDIO_OUT_NONE ||
+	    state->ext_primary_speaker != CPCAP_AUDIO_OUT_NONE ||
+	    (state->microphone != CPCAP_AUDIO_IN_NONE &&
+		state->microphone != CPCAP_AUDIO_IN_BT_MONO))
+		cpcap_audio_configure_power(1);
+
+	is_speaker_off = is_speaker_turning_off(state, previous_state);
+	if (is_speaker_off)
+		cpcap_audio_configure_output(state, previous_state,
+						is_speaker_off);
+
+	if (is_codec_changed(state, previous_state)) {
+		int codec_mute = state->codec_mute;
+
+		state->codec_mute = CPCAP_AUDIO_CODEC_MUTE;
+
+		cpcap_audio_configure_aud_mute(state, previous_state);
+
+		previous_state->codec_mute = state->codec_mute;
+
+		state->codec_mute = codec_mute;
+
+		cpcap_audio_configure_codec(state, previous_state);
+	}
+	if (is_stdac_changed(state, previous_state)) {
+		int stdac_mute = state->stdac_mute;
+
+		state->stdac_mute = CPCAP_AUDIO_STDAC_MUTE;
+
+		cpcap_audio_configure_aud_mute(state, previous_state);
+
+		previous_state->stdac_mute = state->stdac_mute;
+
+		state->stdac_mute = stdac_mute;
+
+		cpcap_audio_configure_stdac(state, previous_state);
+	}
+
+
+	cpcap_audio_configure_analog_source(state, previous_state);
+
+	cpcap_audio_configure_input(state, previous_state);
+
+	cpcap_audio_configure_input_gains(state, previous_state);
+
+	cpcap_audio_configure_output(state, previous_state, is_speaker_off);
+
+	cpcap_audio_configure_output_gains(state, previous_state);
+
+	cpcap_audio_configure_aud_mute(state, previous_state);
+
+	if ((state->codec_mode == CPCAP_AUDIO_CODEC_OFF ||
+	     state->codec_mode == CPCAP_AUDIO_CODEC_CLOCK_ONLY) &&
+	    state->stdac_mode == CPCAP_AUDIO_STDAC_OFF &&
+	    (state->codec_primary_speaker == CPCAP_AUDIO_OUT_NONE ||
+	     state->codec_primary_speaker == CPCAP_AUDIO_OUT_BT_MONO) &&
+	    state->stdac_primary_speaker == CPCAP_AUDIO_OUT_NONE &&
+	    state->ext_primary_speaker == CPCAP_AUDIO_OUT_NONE &&
+	    (state->microphone == CPCAP_AUDIO_IN_NONE ||
+		state->microphone == CPCAP_AUDIO_IN_BT_MONO))
+		cpcap_audio_configure_power(0);
+
+	previous_state_struct = *state;
+}
+
+void cpcap_audio_init(struct cpcap_audio_state *state)
+{
+	CPCAP_AUDIO_DEBUG_LOG("%s() called\n", __func__);
+
+	logged_cpcap_write(state->cpcap, CPCAP_REG_CC, 0, 0xFFFF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_CDI, 0, 0xBFFF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_SDAC, 0, 0xFFF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_SDACDI, 0, 0x3FFF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_TXI, 0, 0xFDF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_TXMP, 0, 0xFFF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_RXOA, 0, 0x1FF);
+	/* logged_cpcap_write(state->cpcap, CPCAP_REG_RXVC, 0, 0xFFF); */
+	logged_cpcap_write(state->cpcap, CPCAP_REG_RXCOA, 0, 0x7FF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_RXSDOA, 0, 0x1FFF);
+	logged_cpcap_write(state->cpcap, CPCAP_REG_RXEPOA, 0, 0x7FFF);
+
+	/* Use free running clock for amplifiers */
+	logged_cpcap_write(state->cpcap, CPCAP_REG_A2LA,
+		CPCAP_BIT_A2_FREE_RUN,
+		CPCAP_BIT_A2_FREE_RUN);
+
+	logged_cpcap_write(state->cpcap, CPCAP_REG_GPIO4,
+			   CPCAP_BIT_GPIO4DIR, CPCAP_BIT_GPIO4DIR);
+
+	audio_reg = regulator_get(NULL, "vaudio");
+
+	if (IS_ERR(audio_reg))
+		CPCAP_AUDIO_ERROR_LOG("could not get regulator for audio\n");
+}
diff --git a/sound/oss/moto_audio/cpcap_audio_driver.h b/sound/oss/moto_audio/cpcap_audio_driver.h
new file mode 100644
index 0000000..063f7a6
--- /dev/null
+++ b/sound/oss/moto_audio/cpcap_audio_driver.h
@@ -0,0 +1,219 @@
+ /*
+  * Copyright (C)2007 - 2009 Motorola, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+  * 02111-1307, USA
+  *
+  */
+
+#ifndef CPCAP_AUDIO_DRIVER_H
+#define CPCAP_AUDIO_DRIVER_H
+
+#include <linux/soundcard.h>
+#include <linux/spi/cpcap-regbits.h>
+#include <linux/spi/cpcap.h>
+
+#define AUDIO_I2S_MODE
+
+enum {
+	CPCAP_AUDIO_MODE_NORMAL,	/* mode of normal audio operation */
+	CPCAP_AUDIO_MODE_DAI,	/* CPCAP_AUDIO is configured for DAI testing */
+	CPCAP_AUDIO_MODE_DAI_DOWNLINK = CPCAP_AUDIO_MODE_DAI,
+	CPCAP_AUDIO_MODE_DAI_UPLINK,
+	CPCAP_AUDIO_MODE_TTY	/* CPCAP_AUDIO is configured for TTY */
+};
+
+enum {
+	CPCAP_AUDIO_CODEC_OFF,	/* codec is powered down */
+	CPCAP_AUDIO_CODEC_CLOCK_ONLY, /* codec is powered down, but clocks
+				   * are activated */
+	CPCAP_AUDIO_CODEC_ON,	/* codec is completely operational */
+	CPCAP_AUDIO_CODEC_LOOPBACK	/* xcap is put in full
+				 * (analog->digital->analog) loopback mode */
+};
+
+enum {
+	CPCAP_AUDIO_CODEC_RATE_8000_HZ,
+		/* codec is running at 8Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_11025_HZ,
+		/* codec is running at 11.025Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_12000_HZ,
+		/* codec is running at 12Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_16000_HZ,
+		/* codec is running at 16Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_22050_HZ,
+		/* codec is running at 22.05Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_24000_HZ,
+		/* codec is running at 24Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_32000_HZ,
+		/* codec is running at 32Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_44100_HZ,
+		/* codec is running at 44.1Khz sample rate */
+	CPCAP_AUDIO_CODEC_RATE_48000_HZ,
+		/* codec is running at 48Khz sample rate */
+};
+
+enum {
+	CPCAP_AUDIO_CODEC_UNMUTE,	/* codec is unmuted */
+	CPCAP_AUDIO_CODEC_MUTE,	/* codec is muted */
+	CPCAP_AUDIO_CODEC_BYPASS_LOOP
+				/* codec is bypassed
+				 * (analog-only loopback mode) */
+};
+
+enum {
+	CPCAP_AUDIO_STDAC_OFF,
+		/* stereo dac is powered down */
+	CPCAP_AUDIO_STDAC_CLOCK_ONLY,
+		/* stereo dac is powered down, but clocks are activated */
+	CPCAP_AUDIO_STDAC_ON
+		/* stereo dac is completely operational */
+};
+
+enum {
+		/* THESE MUST CORRESPOND TO XCPCAP_AUDIO SETTINGS */
+	CPCAP_AUDIO_STDAC_RATE_8000_HZ,
+		/* stereo dac set for 8Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_11025_HZ,
+		/* stereo dac set for 11.025Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_12000_HZ,
+		/* stereo dac set for 12Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_16000_HZ,
+		/* stereo dac set for 16Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_22050_HZ,
+		/* stereo dac set for 22.05Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_24000_HZ,
+		/* stereo dac set for 24Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_32000_HZ,
+		/* stereo dac set for 32Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_44100_HZ,
+		/* stereo dac set for 44.1Khz sample rate */
+	CPCAP_AUDIO_STDAC_RATE_48000_HZ
+		/* stereo dac set for 48Khz sample rate */
+};
+
+enum {
+	CPCAP_AUDIO_STDAC_UNMUTE,	/* stereo dac is unmuted */
+	CPCAP_AUDIO_STDAC_MUTE	/* stereo dac is muted */
+};
+
+enum {
+	CPCAP_AUDIO_ANALOG_SOURCE_OFF,
+		/* Analog PGA input is disabled */
+	CPCAP_AUDIO_ANALOG_SOURCE_R,
+		/* Right analog PGA input is enabled */
+	CPCAP_AUDIO_ANALOG_SOURCE_L,
+		/* Left analog PGA input is enabled */
+	CPCAP_AUDIO_ANALOG_SOURCE_STEREO
+		/* Both analog PGA inputs are enabled */
+};
+
+enum {
+	CPCAP_AUDIO_OUT_NONE,
+		/* No audio output selected */
+	CPCAP_AUDIO_OUT_HANDSET = SOUND_MASK_PHONEOUT,
+		/* handset (earpiece) speaker */
+	CPCAP_AUDIO_OUT_LOUDSPEAKER = SOUND_MASK_SPEAKER,
+		/* loudspeaker (speakerphone) */
+	CPCAP_AUDIO_OUT_LINEAR_VIBRATOR,
+		/* linear vibrator, if equipped */
+	CPCAP_AUDIO_OUT_MONO_HEADSET = SOUND_MASK_LINE1,
+		/* mono (R channel) x.5mm headset */
+	CPCAP_AUDIO_OUT_STEREO_HEADSET = SOUND_MASK_RADIO,
+		/* stereo x.5mm headset */
+	CPCAP_AUDIO_OUT_EXT_BUS_MONO = SOUND_MASK_CD,
+		/* accessory bus mono output(EMU) */
+	CPCAP_AUDIO_OUT_EMU_MONO = SOUND_MASK_LINE2,
+	CPCAP_AUDIO_OUT_EXT_BUS_STEREO = SOUND_MASK_LINE3,
+		/* accessory bus stereo output (EMU only) */
+	CPCAP_AUDIO_OUT_EMU_STEREO = SOUND_MASK_LINE3,
+	CPCAP_AUDIO_OUT_LINEOUT = SOUND_MASK_LINE,
+	CPCAP_AUDIO_OUT_BT_MONO = SOUND_MASK_DIGITAL1,
+	CPCAP_AUDIO_OUT_NUM_OF_PATHS
+		/* Max number of audio output paths */
+};
+
+enum {
+	CPCAP_AUDIO_IN_NONE,
+		/* No audio input selected */
+	CPCAP_AUDIO_IN_HANDSET = SOUND_MASK_PHONEIN,
+		/* handset (internal) microphone */
+	CPCAP_AUDIO_IN_AUX_INTERNAL = SOUND_MASK_MIC,
+		/* Auxiliary (second) internal mic */
+	CPCAP_AUDIO_IN_DUAL_INTERNAL = SOUND_MASK_LINE3,
+		/* both internal microphones are connected */
+	CPCAP_AUDIO_IN_HEADSET = SOUND_MASK_LINE1,
+		/* Audio <- x.5mm headset microphone */
+	CPCAP_AUDIO_IN_EXT_BUS = SOUND_MASK_LINE2,
+		/* Audio <- accessory bus analog input (EMU) */
+	CPCAP_AUDIO_IN_EMU = CPCAP_AUDIO_IN_EXT_BUS,
+	CPCAP_AUDIO_IN_HEADSET_BIAS_ONLY = SOUND_MASK_LINE1,
+		/* 3.5mm headset control when no mic is selected */
+	CPCAP_AUDIO_IN_DUAL_EXTERNAL = SOUND_MASK_LINE,
+		/* Recording from external source */
+	CPCAP_AUDIO_IN_BT_MONO = SOUND_MASK_DIGITAL1,
+	CPCAP_AUDIO_IN_NUM_OF_PATHS
+		/* Max number of audio input paths */
+};
+
+enum {
+		/* Defines the audio path type */
+	CPCAP_AUDIO_AUDIO_IN_PATH,
+		/* Audio input path refers to CPCAP_AUDIO_MIC_TYPE */
+	CPCAP_AUDIO_AUDIO_OUT_PATH
+		/* Audio output path refers to CPCAP_AUDIO_SPEAKER_TYPE */
+};
+
+enum {
+	CPCAP_AUDIO_BALANCE_NEUTRAL,/* audio routed normally */
+	CPCAP_AUDIO_BALANCE_R_ONLY,	/* audio routed to left channel only */
+	CPCAP_AUDIO_BALANCE_L_ONLY	/* audio routed to right channel only */
+};
+
+enum {
+	CPCAP_AUDIO_RAT_NONE,	/* Not in a call mode */
+	CPCAP_AUDIO_RAT_UMTS,	/* 3GSM mode */
+	CPCAP_AUDIO_RAT_CDMA	/* In CDMA call mode */
+};
+
+struct cpcap_audio_state {
+	struct cpcap_device *cpcap;
+	int mode;
+	int codec_mode;
+	int codec_rate;
+	int codec_mute;
+	int stdac_mode;
+	int stdac_rate;
+	int stdac_mute;
+	int analog_source;
+	int codec_primary_speaker;
+	int codec_secondary_speaker;
+	int stdac_primary_speaker;
+	int stdac_secondary_speaker;
+	int ext_primary_speaker;
+	int ext_secondary_speaker;
+	int codec_primary_balance;
+	int stdac_primary_balance;
+	int ext_primary_balance;
+	unsigned int output_gain;
+	int microphone;
+	unsigned int input_gain;
+	int rat_type;
+};
+
+void cpcap_audio_set_audio_state(struct cpcap_audio_state *state);
+
+void cpcap_audio_init(struct cpcap_audio_state *state);
+
+#endif /* CPCAP_AUDIO_DRIVER_H */
diff --git a/sound/oss/moto_audio/omap34xx_audio_driver.c b/sound/oss/moto_audio/omap34xx_audio_driver.c
new file mode 100755
index 0000000..938bd79
--- /dev/null
+++ b/sound/oss/moto_audio/omap34xx_audio_driver.c
@@ -0,0 +1,2357 @@
+ /*
+  * Copyright (C)2007 - 2009 Motorola, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2 as
+  * published by the Free Software Foundation.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+  * 02111-1307, USA
+  *
+  */
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/sound.h>
+#include <linux/poll.h>
+
+#ifdef CONFIG_WAKELOCK
+#include <linux/wakelock.h>
+#endif
+
+#include <mach/mux.h>
+#include <mach/control.h>
+#include "omap34xx_audio_driver.h"
+#include "cpcap_audio_driver.h"
+
+#define AUDIO_DRIVER_NAME "cpcap_audio"
+#define CONFIG_USE_MCBSP_FIFO
+
+#define STDAC_SSI OMAP_MCBSP2
+#define CODEC_SSI OMAP_MCBSP3
+
+#define CODEC_FIFO_SIZE 256
+#define STDAC_FIFO_SIZE 8192
+#define AUDIO_CAPTURE_SIZE 800
+
+#define OMAP2_CONTROL_DEVCONF0_BIT6 6
+
+/* This is the number of total kernel buffers */
+#define AUDIO_NBFRAGS_WRITE 2
+#define AUDIO_NBFRAGS_READ 15
+
+#define AUDIO_TIMEOUT HZ
+
+#define NUMBER_OF_RATES_SUPPORTED (sizeof(valid_sample_rates)/\
+				   sizeof(struct sample_rate_info_t))
+
+/* Log level standard used here:
+ * Log level 3 all messages
+ * Log level 2 all entry-exit points
+ * Log level 1 major messages
+ * Log level 0 no messages
+ */
+#define AUDIO_LOG_LEVEL 1
+
+#define AUDIO_DEBUG_LOG(args...)  printk(KERN_INFO "AUDIO_DRIVER:" args)
+
+#if (AUDIO_LOG_LEVEL >= 1)
+#define AUDIO_LEVEL1_LOG(args...)  AUDIO_DEBUG_LOG(args)
+#else
+#define AUDIO_LEVEL1_LOG(args...)
+#endif
+
+#if (AUDIO_LOG_LEVEL >= 2)
+#define AUDIO_LEVEL2_LOG(args...)  AUDIO_DEBUG_LOG(args)
+#else
+#define AUDIO_LEVEL2_LOG(args...)
+#endif
+
+#if (AUDIO_LOG_LEVEL >= 3)
+#define AUDIO_LEVEL3_LOG(args...)  AUDIO_DEBUG_LOG(args)
+#else
+#define AUDIO_LEVEL3_LOG(args...)
+#endif
+
+#define AUDIO_ERROR_LOG(args...)  printk(KERN_ERR "AUDIO_DRIVER: Error " args)
+
+#define TRY(a)  if (unlikely(a)) goto out;
+DEFINE_MUTEX(audio_lock); /* global audio lock */
+
+struct audio_buf {
+	int offset;		/* current offset */
+	char *data;		/* points to actual buffer */
+	dma_addr_t buf_addr;	/* physical buffer address */
+	int buf_ref;		/* DMA refcount - we do not know
+				 * how many buffers can s/w take. */
+	int master;		/* owner for buffer allocation,
+				 * contain size when true */
+};
+
+/* Structure describing the data stream related information */
+struct audio_stream {
+	char *id;		/* identification string */
+	struct audio_buf *buffers;
+	/* pointer to audio buffer structures */
+	u32 usr_head;		/* user side fragment index i.e.
+				 * where app is reading/writing to */
+	u32 buf_head;		/* BUF fragment index to go */
+	u32 buf_tail;		/* BUF fragment index to complete */
+	u32 fragsize;		/* fragment i.e. buffer size */
+	u32 nbfrags;		/* nbr of fragments i.e. buffers */
+	u32 pending_frags;	/* Fragments sent to BUF */
+	u8 in_use;		/* Is this is use? */
+	int *lch;		/* Chain of channels this stream is
+				 * linked to */
+	int input_output;	/* Direction of this data stream */
+	int bytecount;		/* nbr of processed bytes */
+	int fragcount;		/* nbr of fragment transitions */
+	struct semaphore sem;	/* account for fragment usage */
+	wait_queue_head_t wq;	/* for poll */
+	int mapped:1;		/* mmap()'ed buffers */
+	int active:1;		/* actually in progress */
+	int stopped:1;		/* might be active but stopped */
+	struct inode *inode;
+};
+
+static int audio_stdac_open(struct inode *, struct file *);
+static int audio_stdac_release(struct inode *, struct file *);
+static int audio_ioctl(struct inode *, struct file *file, unsigned int cmd,
+			unsigned long arg);
+static ssize_t audio_write(struct file *fp, const char *buf, size_t bytes,
+			loff_t *nouse);
+static int audio_codec_open(struct inode *, struct file *);
+static int audio_codec_release(struct inode *, struct file *);
+static ssize_t audio_codec_read(struct file *fp, char *buf, size_t bytes,
+				loff_t *nouse);
+static int audio_mixer_open(struct inode *, struct file *);
+static int audio_mixer_close(struct inode *, struct file *);
+static int audio_probe(struct platform_device *dev);
+static int audio_remove(struct platform_device *dev);
+static void mcbsp_dma_tx_cb(u32 ch_status, void *arg);
+static void mcbsp_dma_rx_cb(u32 ch_status, void *arg);
+static int audio_stop_ssi(struct inode *inode, struct file *file);
+static int audio_configure_ssi(struct inode *inode, struct file *file);
+static void audio_discard_buf(struct audio_stream *str, struct inode *inode);
+static void audio_buffer_reset(struct audio_stream *str, struct inode *inode);
+static int audio_process_buf(struct audio_stream *str, struct inode *inode);
+static int audio_setup_buf(struct audio_stream *str, struct inode *inode);
+
+/* File Ops structure */
+static const struct file_operations audio_stdac_fops = {
+	.owner = THIS_MODULE,
+	.open = audio_stdac_open,
+	.release = audio_stdac_release,
+	.ioctl = audio_ioctl,
+	.write = audio_write,
+};
+
+static const struct file_operations codec_fops = {
+	.owner = THIS_MODULE,
+	.open = audio_codec_open,
+	.release = audio_codec_release,
+	.ioctl = audio_ioctl,
+	.write = audio_write,
+	.read = audio_codec_read,
+};
+
+static const struct file_operations mixer_fops = {
+	.owner = THIS_MODULE,
+	.open = audio_mixer_open,
+	.release = audio_mixer_close,
+	.ioctl = audio_ioctl,
+};
+
+/* Driver information structure*/
+static struct platform_driver audio_driver = {
+	.probe = audio_probe,
+	.remove = audio_remove,
+	.driver = {
+		   .name = AUDIO_DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		},
+};
+
+static struct omap_mcbsp_dma_transfer_params tx_params = {
+	.skip_alt = OMAP_MCBSP_SKIP_NONE,
+	.auto_reset = OMAP_MCBSP_AUTO_XRST,
+	.callback = mcbsp_dma_tx_cb,
+	.word_length1 = OMAP_MCBSP_WORD_16,
+};
+
+static struct omap_mcbsp_dma_transfer_params rx_params = {
+	.skip_alt = OMAP_MCBSP_SKIP_NONE,
+	.auto_reset = OMAP_MCBSP_AUTO_RRST,
+	.callback = mcbsp_dma_rx_cb,
+	.word_length1 = OMAP_MCBSP_WORD_16,
+};
+
+static struct omap_mcbsp_cfg_param tx_cfg_params = {
+	.fsync_src = OMAP_MCBSP_TXFSYNC_EXTERNAL,
+	.fs_polarity = OMAP_MCBSP_FS_ACTIVE_HIGH,
+	.clk_polarity = OMAP_MCBSP_CLKX_POLARITY_RISING,
+	.clk_mode = OMAP_MCBSP_CLKTXSRC_EXTERNAL,
+	.frame_length1 = OMAP_MCBSP_FRAMELEN_N(1),
+	.word_length1 = OMAP_MCBSP_WORD_16,
+	.justification = OMAP_MCBSP_RJUST_ZEROMSB,
+	.reverse_compand = OMAP_MCBSP_MSBFIRST,
+	.phase = OMAP_MCBSP_FRAME_SINGLEPHASE,
+	.data_delay = OMAP_MCBSP_DATADELAY1,
+};
+
+static struct omap_mcbsp_cfg_param rx_cfg_params = {
+	.fsync_src = OMAP_MCBSP_RXFSYNC_EXTERNAL,
+	.fs_polarity = OMAP_MCBSP_FS_ACTIVE_HIGH,
+	.clk_polarity = OMAP_MCBSP_CLKR_POLARITY_RISING,
+	.clk_mode = OMAP_MCBSP_CLKRXSRC_EXTERNAL,
+	.frame_length1 = OMAP_MCBSP_FRAMELEN_N(1),
+	.word_length1 = OMAP_MCBSP_WORD_16,
+	.justification = OMAP_MCBSP_RJUST_ZEROMSB,
+	.reverse_compand = OMAP_MCBSP_MSBFIRST,
+	.phase = OMAP_MCBSP_FRAME_SINGLEPHASE,
+	.data_delay = OMAP_MCBSP_DATADELAY1,
+};
+
+static struct omap_mcbsp_srg_fsg_cfg srg_fsg_params = {
+	.period = 0, /* Frame period */
+	.pulse_width = 0, /* Frame width */
+	.fsgm = 0,
+	.sample_rate = 0,
+	.bits_per_sample = 16,
+	.srg_src = OMAP_MCBSP_SRGCLKSRC_CLKX,
+	.sync_mode = OMAP_MCBSP_SRG_FREERUNNING, /* SRG free running mode */
+	.polarity = OMAP_MCBSP_CLKX_POLARITY_RISING,
+	.dlb = 0, /* digital loopback mode */
+};
+
+struct sample_rate_info_t {
+	u16 rate;
+	int cpcap_audio_rate;
+};
+
+static struct {
+	int dev_dsp;
+	int dev_dsp1;
+	int dev_mixer;
+	int dev_dsp_open_count;
+	int dev_dsp1_open_count;
+	int dev_mixer_open_count;
+	struct audio_stream *stdac_out_stream;
+	struct audio_stream *stdac_in_stream;
+	struct audio_stream *codec_out_stream;
+	struct audio_stream *codec_in_stream;
+} state;
+
+struct cpcap_audio_state cpcap_audio_state = {
+	NULL,
+	CPCAP_AUDIO_MODE_NORMAL,
+	CPCAP_AUDIO_CODEC_OFF,
+	CPCAP_AUDIO_CODEC_RATE_8000_HZ,
+	CPCAP_AUDIO_CODEC_MUTE,
+	CPCAP_AUDIO_STDAC_OFF,
+	CPCAP_AUDIO_STDAC_RATE_44100_HZ,
+	CPCAP_AUDIO_STDAC_MUTE,
+	CPCAP_AUDIO_ANALOG_SOURCE_OFF,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_LOUDSPEAKER,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_OUT_NONE,
+	CPCAP_AUDIO_BALANCE_NEUTRAL,
+	CPCAP_AUDIO_BALANCE_NEUTRAL,
+	CPCAP_AUDIO_BALANCE_NEUTRAL,
+	7,			/*default output gain */
+	CPCAP_AUDIO_IN_NONE,
+	31,			/*default input_gain */
+	CPCAP_AUDIO_RAT_NONE
+};
+
+static const struct sample_rate_info_t valid_sample_rates[] = {
+	{.rate = 8000,  .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_8000_HZ},
+	{.rate = 11025, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_11025_HZ},
+	{.rate = 12000, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_12000_HZ},
+	{.rate = 16000, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_16000_HZ},
+	{.rate = 22050, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_22050_HZ},
+	{.rate = 24000, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_24000_HZ},
+	{.rate = 32000, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_32000_HZ},
+	{.rate = 44100, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_44100_HZ},
+	{.rate = 48000, .cpcap_audio_rate = CPCAP_AUDIO_STDAC_RATE_48000_HZ},
+};
+
+static int read_buf_full;
+static int primary_spkr_setting = CPCAP_AUDIO_OUT_NONE;
+static int secondary_spkr_setting = CPCAP_AUDIO_OUT_NONE;
+static int mic_setting = CPCAP_AUDIO_IN_NONE;
+static unsigned int capture_mode;
+static u8 enable_tx;
+static struct omap_mcbsp_wrapper *mcbsp_wrapper;
+static DEFINE_SPINLOCK(audio_write_lock);
+#ifdef CONFIG_WAKELOCK
+static struct wake_lock mcbsp_wakelock;
+#endif
+
+#ifdef MCBSP_WRAPPER
+
+static void omap2_mcbsp_rx_dma_callback(int lch, unsigned short ch_status,
+					void *data)
+{
+	struct omap_mcbsp *mcbsp_dma_rx = data;
+	void __iomem *io_base;
+	int id;
+
+	for (id = 0; id < omap_mcbsp_count; id++) {
+		if (data == mcbsp_ptr[id])
+			break;
+	}
+	if (id == omap_mcbsp_count) {
+		printk(KERN_INFO "No matching McBSP id for rx\n");
+		return;
+	}
+	io_base = mcbsp_dma_rx->io_base;
+
+	/* If we are at the last transfer, Shut down the reciever */
+	if ((mcbsp_wrapper[id].auto_reset & OMAP_MCBSP_AUTO_RRST)
+	    && (omap_dma_chain_status(mcbsp_dma_rx->dma_rx_lch) ==
+		OMAP_DMA_CHAIN_INACTIVE))
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR1,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR1) &
+				 (~RRST));
+
+	if (mcbsp_wrapper[id].rx_callback != NULL)
+		mcbsp_wrapper[id].rx_callback(ch_status,
+					      mcbsp_wrapper[id].rx_cb_arg);
+}
+
+static void omap2_mcbsp_tx_dma_callback(int lch, u16 ch_status, void *data)
+{
+	struct omap_mcbsp *mcbsp_dma_tx = data;
+	void __iomem *io_base;
+	int id;
+
+	for (id = 0; id < omap_mcbsp_count; id++) {
+		if (data == mcbsp_ptr[id])
+			break;
+	}
+	if (id == omap_mcbsp_count) {
+		printk(KERN_INFO "No matching McBSP id for rx\n");
+		return;
+	}
+	io_base = mcbsp_dma_tx->io_base;
+
+	if (mcbsp_wrapper[id].tx_callback != NULL)
+		mcbsp_wrapper[id].tx_callback(ch_status,
+					      mcbsp_wrapper[id].tx_cb_arg);
+}
+
+static void omap2_mcbsp_set_recv_param(unsigned int id,
+				       struct omap_mcbsp_reg_cfg *mcbsp_cfg,
+				       struct omap_mcbsp_cfg_param *rp)
+{
+	mcbsp_cfg->spcr1 = RJUST(rp->justification);
+	mcbsp_cfg->rcr2 = RCOMPAND(rp->reverse_compand) |
+	    RDATDLY(rp->data_delay);
+	if (rp->phase == OMAP_MCBSP_FRAME_SINGLEPHASE)
+		mcbsp_cfg->rcr2 = mcbsp_cfg->rcr2 & ~(RPHASE);
+	else
+		mcbsp_cfg->rcr2 = mcbsp_cfg->rcr2 | (RPHASE) |
+		    RWDLEN2(rp->word_length2) | RFRLEN2(rp->frame_length2);
+	mcbsp_cfg->rcr1 = RWDLEN1(rp->word_length1) |
+	    RFRLEN1(rp->frame_length1);
+	if (rp->fsync_src == OMAP_MCBSP_RXFSYNC_INTERNAL)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | FSRM;
+	if (rp->clk_mode == OMAP_MCBSP_CLKRXSRC_INTERNAL)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | CLKRM;
+	if (rp->clk_polarity == OMAP_MCBSP_CLKR_POLARITY_RISING)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | CLKRP;
+	if (rp->fs_polarity == OMAP_MCBSP_FS_ACTIVE_LOW)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | FSRP;
+
+#ifdef CONFIG_USE_MCBSP_FIFO
+	mcbsp_cfg->wken = mcbsp_cfg->wken | RRDYEN;
+#endif
+	return;
+}
+
+static void omap2_mcbsp_set_trans_param(unsigned int id,
+					struct omap_mcbsp_reg_cfg *mcbsp_cfg,
+					struct omap_mcbsp_cfg_param *tp)
+{
+	mcbsp_cfg->xcr2 = XCOMPAND(tp->reverse_compand) |
+	    XDATDLY(tp->data_delay);
+	if (tp->phase == OMAP_MCBSP_FRAME_SINGLEPHASE)
+		mcbsp_cfg->xcr2 = mcbsp_cfg->xcr2 & ~(XPHASE);
+	else
+		mcbsp_cfg->xcr2 = mcbsp_cfg->xcr2 | (XPHASE) |
+		    RWDLEN2(tp->word_length2) | RFRLEN2(tp->frame_length2);
+	mcbsp_cfg->xcr1 = XWDLEN1(tp->word_length1) |
+	    XFRLEN1(tp->frame_length1);
+	if (tp->fs_polarity == OMAP_MCBSP_FS_ACTIVE_LOW)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | FSXP;
+	if (tp->fsync_src == OMAP_MCBSP_TXFSYNC_INTERNAL)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | FSXM;
+	if (tp->clk_mode == OMAP_MCBSP_CLKTXSRC_INTERNAL)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | CLKXM;
+	if (tp->clk_polarity == OMAP_MCBSP_CLKX_POLARITY_FALLING)
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | CLKXP;
+	return;
+}
+
+static void omap2_mcbsp_set_srg_cfg_param(unsigned int id, int interface_mode,
+					  struct omap_mcbsp_reg_cfg *mcbsp_cfg,
+					  struct omap_mcbsp_srg_fsg_cfg *param)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+	u32 clk_rate, clkgdv;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	mcbsp_wrapper[id].interface_mode = interface_mode;
+	mcbsp_cfg->srgr1 = FWID(param->pulse_width);
+
+	if (interface_mode == OMAP_MCBSP_MASTER) {
+		/* clk_rate = clk_get_rate(omap_mcbsp_clk[id].fck); */
+		clk_rate = 96000000;
+		clkgdv = clk_rate / (param->sample_rate *
+				     (param->bits_per_sample - 1));
+		mcbsp_cfg->srgr1 = mcbsp_cfg->srgr1 | CLKGDV(clkgdv);
+	}
+	if (param->dlb)
+		mcbsp_cfg->spcr1 = mcbsp_cfg->spcr1 & ~(ALB);
+
+	if (param->sync_mode == OMAP_MCBSP_SRG_FREERUNNING)
+		mcbsp_cfg->spcr2 = mcbsp_cfg->spcr2 | FREE;
+	mcbsp_cfg->srgr2 = FPER(param->period) | (param->fsgm ? FSGM : 0);
+
+	switch (param->srg_src) {
+
+	case OMAP_MCBSP_SRGCLKSRC_CLKS:
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 & ~(SCLKME);
+		mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 & ~(CLKSM);
+		/*
+		 * McBSP master operation at low voltage is only possible if
+		 * CLKSP=0 In Master mode, if client driver tries to configiure
+		 * input clock polarity as falling edge, we force it to Rising
+		 */
+
+		if ((param->polarity == OMAP_MCBSP_CLKS_POLARITY_RISING) ||
+		    (interface_mode == OMAP_MCBSP_MASTER))
+			mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 & ~(CLKSP);
+		else
+			mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 | (CLKSP);
+		break;
+
+	case OMAP_MCBSP_SRGCLKSRC_FCLK:
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 & ~(SCLKME);
+		mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 | (CLKSM);
+
+		break;
+
+	case OMAP_MCBSP_SRGCLKSRC_CLKR:
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | (SCLKME);
+		mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 & ~(CLKSM);
+		if (param->polarity == OMAP_MCBSP_CLKR_POLARITY_FALLING)
+			mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 & ~(CLKRP);
+		else
+			mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | (CLKRP);
+
+		break;
+
+	case OMAP_MCBSP_SRGCLKSRC_CLKX:
+		mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | (SCLKME);
+		mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 | (CLKSM);
+
+		if (param->polarity == OMAP_MCBSP_CLKX_POLARITY_RISING)
+			mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 & ~(CLKXP);
+		else
+			mcbsp_cfg->pcr0 = mcbsp_cfg->pcr0 | (CLKXP);
+		break;
+
+	}
+	if (param->sync_mode == OMAP_MCBSP_SRG_FREERUNNING)
+		mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 & ~(GSYNC);
+	else if (param->sync_mode == OMAP_MCBSP_SRG_RUNNING)
+		mcbsp_cfg->srgr2 = mcbsp_cfg->srgr2 | (GSYNC);
+
+	mcbsp_cfg->xccr = omap_mcbsp_read(io_base, OMAP_MCBSP_REG_XCCR);
+	if (param->dlb)
+		mcbsp_cfg->xccr = mcbsp_cfg->xccr | (DILB);
+	mcbsp_cfg->rccr = omap_mcbsp_read(io_base, OMAP_MCBSP_REG_RCCR);
+
+	return;
+}
+
+static void mcbsp_power_settings(unsigned int id, int level)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	if (level == MCBSP2_SYSCONFIG_LVL1)
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SYSCON,
+				 CLOCKACTIVITY(MCBSP_SYSC_IOFF_FON) |
+				 SIDLEMODE(SMART_IDLE) | ENAWAKEUP);
+
+	if (level == MCBSP2_SYSCONFIG_LVL2)
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SYSCON,
+				 CLOCKACTIVITY(MCBSP_SYSC_IOFF_FOFF) |
+				 SIDLEMODE(FORCE_IDLE));
+}
+
+void omap2_mcbsp_set_srg_fsg(unsigned int id, unsigned char state)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	if (state == OMAP_MCBSP_DISABLE_FSG_SRG) {
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR2) &
+				 (~GRST));
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR2) &
+				 (~FRST));
+	} else {
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR2) | GRST);
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR2) | FRST);
+	}
+	return;
+}
+
+int omap2_mcbsp_stop_datatx(unsigned int id)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	if (mcbsp->dma_tx_lch != -1) {
+		if (omap_stop_dma_chain_transfers(mcbsp->dma_tx_lch) != 0)
+			return -EINVAL;
+	}
+	mcbsp_wrapper[id].tx_dma_chain_state = 0;
+	omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+			 omap_mcbsp_read(io_base,
+					 OMAP_MCBSP_REG_SPCR2) & (~XRST));
+
+	if (!mcbsp_wrapper[id].rx_dma_chain_state)
+		omap2_mcbsp_set_srg_fsg(id, OMAP_MCBSP_DISABLE_FSG_SRG);
+
+	return 0;
+}
+
+int omap2_mcbsp_stop_datarx(u32 id)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	if (mcbsp->dma_rx_lch != -1) {
+		if (omap_stop_dma_chain_transfers(mcbsp->dma_rx_lch) != 0)
+			return -EINVAL;
+	}
+	omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR1,
+			 omap_mcbsp_read(io_base,
+					 OMAP_MCBSP_REG_SPCR1) & (~RRST));
+
+	mcbsp_wrapper[id].rx_dma_chain_state = 0;
+	if (!mcbsp_wrapper[id].tx_dma_chain_state)
+		omap2_mcbsp_set_srg_fsg(id, OMAP_MCBSP_DISABLE_FSG_SRG);
+
+	return 0;
+}
+
+int omap2_mcbsp_reset(unsigned int id)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+	int counter = 0;
+	int wait_for_reset = 10000;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SYSCON,
+			 omap_mcbsp_read(io_base,
+					 OMAP_MCBSP_REG_SYSCON) | (SOFTRST));
+
+	while (omap_mcbsp_read(io_base, OMAP_MCBSP_REG_SYSCON) & SOFTRST) {
+		if (!in_interrupt()) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(10);
+		}
+		if (counter++ > wait_for_reset) {
+			printk(KERN_ERR "mcbsp[%d] Reset timeout\n", id);
+			return -ETIMEDOUT;
+		}
+	}
+	mcbsp_power_settings(id, MCBSP2_SYSCONFIG_LVL1);
+	omap_mcbsp_write(io_base, OMAP_MCBSP_REG_WKUPEN, 0xFFFF);
+	return 0;
+}
+
+int omap2_mcbsp_set_xrst(unsigned int id, unsigned char state)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	if (state == OMAP_MCBSP_XRST_DISABLE)
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR2) &
+				 (~XRST));
+	else
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR2) | XRST);
+	udelay(10);
+
+	return 0;
+}
+
+int omap2_mcbsp_set_rrst(unsigned int id, unsigned char state)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+
+	if (state == OMAP_MCBSP_RRST_DISABLE)
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR1,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR1) &
+				 (~RRST));
+	else
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR1,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR1) | RRST);
+	udelay(10);
+	return 0;
+}
+
+int omap2_mcbsp_dma_recv_params(unsigned int id,
+				struct omap_mcbsp_dma_transfer_params *rp)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+	int err, chain_id = -1;
+	struct omap_dma_channel_params rx_params;
+	u32 dt = 0;
+#ifdef CONFIG_USE_MCBSP_FIFO
+	u32 mcbsp_fifo_size;
+#endif
+
+#ifdef CONFIG_USE_MCBSP_FIFO
+	if (id == OMAP_MCBSP2)
+		mcbsp_fifo_size = MCBSP2_FIFO_SIZE;
+	else
+		mcbsp_fifo_size = MCBSP_FIFO_SIZE;
+#endif
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+	dt = rp->word_length1;
+
+	if (dt == OMAP_MCBSP_WORD_8)
+		rx_params.data_type = OMAP_DMA_DATA_TYPE_S8;
+	else if (dt == OMAP_MCBSP_WORD_16)
+		rx_params.data_type = OMAP_DMA_DATA_TYPE_S16;
+	else if (dt == OMAP_MCBSP_WORD_32)
+		rx_params.data_type = OMAP_DMA_DATA_TYPE_S32;
+	else
+		return -EINVAL;
+
+	rx_params.read_prio = DMA_CH_PRIO_HIGH;
+	rx_params.write_prio = DMA_CH_PRIO_HIGH;
+/* If McBSP FIFO is used, do a packet sync DMA */
+#ifdef CONFIG_USE_MCBSP_FIFO
+	mcbsp_wrapper[id].rx_config_done = 0;
+	rx_params.sync_mode = OMAP_DMA_SYNC_PACKET;
+	rx_params.src_fi = mcbsp_fifo_size;
+#else
+	rx_params.sync_mode = OMAP_DMA_SYNC_ELEMENT;
+	rx_params.src_fi = 0;
+#endif
+	rx_params.trigger = mcbsp->dma_rx_sync;
+	rx_params.src_or_dst_synch = 0x01;
+	rx_params.src_amode = OMAP_DMA_AMODE_CONSTANT;
+	rx_params.src_ei = 0x0;
+	/* Indexing is always in bytes - so multiply with dt */
+
+	dt = (rx_params.data_type == OMAP_DMA_DATA_TYPE_S8) ? 1 :
+	    (rx_params.data_type == OMAP_DMA_DATA_TYPE_S16) ? 2 : 4;
+
+	/* SKIP_FIRST and sKIP_SECOND- 24 bit data in stereo mode */
+	if (rp->skip_alt == OMAP_MCBSP_SKIP_SECOND) {
+		rx_params.dst_amode = OMAP_DMA_AMODE_DOUBLE_IDX;
+		rx_params.dst_ei = (1);
+		rx_params.dst_fi = (1) + ((-1) * dt);
+	} else if (rp->skip_alt == OMAP_MCBSP_SKIP_FIRST) {
+		rx_params.dst_amode = OMAP_DMA_AMODE_DOUBLE_IDX;
+		rx_params.dst_ei = 1 + (-2) * dt;
+		rx_params.dst_fi = 1 + (2) * dt;
+	} else {
+		rx_params.dst_amode = OMAP_DMA_AMODE_POST_INC;
+		rx_params.dst_ei = 0;
+		rx_params.dst_fi = 0;
+	}
+
+	mcbsp_wrapper[id].rxskip_alt = rp->skip_alt;
+	mcbsp_wrapper[id].auto_reset &= ~OMAP_MCBSP_AUTO_RRST;
+	mcbsp_wrapper[id].auto_reset |= (rp->auto_reset & OMAP_MCBSP_AUTO_RRST);
+
+	mcbsp->rx_word_length = rx_params.data_type << 0x1;
+	if (rx_params.data_type == 0)
+		mcbsp->rx_word_length = 1;
+
+	mcbsp_wrapper[id].rx_callback = rp->callback;
+	mcbsp_wrapper[id].rx_params = rx_params;
+	/* request for a chain of dma channels for data reception */
+	if (mcbsp->dma_rx_lch == -1) {
+		err = omap_request_dma_chain(id, "McBSP RX",
+					     omap2_mcbsp_rx_dma_callback,
+					     &chain_id, 2,
+					     OMAP_DMA_DYNAMIC_CHAIN, rx_params);
+		if (err < 0) {
+			printk(KERN_ERR "Receive path configuration failed \n");
+			return -EINVAL;
+		}
+		mcbsp->dma_rx_lch = chain_id;
+		mcbsp_wrapper[id].rx_dma_chain_state = 0;
+	} else {
+		/* DMA params already set, modify the same!! */
+		err = omap_modify_dma_chain_params(mcbsp->dma_rx_lch,
+						   rx_params);
+		if (err < 0)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+int omap2_mcbsp_dma_trans_params(unsigned int id,
+				 struct omap_mcbsp_dma_transfer_params *tp)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+	struct omap_dma_channel_params tx_params;
+	int err = 0, chain_id = -1;
+	u32 dt = 0;
+#ifdef CONFIG_USE_MCBSP_FIFO
+	u32 mcbsp_fifo_size;
+#endif
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+#ifdef CONFIG_USE_MCBSP_FIFO
+	if (id == OMAP_MCBSP2)
+		mcbsp_fifo_size = MCBSP2_FIFO_SIZE;
+	else
+		mcbsp_fifo_size = MCBSP_FIFO_SIZE;
+#endif
+
+	dt = tp->word_length1;
+	if ((dt != OMAP_MCBSP_WORD_8) && (dt != OMAP_MCBSP_WORD_16)
+	    && (dt != OMAP_MCBSP_WORD_32))
+		return -EINVAL;
+	if (dt == OMAP_MCBSP_WORD_8)
+		tx_params.data_type = OMAP_DMA_DATA_TYPE_S8;
+	else if (dt == OMAP_MCBSP_WORD_16)
+		tx_params.data_type = OMAP_DMA_DATA_TYPE_S16;
+	else if (dt == OMAP_MCBSP_WORD_32)
+		tx_params.data_type = OMAP_DMA_DATA_TYPE_S32;
+	else
+		return -EINVAL;
+
+	tx_params.read_prio = DMA_CH_PRIO_HIGH;
+	tx_params.write_prio = DMA_CH_PRIO_HIGH;
+/* IF McBSP FIFO is used, use packet sync DMA*/
+#ifdef CONFIG_USE_MCBSP_FIFO
+	tx_params.sync_mode = OMAP_DMA_SYNC_PACKET;
+	tx_params.dst_fi = mcbsp_fifo_size;
+#else
+	tx_params.sync_mode = OMAP_DMA_SYNC_ELEMENT;
+	tx_params.dst_fi = 0;
+#endif
+	tx_params.trigger = mcbsp->dma_tx_sync;
+	tx_params.src_or_dst_synch = 0;
+	/* Indexing is always in bytes - so multiply with dt */
+	mcbsp->tx_word_length = tx_params.data_type << 0x1;
+
+	if (tx_params.data_type == 0)
+		mcbsp->tx_word_length = 1;
+	dt = mcbsp->tx_word_length;
+
+	/* SKIP_FIRST and sKIP_SECOND- 24 bit data in stereo mode */
+	if (tp->skip_alt == OMAP_MCBSP_SKIP_SECOND) {
+		tx_params.src_amode = OMAP_DMA_AMODE_DOUBLE_IDX;
+		tx_params.src_ei = (1);
+		tx_params.src_fi = (1) + ((-1) * dt);
+	} else if (tp->skip_alt == OMAP_MCBSP_SKIP_FIRST) {
+		tx_params.src_amode = OMAP_DMA_AMODE_DOUBLE_IDX;
+		tx_params.src_ei = 1 + (-2) * dt;
+		tx_params.src_fi = 1 + (2) * dt;
+	} else {
+		tx_params.src_amode = OMAP_DMA_AMODE_POST_INC;
+		tx_params.src_ei = 0;
+		tx_params.src_fi = 0;
+	}
+
+	tx_params.dst_amode = OMAP_DMA_AMODE_CONSTANT;
+	tx_params.dst_ei = 0;
+	mcbsp_wrapper[id].txskip_alt = tp->skip_alt;
+	mcbsp_wrapper[id].auto_reset &= ~OMAP_MCBSP_AUTO_XRST;
+	mcbsp_wrapper[id].auto_reset |= (tp->auto_reset & OMAP_MCBSP_AUTO_XRST);
+	mcbsp_wrapper[id].tx_callback = tp->callback;
+
+	/* Based on Rjust we can do double indexing DMA params configuration */
+	if (mcbsp->dma_tx_lch == -1) {
+		err = omap_request_dma_chain(id, "McBSP TX",
+					     omap2_mcbsp_tx_dma_callback,
+					     &chain_id, 2,
+					     OMAP_DMA_DYNAMIC_CHAIN, tx_params);
+		if (err < 0) {
+			printk(KERN_ERR
+			       "Transmit path configuration failed \n");
+			return -EINVAL;
+		}
+		mcbsp_wrapper[id].tx_dma_chain_state = 0;
+		mcbsp->dma_tx_lch = chain_id;
+	} else {
+		/* DMA params already set, modify the same!! */
+		err = omap_modify_dma_chain_params(mcbsp->dma_tx_lch,
+						   tx_params);
+		if (err < 0)
+			return -EINVAL;
+	}
+#ifdef CONFIG_USE_MCBSP_FIFO
+	omap_mcbsp_write(io_base, OMAP_MCBSP_REG_THRSH2, (mcbsp_fifo_size - 1));
+	omap_mcbsp_write(io_base, OMAP_MCBSP_REG_WKUPEN, MCBSP_WKUP_XRDYEN);
+#endif
+
+	return 0;
+}
+
+int omap2_mcbsp_receive_data(unsigned int id, void *cbdata,
+			     dma_addr_t buf_start_addr, u32 buf_size)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+	int enable_rx = 0;
+	int e_count = 0;
+	int f_count = 0;
+	int ret = 0;
+#ifdef CONFIG_USE_MCBSP_FIFO
+	u32 thrsh1 = 256;	/* lowest value for McBSP threshold */
+	u32 mcbsp_fifo_size;
+	int err;
+#endif
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+	mcbsp_wrapper[id].rx_cb_arg = cbdata;
+
+	/* Auto RRST handling logic - disable the Reciever before 1st dma */
+	if ((mcbsp_wrapper[id].auto_reset & OMAP_MCBSP_AUTO_RRST) &&
+	    (omap_dma_chain_status(mcbsp->dma_rx_lch)
+	     == OMAP_DMA_CHAIN_INACTIVE)) {
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR1,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR1) &
+				 (~RRST));
+		enable_rx = 1;
+	}
+
+	/*
+	 * for skip_first and second, we need to set e_count =2,
+	 * and f_count = number of frames = number of elements/e_count
+	 */
+	e_count = (buf_size / mcbsp->rx_word_length);
+
+	/* IF McBSP FIFO is used, change receive side configuration */
+#ifdef CONFIG_USE_MCBSP_FIFO
+	if (mcbsp_wrapper[id].rx_config_done == 0) {
+		mcbsp_wrapper[id].rx_config_done = 1;
+		if (id == OMAP_MCBSP2)
+			mcbsp_fifo_size = MCBSP2_FIFO_SIZE;
+		else
+			mcbsp_fifo_size = MCBSP_FIFO_SIZE;
+
+		if (e_count < mcbsp_fifo_size) {
+			thrsh1 = e_count;
+		} else {
+			/* Find the optimum threshold value for MCBSP
+			   to transfer complete data */
+			if ((e_count % mcbsp_fifo_size) == 0)
+				thrsh1 = mcbsp_fifo_size;
+			else if ((e_count % ((mcbsp_fifo_size * 3) / 4)) == 0)
+				thrsh1 = (mcbsp_fifo_size * 3) / 4;
+			else if ((e_count % ((mcbsp_fifo_size * 1) / 2)) == 0)
+				thrsh1 = (mcbsp_fifo_size * 1) / 2;
+			else if ((e_count % ((mcbsp_fifo_size * 1) / 4)) == 0)
+				thrsh1 = (mcbsp_fifo_size * 1) / 4;
+			else
+				thrsh1 = 1;
+		}
+
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_THRSH1, (thrsh1 - 1));
+
+		if (thrsh1 != mcbsp_fifo_size) {
+			mcbsp_wrapper[id].rx_params.src_fi = thrsh1;
+			/* if threshold =1, use element sync DMA */
+			if (thrsh1 == 1) {
+				mcbsp_wrapper[id].rx_params.sync_mode =
+				    OMAP_DMA_SYNC_ELEMENT;
+				mcbsp_wrapper[id].rx_params.src_fi = 0;
+			}
+			err = omap_modify_dma_chain_params(mcbsp->dma_rx_lch,
+						mcbsp_wrapper[id].rx_params);
+			if (err < 0) {
+				printk(KERN_ERR "DMA reconfiguration failed\n");
+				return -EINVAL;
+			}
+		}
+	}
+#endif
+
+	if (mcbsp_wrapper[id].rxskip_alt != OMAP_MCBSP_SKIP_NONE) {
+		/*
+		 * since the number of frames = total number of elements/element
+		 * count, However, with double indexing for data transfers,
+		 * double the number of elements need to be transmitted
+		 */
+		f_count = e_count;
+		e_count = 2;
+	} else {
+		f_count = 1;
+	}
+	/*
+	 * If the DMA is to be configured to skip the first byte, we need
+	 * to jump backwards, so we need to move one chunk forward and
+	 * ask dma if we dont want the client driver knowing abt this.
+	 */
+	if (mcbsp_wrapper[id].rxskip_alt == OMAP_MCBSP_SKIP_FIRST)
+		buf_start_addr += mcbsp->rx_word_length;
+
+	ret = omap_dma_chain_a_transfer(mcbsp->dma_rx_lch,
+					mcbsp->phys_base + OMAP_MCBSP_REG_DRR,
+					buf_start_addr, e_count, f_count,
+					mcbsp);
+	if (ret < 0)
+		return ret;
+
+	if (mcbsp_wrapper[id].rx_dma_chain_state == 0) {
+		if (mcbsp_wrapper[id].interface_mode == OMAP_MCBSP_MASTER)
+			omap2_mcbsp_set_srg_fsg(id, OMAP_MCBSP_ENABLE_FSG_SRG);
+
+		ret = omap_start_dma_chain_transfers(mcbsp->dma_rx_lch);
+		if (ret < 0)
+			return ret;
+
+		mcbsp_wrapper[id].rx_dma_chain_state = 1;
+	}
+	/* Auto RRST handling logic - Enable the Reciever after 1st dma */
+	if (enable_rx && (omap_dma_chain_status(mcbsp->dma_rx_lch)
+			  == OMAP_DMA_CHAIN_ACTIVE))
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR1,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR1) | RRST);
+
+	return 0;
+}
+
+int omap2_mcbsp_send_data(unsigned int id, void *cbdata,
+			  dma_addr_t buf_start_addr, u32 buf_size)
+{
+	struct omap_mcbsp *mcbsp;
+	void __iomem *io_base;
+	int e_count = 0;
+	int f_count = 0;
+	int ret = 0;
+
+	mcbsp = mcbsp_ptr[id];
+	io_base = mcbsp->io_base;
+	mcbsp_wrapper[id].tx_cb_arg = cbdata;
+
+	/*
+	 * for skip_first and second, we need to set e_count =2, and
+	 * f_count = number of frames = number of elements/e_count
+	 */
+	e_count = (buf_size / mcbsp->tx_word_length);
+	if (mcbsp_wrapper[id].txskip_alt != OMAP_MCBSP_SKIP_NONE) {
+		/*
+		 * number of frames = total number of elements/element count,
+		 * However, with double indexing for data transfers, double I
+		 * the number of elements need to be transmitted
+		 */
+		f_count = e_count;
+		e_count = 2;
+	} else {
+		f_count = 1;
+	}
+
+	/*
+	 * If the DMA is to be configured to skip the first byte, we need
+	 * to jump backwards, so we need to move one chunk forward and ask
+	 * dma if we dont want the client driver knowing abt this.
+	 */
+	if (mcbsp_wrapper[id].txskip_alt == OMAP_MCBSP_SKIP_FIRST)
+		buf_start_addr += mcbsp->tx_word_length;
+
+	ret = omap_dma_chain_a_transfer(mcbsp->dma_tx_lch,
+					buf_start_addr,
+					mcbsp->phys_base + OMAP_MCBSP_REG_DXR,
+					e_count, f_count, mcbsp);
+	if (ret < 0)
+		return ret;
+
+	if (mcbsp_wrapper[id].tx_dma_chain_state == 0) {
+		if (mcbsp_wrapper[id].interface_mode == OMAP_MCBSP_MASTER)
+			omap2_mcbsp_set_srg_fsg(id, OMAP_MCBSP_ENABLE_FSG_SRG);
+		ret = omap_start_dma_chain_transfers(mcbsp->dma_tx_lch);
+		if (ret < 0)
+			return ret;
+		mcbsp_wrapper[id].tx_dma_chain_state = 1;
+	}
+
+	/* Auto XRST handling logic - Enable the Reciever after 1st dma */
+	if ((enable_tx == 0) && (omap_dma_chain_status(mcbsp->dma_tx_lch)
+			  == OMAP_DMA_CHAIN_ACTIVE)) {
+		omap_mcbsp_write(io_base, OMAP_MCBSP_REG_SPCR2,
+				 omap_mcbsp_read(io_base,
+						 OMAP_MCBSP_REG_SPCR2) | XRST);
+		enable_tx = 1;
+	}
+
+	return 0;
+}
+
+int omap2_mcbsp_params_cfg(unsigned int id, int interface_mode,
+			   struct omap_mcbsp_cfg_param *rp,
+			   struct omap_mcbsp_cfg_param *tp,
+			   struct omap_mcbsp_srg_fsg_cfg *param)
+{
+	struct omap_mcbsp_reg_cfg mcbsp_cfg = {0};
+
+	if (rp)
+		omap2_mcbsp_set_recv_param(id, &mcbsp_cfg, rp);
+	if (tp)
+		omap2_mcbsp_set_trans_param(id, &mcbsp_cfg, tp);
+	if (param)
+		omap2_mcbsp_set_srg_cfg_param(id,
+					      interface_mode, &mcbsp_cfg,
+					      param);
+	omap_mcbsp_config(id, &mcbsp_cfg);
+
+	return 0;
+}
+
+#endif /* MCBSP_WRAPPER */
+
+static void map_audioic_speakers(void)
+{
+	if (state.stdac_out_stream != NULL) {
+		cpcap_audio_state.stdac_primary_speaker =
+						primary_spkr_setting;
+		cpcap_audio_state.stdac_secondary_speaker =
+						secondary_spkr_setting;
+	}
+
+	if ((state.codec_out_stream != NULL) ||
+		(cpcap_audio_state.rat_type == CPCAP_AUDIO_RAT_UMTS)) {
+		cpcap_audio_state.codec_primary_speaker = primary_spkr_setting;
+		cpcap_audio_state.codec_secondary_speaker =
+							secondary_spkr_setting;
+
+		if ((primary_spkr_setting == CPCAP_AUDIO_OUT_BT_MONO)
+		 && (secondary_spkr_setting == CPCAP_AUDIO_OUT_NONE)) {
+			AUDIO_LEVEL1_LOG("Setting codec in BT mode\n");
+			cpcap_audio_state.codec_mode =
+						CPCAP_AUDIO_CODEC_CLOCK_ONLY;
+			cpcap_audio_state.codec_mute = CPCAP_AUDIO_CODEC_MUTE;
+		} else{
+			AUDIO_LEVEL1_LOG("Setting codec in Normal mode\n");
+			cpcap_audio_state.codec_mode = CPCAP_AUDIO_CODEC_ON;
+		}
+	}
+}
+
+static int audio_select_speakers(int spkr)
+{
+	int local_spkr = -1;
+	int spkr1 = CPCAP_AUDIO_OUT_NONE;
+	int spkr2 = CPCAP_AUDIO_OUT_NONE;
+
+	AUDIO_LEVEL3_LOG("[%s] enter with spkr = %d\n", __func__, spkr);
+
+	while (spkr) {
+		if ((spkr & CPCAP_AUDIO_OUT_STEREO_HEADSET) ==
+			 CPCAP_AUDIO_OUT_STEREO_HEADSET)
+			local_spkr = CPCAP_AUDIO_OUT_STEREO_HEADSET;
+
+		else if ((spkr & CPCAP_AUDIO_OUT_MONO_HEADSET) ==
+			 CPCAP_AUDIO_OUT_MONO_HEADSET)
+			local_spkr = CPCAP_AUDIO_OUT_MONO_HEADSET;
+
+		else if ((spkr & CPCAP_AUDIO_OUT_BT_MONO) ==
+			 CPCAP_AUDIO_OUT_BT_MONO)
+			local_spkr = CPCAP_AUDIO_OUT_BT_MONO;
+
+		else if ((spkr & CPCAP_AUDIO_OUT_HANDSET) ==
+			CPCAP_AUDIO_OUT_HANDSET)
+			local_spkr = CPCAP_AUDIO_OUT_HANDSET;
+
+		else if ((spkr & CPCAP_AUDIO_OUT_LOUDSPEAKER) ==
+			 CPCAP_AUDIO_OUT_LOUDSPEAKER)
+			local_spkr = CPCAP_AUDIO_OUT_LOUDSPEAKER;
+
+		else if ((spkr & CPCAP_AUDIO_OUT_LINEOUT) ==
+			 CPCAP_AUDIO_OUT_LINEOUT)
+			local_spkr = CPCAP_AUDIO_OUT_LINEOUT;
+
+		else if (local_spkr == -1 && spkr1 == CPCAP_AUDIO_OUT_NONE)
+			return -EINVAL;
+
+		if (spkr1 == CPCAP_AUDIO_OUT_NONE)
+			spkr1 = local_spkr;
+		else
+			if (local_spkr != -1)
+				spkr2 = local_spkr;
+
+		spkr &= ~local_spkr;
+		local_spkr = -1;
+	}
+
+	AUDIO_LEVEL1_LOG("spkr1 = %#x, spkr2 = %#x\n", spkr1, spkr2);
+
+	if (spkr1 != primary_spkr_setting || spkr2 != secondary_spkr_setting) {
+		primary_spkr_setting = spkr1;
+		secondary_spkr_setting = spkr2;
+		map_audioic_speakers();
+		cpcap_audio_state.output_gain = 0;
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+	}
+
+	return 0;
+}
+
+static int audio_hw_transfer(struct audio_stream *str,
+			     void *buffer_phy, u32 size, struct inode *inode)
+{
+	int ret = 0;
+	int minor = MINOR(inode->i_rdev);
+	int ssi = (minor == state.dev_dsp) ? STDAC_SSI : CODEC_SSI;
+
+	AUDIO_LEVEL3_LOG("[%s] enter\n", __func__);
+
+	if (unlikely(str == NULL || buffer_phy == NULL)) {
+		AUDIO_ERROR_LOG("Stream/phy_buf NULL!!\n");
+		return -EPERM;
+	}
+
+	if (str->input_output == FMODE_READ) {
+		AUDIO_LEVEL3_LOG("RX-%d", size);
+		TRY(ret = omap2_mcbsp_receive_data(ssi, str,
+				(dma_addr_t) buffer_phy, size))
+	} else {
+		AUDIO_LEVEL3_LOG("TX-%d\n", size);
+		ret = omap2_mcbsp_send_data(ssi, str, (dma_addr_t) buffer_phy,
+					size);
+	}
+
+out:
+	return ret;
+}
+
+static int audio_setup_buf(struct audio_stream *str, struct inode *inode)
+{
+	int frag;
+	int bufsize = 0;
+	char *bufbuf = NULL;
+	dma_addr_t bufphys = 0;
+
+	if (str == NULL) {
+		AUDIO_ERROR_LOG("Stream not allocated\n");
+		return -EPERM;
+	}
+
+	str->buffers = kmalloc(sizeof(struct audio_buf) * str->nbfrags,
+			       GFP_KERNEL);
+
+	if (!str->buffers) {
+		AUDIO_ERROR_LOG("Error allocating buffers\n");
+		goto out;
+	}
+
+	memset(str->buffers, 0, sizeof(struct audio_buf) * str->nbfrags);
+
+	for (frag = 0; frag < str->nbfrags; frag++) {
+		struct audio_buf *b = &str->buffers[frag];
+
+		/*
+		 * Let's allocate non-cached memory for DMA buffers.
+		 * We try to allocate all memory at once.
+		 * If this fails (a common reason is memory fragmentation),
+		 * then we allocate more smaller buffers.
+		 */
+		if (!bufsize) {
+			bufsize = (str->nbfrags - frag) * str->fragsize;
+
+			do {
+				bufbuf =
+				    dma_alloc_coherent(NULL, bufsize, &bufphys,
+							GFP_KERNEL | GFP_DMA);
+
+				if (!bufbuf)
+					bufsize -= str->fragsize;
+			} while (!bufbuf && bufsize);
+
+			if (!bufbuf)
+				goto out;
+
+			b->master = bufsize;
+			memset(bufbuf, 0, bufsize);
+		}
+
+		b->data = bufbuf;
+		b->buf_addr = bufphys;
+		bufbuf += str->fragsize;
+		bufphys += str->fragsize;
+		bufsize -= str->fragsize;
+	}
+
+	str->bytecount = 0;
+	str->fragcount = 0;
+	sema_init(&str->sem, str->nbfrags);
+	return 0;
+
+out:
+	audio_discard_buf(str, inode);
+	return -ENOMEM;
+}
+
+static void audio_discard_buf(struct audio_stream *str, struct inode *inode)
+{
+	/* ensure DMA isn't using those buffers */
+	audio_buffer_reset(str, inode);
+
+	if (str->buffers) {
+		int frag;
+		for (frag = 0; frag < str->nbfrags; frag++) {
+			if (!str->buffers[frag].master)
+				continue;
+
+			dma_free_coherent(NULL, str->buffers[frag].master,
+					  str->buffers[frag].data,
+					  str->buffers[frag].buf_addr);
+		}
+
+		kfree(str->buffers);
+		str->buffers = NULL;
+	}
+}
+
+static int audio_process_buf(struct audio_stream *str, struct inode *inode)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	if (str == NULL) {
+		AUDIO_ERROR_LOG("Invalid stream parameter\n");
+		ret = -EPERM;
+		goto out;
+	}
+
+	if (str->input_output == FMODE_READ) {
+		struct audio_buf *b = &str->buffers[str->buf_head];
+
+		if (str->fragsize) {
+			ret = audio_hw_transfer(str, (void *)(b->buf_addr),
+						str->fragsize, str->inode);
+			if (!ret) {
+				b->buf_ref++;
+				AUDIO_LEVEL2_LOG
+				    ("b->buf_ref = %d, buf->head = %d\n",
+				     b->buf_ref, str->buf_head);
+			}
+		}
+
+		if (++str->buf_head >= str->nbfrags)
+			str->buf_head = 0;
+	} else {
+		spin_lock_irqsave(&audio_write_lock, flags);
+		if (str->in_use) {
+			spin_unlock_irqrestore(&audio_write_lock, flags);
+			return ret;
+		}
+		str->in_use = 1;
+		spin_unlock_irqrestore(&audio_write_lock, flags);
+
+		while (str->pending_frags) {
+			struct audio_buf *b = &str->buffers[str->buf_head];
+			u32 buf_size = str->fragsize - b->offset;
+
+			AUDIO_LEVEL3_LOG
+			    ("buf_size=%d, fragsize=%d, offset=%d\n",
+			     buf_size, str->fragsize, b->offset);
+
+			if (buf_size) {
+				ret = audio_hw_transfer(str,
+					(void *)(b->buf_addr + b->offset),
+						buf_size, str->inode);
+			}
+
+			if (ret)
+				goto out;
+
+			b->buf_ref++;
+			b->offset += buf_size;
+
+			if (b->offset >= str->fragsize) {
+				str->pending_frags--;
+				if (++str->buf_head >= str->nbfrags)
+					str->buf_head = 0;
+			}
+		}
+out:
+		spin_lock_irqsave(&audio_write_lock, flags);
+		str->in_use = 0;
+		spin_unlock_irqrestore(&audio_write_lock, flags);;
+	}
+
+	return ret;
+}
+
+static void audio_buffer_reset(struct audio_stream *str, struct inode *inode)
+{
+	int frag;
+
+	if (str->buffers) {
+		for (frag = 0; frag < str->nbfrags; frag++) {
+			struct audio_buf *b = &str->buffers[frag];
+			b->offset = 0;
+			b->buf_ref = 0;
+		}
+	}
+
+	str->active = 0;
+	str->stopped = 0;
+	str->fragcount = 0;
+	str->bytecount = 0;
+	str->buf_tail = 0;
+	str->buf_head = 0;
+	str->usr_head = 0;
+	str->fragsize = 0;
+	str->in_use   = 0;
+}
+
+static void mcbsp_dma_tx_cb(u32 ch_status, void *arg)
+{
+	struct audio_stream *str;
+	struct audio_buf *b;
+
+	if (unlikely(!arg)) {
+		AUDIO_ERROR_LOG("No Stream information!!\n");
+		return;
+	}
+
+	str = (struct audio_stream *)arg;
+	b = &str->buffers[str->buf_tail];
+
+	if (ch_status) {
+		AUDIO_ERROR_LOG("Error happend[%d 0x%x]!!\n", ch_status,
+				ch_status);
+		return;
+	}
+
+	/* Try to fill again */
+	if (!str->buffers) {
+		AUDIO_ERROR_LOG("received DMA IRQ for non "
+				"existent buffers!\n");
+		return;
+	} else if (b->buf_ref && --b->buf_ref == 0
+		   && b->offset >= str->fragsize) {
+		/* This fragment is done */
+		b->offset = 0;
+		str->bytecount += str->fragsize;
+		str->fragcount++;
+
+		if (++str->buf_tail >= str->nbfrags)
+			str->buf_tail = 0;
+
+		up(&str->sem);
+		audio_process_buf(str, str->inode);
+	}
+}
+
+static void mcbsp_dma_rx_cb(u32 ch_status, void *arg)
+{
+	struct audio_stream *str;
+	struct audio_buf *b;
+
+	if (unlikely(!arg)) {
+		AUDIO_ERROR_LOG("No Stream information!!\n");
+		return;
+	}
+
+	str = (struct audio_stream *)arg;
+
+	b = &str->buffers[str->buf_tail];
+
+	if (ch_status) {
+		AUDIO_ERROR_LOG("Error happend[%d 0x%x]!!\n", ch_status,
+				ch_status);
+		return;
+	}
+
+	AUDIO_LEVEL2_LOG("b->buf_ref = %d, str->buf_tail = %d full!!\n",
+			 b->buf_ref, str->buf_tail);
+
+	/* Try to fill again */
+	if (!str->buffers) {
+		AUDIO_ERROR_LOG("received DMA IRQ for "
+				"non existent buffers!\n");
+		return;
+	} else if (b->buf_ref && --b->buf_ref == 0) {
+		if (++str->buf_tail >= str->nbfrags)
+			str->buf_tail = 0;
+
+		if (++read_buf_full >= str->nbfrags)
+			read_buf_full = 0;
+
+		audio_process_buf(str, str->inode);
+
+		wake_up_interruptible(&str->wq);
+	} else {
+		AUDIO_LEVEL2_LOG("b->buf_ref = %d\n", b->buf_ref);
+	}
+}
+
+static int audio_configure_ssi(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	unsigned int ssi;
+
+	if (minor == state.dev_dsp) {	/* STDAC setting */
+		tx_cfg_params.word_length1 = OMAP_MCBSP_WORD_32;
+		tx_params.word_length1 = OMAP_MCBSP_WORD_32;
+		ssi = STDAC_SSI;
+#ifdef AUDIO_I2S_MODE
+		/*tx_cfg_params.fs_polarity  = OMAP_MCBSP_FS_ACTIVE_LOW;*/
+		/*tx_cfg_params.phase = OMAP_MCBSP_FRAME_DUALPHASE;*/
+#endif
+		omap_ctrl_writel(omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) |
+					(1 << OMAP2_CONTROL_DEVCONF0_BIT6),
+						OMAP2_CONTROL_DEVCONF0);
+	} else {		/* CODEC setting */
+		tx_cfg_params.word_length1 = OMAP_MCBSP_WORD_16;
+		tx_params.word_length1 = OMAP_MCBSP_WORD_16;
+		ssi = CODEC_SSI;
+
+		/* support for stereo capture */
+		if (file->f_mode & FMODE_READ) {
+			if (capture_mode == 0) {	/* mono capture */
+				rx_cfg_params.word_length1 = OMAP_MCBSP_WORD_16;
+				rx_params.word_length1 = OMAP_MCBSP_WORD_16;
+			} else {
+				rx_cfg_params.word_length1 = OMAP_MCBSP_WORD_32;
+				rx_params.word_length1 = OMAP_MCBSP_WORD_32;
+			}
+		}
+	}
+
+	TRY(omap_mcbsp_set_io_type(ssi, 0))
+
+#ifdef CONFIG_WAKELOCK
+	wake_lock(&mcbsp_wakelock);
+#endif
+
+	TRY(omap_mcbsp_request(ssi))
+
+	TRY(omap2_mcbsp_reset(ssi))
+
+	TRY(omap2_mcbsp_params_cfg(ssi, OMAP_MCBSP_SLAVE, &rx_cfg_params,
+				&tx_cfg_params, &srg_fsg_params))
+
+	if (file->f_mode & FMODE_WRITE)
+		TRY(omap2_mcbsp_dma_trans_params(ssi, &tx_params))
+
+	if (file->f_mode & FMODE_READ)
+		omap2_mcbsp_dma_recv_params(ssi, &rx_params);
+
+	return 0 ;
+
+out:
+	omap_mcbsp_free(ssi);
+#ifdef CONFIG_WAKELOCK
+	wake_unlock(&mcbsp_wakelock);
+#endif
+	return -EPERM ;
+}
+
+int audio_stop_ssi(struct inode *inode, struct file *file)
+{
+	int minor = MINOR(inode->i_rdev);
+	int ssi;
+
+	ssi = (minor == state.dev_dsp) ? STDAC_SSI : CODEC_SSI;
+
+	if (file->f_mode & FMODE_WRITE) {
+		TRY(omap2_mcbsp_set_xrst(ssi, OMAP_MCBSP_XRST_DISABLE))
+		TRY(omap2_mcbsp_stop_datatx(ssi))
+		enable_tx = 0;
+		omap_ctrl_writel(omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0) &
+					~(1 << OMAP2_CONTROL_DEVCONF0_BIT6),
+						OMAP2_CONTROL_DEVCONF0);
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		TRY(omap2_mcbsp_set_rrst(ssi, OMAP_MCBSP_RRST_DISABLE))
+		TRY(omap2_mcbsp_stop_datarx(ssi))
+	}
+
+	(void)omap2_mcbsp_reset(ssi);
+	(void)omap_mcbsp_free(ssi);
+#ifdef CONFIG_WAKELOCK
+	wake_unlock(&mcbsp_wakelock);
+#endif
+	return 0;
+out:
+	return -EPERM;
+}
+
+static int audio_stdac_open(struct inode *inode, struct file *file)
+{
+	int error = 0;
+	mutex_lock(&audio_lock);
+
+	if (state.dev_dsp_open_count == 1) {
+		error = -EBUSY;
+		goto out;
+	}
+
+	state.dev_dsp_open_count = 1;
+	file->private_data = inode;
+
+	if (file->f_mode & FMODE_WRITE) {
+		state.stdac_out_stream =
+		    kmalloc(sizeof(struct audio_stream), GFP_KERNEL);
+		memset(state.stdac_out_stream, 0,
+		       sizeof(struct audio_stream));
+		state.stdac_out_stream->inode = inode;
+		audio_buffer_reset(state.stdac_out_stream, inode);
+
+		TRY(error = audio_configure_ssi(inode, file))
+
+		cpcap_audio_state.stdac_mode = CPCAP_AUDIO_STDAC_ON;
+
+		map_audioic_speakers();
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+	}
+
+out:
+	mutex_unlock(&audio_lock);
+	return error;
+}
+
+static int audio_stdac_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&audio_lock);
+	state.dev_dsp_open_count = 0;
+
+	if (file->f_mode & FMODE_WRITE) {
+		audio_stop_ssi(inode, file);
+
+		audio_discard_buf(state.stdac_out_stream, inode);
+		kfree(state.stdac_out_stream);
+		state.stdac_out_stream = NULL;
+
+		cpcap_audio_state.stdac_mode = CPCAP_AUDIO_STDAC_OFF;
+		cpcap_audio_state.stdac_mute = CPCAP_AUDIO_STDAC_MUTE;
+
+		cpcap_audio_state.stdac_primary_speaker = CPCAP_AUDIO_OUT_NONE;
+		cpcap_audio_state.stdac_secondary_speaker =
+							CPCAP_AUDIO_OUT_NONE;
+
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+	}
+
+	mutex_unlock(&audio_lock);
+
+	return 0;
+}
+
+static int audio_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	int minor = MINOR(inode->i_rdev);
+	int ret = 0;
+
+	mutex_lock(&audio_lock);
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		ret = put_user(SOUND_VERSION, (int *)arg);
+		break;
+
+	case SNDCTL_DSP_SPEED:
+	{
+		unsigned int samp_rate;
+		int count = 0;
+		TRY(copy_from_user(&samp_rate, (unsigned int *)arg,
+			     sizeof(unsigned int)))
+
+		/* validate if rate is proper */
+		for (; count < NUMBER_OF_RATES_SUPPORTED; count++) {
+			if (valid_sample_rates[count].rate == samp_rate)
+				break;
+		}
+
+		if (count >= NUMBER_OF_RATES_SUPPORTED) {
+			AUDIO_ERROR_LOG("[%d] Unsupported sample rate!!\n",
+				     (u32) samp_rate);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (minor == state.dev_dsp) {
+			if (samp_rate != cpcap_audio_state.stdac_rate) {
+				cpcap_audio_state.stdac_rate =
+				valid_sample_rates[count].cpcap_audio_rate;
+				cpcap_audio_set_audio_state(&cpcap_audio_state);
+			}
+		} else {
+			if (samp_rate != cpcap_audio_state.codec_rate) {
+				if ((file->f_mode & FMODE_WRITE) &&
+				(samp_rate != 8000 && samp_rate != 16000)) {
+					AUDIO_ERROR_LOG("[%d] Unsupported "
+						"Codec sample rate!!\n",
+						(u32) samp_rate);
+					ret = -EINVAL;
+					goto out;
+				}
+				cpcap_audio_state.codec_rate =
+				valid_sample_rates[count].cpcap_audio_rate;
+				cpcap_audio_set_audio_state(&cpcap_audio_state);
+			}
+		}
+		break;
+	}
+
+	case SNDCTL_DSP_POST:
+		break;
+
+	case SNDCTL_DSP_STEREO:
+	{
+		int val;
+		TRY(copy_from_user(&val, (int *)arg, sizeof(int)))
+		if (minor == state.dev_dsp) {
+			if (val != 1) {
+				ret = -EINVAL;
+				goto out;
+			}
+		} else {	/* Codec case */
+			if (file->f_mode & FMODE_WRITE) {
+				if (val != 0) {
+					ret = -EINVAL;
+					goto out;
+				}
+			} else {	/* support for stereo capture */
+				capture_mode = val;
+				TRY(audio_stop_ssi(inode, file))
+				TRY(audio_configure_ssi(inode, file))
+			}
+		}
+		break;
+	}
+
+	case SNDCTL_DSP_SYNC:
+		break;
+
+	case SNDCTL_DSP_GETBLKSIZE:
+	{
+		int val = 0;
+		if (file->f_mode & FMODE_WRITE) {
+			val = (minor == state.dev_dsp) ? STDAC_FIFO_SIZE :
+				CODEC_FIFO_SIZE;
+		} else {
+			/* McBSP/DMA driver returns blank data
+			 * if any other size other than
+			 * 800 is used for capture */
+			val = AUDIO_CAPTURE_SIZE;
+		}
+		put_user(val, (int *)arg);
+		break;
+	}
+
+	case SNDCTL_DSP_GETOSPACE:
+	case SNDCTL_DSP_GETISPACE:
+	{
+		audio_buf_info inf = { 0 };
+		struct audio_stream *str;
+		if (minor == state.dev_dsp) {
+			str = (file->f_mode & FMODE_WRITE) ?
+				state.stdac_out_stream : state.stdac_in_stream;
+		} else {
+			str = (file->f_mode & FMODE_WRITE) ?
+				state.codec_out_stream : state.codec_in_stream;
+		}
+
+		inf.bytes = str->fragsize;
+		inf.fragments = 1;
+		inf.fragsize = str->fragsize;
+		inf.fragstotal = str->nbfrags;
+		ret = copy_to_user((void *)arg, &inf, sizeof(inf));
+		break;
+	}
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		break;
+
+	case SNDCTL_DSP_RESET:
+	{
+		struct audio_stream *str;
+		int ssi;
+		if (minor == state.dev_dsp) {
+			str = (file->f_mode & FMODE_WRITE) ?
+				state.stdac_out_stream : state.stdac_in_stream;
+				ssi = STDAC_SSI;
+		} else {
+			str = (file->f_mode & FMODE_WRITE) ?
+				state.codec_out_stream : state.codec_in_stream;
+			ssi = CODEC_SSI;
+		}
+		TRY(omap2_mcbsp_set_xrst(ssi, OMAP_MCBSP_XRST_DISABLE))
+		audio_buffer_reset(str, inode);
+		break;
+	}
+
+	case SNDCTL_DSP_GETOPTR:
+	{
+		int bytes_left_in_kernel = 0;
+
+		struct audio_stream *str = (minor == state.dev_dsp) ?
+			state.stdac_out_stream : state.codec_out_stream;
+
+		if ((str != NULL) && (str->nbfrags != 0)) {
+			bytes_left_in_kernel = ((str->nbfrags - str->buf_tail +
+			str->usr_head - 1) % str->nbfrags) * str->fragsize;
+		}
+
+		TRY(put_user(bytes_left_in_kernel, (int *)arg))
+		break;
+	}
+
+		/* MIXER ioctls */
+	case SOUND_MIXER_OUTSRC:
+	{
+		int spkr;
+		TRY(copy_from_user(&spkr, (int *)arg, sizeof(int)))
+		AUDIO_LEVEL2_LOG("SOUND_MIXER_OUTSRC with spkr = %#x\n", spkr);
+		ret = audio_select_speakers(spkr);
+		break;
+	}
+
+	case SOUND_MIXER_FMPATH:
+		{
+			int spkr;
+			TRY(copy_from_user(&spkr, (int *)arg, sizeof(int)))
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMPATH with spkr = %#x\n", spkr);
+			cpcap_audio_state.ext_primary_speaker = spkr;
+/* 	FM radio output gain is controlled by cpcap_audio_driver.c
+	So, this value should not be changed here.
+	This value should be synced other output gain value.
+*/
+			cpcap_audio_state.output_gain = 0xFF;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
+	case SOUND_MIXER_FMON:
+		{
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMON\n");
+			cpcap_audio_state.ext_primary_speaker = CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_state.analog_source =
+				CPCAP_AUDIO_ANALOG_SOURCE_STEREO;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
+	case SOUND_MIXER_FMOFF:
+		{
+			AUDIO_LEVEL2_LOG("SOUND_MIXER_FMOFF\n");
+			cpcap_audio_state.ext_primary_speaker =	CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_state.ext_secondary_speaker =
+				CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			break;
+		}
+
+	case SOUND_MIXER_RECSRC:
+	{
+		int mic;
+		TRY(copy_from_user(&mic, (int *)arg, sizeof(int)))
+		AUDIO_LEVEL2_LOG("SOUND_MIXER_RECSRC with mic = %#x\n", mic);
+		if (mic != mic_setting) {
+			if (state.dev_dsp1_open_count == 1) {
+				cpcap_audio_state.microphone = mic;
+				cpcap_audio_state.input_gain = 0;
+				cpcap_audio_set_audio_state(&cpcap_audio_state);
+			}
+			mic_setting = mic;
+		}
+		break;
+	}
+
+	case SOUND_MIXER_VOLUME:
+	{
+		unsigned int gain;
+		TRY(copy_from_user(&gain, (unsigned int *)arg,
+					sizeof(unsigned int)))
+		if (gain == 0) {
+			cpcap_audio_state.stdac_mute = CPCAP_AUDIO_STDAC_MUTE;
+			cpcap_audio_state.codec_mute = CPCAP_AUDIO_CODEC_MUTE;
+		} else {
+			/* unmute codec or stereo DAC */
+			if (cpcap_audio_state.stdac_mode ==
+							CPCAP_AUDIO_STDAC_ON)
+				cpcap_audio_state.stdac_mute =
+						CPCAP_AUDIO_STDAC_UNMUTE;
+
+			if (cpcap_audio_state.codec_mode ==
+					CPCAP_AUDIO_CODEC_ON)
+				cpcap_audio_state.codec_mute =
+						CPCAP_AUDIO_CODEC_UNMUTE;
+
+			cpcap_audio_state.output_gain = gain;
+		}
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+		AUDIO_LEVEL2_LOG("SOUND_MIXER_VOLUME, output_gain = %d\n",
+				cpcap_audio_state.output_gain);
+		break;
+	}
+
+	case SOUND_MIXER_RECLEV:
+	{
+		unsigned int gain;
+		TRY(copy_from_user(&gain, (unsigned int *)arg,
+						sizeof(unsigned int)))
+		cpcap_audio_state.input_gain = gain;
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+		AUDIO_LEVEL2_LOG("SOUND_MIXER_RECLEV, input_gain = %d\n",
+				cpcap_audio_state.input_gain);
+		break;
+	}
+
+	case SOUND_MIXER_PRIVATE1:  /* Codec loopback mode */
+	{
+		AUDIO_LEVEL2_LOG("Audio IC loopback ioctl called\n");
+		cpcap_audio_state.codec_mode = CPCAP_AUDIO_CODEC_LOOPBACK;
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+
+		break;
+	}
+
+	case SOUND_MIXER_PRIVATE2: /* Balance control */
+	{
+		unsigned int balance;
+		TRY(copy_from_user(&balance, (unsigned int *)arg,
+						sizeof(unsigned int)))
+		cpcap_audio_state.stdac_primary_balance = balance;
+		cpcap_audio_state.codec_primary_balance = balance;
+		cpcap_audio_state.ext_primary_balance =  balance;
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+
+		break;
+	}
+
+	default:
+		break;
+	}
+
+out:
+	mutex_unlock(&audio_lock);
+	return ret;
+}
+
+static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
+								loff_t *nouse)
+{
+	int chunksize, ret = 0;
+	unsigned long flags;
+	const char *buffer0 = buffer;
+	struct inode *inode = (struct inode *)file->private_data;
+	int minor = MINOR(inode->i_rdev);
+	struct audio_stream *str = (minor == state.dev_dsp) ?
+			state.stdac_out_stream : state.codec_out_stream;
+
+	mutex_lock(&audio_lock);
+
+	if (minor == state.dev_dsp) {
+		if (!str->active) {
+			int temp_size = count % STDAC_FIFO_SIZE;
+			if (temp_size != 0)
+				str->fragsize = (count - temp_size) +
+								STDAC_FIFO_SIZE;
+			else
+				str->fragsize = count;
+			str->nbfrags = AUDIO_NBFRAGS_WRITE;
+			if (audio_setup_buf(str, file->private_data)) {
+				AUDIO_ERROR_LOG("Unable to allocate memory\n");
+				ret = -ENOMEM;
+				goto out;
+			}
+			str->active = 1;
+		}
+	} else {
+		if (!str->active) {
+			int temp_size = count % CODEC_FIFO_SIZE;
+			if (temp_size != 0)
+				str->fragsize = (count - temp_size) +
+								CODEC_FIFO_SIZE;
+			else
+				str->fragsize = count;
+			str->nbfrags = AUDIO_NBFRAGS_WRITE;
+			if (audio_setup_buf(str, file->private_data)) {
+				AUDIO_ERROR_LOG("Unable to allocate memory\n");
+				ret = -ENOMEM;
+				goto out;
+			}
+			str->active = 1;
+		}
+	}
+
+	while (count > 0) {
+		struct audio_buf *buf = &str->buffers[str->usr_head];
+
+		/* Wait for a buffer to become free */
+		if (file->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			if (down_trylock(&str->sem))
+				break;
+		} else {
+			mutex_unlock(&audio_lock);
+			ret = down_timeout(&str->sem, AUDIO_TIMEOUT);
+			mutex_lock(&audio_lock);
+			if (ret) {
+				AUDIO_ERROR_LOG("audio_write: timedout\n");
+				break;
+			}
+		}
+
+		chunksize = str->fragsize - buf->offset;
+
+		if (chunksize > count)
+			chunksize = count;
+
+		if (copy_from_user(buf->data + buf->offset,
+				buffer, chunksize)) {
+			AUDIO_ERROR_LOG("Audio: CopyFrom User failed \n");
+			up(&str->sem);
+			ret = -EFAULT;
+			goto out;
+		}
+
+		/* Workaround for CPCAP channel inversion issue */
+		if (cpcap_audio_state.cpcap->revision == CPCAP_REVISION_2_1 &&
+			cpcap_audio_state.cpcap->vendor == CPCAP_VENDOR_TI) {
+			if (minor == state.dev_dsp &&
+				(cpcap_audio_state.stdac_primary_speaker ==
+					CPCAP_AUDIO_OUT_STEREO_HEADSET ||
+				cpcap_audio_state.stdac_secondary_speaker ==
+					CPCAP_AUDIO_OUT_STEREO_HEADSET)) {
+				int lc;
+				short *ptr = (short *)(buf->data + buf->offset);
+				for (lc = 0; lc < chunksize / 2; lc += 2) {
+					ptr[lc] = -ptr[lc];
+					if (ptr[lc] == (short)0x8000)
+						ptr[lc] = (short)0x7FFF;
+				}
+			}
+		}
+
+		buffer += chunksize;
+		count -= chunksize;
+		buf->offset += chunksize;
+
+		if (buf->offset < str->fragsize) {
+			up(&str->sem);
+			break;
+		}
+
+		buf->offset = 0;
+
+		spin_lock_irqsave(&audio_write_lock, flags);
+
+		if (++str->usr_head >= str->nbfrags)
+			str->usr_head = 0;
+
+		str->pending_frags++;
+
+		ret = audio_process_buf(str, inode);
+
+		spin_unlock_irqrestore(&audio_write_lock, flags);
+	}
+
+	if (buffer - buffer0)
+		ret = buffer - buffer0;
+
+out:
+	mutex_unlock(&audio_lock);
+	return ret;
+}
+
+static int audio_codec_open(struct inode *inode, struct file *file)
+{
+	int ret = 0;
+	mutex_lock(&audio_lock);
+	if (state.dev_dsp1_open_count == 1) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	state.dev_dsp1_open_count = 1;
+	file->private_data = inode;
+
+	cpcap_audio_state.codec_mode = CPCAP_AUDIO_CODEC_ON;
+
+	if (file->f_flags & O_TRUNC) {
+		AUDIO_LEVEL1_LOG("CODEC in phone mode called \n");
+		cpcap_audio_state.rat_type = CPCAP_AUDIO_RAT_UMTS;
+		cpcap_audio_state.output_gain = 0;
+		cpcap_audio_state.codec_rate = CPCAP_AUDIO_CODEC_RATE_8000_HZ;
+		if (primary_spkr_setting == CPCAP_AUDIO_OUT_LOUDSPEAKER) {
+			cpcap_audio_state.codec_primary_speaker =
+							CPCAP_AUDIO_OUT_HANDSET;
+			cpcap_audio_state.microphone =
+						CPCAP_AUDIO_IN_DUAL_INTERNAL;
+			primary_spkr_setting = CPCAP_AUDIO_OUT_HANDSET;
+			mic_setting = CPCAP_AUDIO_IN_DUAL_INTERNAL;
+		} else {
+			cpcap_audio_state.codec_primary_speaker =
+							primary_spkr_setting;
+			cpcap_audio_state.microphone = mic_setting;
+		}
+		cpcap_audio_set_audio_state(&cpcap_audio_state);
+	} else {
+		if (file->f_mode & FMODE_WRITE) {
+			state.codec_out_stream =
+			    kmalloc(sizeof(struct audio_stream), GFP_KERNEL);
+			memset(state.codec_out_stream, 0,
+			       sizeof(struct audio_stream));
+			state.codec_out_stream->inode = inode;
+			audio_buffer_reset(state.codec_out_stream, inode);
+			TRY(audio_configure_ssi(inode, file))
+			map_audioic_speakers();
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			cpcap_audio_state.microphone = mic_setting;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			state.codec_in_stream =
+			    kmalloc(sizeof(struct audio_stream), GFP_KERNEL);
+			memset(state.codec_in_stream, 0,
+			       sizeof(struct audio_stream));
+			state.codec_in_stream->inode = inode;
+			msleep(8);
+			TRY(audio_configure_ssi(inode, file))
+		}
+	}
+out:
+	mutex_unlock(&audio_lock);
+	return ret;
+}
+
+static int audio_codec_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&audio_lock);
+	state.dev_dsp1_open_count = 0;
+
+	read_buf_full = 0;
+	cpcap_audio_state.codec_mode = CPCAP_AUDIO_CODEC_OFF;
+	cpcap_audio_state.codec_mute = CPCAP_AUDIO_CODEC_MUTE;
+	cpcap_audio_state.codec_primary_speaker = CPCAP_AUDIO_OUT_NONE;
+	cpcap_audio_state.codec_secondary_speaker = CPCAP_AUDIO_OUT_NONE;
+	cpcap_audio_state.microphone = CPCAP_AUDIO_IN_NONE;
+
+	if (cpcap_audio_state.rat_type != CPCAP_AUDIO_RAT_NONE) {
+		cpcap_audio_state.rat_type = CPCAP_AUDIO_RAT_NONE;
+	} else {
+		if (file->f_mode & FMODE_WRITE) {
+			audio_stop_ssi(inode, file);
+			audio_discard_buf(state.codec_out_stream, inode);
+			kfree(state.codec_out_stream);
+			state.codec_out_stream = NULL;
+		}
+
+		if (file->f_mode & FMODE_READ) {
+			audio_stop_ssi(inode, file);
+			audio_discard_buf(state.codec_in_stream, inode);
+			kfree(state.codec_in_stream);
+			state.codec_in_stream = NULL;
+		}
+	}
+
+	cpcap_audio_set_audio_state(&cpcap_audio_state);
+
+	AUDIO_LEVEL3_LOG("[%s] enter\n", __func__);
+	mutex_unlock(&audio_lock);
+
+	return 0;
+}
+
+static ssize_t audio_codec_read(struct file *file, char *buffer, size_t size,
+								loff_t *nouse)
+{
+	struct audio_stream *str = state.codec_in_stream;
+	int local_size = size, ret = 0;
+
+	mutex_lock(&audio_lock);
+
+	if (size <= 0) {
+		ret = size;
+		goto err;
+	}
+
+	if (str == NULL) {
+		ret = -EPERM;
+		goto err;
+	}
+
+	if (str->fragsize != size) {
+		str->fragsize = size;
+		str->nbfrags = AUDIO_NBFRAGS_READ;
+		str->input_output = FMODE_READ;
+		init_waitqueue_head(&str->wq);
+		if (audio_setup_buf(str, file->private_data)) {
+			AUDIO_ERROR_LOG("Unable to allocate memory\n");
+			ret = -ENOMEM;
+			goto err;
+		}
+	}
+
+	while (size > 0) {
+		struct audio_buf *buf = &str->buffers[str->usr_head];
+
+		/* Start the stream if has not already been started. The first
+		 * time around we call process_buf back to back to start both
+		 * receive DMA channels */
+		if (str->active == 0) {
+			ret = audio_process_buf(str,
+				((struct inode *)file->private_data));
+			if (ret == -EBUSY) {
+				AUDIO_ERROR_LOG(
+					"buffer processing failed to start\n");
+				goto err;
+			} else {
+				ret = audio_process_buf(str,
+					((struct inode *)file->private_data));
+				if (ret == -EBUSY) {
+					AUDIO_ERROR_LOG("buffer processing "
+					"failed to start for second buf\n");
+					goto err;
+				} else {
+					str->active = 1;
+				}
+			}
+		}
+
+		mutex_unlock(&audio_lock);
+
+		wait_event_interruptible_timeout(str->wq, read_buf_full > 0,
+						 AUDIO_TIMEOUT);
+		mutex_lock(&audio_lock);
+
+		read_buf_full--;
+
+		if (read_buf_full < 0)
+			read_buf_full = 0;
+
+		if (copy_to_user(buffer, buf->data, str->fragsize)) {
+			AUDIO_ERROR_LOG("Audio: CopyTo User failed \n");
+			ret = -EFAULT;
+			goto err;
+		}
+
+		if (++str->usr_head >= str->nbfrags)
+			str->usr_head = 0;
+
+		size -= str->fragsize;
+	}
+
+	ret = local_size;
+err:
+	mutex_unlock(&audio_lock);
+	return ret;
+}
+
+static int audio_mixer_open(struct inode *inode, struct file *file)
+{
+	int ret = 0;
+	mutex_lock(&audio_lock);
+	if (state.dev_mixer_open_count == 1) {
+		ret = -EBUSY;
+		goto err;
+	}
+
+	state.dev_mixer_open_count = 1;
+
+err:
+	mutex_unlock(&audio_lock);
+	return ret;
+}
+
+static int audio_mixer_close(struct inode *inode, struct file *file)
+{
+	mutex_lock(&audio_lock);
+	state.dev_mixer_open_count = 0;
+	mutex_unlock(&audio_lock);
+	return 0;
+}
+
+static int __init audio_init(void)
+{
+	int err = platform_driver_register(&audio_driver);
+
+	if (err)
+		return err;
+
+#ifdef CONFIG_WAKELOCK
+	wake_lock_init(&mcbsp_wakelock, WAKE_LOCK_SUSPEND, "mcbsp");
+#endif
+	return 0;
+}
+
+static void __exit audio_exit(void)
+{
+	platform_driver_unregister(&audio_driver);
+	wake_lock_destroy(&mcbsp_wakelock);
+}
+
+static void audio_callback(int status)
+{
+	mutex_lock(&audio_lock);
+	if (status == 1 || status == 2) {
+		if (cpcap_audio_state.stdac_primary_speaker ==
+					CPCAP_AUDIO_OUT_STEREO_HEADSET) {
+			cpcap_audio_state.stdac_primary_speaker =
+							CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			cpcap_audio_state.stdac_primary_speaker =
+						CPCAP_AUDIO_OUT_STEREO_HEADSET;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+		}
+		if (cpcap_audio_state.codec_primary_speaker ==
+					CPCAP_AUDIO_OUT_STEREO_HEADSET) {
+			cpcap_audio_state.codec_primary_speaker =
+							CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			cpcap_audio_state.codec_primary_speaker =
+					CPCAP_AUDIO_OUT_STEREO_HEADSET;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+		}
+		if (cpcap_audio_state.ext_primary_speaker ==
+					CPCAP_AUDIO_OUT_STEREO_HEADSET) {
+			cpcap_audio_state.ext_primary_speaker =
+							CPCAP_AUDIO_OUT_NONE;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			cpcap_audio_state.ext_primary_speaker =
+					CPCAP_AUDIO_OUT_STEREO_HEADSET;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+		}
+		if (cpcap_audio_state.microphone == CPCAP_AUDIO_IN_HEADSET) {
+			cpcap_audio_state.microphone = CPCAP_AUDIO_IN_NONE;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+			cpcap_audio_state.microphone = CPCAP_AUDIO_IN_HEADSET;
+			cpcap_audio_set_audio_state(&cpcap_audio_state);
+		}
+	}
+	mutex_unlock(&audio_lock);
+}
+
+static int audio_probe(struct platform_device *dev)
+{
+	mcbsp_wrapper =
+		kzalloc(omap_mcbsp_count * sizeof(struct omap_mcbsp_wrapper),
+		    GFP_KERNEL);
+
+	/* /dev/dsp - stdac */
+	state.dev_dsp = register_sound_dsp(&audio_stdac_fops, -1);
+	/* /dev/dsp1 - codec */
+	state.dev_dsp1 = register_sound_dsp(&codec_fops, -1);
+
+	state.dev_mixer = register_sound_mixer(&mixer_fops, -1);
+
+	state.dev_dsp_open_count = 0;
+	state.dev_dsp1_open_count = 0;
+	state.dev_mixer_open_count = 0;
+	state.stdac_out_stream = NULL;
+	state.stdac_in_stream = NULL;
+	state.codec_out_stream = NULL;
+	state.codec_in_stream = NULL;
+
+	enable_tx = 0;
+	cpcap_audio_state.cpcap = dev->dev.platform_data;
+	cpcap_audio_init(&cpcap_audio_state);
+
+	cpcap_audio_state.cpcap->h2w_new_state = &audio_callback;
+	return 0;
+}
+
+static int audio_remove(struct platform_device *dev)
+{
+	unregister_sound_dsp(state.dev_dsp);
+	unregister_sound_dsp(state.dev_dsp1);
+	unregister_sound_mixer(state.dev_mixer);
+
+	state.dev_dsp_open_count = 0;
+	state.dev_dsp1_open_count = 0;
+	state.dev_mixer_open_count = 0;
+	state.stdac_out_stream = NULL;
+	state.stdac_in_stream = NULL;
+	state.codec_out_stream = NULL;
+	state.codec_in_stream = NULL;
+
+	return 0;
+}
+
+module_init(audio_init);
+module_exit(audio_exit);
+
+MODULE_DESCRIPTION("OMAP audio driver");
+MODULE_AUTHOR("Motorola, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/oss/moto_audio/omap34xx_audio_driver.h b/sound/oss/moto_audio/omap34xx_audio_driver.h
new file mode 100644
index 0000000..08d8510
--- /dev/null
+++ b/sound/oss/moto_audio/omap34xx_audio_driver.h
@@ -0,0 +1,175 @@
+
+#ifndef OMAP34XX_AUDIO_DRIVER_H
+#define OMAP34XX_AUDIO_DRIVER_H
+
+#define MCBSP_WRAPPER
+
+#ifdef MCBSP_WRAPPER
+#include <mach/dma.h>
+#include <mach/mcbsp.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#endif /* MCBSP_WRAPPER */
+
+#ifdef MCBSP_WRAPPER
+
+#if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
+#define OMAP_MCBSP_REG_WKUPEN 0xA8
+#endif
+
+#define MCBSP_WKUP_XRDYEN		0x400
+
+#define OMAP_MCBSP_BIT(ARG) ((0x01)<<(ARG))
+
+#define MCBSP2_SYSCONFIG_LVL1 1
+#define MCBSP2_SYSCONFIG_LVL2 2
+
+#define MCBSP_FIFO_SIZE 64
+#define MCBSP2_FIFO_SIZE 1024
+#define OMAP_MCBSP_REG_THRSH1 0x94
+#define OMAP_MCBSP_REG_THRSH2 0x90
+
+/********************** McBSP SYSCONFIG bit definitions ********************/
+#define FORCE_IDLE 0x0
+#define SMART_IDLE 0x2
+#define MCBSP_SYSC_IOFF_FOFF 0x0
+#define MCBSP_SYSC_IOFF_FON 0x2	/* Err in TRM ES2.0 ?? */
+
+/* McBSP interface operating mode */
+#define OMAP_MCBSP_MASTER 1
+#define OMAP_MCBSP_SLAVE 0
+
+#define OMAP_MCBSP_AUTO_RRST (0x1<<1)
+#define OMAP_MCBSP_AUTO_XRST (0x1<<2)
+
+/* SRG ENABLE/DISABLE state */
+#define OMAP_MCBSP_ENABLE_FSG_SRG               1
+#define OMAP_MCBSP_DISABLE_FSG_SRG              2
+/* mono to mono mode*/
+#define OMAP_MCBSP_SKIP_NONE (0x0)
+/* mono to stereo mode */
+#define OMAP_MCBSP_SKIP_FIRST (0x1<<1)
+#define OMAP_MCBSP_SKIP_SECOND (0x1<<2)
+/* RRST STATE */
+#define OMAP_MCBSP_RRST_DISABLE 0
+/*XRST STATE */
+#define OMAP_MCBSP_XRST_DISABLE 0
+
+#define OMAP_MCBSP_FRAME_SINGLEPHASE 1
+#define OMAP_MCBSP_FRAME_DUALPHASE   2
+
+/* Sample Rate Generator Clock source */
+#define OMAP_MCBSP_SRGCLKSRC_CLKS 1
+#define OMAP_MCBSP_SRGCLKSRC_FCLK 2
+#define OMAP_MCBSP_SRGCLKSRC_CLKR 3
+#define OMAP_MCBSP_SRGCLKSRC_CLKX 4
+
+/* SRG input clock polarity */
+#define OMAP_MCBSP_CLKS_POLARITY_RISING 1
+#define OMAP_MCBSP_CLKX_POLARITY_RISING 1
+#define OMAP_MCBSP_CLKX_POLARITY_FALLING 2
+#define OMAP_MCBSP_CLKR_POLARITY_RISING 1
+#define OMAP_MCBSP_CLKR_POLARITY_FALLING 2
+
+/* SRG Clock synchronization mode */
+#define OMAP_MCBSP_SRG_FREERUNNING 1
+#define OMAP_MCBSP_SRG_RUNNING 2
+
+/* Frame Sync Source */
+#define OMAP_MCBSP_TXFSYNC_EXTERNAL 0
+#define OMAP_MCBSP_TXFSYNC_INTERNAL 1
+#define OMAP_MCBSP_RXFSYNC_EXTERNAL 0
+#define OMAP_MCBSP_RXFSYNC_INTERNAL 1
+#define OMAP_MCBSP_CLKRXSRC_EXTERNAL 1
+#define OMAP_MCBSP_CLKRXSRC_INTERNAL 2
+#define OMAP_MCBSP_CLKTXSRC_EXTERNAL 1
+#define OMAP_MCBSP_CLKTXSRC_INTERNAL 2
+
+/* Justification */
+#define OMAP_MCBSP_RJUST_ZEROMSB 0
+
+#define OMAP_MCBSP_DATADELAY1 1
+
+/* Reverse mode for 243X and 34XX */
+#define OMAP_MCBSP_MSBFIRST 0
+
+#define OMAP_MCBSP_FRAMELEN_N(NUM_WORDS) ((NUM_WORDS - 1) & 0x7F)
+
+struct omap_mcbsp_cfg_param {
+	u8 fsync_src;
+	u8 fs_polarity;
+	u8 clk_polarity;
+	u8 clk_mode;
+	u8 frame_length1;
+	u8 frame_length2;
+	u8 word_length1;
+	u8 word_length2;
+	u8 justification;
+	u8 reverse_compand;
+	u8 phase;
+	u8 data_delay;
+};
+
+struct omap_mcbsp_srg_fsg_cfg {
+	u32 period;		/* Frame period */
+	u32 pulse_width;	/* Frame width */
+	u8 fsgm;
+	u32 sample_rate;
+	u32 bits_per_sample;
+	u32 srg_src;
+	u8 sync_mode;		/* SRG free running mode */
+	u8 polarity;
+	u8 dlb;			/* digital loopback mode */
+};
+
+struct omap_mcbsp_dma_transfer_params {
+	/* Skip the alternate element use fro stereo mode */
+	u8 skip_alt;
+	/* Automagically handle Transfer [XR]RST? */
+	u8 auto_reset;
+	/* callback function executed for every tx/rx completion */
+	void (*callback) (u32 ch_status, void *arg);
+	/* word length of data */
+	u32 word_length1;
+};
+
+struct omap_mcbsp_wrapper {
+	u8 auto_reset;		/* Auto Reset */
+	u8 txskip_alt;		/* Tx skip flags */
+	u8 rxskip_alt;		/* Rx skip flags */
+	void *rx_cb_arg;
+	void *tx_cb_arg;
+	void (*rx_callback) (u32 ch_status, void *arg);
+	void (*tx_callback) (u32 ch_status, void *arg);
+	int rx_dma_chain_state;
+	int tx_dma_chain_state;
+	int interface_mode;	/* Master / Slave */
+	struct omap_dma_channel_params rx_params;	/* Used For Rx FIFO */
+	int rx_config_done;
+};
+#endif /* MCBSP_WRAPPER */
+#ifdef MCBSP_WRAPPER
+
+void omap_mcbsp_write(void __iomem *io_base, u16 reg, u32 val);
+int omap_mcbsp_read(void __iomem *io_base, u16 reg);
+
+int omap2_mcbsp_stop_datatx(u32 id);
+int omap2_mcbsp_stop_datarx(u32 id);
+int omap2_mcbsp_reset(unsigned int id);
+int omap2_mcbsp_set_xrst(unsigned int id, u8 state);
+int omap2_mcbsp_set_rrst(unsigned int id, u8 state);
+int omap2_mcbsp_dma_recv_params(unsigned int id,
+				struct omap_mcbsp_dma_transfer_params *rp);
+int omap2_mcbsp_dma_trans_params(unsigned int id,
+				 struct omap_mcbsp_dma_transfer_params *tp);
+int omap2_mcbsp_receive_data(unsigned int id, void *cbdata,
+			     dma_addr_t buf_start_addr, u32 buf_size);
+int omap2_mcbsp_send_data(unsigned int id, void *cbdata,
+			  dma_addr_t buf_start_addr, u32 buf_size);
+int omap2_mcbsp_params_cfg(unsigned int id, int interface_mode,
+			   struct omap_mcbsp_cfg_param *rp,
+			   struct omap_mcbsp_cfg_param *tp,
+			   struct omap_mcbsp_srg_fsg_cfg *param);
+#endif /* MCBSP_WRAPPER */
+
+#endif /* OMAP34XX_AUDIO_DRIVER_H */
diff --git a/sound/oss/omap34xx_audio_driver.c b/sound/oss/omap34xx_audio_driver.c
index 76b6173..7a87d44 100755
--- a/sound/oss/omap34xx_audio_driver.c
+++ b/sound/oss/omap34xx_audio_driver.c
@@ -1886,7 +1886,6 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 	int minor = MINOR(inode->i_rdev);
 	struct audio_stream *str = (minor == state.dev_dsp) ?
 			state.stdac_out_stream : state.codec_out_stream;
-	unsigned long flags;
 
 	mutex_lock(&audio_lock);
 
@@ -1982,23 +1981,12 @@ static ssize_t audio_write(struct file *file, const char *buffer, size_t count,
 
 		buf->offset = 0;
 
-		/*
-		 * HACKHACKHACK
-		 *
-		 * Disabling IRQs works around a race accessing str between the
-		 * following code and the interrupt handler.  This should be
-		 * replaced with propper locking around access to any
-		 * audio_stream throughout the dirver.
-		 */
-
-		local_irq_save(flags);
 		if (++str->usr_head >= str->nbfrags)
 			str->usr_head = 0;
 
 		str->pending_frags++;
 
 		ret = audio_process_buf(str, inode);
-		local_irq_restore(flags);
 	}
 
 	if (buffer - buffer0)
-- 
1.7.8.1

